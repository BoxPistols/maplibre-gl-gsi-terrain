var If = Object.defineProperty;
var Bf = (K, J, se) =>
  J in K
    ? If(K, J, { enumerable: !0, configurable: !0, writable: !0, value: se })
    : (K[J] = se);
var Pl = (K, J, se) => (Bf(K, typeof J != "symbol" ? J + "" : J, se), se);
(function () {
  const J = document.createElement("link").relList;
  if (J && J.supports && J.supports("modulepreload")) return;
  for (const U of document.querySelectorAll("link[rel=\"modulepreload\"]")) le(U);
  new MutationObserver((U) => {
    for (const X of U)
      if (X.type === "childList")
        for (const E of X.addedNodes)
          E.tagName === "LINK" && E.rel === "modulepreload" && le(E);
  }).observe(document, { childList: !0, subtree: !0 });
  function se(U) {
    const X = {};
    return (
      U.integrity && (X.integrity = U.integrity),
      U.referrerpolicy && (X.referrerPolicy = U.referrerpolicy),
      U.crossorigin === "use-credentials"
        ? (X.credentials = "include")
        : U.crossorigin === "anonymous"
          ? (X.credentials = "omit")
          : (X.credentials = "same-origin"),
      X
    );
  }
  function le(U) {
    if (U.ep) return;
    U.ep = !0;
    const X = se(U);
    fetch(U.href, X);
  }
})();
var kf =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
      ? window
      : typeof global < "u"
        ? global
        : typeof self < "u"
          ? self
          : {};
function zf(K) {
  return K && K.__esModule && Object.prototype.hasOwnProperty.call(K, "default")
    ? K.default
    : K;
}
var Kd = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.0.0/LICENSE.txt
 */ (function (K, J) {
  (function (se, le) {
    K.exports = le();
  })(kf, function () {
    var se = {},
      le = {};
    function U(E, u, Ue) {
      if (((le[E] = Ue), E === "index")) {
        var rt =
            "var sharedModule = {}; (" +
            le.shared +
            ")(sharedModule); (" +
            le.worker +
            ")(sharedModule);",
          _t = {};
        return (
          le.shared(_t),
          le.index(se, _t),
          typeof window < "u" &&
            se.setWorkerUrl(
              window.URL.createObjectURL(
                new Blob([rt], { type: "text/javascript" }),
              ),
            ),
          se
        );
      }
    }
    (U("shared", ["exports"], function (E) {
      function u(n, t, r, o) {
        return new (r || (r = Promise))(function (l, d) {
          function p(x) {
            try {
              _(o.next(x));
            } catch (b) {
              d(b);
            }
          }
          function m(x) {
            try {
              _(o.throw(x));
            } catch (b) {
              d(b);
            }
          }
          function _(x) {
            var b;
            x.done
              ? l(x.value)
              : ((b = x.value),
                b instanceof r
                  ? b
                  : new r(function (w) {
                      w(b);
                    })).then(p, m);
          }
          _((o = o.apply(n, t || [])).next());
        });
      }
      function Ue(n) {
        return n &&
          n.__esModule &&
          Object.prototype.hasOwnProperty.call(n, "default")
          ? n.default
          : n;
      }
      var rt, _t;
      function li() {
        if (_t) return rt;
        function n(t, r) {
          ((this.x = t), (this.y = r));
        }
        return (
          (_t = 1),
          (rt = n),
          (n.prototype = {
            clone: function () {
              return new n(this.x, this.y);
            },
            add: function (t) {
              return this.clone()._add(t);
            },
            sub: function (t) {
              return this.clone()._sub(t);
            },
            multByPoint: function (t) {
              return this.clone()._multByPoint(t);
            },
            divByPoint: function (t) {
              return this.clone()._divByPoint(t);
            },
            mult: function (t) {
              return this.clone()._mult(t);
            },
            div: function (t) {
              return this.clone()._div(t);
            },
            rotate: function (t) {
              return this.clone()._rotate(t);
            },
            rotateAround: function (t, r) {
              return this.clone()._rotateAround(t, r);
            },
            matMult: function (t) {
              return this.clone()._matMult(t);
            },
            unit: function () {
              return this.clone()._unit();
            },
            perp: function () {
              return this.clone()._perp();
            },
            round: function () {
              return this.clone()._round();
            },
            mag: function () {
              return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            equals: function (t) {
              return this.x === t.x && this.y === t.y;
            },
            dist: function (t) {
              return Math.sqrt(this.distSqr(t));
            },
            distSqr: function (t) {
              var r = t.x - this.x,
                o = t.y - this.y;
              return r * r + o * o;
            },
            angle: function () {
              return Math.atan2(this.y, this.x);
            },
            angleTo: function (t) {
              return Math.atan2(this.y - t.y, this.x - t.x);
            },
            angleWith: function (t) {
              return this.angleWithSep(t.x, t.y);
            },
            angleWithSep: function (t, r) {
              return Math.atan2(
                this.x * r - this.y * t,
                this.x * t + this.y * r,
              );
            },
            _matMult: function (t) {
              var r = t[2] * this.x + t[3] * this.y;
              return (
                (this.x = t[0] * this.x + t[1] * this.y),
                (this.y = r),
                this
              );
            },
            _add: function (t) {
              return ((this.x += t.x), (this.y += t.y), this);
            },
            _sub: function (t) {
              return ((this.x -= t.x), (this.y -= t.y), this);
            },
            _mult: function (t) {
              return ((this.x *= t), (this.y *= t), this);
            },
            _div: function (t) {
              return ((this.x /= t), (this.y /= t), this);
            },
            _multByPoint: function (t) {
              return ((this.x *= t.x), (this.y *= t.y), this);
            },
            _divByPoint: function (t) {
              return ((this.x /= t.x), (this.y /= t.y), this);
            },
            _unit: function () {
              return (this._div(this.mag()), this);
            },
            _perp: function () {
              var t = this.y;
              return ((this.y = this.x), (this.x = -t), this);
            },
            _rotate: function (t) {
              var r = Math.cos(t),
                o = Math.sin(t),
                l = o * this.x + r * this.y;
              return ((this.x = r * this.x - o * this.y), (this.y = l), this);
            },
            _rotateAround: function (t, r) {
              var o = Math.cos(t),
                l = Math.sin(t),
                d = r.y + l * (this.x - r.x) + o * (this.y - r.y);
              return (
                (this.x = r.x + o * (this.x - r.x) - l * (this.y - r.y)),
                (this.y = d),
                this
              );
            },
            _round: function () {
              return (
                (this.x = Math.round(this.x)),
                (this.y = Math.round(this.y)),
                this
              );
            },
          }),
          (n.convert = function (t) {
            return t instanceof n
              ? t
              : Array.isArray(t)
                ? new n(t[0], t[1])
                : t;
          }),
          rt
        );
      }
      typeof SuppressedError == "function" && SuppressedError;
      var Qe,
        me,
        Ze = Ue(li()),
        Ni = (function () {
          if (me) return Qe;
          function n(t, r, o, l) {
            ((this.cx = 3 * t),
              (this.bx = 3 * (o - t) - this.cx),
              (this.ax = 1 - this.cx - this.bx),
              (this.cy = 3 * r),
              (this.by = 3 * (l - r) - this.cy),
              (this.ay = 1 - this.cy - this.by),
              (this.p1x = t),
              (this.p1y = r),
              (this.p2x = o),
              (this.p2y = l));
          }
          return (
            (me = 1),
            (Qe = n),
            (n.prototype = {
              sampleCurveX: function (t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t;
              },
              sampleCurveY: function (t) {
                return ((this.ay * t + this.by) * t + this.cy) * t;
              },
              sampleCurveDerivativeX: function (t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
              },
              solveCurveX: function (t, r) {
                if ((r === void 0 && (r = 1e-6), t < 0)) return 0;
                if (t > 1) return 1;
                for (var o = t, l = 0; l < 8; l++) {
                  var d = this.sampleCurveX(o) - t;
                  if (Math.abs(d) < r) return o;
                  var p = this.sampleCurveDerivativeX(o);
                  if (Math.abs(p) < 1e-6) break;
                  o -= d / p;
                }
                var m = 0,
                  _ = 1;
                for (
                  o = t, l = 0;
                  l < 20 &&
                  ((d = this.sampleCurveX(o)), !(Math.abs(d - t) < r));
                  l++
                )
                  (t > d ? (m = o) : (_ = o), (o = 0.5 * (_ - m) + m));
                return o;
              },
              solve: function (t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r));
              },
            }),
            Qe
          );
        })(),
        Ei = Ue(Ni);
      let Mi, Ki;
      function mr() {
        return (
          Mi == null &&
            (Mi =
              typeof OffscreenCanvas < "u" &&
              new OffscreenCanvas(1, 1).getContext("2d") &&
              typeof createImageBitmap == "function"),
          Mi
        );
      }
      function ei() {
        if (Ki == null && ((Ki = !1), mr())) {
          const t = new OffscreenCanvas(5, 5).getContext("2d", {
            willReadFrequently: !0,
          });
          if (t) {
            for (let o = 0; o < 5 * 5; o++) {
              const l = 4 * o;
              ((t.fillStyle = `rgb(${l},${l + 1},${l + 2})`),
                t.fillRect(o % 5, Math.floor(o / 5), 1, 1));
            }
            const r = t.getImageData(0, 0, 5, 5).data;
            for (let o = 0; o < 5 * 5 * 4; o++)
              if (o % 4 != 3 && r[o] !== o) {
                Ki = !0;
                break;
              }
          }
        }
        return Ki || !1;
      }
      var Vi,
        It = 1e-6,
        Dt = typeof Float32Array < "u" ? Float32Array : Array;
      function Bt() {
        var n = new Dt(9);
        return (
          Dt != Float32Array &&
            ((n[1] = 0),
            (n[2] = 0),
            (n[3] = 0),
            (n[5] = 0),
            (n[6] = 0),
            (n[7] = 0)),
          (n[0] = 1),
          (n[4] = 1),
          (n[8] = 1),
          n
        );
      }
      function Xr(n) {
        return (
          (n[0] = 1),
          (n[1] = 0),
          (n[2] = 0),
          (n[3] = 0),
          (n[4] = 0),
          (n[5] = 1),
          (n[6] = 0),
          (n[7] = 0),
          (n[8] = 0),
          (n[9] = 0),
          (n[10] = 1),
          (n[11] = 0),
          (n[12] = 0),
          (n[13] = 0),
          (n[14] = 0),
          (n[15] = 1),
          n
        );
      }
      function dn() {
        var n = new Dt(3);
        return (Dt != Float32Array && ((n[0] = 0), (n[1] = 0), (n[2] = 0)), n);
      }
      function or(n, t, r) {
        var o = new Dt(3);
        return ((o[0] = n), (o[1] = t), (o[2] = r), o);
      }
      function sr(n, t, r) {
        var o = t[0],
          l = t[1],
          d = t[2],
          p = t[3];
        return (
          (n[0] = r[0] * o + r[4] * l + r[8] * d + r[12] * p),
          (n[1] = r[1] * o + r[5] * l + r[9] * d + r[13] * p),
          (n[2] = r[2] * o + r[6] * l + r[10] * d + r[14] * p),
          (n[3] = r[3] * o + r[7] * l + r[11] * d + r[15] * p),
          n
        );
      }
      function Ae() {
        var n = new Dt(4);
        return (
          Dt != Float32Array && ((n[0] = 0), (n[1] = 0), (n[2] = 0)),
          (n[3] = 1),
          n
        );
      }
      function Oe() {
        var n = new Dt(2);
        return (Dt != Float32Array && ((n[0] = 0), (n[1] = 0)), n);
      }
      function $e(n, t) {
        var r = new Dt(2);
        return ((r[0] = n), (r[1] = t), r);
      }
      (Math.hypot ||
        (Math.hypot = function () {
          for (var n = 0, t = arguments.length; t--; )
            n += arguments[t] * arguments[t];
          return Math.sqrt(n);
        }),
        dn(),
        (Vi = new Dt(4)),
        Dt != Float32Array &&
          ((Vi[0] = 0), (Vi[1] = 0), (Vi[2] = 0), (Vi[3] = 0)),
        dn(),
        or(1, 0, 0),
        or(0, 1, 0),
        Ae(),
        Ae(),
        Bt(),
        Oe());
      const qe = 8192;
      function pt(n, t, r) {
        return t * (qe / (n.tileSize * Math.pow(2, r - n.tileID.overscaledZ)));
      }
      function tt(n, t) {
        return ((n % t) + t) % t;
      }
      function Et(n, t, r) {
        return n * (1 - r) + t * r;
      }
      function $t(n) {
        if (n <= 0) return 0;
        if (n >= 1) return 1;
        const t = n * n,
          r = t * n;
        return 4 * (n < 0.5 ? r : 3 * (n - t) + r - 0.75);
      }
      function _i(n, t, r, o) {
        const l = new Ei(n, t, r, o);
        return (d) => l.solve(d);
      }
      const Ii = _i(0.25, 0.1, 0.25, 1);
      function Bi(n, t, r) {
        return Math.min(r, Math.max(t, n));
      }
      function ar(n, t, r) {
        const o = r - t,
          l = ((((n - t) % o) + o) % o) + t;
        return l === t ? r : l;
      }
      function yi(n, ...t) {
        for (const r of t) for (const o in r) n[o] = r[o];
        return n;
      }
      let pn = 1;
      function fn(n, t, r) {
        const o = {};
        for (const l in n) o[l] = t.call(this, n[l], l, n);
        return o;
      }
      function mn(n, t, r) {
        const o = {};
        for (const l in n) t.call(this, n[l], l, n) && (o[l] = n[l]);
        return o;
      }
      function Yi(n) {
        return Array.isArray(n)
          ? n.map(Yi)
          : typeof n == "object" && n
            ? fn(n, Yi)
            : n;
      }
      const Eo = {};
      function Ai(n) {
        Eo[n] || (typeof console < "u" && console.warn(n), (Eo[n] = !0));
      }
      function ui(n, t, r) {
        return (r.y - n.y) * (t.x - n.x) > (t.y - n.y) * (r.x - n.x);
      }
      function zr(n) {
        return (
          typeof WorkerGlobalScope < "u" &&
          n !== void 0 &&
          n instanceof WorkerGlobalScope
        );
      }
      let ti = null;
      function gn(n) {
        return typeof ImageBitmap < "u" && n instanceof ImageBitmap;
      }
      const _n =
        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function gr(n, t, r, o, l) {
        return u(this, void 0, void 0, function* () {
          if (typeof VideoFrame > "u")
            throw new Error("VideoFrame not supported");
          const d = new VideoFrame(n, { timestamp: 0 });
          try {
            const p = d == null ? void 0 : d.format;
            if (!p || (!p.startsWith("BGR") && !p.startsWith("RGB")))
              throw new Error(`Unrecognized format ${p}`);
            const m = p.startsWith("BGR"),
              _ = new Uint8ClampedArray(o * l * 4);
            if (
              (yield d.copyTo(
                _,
                (function (x, b, w, F, S) {
                  const D = 4 * Math.max(-b, 0),
                    I = (Math.max(0, w) - w) * F * 4 + D,
                    O = 4 * F,
                    Z = Math.max(0, b),
                    ne = Math.max(0, w);
                  return {
                    rect: {
                      x: Z,
                      y: ne,
                      width: Math.min(x.width, b + F) - Z,
                      height: Math.min(x.height, w + S) - ne,
                    },
                    layout: [{ offset: I, stride: O }],
                  };
                })(n, t, r, o, l),
              ),
              m)
            )
              for (let x = 0; x < _.length; x += 4) {
                const b = _[x];
                ((_[x] = _[x + 2]), (_[x + 2] = b));
              }
            return _;
          } finally {
            d.close();
          }
        });
      }
      let Wr, Kr;
      function Ji(n) {
        return (n / Math.PI) * 180;
      }
      const yn = "AbortError";
      function xn() {
        return new Error(yn);
      }
      const Yr = {
        MAX_PARALLEL_IMAGE_REQUESTS: 16,
        MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
        MAX_TILE_CACHE_ZOOM_LEVELS: 5,
        REGISTERED_PROTOCOLS: {},
        WORKER_URL: "",
      };
      function Ao(n) {
        return Yr.REGISTERED_PROTOCOLS[n.substring(0, n.indexOf("://"))];
      }
      const vn = "global-dispatcher";
      class Lr extends Error {
        constructor(t, r, o, l) {
          (super(`AJAXError: ${r} (${t}): ${o}`),
            (this.status = t),
            (this.statusText = r),
            (this.url = o),
            (this.body = l));
        }
      }
      const bn = () =>
          zr(self)
            ? self.worker && self.worker.referrer
            : (window.location.protocol === "blob:" ? window.parent : window)
                .location.href,
        Rr = function (n, t) {
          if (/:\/\//.test(n.url) && !/^https?:|^file:/.test(n.url)) {
            const o = Ao(n.url);
            if (o) return o(n, t);
            if (zr(self) && self.worker && self.worker.actor)
              return self.worker.actor.sendAsync(
                { type: "GR", data: n, targetMapId: vn },
                t,
              );
          }
          if (
            !(
              /^file:/.test((r = n.url)) ||
              (/^file:/.test(bn()) && !/^\w+:/.test(r))
            )
          ) {
            if (
              fetch &&
              Request &&
              AbortController &&
              Object.prototype.hasOwnProperty.call(Request.prototype, "signal")
            )
              return (function (o, l) {
                return u(this, void 0, void 0, function* () {
                  const d = new Request(o.url, {
                    method: o.method || "GET",
                    body: o.body,
                    credentials: o.credentials,
                    headers: o.headers,
                    cache: o.cache,
                    referrer: bn(),
                    signal: l.signal,
                  });
                  let p, m;
                  o.type !== "json" ||
                    d.headers.has("Accept") ||
                    d.headers.set("Accept", "application/json");
                  try {
                    p = yield fetch(d);
                  } catch (x) {
                    throw new Lr(0, x.message, o.url, new Blob());
                  }
                  if (!p.ok) {
                    const x = yield p.blob();
                    throw new Lr(p.status, p.statusText, o.url, x);
                  }
                  m =
                    o.type === "arrayBuffer" || o.type === "image"
                      ? p.arrayBuffer()
                      : o.type === "json"
                        ? p.json()
                        : p.text();
                  const _ = yield m;
                  if (l.signal.aborted) throw xn();
                  return {
                    data: _,
                    cacheControl: p.headers.get("Cache-Control"),
                    expires: p.headers.get("Expires"),
                  };
                });
              })(n, t);
            if (zr(self) && self.worker && self.worker.actor)
              return self.worker.actor.sendAsync(
                { type: "GR", data: n, mustQueue: !0, targetMapId: vn },
                t,
              );
          }
          var r;
          return (function (o, l) {
            return new Promise((d, p) => {
              var m;
              const _ = new XMLHttpRequest();
              (_.open(o.method || "GET", o.url, !0),
                (o.type !== "arrayBuffer" && o.type !== "image") ||
                  (_.responseType = "arraybuffer"));
              for (const x in o.headers) _.setRequestHeader(x, o.headers[x]);
              (o.type === "json" &&
                ((_.responseType = "text"),
                (!((m = o.headers) === null || m === void 0) && m.Accept) ||
                  _.setRequestHeader("Accept", "application/json")),
                (_.withCredentials = o.credentials === "include"),
                (_.onerror = () => {
                  p(new Error(_.statusText));
                }),
                (_.onload = () => {
                  if (!l.signal.aborted)
                    if (
                      ((_.status >= 200 && _.status < 300) || _.status === 0) &&
                      _.response !== null
                    ) {
                      let x = _.response;
                      if (o.type === "json")
                        try {
                          x = JSON.parse(_.response);
                        } catch (b) {
                          return void p(b);
                        }
                      d({
                        data: x,
                        cacheControl: _.getResponseHeader("Cache-Control"),
                        expires: _.getResponseHeader("Expires"),
                      });
                    } else {
                      const x = new Blob([_.response], {
                        type: _.getResponseHeader("Content-Type"),
                      });
                      p(new Lr(_.status, _.statusText, o.url, x));
                    }
                }),
                l.signal.addEventListener("abort", () => {
                  (_.abort(), p(xn()));
                }),
                _.send(o.body));
            });
          })(n, t);
        };
      function wn(n) {
        if (
          !n ||
          n.indexOf("://") <= 0 ||
          n.indexOf("data:image/") === 0 ||
          n.indexOf("blob:") === 0
        )
          return !0;
        const t = new URL(n),
          r = window.location;
        return t.protocol === r.protocol && t.host === r.host;
      }
      function Jr(n, t, r) {
        (r[n] && r[n].indexOf(t) !== -1) || ((r[n] = r[n] || []), r[n].push(t));
      }
      function Gn(n, t, r) {
        if (r && r[n]) {
          const o = r[n].indexOf(t);
          o !== -1 && r[n].splice(o, 1);
        }
      }
      class qn {
        constructor(t, r = {}) {
          (yi(this, r), (this.type = t));
        }
      }
      class To extends qn {
        constructor(t, r = {}) {
          super("error", yi({ error: t }, r));
        }
      }
      class Qr {
        on(t, r) {
          return (
            (this._listeners = this._listeners || {}),
            Jr(t, r, this._listeners),
            {
              unsubscribe: () => {
                this.off(t, r);
              },
            }
          );
        }
        off(t, r) {
          return (
            Gn(t, r, this._listeners),
            Gn(t, r, this._oneTimeListeners),
            this
          );
        }
        once(t, r) {
          return r
            ? ((this._oneTimeListeners = this._oneTimeListeners || {}),
              Jr(t, r, this._oneTimeListeners),
              this)
            : new Promise((o) => this.once(t, o));
        }
        fire(t, r) {
          typeof t == "string" && (t = new qn(t, r || {}));
          const o = t.type;
          if (this.listens(o)) {
            t.target = this;
            const l =
              this._listeners && this._listeners[o]
                ? this._listeners[o].slice()
                : [];
            for (const m of l) m.call(this, t);
            const d =
              this._oneTimeListeners && this._oneTimeListeners[o]
                ? this._oneTimeListeners[o].slice()
                : [];
            for (const m of d)
              (Gn(o, m, this._oneTimeListeners), m.call(this, t));
            const p = this._eventedParent;
            p &&
              (yi(
                t,
                typeof this._eventedParentData == "function"
                  ? this._eventedParentData()
                  : this._eventedParentData,
              ),
              p.fire(t));
          } else t instanceof To && console.error(t.error);
          return this;
        }
        listens(t) {
          return (
            (this._listeners &&
              this._listeners[t] &&
              this._listeners[t].length > 0) ||
            (this._oneTimeListeners &&
              this._oneTimeListeners[t] &&
              this._oneTimeListeners[t].length > 0) ||
            (this._eventedParent && this._eventedParent.listens(t))
          );
        }
        setEventedParent(t, r) {
          return (
            (this._eventedParent = t),
            (this._eventedParentData = r),
            this
          );
        }
      }
      var j = {
        $version: 8,
        $root: {
          version: { required: !0, type: "enum", values: [8] },
          name: { type: "string" },
          metadata: { type: "*" },
          center: { type: "array", value: "number" },
          centerAltitude: { type: "number" },
          zoom: { type: "number" },
          bearing: {
            type: "number",
            default: 0,
            period: 360,
            units: "degrees",
          },
          pitch: { type: "number", default: 0, units: "degrees" },
          roll: { type: "number", default: 0, units: "degrees" },
          light: { type: "light" },
          sky: { type: "sky" },
          projection: { type: "projection" },
          terrain: { type: "terrain" },
          sources: { required: !0, type: "sources" },
          sprite: { type: "sprite" },
          glyphs: { type: "string" },
          transition: { type: "transition" },
          layers: { required: !0, type: "array", value: "layer" },
        },
        sources: { "*": { type: "source" } },
        source: [
          "source_vector",
          "source_raster",
          "source_raster_dem",
          "source_geojson",
          "source_video",
          "source_image",
        ],
        source_vector: {
          type: { required: !0, type: "enum", values: { vector: {} } },
          url: { type: "string" },
          tiles: { type: "array", value: "string" },
          bounds: {
            type: "array",
            value: "number",
            length: 4,
            default: [-180, -85.051129, 180, 85.051129],
          },
          scheme: {
            type: "enum",
            values: { xyz: {}, tms: {} },
            default: "xyz",
          },
          minzoom: { type: "number", default: 0 },
          maxzoom: { type: "number", default: 22 },
          attribution: { type: "string" },
          promoteId: { type: "promoteId" },
          volatile: { type: "boolean", default: !1 },
          "*": { type: "*" },
        },
        source_raster: {
          type: { required: !0, type: "enum", values: { raster: {} } },
          url: { type: "string" },
          tiles: { type: "array", value: "string" },
          bounds: {
            type: "array",
            value: "number",
            length: 4,
            default: [-180, -85.051129, 180, 85.051129],
          },
          minzoom: { type: "number", default: 0 },
          maxzoom: { type: "number", default: 22 },
          tileSize: { type: "number", default: 512, units: "pixels" },
          scheme: {
            type: "enum",
            values: { xyz: {}, tms: {} },
            default: "xyz",
          },
          attribution: { type: "string" },
          volatile: { type: "boolean", default: !1 },
          "*": { type: "*" },
        },
        source_raster_dem: {
          type: { required: !0, type: "enum", values: { "raster-dem": {} } },
          url: { type: "string" },
          tiles: { type: "array", value: "string" },
          bounds: {
            type: "array",
            value: "number",
            length: 4,
            default: [-180, -85.051129, 180, 85.051129],
          },
          minzoom: { type: "number", default: 0 },
          maxzoom: { type: "number", default: 22 },
          tileSize: { type: "number", default: 512, units: "pixels" },
          attribution: { type: "string" },
          encoding: {
            type: "enum",
            values: { terrarium: {}, mapbox: {}, custom: {} },
            default: "mapbox",
          },
          redFactor: { type: "number", default: 1 },
          blueFactor: { type: "number", default: 1 },
          greenFactor: { type: "number", default: 1 },
          baseShift: { type: "number", default: 0 },
          volatile: { type: "boolean", default: !1 },
          "*": { type: "*" },
        },
        source_geojson: {
          type: { required: !0, type: "enum", values: { geojson: {} } },
          data: { required: !0, type: "*" },
          maxzoom: { type: "number", default: 18 },
          attribution: { type: "string" },
          buffer: { type: "number", default: 128, maximum: 512, minimum: 0 },
          filter: { type: "*" },
          tolerance: { type: "number", default: 0.375 },
          cluster: { type: "boolean", default: !1 },
          clusterRadius: { type: "number", default: 50, minimum: 0 },
          clusterMaxZoom: { type: "number" },
          clusterMinPoints: { type: "number" },
          clusterProperties: { type: "*" },
          lineMetrics: { type: "boolean", default: !1 },
          generateId: { type: "boolean", default: !1 },
          promoteId: { type: "promoteId" },
        },
        source_video: {
          type: { required: !0, type: "enum", values: { video: {} } },
          urls: { required: !0, type: "array", value: "string" },
          coordinates: {
            required: !0,
            type: "array",
            length: 4,
            value: { type: "array", length: 2, value: "number" },
          },
        },
        source_image: {
          type: { required: !0, type: "enum", values: { image: {} } },
          url: { required: !0, type: "string" },
          coordinates: {
            required: !0,
            type: "array",
            length: 4,
            value: { type: "array", length: 2, value: "number" },
          },
        },
        layer: {
          id: { type: "string", required: !0 },
          type: {
            type: "enum",
            values: {
              fill: {},
              line: {},
              symbol: {},
              circle: {},
              heatmap: {},
              "fill-extrusion": {},
              raster: {},
              hillshade: {},
              background: {},
            },
            required: !0,
          },
          metadata: { type: "*" },
          source: { type: "string" },
          "source-layer": { type: "string" },
          minzoom: { type: "number", minimum: 0, maximum: 24 },
          maxzoom: { type: "number", minimum: 0, maximum: 24 },
          filter: { type: "filter" },
          layout: { type: "layout" },
          paint: { type: "paint" },
        },
        layout: [
          "layout_fill",
          "layout_line",
          "layout_circle",
          "layout_heatmap",
          "layout_fill-extrusion",
          "layout_symbol",
          "layout_raster",
          "layout_hillshade",
          "layout_background",
        ],
        layout_background: {
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant",
          },
        },
        layout_fill: {
          "fill-sort-key": {
            type: "number",
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant",
          },
        },
        layout_circle: {
          "circle-sort-key": {
            type: "number",
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant",
          },
        },
        layout_heatmap: {
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant",
          },
        },
        "layout_fill-extrusion": {
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant",
          },
        },
        layout_line: {
          "line-cap": {
            type: "enum",
            values: { butt: {}, round: {}, square: {} },
            default: "butt",
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "line-join": {
            type: "enum",
            values: { bevel: {}, round: {}, miter: {} },
            default: "miter",
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "line-miter-limit": {
            type: "number",
            default: 2,
            requires: [{ "line-join": "miter" }],
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "line-round-limit": {
            type: "number",
            default: 1.05,
            requires: [{ "line-join": "round" }],
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "line-sort-key": {
            type: "number",
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant",
          },
        },
        layout_symbol: {
          "symbol-placement": {
            type: "enum",
            values: { point: {}, line: {}, "line-center": {} },
            default: "point",
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "symbol-spacing": {
            type: "number",
            default: 250,
            minimum: 1,
            units: "pixels",
            requires: [{ "symbol-placement": "line" }],
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "symbol-avoid-edges": {
            type: "boolean",
            default: !1,
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "symbol-sort-key": {
            type: "number",
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "symbol-z-order": {
            type: "enum",
            values: { auto: {}, "viewport-y": {}, source: {} },
            default: "auto",
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "icon-allow-overlap": {
            type: "boolean",
            default: !1,
            requires: ["icon-image", { "!": "icon-overlap" }],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "icon-overlap": {
            type: "enum",
            values: { never: {}, always: {}, cooperative: {} },
            requires: ["icon-image"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "icon-ignore-placement": {
            type: "boolean",
            default: !1,
            requires: ["icon-image"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "icon-optional": {
            type: "boolean",
            default: !1,
            requires: ["icon-image", "text-field"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "icon-rotation-alignment": {
            type: "enum",
            values: { map: {}, viewport: {}, auto: {} },
            default: "auto",
            requires: ["icon-image"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "icon-size": {
            type: "number",
            default: 1,
            minimum: 0,
            units: "factor of the original icon size",
            requires: ["icon-image"],
            expression: { interpolated: !0, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "icon-text-fit": {
            type: "enum",
            values: { none: {}, width: {}, height: {}, both: {} },
            default: "none",
            requires: ["icon-image", "text-field"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "icon-text-fit-padding": {
            type: "array",
            value: "number",
            length: 4,
            default: [0, 0, 0, 0],
            units: "pixels",
            requires: [
              "icon-image",
              "text-field",
              { "icon-text-fit": ["both", "width", "height"] },
            ],
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "icon-image": {
            type: "resolvedImage",
            tokens: !0,
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "icon-rotate": {
            type: "number",
            default: 0,
            period: 360,
            units: "degrees",
            requires: ["icon-image"],
            expression: { interpolated: !0, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "icon-padding": {
            type: "padding",
            default: [2],
            units: "pixels",
            requires: ["icon-image"],
            expression: { interpolated: !0, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "icon-keep-upright": {
            type: "boolean",
            default: !1,
            requires: [
              "icon-image",
              { "icon-rotation-alignment": "map" },
              { "symbol-placement": ["line", "line-center"] },
            ],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "icon-offset": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            requires: ["icon-image"],
            expression: { interpolated: !0, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "icon-anchor": {
            type: "enum",
            values: {
              center: {},
              left: {},
              right: {},
              top: {},
              bottom: {},
              "top-left": {},
              "top-right": {},
              "bottom-left": {},
              "bottom-right": {},
            },
            default: "center",
            requires: ["icon-image"],
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "icon-pitch-alignment": {
            type: "enum",
            values: { map: {}, viewport: {}, auto: {} },
            default: "auto",
            requires: ["icon-image"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-pitch-alignment": {
            type: "enum",
            values: { map: {}, viewport: {}, auto: {} },
            default: "auto",
            requires: ["text-field"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-rotation-alignment": {
            type: "enum",
            values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} },
            default: "auto",
            requires: ["text-field"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-field": {
            type: "formatted",
            default: "",
            tokens: !0,
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "text-font": {
            type: "array",
            value: "string",
            default: ["Open Sans Regular", "Arial Unicode MS Regular"],
            requires: ["text-field"],
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "text-size": {
            type: "number",
            default: 16,
            minimum: 0,
            units: "pixels",
            requires: ["text-field"],
            expression: { interpolated: !0, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "text-max-width": {
            type: "number",
            default: 10,
            minimum: 0,
            units: "ems",
            requires: ["text-field"],
            expression: { interpolated: !0, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "text-line-height": {
            type: "number",
            default: 1.2,
            units: "ems",
            requires: ["text-field"],
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-letter-spacing": {
            type: "number",
            default: 0,
            units: "ems",
            requires: ["text-field"],
            expression: { interpolated: !0, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "text-justify": {
            type: "enum",
            values: { auto: {}, left: {}, center: {}, right: {} },
            default: "center",
            requires: ["text-field"],
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "text-radial-offset": {
            type: "number",
            units: "ems",
            default: 0,
            requires: ["text-field"],
            "property-type": "data-driven",
            expression: { interpolated: !0, parameters: ["zoom", "feature"] },
          },
          "text-variable-anchor": {
            type: "array",
            value: "enum",
            values: {
              center: {},
              left: {},
              right: {},
              top: {},
              bottom: {},
              "top-left": {},
              "top-right": {},
              "bottom-left": {},
              "bottom-right": {},
            },
            requires: ["text-field", { "symbol-placement": ["point"] }],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-variable-anchor-offset": {
            type: "variableAnchorOffsetCollection",
            requires: ["text-field", { "symbol-placement": ["point"] }],
            expression: { interpolated: !0, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "text-anchor": {
            type: "enum",
            values: {
              center: {},
              left: {},
              right: {},
              top: {},
              bottom: {},
              "top-left": {},
              "top-right": {},
              "bottom-left": {},
              "bottom-right": {},
            },
            default: "center",
            requires: ["text-field", { "!": "text-variable-anchor" }],
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "text-max-angle": {
            type: "number",
            default: 45,
            units: "degrees",
            requires: [
              "text-field",
              { "symbol-placement": ["line", "line-center"] },
            ],
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-writing-mode": {
            type: "array",
            value: "enum",
            values: { horizontal: {}, vertical: {} },
            requires: ["text-field", { "symbol-placement": ["point"] }],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-rotate": {
            type: "number",
            default: 0,
            period: 360,
            units: "degrees",
            requires: ["text-field"],
            expression: { interpolated: !0, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "text-padding": {
            type: "number",
            default: 2,
            minimum: 0,
            units: "pixels",
            requires: ["text-field"],
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-keep-upright": {
            type: "boolean",
            default: !0,
            requires: [
              "text-field",
              { "text-rotation-alignment": "map" },
              { "symbol-placement": ["line", "line-center"] },
            ],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-transform": {
            type: "enum",
            values: { none: {}, uppercase: {}, lowercase: {} },
            default: "none",
            requires: ["text-field"],
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "text-offset": {
            type: "array",
            value: "number",
            units: "ems",
            length: 2,
            default: [0, 0],
            requires: ["text-field", { "!": "text-radial-offset" }],
            expression: { interpolated: !0, parameters: ["zoom", "feature"] },
            "property-type": "data-driven",
          },
          "text-allow-overlap": {
            type: "boolean",
            default: !1,
            requires: ["text-field", { "!": "text-overlap" }],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-overlap": {
            type: "enum",
            values: { never: {}, always: {}, cooperative: {} },
            requires: ["text-field"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-ignore-placement": {
            type: "boolean",
            default: !1,
            requires: ["text-field"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-optional": {
            type: "boolean",
            default: !1,
            requires: ["text-field", "icon-image"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant",
          },
        },
        layout_raster: {
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant",
          },
        },
        layout_hillshade: {
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant",
          },
        },
        filter: { type: "array", value: "*" },
        filter_operator: {
          type: "enum",
          values: {
            "==": {},
            "!=": {},
            ">": {},
            ">=": {},
            "<": {},
            "<=": {},
            in: {},
            "!in": {},
            all: {},
            any: {},
            none: {},
            has: {},
            "!has": {},
          },
        },
        geometry_type: {
          type: "enum",
          values: { Point: {}, LineString: {}, Polygon: {} },
        },
        function: {
          expression: { type: "expression" },
          stops: { type: "array", value: "function_stop" },
          base: { type: "number", default: 1, minimum: 0 },
          property: { type: "string", default: "$zoom" },
          type: {
            type: "enum",
            values: {
              identity: {},
              exponential: {},
              interval: {},
              categorical: {},
            },
            default: "exponential",
          },
          colorSpace: {
            type: "enum",
            values: { rgb: {}, lab: {}, hcl: {} },
            default: "rgb",
          },
          default: { type: "*", required: !1 },
        },
        function_stop: {
          type: "array",
          minimum: 0,
          maximum: 24,
          value: ["number", "color"],
          length: 2,
        },
        expression: { type: "array", value: "*", minimum: 1 },
        light: {
          anchor: {
            type: "enum",
            default: "viewport",
            values: { map: {}, viewport: {} },
            "property-type": "data-constant",
            transition: !1,
            expression: { interpolated: !1, parameters: ["zoom"] },
          },
          position: {
            type: "array",
            default: [1.15, 210, 30],
            length: 3,
            value: "number",
            "property-type": "data-constant",
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
          },
          color: {
            type: "color",
            "property-type": "data-constant",
            default: "#ffffff",
            expression: { interpolated: !0, parameters: ["zoom"] },
            transition: !0,
          },
          intensity: {
            type: "number",
            "property-type": "data-constant",
            default: 0.5,
            minimum: 0,
            maximum: 1,
            expression: { interpolated: !0, parameters: ["zoom"] },
            transition: !0,
          },
        },
        sky: {
          "sky-color": {
            type: "color",
            "property-type": "data-constant",
            default: "#88C6FC",
            expression: { interpolated: !0, parameters: ["zoom"] },
            transition: !0,
          },
          "horizon-color": {
            type: "color",
            "property-type": "data-constant",
            default: "#ffffff",
            expression: { interpolated: !0, parameters: ["zoom"] },
            transition: !0,
          },
          "fog-color": {
            type: "color",
            "property-type": "data-constant",
            default: "#ffffff",
            expression: { interpolated: !0, parameters: ["zoom"] },
            transition: !0,
          },
          "fog-ground-blend": {
            type: "number",
            "property-type": "data-constant",
            default: 0.5,
            minimum: 0,
            maximum: 1,
            expression: { interpolated: !0, parameters: ["zoom"] },
            transition: !0,
          },
          "horizon-fog-blend": {
            type: "number",
            "property-type": "data-constant",
            default: 0.8,
            minimum: 0,
            maximum: 1,
            expression: { interpolated: !0, parameters: ["zoom"] },
            transition: !0,
          },
          "sky-horizon-blend": {
            type: "number",
            "property-type": "data-constant",
            default: 0.8,
            minimum: 0,
            maximum: 1,
            expression: { interpolated: !0, parameters: ["zoom"] },
            transition: !0,
          },
          "atmosphere-blend": {
            type: "number",
            "property-type": "data-constant",
            default: 0.8,
            minimum: 0,
            maximum: 1,
            expression: { interpolated: !0, parameters: ["zoom"] },
            transition: !0,
          },
        },
        terrain: {
          source: { type: "string", required: !0 },
          exaggeration: { type: "number", minimum: 0, default: 1 },
        },
        projection: {
          type: {
            type: "projectionDefinition",
            default: "mercator",
            "property-type": "data-constant",
            transition: !1,
            expression: { interpolated: !0, parameters: ["zoom"] },
          },
        },
        paint: [
          "paint_fill",
          "paint_line",
          "paint_circle",
          "paint_heatmap",
          "paint_fill-extrusion",
          "paint_symbol",
          "paint_raster",
          "paint_hillshade",
          "paint_background",
        ],
        paint_fill: {
          "fill-antialias": {
            type: "boolean",
            default: !0,
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "fill-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: !0,
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "fill-color": {
            type: "color",
            default: "#000000",
            transition: !0,
            requires: [{ "!": "fill-pattern" }],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "fill-outline-color": {
            type: "color",
            transition: !0,
            requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "fill-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: !0,
            units: "pixels",
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "fill-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["fill-translate"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "fill-pattern": {
            type: "resolvedImage",
            transition: !0,
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "cross-faded-data-driven",
          },
        },
        "paint_fill-extrusion": {
          "fill-extrusion-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "fill-extrusion-color": {
            type: "color",
            default: "#000000",
            transition: !0,
            requires: [{ "!": "fill-extrusion-pattern" }],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "fill-extrusion-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: !0,
            units: "pixels",
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "fill-extrusion-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["fill-extrusion-translate"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "fill-extrusion-pattern": {
            type: "resolvedImage",
            transition: !0,
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "cross-faded-data-driven",
          },
          "fill-extrusion-height": {
            type: "number",
            default: 0,
            minimum: 0,
            units: "meters",
            transition: !0,
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "fill-extrusion-base": {
            type: "number",
            default: 0,
            minimum: 0,
            units: "meters",
            transition: !0,
            requires: ["fill-extrusion-height"],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "fill-extrusion-vertical-gradient": {
            type: "boolean",
            default: !0,
            transition: !1,
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
        },
        paint_line: {
          "line-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: !0,
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "line-color": {
            type: "color",
            default: "#000000",
            transition: !0,
            requires: [{ "!": "line-pattern" }],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "line-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: !0,
            units: "pixels",
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "line-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["line-translate"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "line-width": {
            type: "number",
            default: 1,
            minimum: 0,
            transition: !0,
            units: "pixels",
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "line-gap-width": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: !0,
            units: "pixels",
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "line-offset": {
            type: "number",
            default: 0,
            transition: !0,
            units: "pixels",
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "line-blur": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: !0,
            units: "pixels",
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "line-dasharray": {
            type: "array",
            value: "number",
            minimum: 0,
            transition: !0,
            units: "line widths",
            requires: [{ "!": "line-pattern" }],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "cross-faded",
          },
          "line-pattern": {
            type: "resolvedImage",
            transition: !0,
            expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            "property-type": "cross-faded-data-driven",
          },
          "line-gradient": {
            type: "color",
            transition: !1,
            requires: [
              { "!": "line-dasharray" },
              { "!": "line-pattern" },
              { source: "geojson", has: { lineMetrics: !0 } },
            ],
            expression: { interpolated: !0, parameters: ["line-progress"] },
            "property-type": "color-ramp",
          },
        },
        paint_circle: {
          "circle-radius": {
            type: "number",
            default: 5,
            minimum: 0,
            transition: !0,
            units: "pixels",
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "circle-color": {
            type: "color",
            default: "#000000",
            transition: !0,
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "circle-blur": {
            type: "number",
            default: 0,
            transition: !0,
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "circle-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: !0,
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "circle-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: !0,
            units: "pixels",
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "circle-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["circle-translate"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "circle-pitch-scale": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "circle-pitch-alignment": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "viewport",
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "circle-stroke-width": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: !0,
            units: "pixels",
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "circle-stroke-color": {
            type: "color",
            default: "#000000",
            transition: !0,
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "circle-stroke-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: !0,
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
        },
        paint_heatmap: {
          "heatmap-radius": {
            type: "number",
            default: 30,
            minimum: 1,
            transition: !0,
            units: "pixels",
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "heatmap-weight": {
            type: "number",
            default: 1,
            minimum: 0,
            transition: !1,
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "heatmap-intensity": {
            type: "number",
            default: 1,
            minimum: 0,
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "heatmap-color": {
            type: "color",
            default: [
              "interpolate",
              ["linear"],
              ["heatmap-density"],
              0,
              "rgba(0, 0, 255, 0)",
              0.1,
              "royalblue",
              0.3,
              "cyan",
              0.5,
              "lime",
              0.7,
              "yellow",
              1,
              "red",
            ],
            transition: !1,
            expression: { interpolated: !0, parameters: ["heatmap-density"] },
            "property-type": "color-ramp",
          },
          "heatmap-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
        },
        paint_symbol: {
          "icon-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: !0,
            requires: ["icon-image"],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "icon-color": {
            type: "color",
            default: "#000000",
            transition: !0,
            requires: ["icon-image"],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "icon-halo-color": {
            type: "color",
            default: "rgba(0, 0, 0, 0)",
            transition: !0,
            requires: ["icon-image"],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "icon-halo-width": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: !0,
            units: "pixels",
            requires: ["icon-image"],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "icon-halo-blur": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: !0,
            units: "pixels",
            requires: ["icon-image"],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "icon-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: !0,
            units: "pixels",
            requires: ["icon-image"],
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "icon-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["icon-image", "icon-translate"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: !0,
            requires: ["text-field"],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "text-color": {
            type: "color",
            default: "#000000",
            transition: !0,
            overridable: !0,
            requires: ["text-field"],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "text-halo-color": {
            type: "color",
            default: "rgba(0, 0, 0, 0)",
            transition: !0,
            requires: ["text-field"],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "text-halo-width": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: !0,
            units: "pixels",
            requires: ["text-field"],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "text-halo-blur": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: !0,
            units: "pixels",
            requires: ["text-field"],
            expression: {
              interpolated: !0,
              parameters: ["zoom", "feature", "feature-state"],
            },
            "property-type": "data-driven",
          },
          "text-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: !0,
            units: "pixels",
            requires: ["text-field"],
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "text-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["text-field", "text-translate"],
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
        },
        paint_raster: {
          "raster-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "raster-hue-rotate": {
            type: "number",
            default: 0,
            period: 360,
            transition: !0,
            units: "degrees",
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "raster-brightness-min": {
            type: "number",
            default: 0,
            minimum: 0,
            maximum: 1,
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "raster-brightness-max": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "raster-saturation": {
            type: "number",
            default: 0,
            minimum: -1,
            maximum: 1,
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "raster-contrast": {
            type: "number",
            default: 0,
            minimum: -1,
            maximum: 1,
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "raster-resampling": {
            type: "enum",
            values: { linear: {}, nearest: {} },
            default: "linear",
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "raster-fade-duration": {
            type: "number",
            default: 300,
            minimum: 0,
            transition: !1,
            units: "milliseconds",
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
        },
        paint_hillshade: {
          "hillshade-illumination-direction": {
            type: "number",
            default: 335,
            minimum: 0,
            maximum: 359,
            transition: !1,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "hillshade-illumination-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "viewport",
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "hillshade-exaggeration": {
            type: "number",
            default: 0.5,
            minimum: 0,
            maximum: 1,
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "hillshade-shadow-color": {
            type: "color",
            default: "#000000",
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "hillshade-highlight-color": {
            type: "color",
            default: "#FFFFFF",
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "hillshade-accent-color": {
            type: "color",
            default: "#000000",
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
        },
        paint_background: {
          "background-color": {
            type: "color",
            default: "#000000",
            transition: !0,
            requires: [{ "!": "background-pattern" }],
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
          "background-pattern": {
            type: "resolvedImage",
            transition: !0,
            expression: { interpolated: !1, parameters: ["zoom"] },
            "property-type": "cross-faded",
          },
          "background-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: !0,
            expression: { interpolated: !0, parameters: ["zoom"] },
            "property-type": "data-constant",
          },
        },
        transition: {
          duration: {
            type: "number",
            default: 300,
            minimum: 0,
            units: "milliseconds",
          },
          delay: {
            type: "number",
            default: 0,
            minimum: 0,
            units: "milliseconds",
          },
        },
        "property-type": {
          "data-driven": { type: "property-type" },
          "cross-faded": { type: "property-type" },
          "cross-faded-data-driven": { type: "property-type" },
          "color-ramp": { type: "property-type" },
          "data-constant": { type: "property-type" },
          constant: { type: "property-type" },
        },
        promoteId: { "*": { type: "string" } },
      };
      const B = [
        "type",
        "source",
        "source-layer",
        "minzoom",
        "maxzoom",
        "filter",
        "layout",
      ];
      function z(n, t) {
        const r = {};
        for (const o in n) o !== "ref" && (r[o] = n[o]);
        return (
          B.forEach((o) => {
            o in t && (r[o] = t[o]);
          }),
          r
        );
      }
      function L(n, t) {
        if (Array.isArray(n)) {
          if (!Array.isArray(t) || n.length !== t.length) return !1;
          for (let r = 0; r < n.length; r++) if (!L(n[r], t[r])) return !1;
          return !0;
        }
        if (typeof n == "object" && n !== null && t !== null) {
          if (
            typeof t != "object" ||
            Object.keys(n).length !== Object.keys(t).length
          )
            return !1;
          for (const r in n) if (!L(n[r], t[r])) return !1;
          return !0;
        }
        return n === t;
      }
      function q(n, t) {
        n.push(t);
      }
      function te(n, t, r) {
        q(r, { command: "addSource", args: [n, t[n]] });
      }
      function ue(n, t, r) {
        (q(t, { command: "removeSource", args: [n] }), (r[n] = !0));
      }
      function fe(n, t, r, o) {
        (ue(n, r, o), te(n, t, r));
      }
      function ae(n, t, r) {
        let o;
        for (o in n[r])
          if (
            Object.prototype.hasOwnProperty.call(n[r], o) &&
            o !== "data" &&
            !L(n[r][o], t[r][o])
          )
            return !1;
        for (o in t[r])
          if (
            Object.prototype.hasOwnProperty.call(t[r], o) &&
            o !== "data" &&
            !L(n[r][o], t[r][o])
          )
            return !1;
        return !0;
      }
      function ve(n, t, r, o, l, d) {
        ((n = n || {}), (t = t || {}));
        for (const p in n)
          Object.prototype.hasOwnProperty.call(n, p) &&
            (L(n[p], t[p]) || r.push({ command: d, args: [o, p, t[p], l] }));
        for (const p in t)
          Object.prototype.hasOwnProperty.call(t, p) &&
            !Object.prototype.hasOwnProperty.call(n, p) &&
            (L(n[p], t[p]) || r.push({ command: d, args: [o, p, t[p], l] }));
      }
      function _e(n) {
        return n.id;
      }
      function ce(n, t) {
        return ((n[t.id] = t), n);
      }
      class oe {
        constructor(t, r, o, l) {
          ((this.message = (t ? `${t}: ` : "") + o),
            l && (this.identifier = l),
            r != null && r.__line__ && (this.line = r.__line__));
        }
      }
      function ke(n, ...t) {
        for (const r of t) for (const o in r) n[o] = r[o];
        return n;
      }
      class Ie extends Error {
        constructor(t, r) {
          (super(r), (this.message = r), (this.key = t));
        }
      }
      class Je {
        constructor(t, r = []) {
          ((this.parent = t), (this.bindings = {}));
          for (const [o, l] of r) this.bindings[o] = l;
        }
        concat(t) {
          return new Je(this, t);
        }
        get(t) {
          if (this.bindings[t]) return this.bindings[t];
          if (this.parent) return this.parent.get(t);
          throw new Error(`${t} not found in scope.`);
        }
        has(t) {
          return !!this.bindings[t] || (!!this.parent && this.parent.has(t));
        }
      }
      const nt = { kind: "null" },
        Ce = { kind: "number" },
        ze = { kind: "string" },
        Ve = { kind: "boolean" },
        lt = { kind: "color" },
        mt = { kind: "projectionDefinition" },
        it = { kind: "object" },
        je = { kind: "value" },
        Ht = { kind: "collator" },
        en = { kind: "formatted" },
        ci = { kind: "padding" },
        ni = { kind: "resolvedImage" },
        kt = { kind: "variableAnchorOffsetCollection" };
      function Qi(n, t) {
        return { kind: "array", itemType: n, N: t };
      }
      function zt(n) {
        if (n.kind === "array") {
          const t = zt(n.itemType);
          return typeof n.N == "number"
            ? `array<${t}, ${n.N}>`
            : n.itemType.kind === "value"
              ? "array"
              : `array<${t}>`;
        }
        return n.kind;
      }
      const Fo = [nt, Ce, ze, Ve, lt, mt, en, it, Qi(je), ci, ni, kt];
      function Hn(n, t) {
        if (t.kind === "error") return null;
        if (n.kind === "array") {
          if (
            t.kind === "array" &&
            ((t.N === 0 && t.itemType.kind === "value") ||
              !Hn(n.itemType, t.itemType)) &&
            (typeof n.N != "number" || n.N === t.N)
          )
            return null;
        } else {
          if (n.kind === t.kind) return null;
          if (n.kind === "value") {
            for (const r of Fo) if (!Hn(r, t)) return null;
          }
        }
        return `Expected ${zt(n)} but found ${zt(t)} instead.`;
      }
      function da(n, t) {
        return t.some((r) => r.kind === n.kind);
      }
      function Cn(n, t) {
        return t.some((r) =>
          r === "null"
            ? n === null
            : r === "array"
              ? Array.isArray(n)
              : r === "object"
                ? n && !Array.isArray(n) && typeof n == "object"
                : r === typeof n,
        );
      }
      function En(n, t) {
        return n.kind === "array" && t.kind === "array"
          ? n.itemType.kind === t.itemType.kind && typeof n.N == "number"
          : n.kind === t.kind;
      }
      const Il = 0.96422,
        pa = 0.82521,
        Bl = 4 / 29,
        Xn = 6 / 29,
        kl = 3 * Xn * Xn,
        ec = Xn * Xn * Xn,
        tc = Math.PI / 180,
        ic = 180 / Math.PI;
      function zl(n) {
        return ((n %= 360) < 0 && (n += 360), n);
      }
      function fa([n, t, r, o]) {
        let l, d;
        const p = ma(
          (0.2225045 * (n = An(n)) +
            0.7168786 * (t = An(t)) +
            0.0606169 * (r = An(r))) /
            1,
        );
        n === t && t === r
          ? (l = d = p)
          : ((l = ma((0.4360747 * n + 0.3850649 * t + 0.1430804 * r) / Il)),
            (d = ma((0.0139322 * n + 0.0971045 * t + 0.7141733 * r) / pa)));
        const m = 116 * p - 16;
        return [m < 0 ? 0 : m, 500 * (l - p), 200 * (p - d), o];
      }
      function An(n) {
        return n <= 0.04045 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4);
      }
      function ma(n) {
        return n > ec ? Math.pow(n, 1 / 3) : n / kl + Bl;
      }
      function Ll([n, t, r, o]) {
        let l = (n + 16) / 116,
          d = isNaN(t) ? l : l + t / 500,
          p = isNaN(r) ? l : l - r / 200;
        return (
          (l = 1 * ga(l)),
          (d = Il * ga(d)),
          (p = pa * ga(p)),
          [
            Tn(3.1338561 * d - 1.6168667 * l - 0.4906146 * p),
            Tn(-0.9787684 * d + 1.9161415 * l + 0.033454 * p),
            Tn(0.0719453 * d - 0.2289914 * l + 1.4052427 * p),
            o,
          ]
        );
      }
      function Tn(n) {
        return (n =
          n <= 0.00304 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - 0.055) < 0
          ? 0
          : n > 1
            ? 1
            : n;
      }
      function ga(n) {
        return n > Xn ? n * n * n : kl * (n - Bl);
      }
      function ss(n) {
        return parseInt(n.padEnd(2, n), 16) / 255;
      }
      function Rl(n, t) {
        return Fn(t ? n / 100 : n, 0, 1);
      }
      function Fn(n, t, r) {
        return Math.min(Math.max(t, n), r);
      }
      function _a(n) {
        return !n.some(Number.isNaN);
      }
      const Tr = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
      };
      function ut(n, t, r) {
        return n + r * (t - n);
      }
      function Fr(n, t, r) {
        return n.map((o, l) => ut(o, t[l], r));
      }
      class ct {
        constructor(t, r, o, l = 1, d = !0) {
          ((this.r = t),
            (this.g = r),
            (this.b = o),
            (this.a = l),
            d ||
              ((this.r *= l),
              (this.g *= l),
              (this.b *= l),
              l || this.overwriteGetter("rgb", [t, r, o, l])));
        }
        static parse(t) {
          if (t instanceof ct) return t;
          if (typeof t != "string") return;
          const r = (function (o) {
            if ((o = o.toLowerCase().trim()) === "transparent")
              return [0, 0, 0, 0];
            const l = Tr[o];
            if (l) {
              const [p, m, _] = l;
              return [p / 255, m / 255, _ / 255, 1];
            }
            if (
              o.startsWith("#") &&
              /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(o)
            ) {
              const p = o.length < 6 ? 1 : 2;
              let m = 1;
              return [
                ss(o.slice(m, (m += p))),
                ss(o.slice(m, (m += p))),
                ss(o.slice(m, (m += p))),
                ss(o.slice(m, m + p) || "ff"),
              ];
            }
            if (o.startsWith("rgb")) {
              const p = o.match(
                /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/,
              );
              if (p) {
                const [m, _, x, b, w, F, S, D, I, O, Z, ne] = p,
                  H = [b || " ", S || " ", O].join("");
                if (H === "  " || H === "  /" || H === ",," || H === ",,,") {
                  const P = [x, F, I].join(""),
                    R = P === "%%%" ? 100 : P === "" ? 255 : 0;
                  if (R) {
                    const W = [
                      Fn(+_ / R, 0, 1),
                      Fn(+w / R, 0, 1),
                      Fn(+D / R, 0, 1),
                      Z ? Rl(+Z, ne) : 1,
                    ];
                    if (_a(W)) return W;
                  }
                }
                return;
              }
            }
            const d = o.match(
              /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/,
            );
            if (d) {
              const [p, m, _, x, b, w, F, S, D] = d,
                I = [_ || " ", b || " ", F].join("");
              if (I === "  " || I === "  /" || I === ",," || I === ",,,") {
                const O = [
                  +m,
                  Fn(+x, 0, 100),
                  Fn(+w, 0, 100),
                  S ? Rl(+S, D) : 1,
                ];
                if (_a(O))
                  return (function ([Z, ne, H, P]) {
                    function R(W) {
                      const de = (W + Z / 30) % 12,
                        Te = ne * Math.min(H, 1 - H);
                      return H - Te * Math.max(-1, Math.min(de - 3, 9 - de, 1));
                    }
                    return (
                      (Z = zl(Z)),
                      (ne /= 100),
                      (H /= 100),
                      [R(0), R(8), R(4), P]
                    );
                  })(O);
              }
            }
          })(t);
          return r ? new ct(...r, !1) : void 0;
        }
        get rgb() {
          const { r: t, g: r, b: o, a: l } = this,
            d = l || 1 / 0;
          return this.overwriteGetter("rgb", [t / d, r / d, o / d, l]);
        }
        get hcl() {
          return this.overwriteGetter(
            "hcl",
            (function (t) {
              const [r, o, l, d] = fa(t),
                p = Math.sqrt(o * o + l * l);
              return [
                Math.round(1e4 * p) ? zl(Math.atan2(l, o) * ic) : NaN,
                p,
                r,
                d,
              ];
            })(this.rgb),
          );
        }
        get lab() {
          return this.overwriteGetter("lab", fa(this.rgb));
        }
        overwriteGetter(t, r) {
          return (Object.defineProperty(this, t, { value: r }), r);
        }
        toString() {
          const [t, r, o, l] = this.rgb;
          return `rgba(${[t, r, o].map((d) => Math.round(255 * d)).join(",")},${l})`;
        }
        static interpolate(t, r, o, l = "rgb") {
          switch (l) {
            case "rgb": {
              const [d, p, m, _] = Fr(t.rgb, r.rgb, o);
              return new ct(d, p, m, _, !1);
            }
            case "hcl": {
              const [d, p, m, _] = t.hcl,
                [x, b, w, F] = r.hcl;
              let S, D;
              if (isNaN(d) || isNaN(x))
                isNaN(d)
                  ? isNaN(x)
                    ? (S = NaN)
                    : ((S = x), (m !== 1 && m !== 0) || (D = b))
                  : ((S = d), (w !== 1 && w !== 0) || (D = p));
              else {
                let H = x - d;
                (x > d && H > 180
                  ? (H -= 360)
                  : x < d && d - x > 180 && (H += 360),
                  (S = d + o * H));
              }
              const [I, O, Z, ne] = (function ([H, P, R, W]) {
                return (
                  (H = isNaN(H) ? 0 : H * tc),
                  Ll([R, Math.cos(H) * P, Math.sin(H) * P, W])
                );
              })([S, D != null ? D : ut(p, b, o), ut(m, w, o), ut(_, F, o)]);
              return new ct(I, O, Z, ne, !1);
            }
            case "lab": {
              const [d, p, m, _] = Ll(Fr(t.lab, r.lab, o));
              return new ct(d, p, m, _, !1);
            }
          }
        }
      }
      ((ct.black = new ct(0, 0, 0, 1)),
        (ct.white = new ct(1, 1, 1, 1)),
        (ct.transparent = new ct(0, 0, 0, 0)),
        (ct.red = new ct(1, 0, 0, 1)));
      class as {
        constructor(t, r, o) {
          ((this.sensitivity = t
            ? r
              ? "variant"
              : "case"
            : r
              ? "accent"
              : "base"),
            (this.locale = o),
            (this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search",
            })));
        }
        compare(t, r) {
          return this.collator.compare(t, r);
        }
        resolvedLocale() {
          return new Intl.Collator(
            this.locale ? this.locale : [],
          ).resolvedOptions().locale;
        }
      }
      class ls {
        constructor(t, r, o, l, d) {
          ((this.text = t),
            (this.image = r),
            (this.scale = o),
            (this.fontStack = l),
            (this.textColor = d));
        }
      }
      class ki {
        constructor(t) {
          this.sections = t;
        }
        static fromString(t) {
          return new ki([new ls(t, null, null, null, null)]);
        }
        isEmpty() {
          return (
            this.sections.length === 0 ||
            !this.sections.some(
              (t) =>
                t.text.length !== 0 || (t.image && t.image.name.length !== 0),
            )
          );
        }
        static factory(t) {
          return t instanceof ki ? t : ki.fromString(t);
        }
        toString() {
          return this.sections.length === 0
            ? ""
            : this.sections.map((t) => t.text).join("");
        }
      }
      class Zt {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof Zt) return t;
          if (typeof t == "number") return new Zt([t, t, t, t]);
          if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
            for (const r of t) if (typeof r != "number") return;
            switch (t.length) {
              case 1:
                t = [t[0], t[0], t[0], t[0]];
                break;
              case 2:
                t = [t[0], t[1], t[0], t[1]];
                break;
              case 3:
                t = [t[0], t[1], t[2], t[1]];
            }
            return new Zt(t);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(t, r, o) {
          return new Zt(Fr(t.values, r.values, o));
        }
      }
      class Lt {
        constructor(t) {
          ((this.name = "ExpressionEvaluationError"), (this.message = t));
        }
        toJSON() {
          return this.message;
        }
      }
      const us = new Set([
        "center",
        "left",
        "right",
        "top",
        "bottom",
        "top-left",
        "top-right",
        "bottom-left",
        "bottom-right",
      ]);
      class Ti {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof Ti) return t;
          if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
            for (let r = 0; r < t.length; r += 2) {
              const o = t[r],
                l = t[r + 1];
              if (
                typeof o != "string" ||
                !us.has(o) ||
                !Array.isArray(l) ||
                l.length !== 2 ||
                typeof l[0] != "number" ||
                typeof l[1] != "number"
              )
                return;
            }
            return new Ti(t);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(t, r, o) {
          const l = t.values,
            d = r.values;
          if (l.length !== d.length)
            throw new Lt(
              `Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`,
            );
          const p = [];
          for (let m = 0; m < l.length; m += 2) {
            if (l[m] !== d[m])
              throw new Lt(
                `Cannot interpolate values containing mismatched anchors. from[${m}]: ${l[m]}, to[${m}]: ${d[m]}`,
              );
            p.push(l[m]);
            const [_, x] = l[m + 1],
              [b, w] = d[m + 1];
            p.push([ut(_, b, o), ut(x, w, o)]);
          }
          return new Ti(p);
        }
      }
      class Ui {
        constructor(t) {
          ((this.name = t.name), (this.available = t.available));
        }
        toString() {
          return this.name;
        }
        static fromString(t) {
          return t ? new Ui({ name: t, available: !1 }) : null;
        }
      }
      class xi {
        constructor(t, r, o) {
          ((this.from = t), (this.to = r), (this.transition = o));
        }
        static interpolate(t, r, o) {
          return new xi(t, r, o);
        }
        static parse(t) {
          return t instanceof xi
            ? t
            : Array.isArray(t) &&
                t.length === 3 &&
                typeof t[0] == "string" &&
                typeof t[1] == "string" &&
                typeof t[2] == "number"
              ? new xi(t[0], t[1], t[2])
              : typeof t == "object" &&
                  typeof t.from == "string" &&
                  typeof t.to == "string" &&
                  typeof t.transition == "number"
                ? new xi(t.from, t.to, t.transition)
                : typeof t == "string"
                  ? new xi(t, t, 1)
                  : void 0;
        }
      }
      function Po(n, t, r, o) {
        return typeof n == "number" &&
          n >= 0 &&
          n <= 255 &&
          typeof t == "number" &&
          t >= 0 &&
          t <= 255 &&
          typeof r == "number" &&
          r >= 0 &&
          r <= 255
          ? o === void 0 || (typeof o == "number" && o >= 0 && o <= 1)
            ? null
            : `Invalid rgba value [${[n, t, r, o].join(", ")}]: 'a' must be between 0 and 1.`
          : `Invalid rgba value [${(typeof o == "number" ? [n, t, r, o] : [n, t, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Wn(n) {
        if (
          n === null ||
          typeof n == "string" ||
          typeof n == "boolean" ||
          typeof n == "number" ||
          n instanceof xi ||
          n instanceof ct ||
          n instanceof as ||
          n instanceof ki ||
          n instanceof Zt ||
          n instanceof Ti ||
          n instanceof Ui
        )
          return !0;
        if (Array.isArray(n)) {
          for (const t of n) if (!Wn(t)) return !1;
          return !0;
        }
        if (typeof n == "object") {
          for (const t in n) if (!Wn(n[t])) return !1;
          return !0;
        }
        return !1;
      }
      function Kt(n) {
        if (n === null) return nt;
        if (typeof n == "string") return ze;
        if (typeof n == "boolean") return Ve;
        if (typeof n == "number") return Ce;
        if (n instanceof ct) return lt;
        if (n instanceof xi) return mt;
        if (n instanceof as) return Ht;
        if (n instanceof ki) return en;
        if (n instanceof Zt) return ci;
        if (n instanceof Ti) return kt;
        if (n instanceof Ui) return ni;
        if (Array.isArray(n)) {
          const t = n.length;
          let r;
          for (const o of n) {
            const l = Kt(o);
            if (r) {
              if (r === l) continue;
              r = je;
              break;
            }
            r = l;
          }
          return Qi(r || je, t);
        }
        return it;
      }
      function _r(n) {
        const t = typeof n;
        return n === null
          ? ""
          : t === "string" || t === "number" || t === "boolean"
            ? String(n)
            : n instanceof ct ||
                n instanceof xi ||
                n instanceof ki ||
                n instanceof Zt ||
                n instanceof Ti ||
                n instanceof Ui
              ? n.toString()
              : JSON.stringify(n);
      }
      class Pn {
        constructor(t, r) {
          ((this.type = t), (this.value = r));
        }
        static parse(t, r) {
          if (t.length !== 2)
            return r.error(
              `'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`,
            );
          if (!Wn(t[1])) return r.error("invalid value");
          const o = t[1];
          let l = Kt(o);
          const d = r.expectedType;
          return (
            l.kind !== "array" ||
              l.N !== 0 ||
              !d ||
              d.kind !== "array" ||
              (typeof d.N == "number" && d.N !== 0) ||
              (l = d),
            new Pn(l, o)
          );
        }
        evaluate() {
          return this.value;
        }
        eachChild() {}
        outputDefined() {
          return !0;
        }
      }
      const Sn = { string: ze, number: Ce, boolean: Ve, object: it };
      class Fi {
        constructor(t, r) {
          ((this.type = t), (this.args = r));
        }
        static parse(t, r) {
          if (t.length < 2) return r.error("Expected at least one argument.");
          let o,
            l = 1;
          const d = t[0];
          if (d === "array") {
            let m, _;
            if (t.length > 2) {
              const x = t[1];
              if (typeof x != "string" || !(x in Sn) || x === "object")
                return r.error(
                  "The item type argument of \"array\" must be one of string, number, boolean",
                  1,
                );
              ((m = Sn[x]), l++);
            } else m = je;
            if (t.length > 3) {
              if (
                t[2] !== null &&
                (typeof t[2] != "number" ||
                  t[2] < 0 ||
                  t[2] !== Math.floor(t[2]))
              )
                return r.error(
                  "The length argument to \"array\" must be a positive integer literal",
                  2,
                );
              ((_ = t[2]), l++);
            }
            o = Qi(m, _);
          } else {
            if (!Sn[d]) throw new Error(`Types doesn't contain name = ${d}`);
            o = Sn[d];
          }
          const p = [];
          for (; l < t.length; l++) {
            const m = r.parse(t[l], l, je);
            if (!m) return null;
            p.push(m);
          }
          return new Fi(o, p);
        }
        evaluate(t) {
          for (let r = 0; r < this.args.length; r++) {
            const o = this.args[r].evaluate(t);
            if (!Hn(this.type, Kt(o))) return o;
            if (r === this.args.length - 1)
              throw new Lt(
                `Expected value to be of type ${zt(this.type)}, but found ${zt(Kt(o))} instead.`,
              );
          }
          throw new Error();
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      const ya = {
        "to-boolean": Ve,
        "to-color": lt,
        "to-number": Ce,
        "to-string": ze,
      };
      class Or {
        constructor(t, r) {
          ((this.type = t), (this.args = r));
        }
        static parse(t, r) {
          if (t.length < 2) return r.error("Expected at least one argument.");
          const o = t[0];
          if (!ya[o])
            throw new Error(
              `Can't parse ${o} as it is not part of the known types`,
            );
          if ((o === "to-boolean" || o === "to-string") && t.length !== 2)
            return r.error("Expected one argument.");
          const l = ya[o],
            d = [];
          for (let p = 1; p < t.length; p++) {
            const m = r.parse(t[p], p, je);
            if (!m) return null;
            d.push(m);
          }
          return new Or(l, d);
        }
        evaluate(t) {
          switch (this.type.kind) {
            case "boolean":
              return Boolean(this.args[0].evaluate(t));
            case "color": {
              let r, o;
              for (const l of this.args) {
                if (((r = l.evaluate(t)), (o = null), r instanceof ct))
                  return r;
                if (typeof r == "string") {
                  const d = t.parseColor(r);
                  if (d) return d;
                } else if (
                  Array.isArray(r) &&
                  ((o =
                    r.length < 3 || r.length > 4
                      ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.`
                      : Po(r[0], r[1], r[2], r[3])),
                  !o)
                )
                  return new ct(r[0] / 255, r[1] / 255, r[2] / 255, r[3]);
              }
              throw new Lt(
                o ||
                  `Could not parse color from value '${typeof r == "string" ? r : JSON.stringify(r)}'`,
              );
            }
            case "padding": {
              let r;
              for (const o of this.args) {
                r = o.evaluate(t);
                const l = Zt.parse(r);
                if (l) return l;
              }
              throw new Lt(
                `Could not parse padding from value '${typeof r == "string" ? r : JSON.stringify(r)}'`,
              );
            }
            case "variableAnchorOffsetCollection": {
              let r;
              for (const o of this.args) {
                r = o.evaluate(t);
                const l = Ti.parse(r);
                if (l) return l;
              }
              throw new Lt(
                `Could not parse variableAnchorOffsetCollection from value '${typeof r == "string" ? r : JSON.stringify(r)}'`,
              );
            }
            case "number": {
              let r = null;
              for (const o of this.args) {
                if (((r = o.evaluate(t)), r === null)) return 0;
                const l = Number(r);
                if (!isNaN(l)) return l;
              }
              throw new Lt(`Could not convert ${JSON.stringify(r)} to number.`);
            }
            case "formatted":
              return ki.fromString(_r(this.args[0].evaluate(t)));
            case "resolvedImage":
              return Ui.fromString(_r(this.args[0].evaluate(t)));
            case "projectionDefinition":
              return this.args[0].evaluate(t);
            default:
              return _r(this.args[0].evaluate(t));
          }
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      function xa(n, t, r = 0, o = n.length - 1, l = Rt) {
        for (; o > r; ) {
          if (o - r > 600) {
            const _ = o - r + 1,
              x = t - r + 1,
              b = Math.log(_),
              w = 0.5 * Math.exp((2 * b) / 3),
              F =
                0.5 *
                Math.sqrt((b * w * (_ - w)) / _) *
                (x - _ / 2 < 0 ? -1 : 1);
            xa(
              n,
              t,
              Math.max(r, Math.floor(t - (x * w) / _ + F)),
              Math.min(o, Math.floor(t + ((_ - x) * w) / _ + F)),
              l,
            );
          }
          const d = n[t];
          let p = r,
            m = o;
          for (tn(n, r, t), l(n[o], d) > 0 && tn(n, r, o); p < m; ) {
            for (tn(n, p, m), p++, m--; l(n[p], d) < 0; ) p++;
            for (; l(n[m], d) > 0; ) m--;
          }
          (l(n[r], d) === 0 ? tn(n, r, m) : (m++, tn(n, m, o)),
            m <= t && (r = m + 1),
            t <= m && (o = m - 1));
        }
      }
      function tn(n, t, r) {
        const o = n[t];
        ((n[t] = n[r]), (n[r] = o));
      }
      function Rt(n, t) {
        return n < t ? -1 : n > t ? 1 : 0;
      }
      function Kn(n, t) {
        if (n.length <= 1) return [n];
        const r = [];
        let o, l;
        for (const d of n) {
          const p = at(d);
          p !== 0 &&
            ((d.area = Math.abs(p)),
            l === void 0 && (l = p < 0),
            l === p < 0 ? (o && r.push(o), (o = [d])) : o.push(d));
        }
        if ((o && r.push(o), t > 1))
          for (let d = 0; d < r.length; d++)
            r[d].length <= t ||
              (xa(r[d], t, 1, r[d].length - 1, xt), (r[d] = r[d].slice(0, t)));
        return r;
      }
      function xt(n, t) {
        return t.area - n.area;
      }
      function at(n) {
        let t = 0;
        for (let r, o, l = 0, d = n.length, p = d - 1; l < d; p = l++)
          ((r = n[l]), (o = n[p]), (t += (o.x - r.x) * (r.y + o.y)));
        return t;
      }
      const cs = ["Unknown", "Point", "LineString", "Polygon"],
        vt = {
          Unknown: "Unknown",
          Point: "Point",
          MultiPoint: "Point",
          LineString: "LineString",
          MultiLineString: "LineString",
          Polygon: "Polygon",
          MultiPolygon: "Polygon",
        };
      class hs {
        constructor() {
          ((this.globals = null),
            (this.feature = null),
            (this.featureState = null),
            (this.formattedSection = null),
            (this._parseColorCache = {}),
            (this.availableImages = null),
            (this.canonical = null));
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryDollarType() {
          return this.feature
            ? typeof this.feature.type == "number"
              ? cs[this.feature.type]
              : vt[this.feature.type]
            : null;
        }
        geometryType() {
          let t = this.feature.type;
          if (
            typeof t != "number" ||
            ((t = cs[this.feature.type]), t === "Unknown")
          )
            return t;
          const r = this.geometry();
          return r.length === 1
            ? t
            : t !== "Polygon"
              ? `Multi${t}`
              : (function (o) {
                    const l = o.length;
                    for (let d, p = 0; p < l; p++) {
                      const m = at(o[p]);
                      if (m !== 0) {
                        if (d === void 0) d = m < 0;
                        else if (d === m < 0) return !0;
                      }
                    }
                    return !1;
                  })(r)
                ? "MultiPolygon"
                : "Polygon";
        }
        geometry() {
          return this.feature && "geometry" in this.feature
            ? this.feature.geometry
            : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return (this.feature && this.feature.properties) || {};
        }
        parseColor(t) {
          let r = this._parseColorCache[t];
          return (r || (r = this._parseColorCache[t] = ct.parse(t)), r);
        }
      }
      class lr {
        constructor(t, r, o = [], l, d = new Je(), p = []) {
          ((this.registry = t),
            (this.path = o),
            (this.key = o.map((m) => `[${m}]`).join("")),
            (this.scope = d),
            (this.errors = p),
            (this.expectedType = l),
            (this._isConstant = r));
        }
        parse(t, r, o, l, d = {}) {
          return r ? this.concat(r, o, l)._parse(t, d) : this._parse(t, d);
        }
        _parse(t, r) {
          function o(l, d, p) {
            return p === "assert"
              ? new Fi(d, [l])
              : p === "coerce"
                ? new Or(d, [l])
                : l;
          }
          if (
            ((t !== null &&
              typeof t != "string" &&
              typeof t != "boolean" &&
              typeof t != "number") ||
              (t = ["literal", t]),
            Array.isArray(t))
          ) {
            if (t.length === 0)
              return this.error(
                "Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].",
              );
            const l = t[0];
            if (typeof l != "string")
              return (
                this.error(
                  `Expression name must be a string, but found ${typeof l} instead. If you wanted a literal array, use ["literal", [...]].`,
                  0,
                ),
                null
              );
            const d = this.registry[l];
            if (d) {
              let p = d.parse(t, this);
              if (!p) return null;
              if (this.expectedType) {
                const m = this.expectedType,
                  _ = p.type;
                if (
                  (m.kind !== "string" &&
                    m.kind !== "number" &&
                    m.kind !== "boolean" &&
                    m.kind !== "object" &&
                    m.kind !== "array") ||
                  _.kind !== "value"
                )
                  if (
                    m.kind !== "projectionDefinition" ||
                    (_.kind !== "string" && _.kind !== "array")
                  )
                    if (
                      (m.kind !== "color" &&
                        m.kind !== "formatted" &&
                        m.kind !== "resolvedImage") ||
                      (_.kind !== "value" && _.kind !== "string")
                    )
                      if (
                        m.kind !== "padding" ||
                        (_.kind !== "value" &&
                          _.kind !== "number" &&
                          _.kind !== "array")
                      )
                        if (
                          m.kind !== "variableAnchorOffsetCollection" ||
                          (_.kind !== "value" && _.kind !== "array")
                        ) {
                          if (this.checkSubtype(m, _)) return null;
                        } else p = o(p, m, r.typeAnnotation || "coerce");
                      else p = o(p, m, r.typeAnnotation || "coerce");
                    else p = o(p, m, r.typeAnnotation || "coerce");
                  else p = o(p, m, r.typeAnnotation || "coerce");
                else p = o(p, m, r.typeAnnotation || "assert");
              }
              if (
                !(p instanceof Pn) &&
                p.type.kind !== "resolvedImage" &&
                this._isConstant(p)
              ) {
                const m = new hs();
                try {
                  p = new Pn(p.type, p.evaluate(m));
                } catch (_) {
                  return (this.error(_.message), null);
                }
              }
              return p;
            }
            return this.error(
              `Unknown expression "${l}". If you wanted a literal array, use ["literal", [...]].`,
              0,
            );
          }
          return this.error(
            t === void 0
              ? "'undefined' value invalid. Use null instead."
              : typeof t == "object"
                ? "Bare objects invalid. Use [\"literal\", {...}] instead."
                : `Expected an array, but found ${typeof t} instead.`,
          );
        }
        concat(t, r, o) {
          const l = typeof t == "number" ? this.path.concat(t) : this.path,
            d = o ? this.scope.concat(o) : this.scope;
          return new lr(
            this.registry,
            this._isConstant,
            l,
            r || null,
            d,
            this.errors,
          );
        }
        error(t, ...r) {
          const o = `${this.key}${r.map((l) => `[${l}]`).join("")}`;
          this.errors.push(new Ie(o, t));
        }
        checkSubtype(t, r) {
          const o = Hn(t, r);
          return (o && this.error(o), o);
        }
      }
      class Yn {
        constructor(t, r) {
          ((this.type = r.type),
            (this.bindings = [].concat(t)),
            (this.result = r));
        }
        evaluate(t) {
          return this.result.evaluate(t);
        }
        eachChild(t) {
          for (const r of this.bindings) t(r[1]);
          t(this.result);
        }
        static parse(t, r) {
          if (t.length < 4)
            return r.error(
              `Expected at least 3 arguments, but found ${t.length - 1} instead.`,
            );
          const o = [];
          for (let d = 1; d < t.length - 1; d += 2) {
            const p = t[d];
            if (typeof p != "string")
              return r.error(
                `Expected string, but found ${typeof p} instead.`,
                d,
              );
            if (/[^a-zA-Z0-9_]/.test(p))
              return r.error(
                "Variable names must contain only alphanumeric characters or '_'.",
                d,
              );
            const m = r.parse(t[d + 1], d + 1);
            if (!m) return null;
            o.push([p, m]);
          }
          const l = r.parse(t[t.length - 1], t.length - 1, r.expectedType, o);
          return l ? new Yn(o, l) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Dn {
        constructor(t, r) {
          ((this.type = r.type), (this.name = t), (this.boundExpression = r));
        }
        static parse(t, r) {
          if (t.length !== 2 || typeof t[1] != "string")
            return r.error(
              "'var' expression requires exactly one string literal argument.",
            );
          const o = t[1];
          return r.scope.has(o)
            ? new Dn(o, r.scope.get(o))
            : r.error(
                `Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`,
                1,
              );
        }
        evaluate(t) {
          return this.boundExpression.evaluate(t);
        }
        eachChild() {}
        outputDefined() {
          return !1;
        }
      }
      class ds {
        constructor(t, r, o) {
          ((this.type = t), (this.index = r), (this.input = o));
        }
        static parse(t, r) {
          if (t.length !== 3)
            return r.error(
              `Expected 2 arguments, but found ${t.length - 1} instead.`,
            );
          const o = r.parse(t[1], 1, Ce),
            l = r.parse(t[2], 2, Qi(r.expectedType || je));
          return o && l ? new ds(l.type.itemType, o, l) : null;
        }
        evaluate(t) {
          const r = this.index.evaluate(t),
            o = this.input.evaluate(t);
          if (r < 0) throw new Lt(`Array index out of bounds: ${r} < 0.`);
          if (r >= o.length)
            throw new Lt(`Array index out of bounds: ${r} > ${o.length - 1}.`);
          if (r !== Math.floor(r))
            throw new Lt(
              `Array index must be an integer, but found ${r} instead.`,
            );
          return o[r];
        }
        eachChild(t) {
          (t(this.index), t(this.input));
        }
        outputDefined() {
          return !1;
        }
      }
      class So {
        constructor(t, r) {
          ((this.type = Ve), (this.needle = t), (this.haystack = r));
        }
        static parse(t, r) {
          if (t.length !== 3)
            return r.error(
              `Expected 2 arguments, but found ${t.length - 1} instead.`,
            );
          const o = r.parse(t[1], 1, je),
            l = r.parse(t[2], 2, je);
          return o && l
            ? da(o.type, [Ve, ze, Ce, nt, je])
              ? new So(o, l)
              : r.error(
                  `Expected first argument to be of type boolean, string, number or null, but found ${zt(o.type)} instead`,
                )
            : null;
        }
        evaluate(t) {
          const r = this.needle.evaluate(t),
            o = this.haystack.evaluate(t);
          if (!o) return !1;
          if (!Cn(r, ["boolean", "string", "number", "null"]))
            throw new Lt(
              `Expected first argument to be of type boolean, string, number or null, but found ${zt(Kt(r))} instead.`,
            );
          if (!Cn(o, ["string", "array"]))
            throw new Lt(
              `Expected second argument to be of type array or string, but found ${zt(Kt(o))} instead.`,
            );
          return o.indexOf(r) >= 0;
        }
        eachChild(t) {
          (t(this.needle), t(this.haystack));
        }
        outputDefined() {
          return !0;
        }
      }
      class Do {
        constructor(t, r, o) {
          ((this.type = Ce),
            (this.needle = t),
            (this.haystack = r),
            (this.fromIndex = o));
        }
        static parse(t, r) {
          if (t.length <= 2 || t.length >= 5)
            return r.error(
              `Expected 3 or 4 arguments, but found ${t.length - 1} instead.`,
            );
          const o = r.parse(t[1], 1, je),
            l = r.parse(t[2], 2, je);
          if (!o || !l) return null;
          if (!da(o.type, [Ve, ze, Ce, nt, je]))
            return r.error(
              `Expected first argument to be of type boolean, string, number or null, but found ${zt(o.type)} instead`,
            );
          if (t.length === 4) {
            const d = r.parse(t[3], 3, Ce);
            return d ? new Do(o, l, d) : null;
          }
          return new Do(o, l);
        }
        evaluate(t) {
          const r = this.needle.evaluate(t),
            o = this.haystack.evaluate(t);
          if (!Cn(r, ["boolean", "string", "number", "null"]))
            throw new Lt(
              `Expected first argument to be of type boolean, string, number or null, but found ${zt(Kt(r))} instead.`,
            );
          let l;
          if (
            (this.fromIndex && (l = this.fromIndex.evaluate(t)),
            Cn(o, ["string"]))
          ) {
            const d = o.indexOf(r, l);
            return d === -1 ? -1 : [...o.slice(0, d)].length;
          }
          if (Cn(o, ["array"])) return o.indexOf(r, l);
          throw new Lt(
            `Expected second argument to be of type array or string, but found ${zt(Kt(o))} instead.`,
          );
        }
        eachChild(t) {
          (t(this.needle),
            t(this.haystack),
            this.fromIndex && t(this.fromIndex));
        }
        outputDefined() {
          return !1;
        }
      }
      class va {
        constructor(t, r, o, l, d, p) {
          ((this.inputType = t),
            (this.type = r),
            (this.input = o),
            (this.cases = l),
            (this.outputs = d),
            (this.otherwise = p));
        }
        static parse(t, r) {
          if (t.length < 5)
            return r.error(
              `Expected at least 4 arguments, but found only ${t.length - 1}.`,
            );
          if (t.length % 2 != 1)
            return r.error("Expected an even number of arguments.");
          let o, l;
          r.expectedType &&
            r.expectedType.kind !== "value" &&
            (l = r.expectedType);
          const d = {},
            p = [];
          for (let x = 2; x < t.length - 1; x += 2) {
            let b = t[x];
            const w = t[x + 1];
            Array.isArray(b) || (b = [b]);
            const F = r.concat(x);
            if (b.length === 0)
              return F.error("Expected at least one branch label.");
            for (const D of b) {
              if (typeof D != "number" && typeof D != "string")
                return F.error("Branch labels must be numbers or strings.");
              if (typeof D == "number" && Math.abs(D) > Number.MAX_SAFE_INTEGER)
                return F.error(
                  `Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`,
                );
              if (typeof D == "number" && Math.floor(D) !== D)
                return F.error("Numeric branch labels must be integer values.");
              if (o) {
                if (F.checkSubtype(o, Kt(D))) return null;
              } else o = Kt(D);
              if (d[String(D)] !== void 0)
                return F.error("Branch labels must be unique.");
              d[String(D)] = p.length;
            }
            const S = r.parse(w, x, l);
            if (!S) return null;
            ((l = l || S.type), p.push(S));
          }
          const m = r.parse(t[1], 1, je);
          if (!m) return null;
          const _ = r.parse(t[t.length - 1], t.length - 1, l);
          return _
            ? m.type.kind !== "value" && r.concat(1).checkSubtype(o, m.type)
              ? null
              : new va(o, l, m, d, p, _)
            : null;
        }
        evaluate(t) {
          const r = this.input.evaluate(t);
          return (
            (Kt(r) === this.inputType && this.outputs[this.cases[r]]) ||
            this.otherwise
          ).evaluate(t);
        }
        eachChild(t) {
          (t(this.input), this.outputs.forEach(t), t(this.otherwise));
        }
        outputDefined() {
          return (
            this.outputs.every((t) => t.outputDefined()) &&
            this.otherwise.outputDefined()
          );
        }
      }
      class ps {
        constructor(t, r, o) {
          ((this.type = t), (this.branches = r), (this.otherwise = o));
        }
        static parse(t, r) {
          if (t.length < 4)
            return r.error(
              `Expected at least 3 arguments, but found only ${t.length - 1}.`,
            );
          if (t.length % 2 != 0)
            return r.error("Expected an odd number of arguments.");
          let o;
          r.expectedType &&
            r.expectedType.kind !== "value" &&
            (o = r.expectedType);
          const l = [];
          for (let p = 1; p < t.length - 1; p += 2) {
            const m = r.parse(t[p], p, Ve);
            if (!m) return null;
            const _ = r.parse(t[p + 1], p + 1, o);
            if (!_) return null;
            (l.push([m, _]), (o = o || _.type));
          }
          const d = r.parse(t[t.length - 1], t.length - 1, o);
          if (!d) return null;
          if (!o) throw new Error("Can't infer output type");
          return new ps(o, l, d);
        }
        evaluate(t) {
          for (const [r, o] of this.branches)
            if (r.evaluate(t)) return o.evaluate(t);
          return this.otherwise.evaluate(t);
        }
        eachChild(t) {
          for (const [r, o] of this.branches) (t(r), t(o));
          t(this.otherwise);
        }
        outputDefined() {
          return (
            this.branches.every(([t, r]) => r.outputDefined()) &&
            this.otherwise.outputDefined()
          );
        }
      }
      class Mo {
        constructor(t, r, o, l) {
          ((this.type = t),
            (this.input = r),
            (this.beginIndex = o),
            (this.endIndex = l));
        }
        static parse(t, r) {
          if (t.length <= 2 || t.length >= 5)
            return r.error(
              `Expected 3 or 4 arguments, but found ${t.length - 1} instead.`,
            );
          const o = r.parse(t[1], 1, je),
            l = r.parse(t[2], 2, Ce);
          if (!o || !l) return null;
          if (!da(o.type, [Qi(je), ze, je]))
            return r.error(
              `Expected first argument to be of type array or string, but found ${zt(o.type)} instead`,
            );
          if (t.length === 4) {
            const d = r.parse(t[3], 3, Ce);
            return d ? new Mo(o.type, o, l, d) : null;
          }
          return new Mo(o.type, o, l);
        }
        evaluate(t) {
          const r = this.input.evaluate(t),
            o = this.beginIndex.evaluate(t);
          let l;
          if (
            (this.endIndex && (l = this.endIndex.evaluate(t)),
            Cn(r, ["string"]))
          )
            return [...r].slice(o, l).join("");
          if (Cn(r, ["array"])) return r.slice(o, l);
          throw new Lt(
            `Expected first argument to be of type array or string, but found ${zt(Kt(r))} instead.`,
          );
        }
        eachChild(t) {
          (t(this.input),
            t(this.beginIndex),
            this.endIndex && t(this.endIndex));
        }
        outputDefined() {
          return !1;
        }
      }
      function rn(n, t) {
        const r = n.length - 1;
        let o,
          l,
          d = 0,
          p = r,
          m = 0;
        for (; d <= p; )
          if (
            ((m = Math.floor((d + p) / 2)), (o = n[m]), (l = n[m + 1]), o <= t)
          ) {
            if (m === r || t < l) return m;
            d = m + 1;
          } else {
            if (!(o > t)) throw new Lt("Input is not a number.");
            p = m - 1;
          }
        return 0;
      }
      class oi {
        constructor(t, r, o) {
          ((this.type = t),
            (this.input = r),
            (this.labels = []),
            (this.outputs = []));
          for (const [l, d] of o) (this.labels.push(l), this.outputs.push(d));
        }
        static parse(t, r) {
          if (t.length - 1 < 4)
            return r.error(
              `Expected at least 4 arguments, but found only ${t.length - 1}.`,
            );
          if ((t.length - 1) % 2 != 0)
            return r.error("Expected an even number of arguments.");
          const o = r.parse(t[1], 1, Ce);
          if (!o) return null;
          const l = [];
          let d = null;
          r.expectedType &&
            r.expectedType.kind !== "value" &&
            (d = r.expectedType);
          for (let p = 1; p < t.length; p += 2) {
            const m = p === 1 ? -1 / 0 : t[p],
              _ = t[p + 1],
              x = p,
              b = p + 1;
            if (typeof m != "number")
              return r.error(
                "Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.",
                x,
              );
            if (l.length && l[l.length - 1][0] >= m)
              return r.error(
                "Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.",
                x,
              );
            const w = r.parse(_, b, d);
            if (!w) return null;
            ((d = d || w.type), l.push([m, w]));
          }
          return new oi(d, o, l);
        }
        evaluate(t) {
          const r = this.labels,
            o = this.outputs;
          if (r.length === 1) return o[0].evaluate(t);
          const l = this.input.evaluate(t);
          if (l <= r[0]) return o[0].evaluate(t);
          const d = r.length;
          return l >= r[d - 1] ? o[d - 1].evaluate(t) : o[rn(r, l)].evaluate(t);
        }
        eachChild(t) {
          t(this.input);
          for (const r of this.outputs) t(r);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
      }
      function fs(n) {
        return n &&
          n.__esModule &&
          Object.prototype.hasOwnProperty.call(n, "default")
          ? n.default
          : n;
      }
      var ms,
        Io,
        mi = (function () {
          if (Io) return ms;
          function n(t, r, o, l) {
            ((this.cx = 3 * t),
              (this.bx = 3 * (o - t) - this.cx),
              (this.ax = 1 - this.cx - this.bx),
              (this.cy = 3 * r),
              (this.by = 3 * (l - r) - this.cy),
              (this.ay = 1 - this.cy - this.by),
              (this.p1x = t),
              (this.p1y = r),
              (this.p2x = o),
              (this.p2y = l));
          }
          return (
            (Io = 1),
            (ms = n),
            (n.prototype = {
              sampleCurveX: function (t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t;
              },
              sampleCurveY: function (t) {
                return ((this.ay * t + this.by) * t + this.cy) * t;
              },
              sampleCurveDerivativeX: function (t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
              },
              solveCurveX: function (t, r) {
                if ((r === void 0 && (r = 1e-6), t < 0)) return 0;
                if (t > 1) return 1;
                for (var o = t, l = 0; l < 8; l++) {
                  var d = this.sampleCurveX(o) - t;
                  if (Math.abs(d) < r) return o;
                  var p = this.sampleCurveDerivativeX(o);
                  if (Math.abs(p) < 1e-6) break;
                  o -= d / p;
                }
                var m = 0,
                  _ = 1;
                for (
                  o = t, l = 0;
                  l < 20 &&
                  ((d = this.sampleCurveX(o)), !(Math.abs(d - t) < r));
                  l++
                )
                  (t > d ? (m = o) : (_ = o), (o = 0.5 * (_ - m) + m));
                return o;
              },
              solve: function (t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r));
              },
            }),
            ms
          );
        })(),
        Ol = fs(mi);
      class zi {
        constructor(t, r, o, l, d) {
          ((this.type = t),
            (this.operator = r),
            (this.interpolation = o),
            (this.input = l),
            (this.labels = []),
            (this.outputs = []));
          for (const [p, m] of d) (this.labels.push(p), this.outputs.push(m));
        }
        static interpolationFactor(t, r, o, l) {
          let d = 0;
          if (t.name === "exponential") d = gs(r, t.base, o, l);
          else if (t.name === "linear") d = gs(r, 1, o, l);
          else if (t.name === "cubic-bezier") {
            const p = t.controlPoints;
            d = new Ol(p[0], p[1], p[2], p[3]).solve(gs(r, 1, o, l));
          }
          return d;
        }
        static parse(t, r) {
          let [o, l, d, ...p] = t;
          if (!Array.isArray(l) || l.length === 0)
            return r.error("Expected an interpolation type expression.", 1);
          if (l[0] === "linear") l = { name: "linear" };
          else if (l[0] === "exponential") {
            const x = l[1];
            if (typeof x != "number")
              return r.error(
                "Exponential interpolation requires a numeric base.",
                1,
                1,
              );
            l = { name: "exponential", base: x };
          } else {
            if (l[0] !== "cubic-bezier")
              return r.error(
                `Unknown interpolation type ${String(l[0])}`,
                1,
                0,
              );
            {
              const x = l.slice(1);
              if (
                x.length !== 4 ||
                x.some((b) => typeof b != "number" || b < 0 || b > 1)
              )
                return r.error(
                  "Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",
                  1,
                );
              l = { name: "cubic-bezier", controlPoints: x };
            }
          }
          if (t.length - 1 < 4)
            return r.error(
              `Expected at least 4 arguments, but found only ${t.length - 1}.`,
            );
          if ((t.length - 1) % 2 != 0)
            return r.error("Expected an even number of arguments.");
          if (((d = r.parse(d, 2, Ce)), !d)) return null;
          const m = [];
          let _ = null;
          o === "interpolate-hcl" || o === "interpolate-lab"
            ? (_ = lt)
            : r.expectedType &&
              r.expectedType.kind !== "value" &&
              (_ = r.expectedType);
          for (let x = 0; x < p.length; x += 2) {
            const b = p[x],
              w = p[x + 1],
              F = x + 3,
              S = x + 4;
            if (typeof b != "number")
              return r.error(
                "Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.",
                F,
              );
            if (m.length && m[m.length - 1][0] >= b)
              return r.error(
                "Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.",
                F,
              );
            const D = r.parse(w, S, _);
            if (!D) return null;
            ((_ = _ || D.type), m.push([b, D]));
          }
          return En(_, Ce) ||
            En(_, mt) ||
            En(_, lt) ||
            En(_, ci) ||
            En(_, kt) ||
            En(_, Qi(Ce))
            ? new zi(_, o, l, d, m)
            : r.error(`Type ${zt(_)} is not interpolatable.`);
        }
        evaluate(t) {
          const r = this.labels,
            o = this.outputs;
          if (r.length === 1) return o[0].evaluate(t);
          const l = this.input.evaluate(t);
          if (l <= r[0]) return o[0].evaluate(t);
          const d = r.length;
          if (l >= r[d - 1]) return o[d - 1].evaluate(t);
          const p = rn(r, l),
            m = zi.interpolationFactor(this.interpolation, l, r[p], r[p + 1]),
            _ = o[p].evaluate(t),
            x = o[p + 1].evaluate(t);
          switch (this.operator) {
            case "interpolate":
              switch (this.type.kind) {
                case "number":
                  return ut(_, x, m);
                case "color":
                  return ct.interpolate(_, x, m);
                case "padding":
                  return Zt.interpolate(_, x, m);
                case "variableAnchorOffsetCollection":
                  return Ti.interpolate(_, x, m);
                case "array":
                  return Fr(_, x, m);
                case "projectionDefinition":
                  return xi.interpolate(_, x, m);
              }
            case "interpolate-hcl":
              return ct.interpolate(_, x, m, "hcl");
            case "interpolate-lab":
              return ct.interpolate(_, x, m, "lab");
          }
        }
        eachChild(t) {
          t(this.input);
          for (const r of this.outputs) t(r);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
      }
      function gs(n, t, r, o) {
        const l = o - r,
          d = n - r;
        return l === 0
          ? 0
          : t === 1
            ? d / l
            : (Math.pow(t, d) - 1) / (Math.pow(t, l) - 1);
      }
      const Pr = {
        color: ct.interpolate,
        number: ut,
        padding: Zt.interpolate,
        variableAnchorOffsetCollection: Ti.interpolate,
        array: Fr,
      };
      class Mn {
        constructor(t, r) {
          ((this.type = t), (this.args = r));
        }
        static parse(t, r) {
          if (t.length < 2) return r.error("Expected at least one argument.");
          let o = null;
          const l = r.expectedType;
          l && l.kind !== "value" && (o = l);
          const d = [];
          for (const m of t.slice(1)) {
            const _ = r.parse(m, 1 + d.length, o, void 0, {
              typeAnnotation: "omit",
            });
            if (!_) return null;
            ((o = o || _.type), d.push(_));
          }
          if (!o) throw new Error("No output type");
          const p = l && d.some((m) => Hn(l, m.type));
          return new Mn(p ? je : o, d);
        }
        evaluate(t) {
          let r,
            o = null,
            l = 0;
          for (const d of this.args)
            if (
              (l++,
              (o = d.evaluate(t)),
              o &&
                o instanceof Ui &&
                !o.available &&
                (r || (r = o.name),
                (o = null),
                l === this.args.length && (o = r)),
              o !== null)
            )
              break;
          return o;
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      function _s(n, t) {
        return n === "==" || n === "!="
          ? t.kind === "boolean" ||
              t.kind === "string" ||
              t.kind === "number" ||
              t.kind === "null" ||
              t.kind === "value"
          : t.kind === "string" || t.kind === "number" || t.kind === "value";
      }
      function jl(n, t, r, o) {
        return o.compare(t, r) === 0;
      }
      function jr(n, t, r) {
        const o = n !== "==" && n !== "!=";
        return class Yd {
          constructor(d, p, m) {
            ((this.type = Ve),
              (this.lhs = d),
              (this.rhs = p),
              (this.collator = m),
              (this.hasUntypedArgument =
                d.type.kind === "value" || p.type.kind === "value"));
          }
          static parse(d, p) {
            if (d.length !== 3 && d.length !== 4)
              return p.error("Expected two or three arguments.");
            const m = d[0];
            let _ = p.parse(d[1], 1, je);
            if (!_) return null;
            if (!_s(m, _.type))
              return p
                .concat(1)
                .error(
                  `"${m}" comparisons are not supported for type '${zt(_.type)}'.`,
                );
            let x = p.parse(d[2], 2, je);
            if (!x) return null;
            if (!_s(m, x.type))
              return p
                .concat(2)
                .error(
                  `"${m}" comparisons are not supported for type '${zt(x.type)}'.`,
                );
            if (
              _.type.kind !== x.type.kind &&
              _.type.kind !== "value" &&
              x.type.kind !== "value"
            )
              return p.error(
                `Cannot compare types '${zt(_.type)}' and '${zt(x.type)}'.`,
              );
            o &&
              (_.type.kind === "value" && x.type.kind !== "value"
                ? (_ = new Fi(x.type, [_]))
                : _.type.kind !== "value" &&
                  x.type.kind === "value" &&
                  (x = new Fi(_.type, [x])));
            let b = null;
            if (d.length === 4) {
              if (
                _.type.kind !== "string" &&
                x.type.kind !== "string" &&
                _.type.kind !== "value" &&
                x.type.kind !== "value"
              )
                return p.error(
                  "Cannot use collator to compare non-string types.",
                );
              if (((b = p.parse(d[3], 3, Ht)), !b)) return null;
            }
            return new Yd(_, x, b);
          }
          evaluate(d) {
            const p = this.lhs.evaluate(d),
              m = this.rhs.evaluate(d);
            if (o && this.hasUntypedArgument) {
              const _ = Kt(p),
                x = Kt(m);
              if (
                _.kind !== x.kind ||
                (_.kind !== "string" && _.kind !== "number")
              )
                throw new Lt(
                  `Expected arguments for "${n}" to be (string, string) or (number, number), but found (${_.kind}, ${x.kind}) instead.`,
                );
            }
            if (this.collator && !o && this.hasUntypedArgument) {
              const _ = Kt(p),
                x = Kt(m);
              if (_.kind !== "string" || x.kind !== "string") return t(d, p, m);
            }
            return this.collator
              ? r(d, p, m, this.collator.evaluate(d))
              : t(d, p, m);
          }
          eachChild(d) {
            (d(this.lhs), d(this.rhs), this.collator && d(this.collator));
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const ys = jr(
          "==",
          function (n, t, r) {
            return t === r;
          },
          jl,
        ),
        yr = jr(
          "!=",
          function (n, t, r) {
            return t !== r;
          },
          function (n, t, r, o) {
            return !jl(0, t, r, o);
          },
        ),
        Nl = jr(
          "<",
          function (n, t, r) {
            return t < r;
          },
          function (n, t, r, o) {
            return o.compare(t, r) < 0;
          },
        ),
        xs = jr(
          ">",
          function (n, t, r) {
            return t > r;
          },
          function (n, t, r, o) {
            return o.compare(t, r) > 0;
          },
        ),
        rc = jr(
          "<=",
          function (n, t, r) {
            return t <= r;
          },
          function (n, t, r, o) {
            return o.compare(t, r) <= 0;
          },
        ),
        ba = jr(
          ">=",
          function (n, t, r) {
            return t >= r;
          },
          function (n, t, r, o) {
            return o.compare(t, r) >= 0;
          },
        );
      class vs {
        constructor(t, r, o) {
          ((this.type = Ht),
            (this.locale = o),
            (this.caseSensitive = t),
            (this.diacriticSensitive = r));
        }
        static parse(t, r) {
          if (t.length !== 2) return r.error("Expected one argument.");
          const o = t[1];
          if (typeof o != "object" || Array.isArray(o))
            return r.error("Collator options argument must be an object.");
          const l = r.parse(
            o["case-sensitive"] !== void 0 && o["case-sensitive"],
            1,
            Ve,
          );
          if (!l) return null;
          const d = r.parse(
            o["diacritic-sensitive"] !== void 0 && o["diacritic-sensitive"],
            1,
            Ve,
          );
          if (!d) return null;
          let p = null;
          return o.locale && ((p = r.parse(o.locale, 1, ze)), !p)
            ? null
            : new vs(l, d, p);
        }
        evaluate(t) {
          return new as(
            this.caseSensitive.evaluate(t),
            this.diacriticSensitive.evaluate(t),
            this.locale ? this.locale.evaluate(t) : null,
          );
        }
        eachChild(t) {
          (t(this.caseSensitive),
            t(this.diacriticSensitive),
            this.locale && t(this.locale));
        }
        outputDefined() {
          return !1;
        }
      }
      class wa {
        constructor(t, r, o, l, d) {
          ((this.type = ze),
            (this.number = t),
            (this.locale = r),
            (this.currency = o),
            (this.minFractionDigits = l),
            (this.maxFractionDigits = d));
        }
        static parse(t, r) {
          if (t.length !== 3) return r.error("Expected two arguments.");
          const o = r.parse(t[1], 1, Ce);
          if (!o) return null;
          const l = t[2];
          if (typeof l != "object" || Array.isArray(l))
            return r.error("NumberFormat options argument must be an object.");
          let d = null;
          if (l.locale && ((d = r.parse(l.locale, 1, ze)), !d)) return null;
          let p = null;
          if (l.currency && ((p = r.parse(l.currency, 1, ze)), !p)) return null;
          let m = null;
          if (
            l["min-fraction-digits"] &&
            ((m = r.parse(l["min-fraction-digits"], 1, Ce)), !m)
          )
            return null;
          let _ = null;
          return l["max-fraction-digits"] &&
            ((_ = r.parse(l["max-fraction-digits"], 1, Ce)), !_)
            ? null
            : new wa(o, d, p, m, _);
        }
        evaluate(t) {
          return new Intl.NumberFormat(
            this.locale ? this.locale.evaluate(t) : [],
            {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits
                ? this.minFractionDigits.evaluate(t)
                : void 0,
              maximumFractionDigits: this.maxFractionDigits
                ? this.maxFractionDigits.evaluate(t)
                : void 0,
            },
          ).format(this.number.evaluate(t));
        }
        eachChild(t) {
          (t(this.number),
            this.locale && t(this.locale),
            this.currency && t(this.currency),
            this.minFractionDigits && t(this.minFractionDigits),
            this.maxFractionDigits && t(this.maxFractionDigits));
        }
        outputDefined() {
          return !1;
        }
      }
      class bs {
        constructor(t) {
          ((this.type = en), (this.sections = t));
        }
        static parse(t, r) {
          if (t.length < 2) return r.error("Expected at least one argument.");
          const o = t[1];
          if (!Array.isArray(o) && typeof o == "object")
            return r.error("First argument must be an image or text section.");
          const l = [];
          let d = !1;
          for (let p = 1; p <= t.length - 1; ++p) {
            const m = t[p];
            if (d && typeof m == "object" && !Array.isArray(m)) {
              d = !1;
              let _ = null;
              if (
                m["font-scale"] &&
                ((_ = r.parse(m["font-scale"], 1, Ce)), !_)
              )
                return null;
              let x = null;
              if (
                m["text-font"] &&
                ((x = r.parse(m["text-font"], 1, Qi(ze))), !x)
              )
                return null;
              let b = null;
              if (
                m["text-color"] &&
                ((b = r.parse(m["text-color"], 1, lt)), !b)
              )
                return null;
              const w = l[l.length - 1];
              ((w.scale = _), (w.font = x), (w.textColor = b));
            } else {
              const _ = r.parse(t[p], 1, je);
              if (!_) return null;
              const x = _.type.kind;
              if (
                x !== "string" &&
                x !== "value" &&
                x !== "null" &&
                x !== "resolvedImage"
              )
                return r.error(
                  "Formatted text type must be 'string', 'value', 'image' or 'null'.",
                );
              ((d = !0),
                l.push({
                  content: _,
                  scale: null,
                  font: null,
                  textColor: null,
                }));
            }
          }
          return new bs(l);
        }
        evaluate(t) {
          return new ki(
            this.sections.map((r) => {
              const o = r.content.evaluate(t);
              return Kt(o) === ni
                ? new ls("", o, null, null, null)
                : new ls(
                    _r(o),
                    null,
                    r.scale ? r.scale.evaluate(t) : null,
                    r.font ? r.font.evaluate(t).join(",") : null,
                    r.textColor ? r.textColor.evaluate(t) : null,
                  );
            }),
          );
        }
        eachChild(t) {
          for (const r of this.sections)
            (t(r.content),
              r.scale && t(r.scale),
              r.font && t(r.font),
              r.textColor && t(r.textColor));
        }
        outputDefined() {
          return !1;
        }
      }
      class Ca {
        constructor(t) {
          ((this.type = ni), (this.input = t));
        }
        static parse(t, r) {
          if (t.length !== 2) return r.error("Expected two arguments.");
          const o = r.parse(t[1], 1, ze);
          return o ? new Ca(o) : r.error("No image name provided.");
        }
        evaluate(t) {
          const r = this.input.evaluate(t),
            o = Ui.fromString(r);
          return (
            o &&
              t.availableImages &&
              (o.available = t.availableImages.indexOf(r) > -1),
            o
          );
        }
        eachChild(t) {
          t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Jn {
        constructor(t) {
          ((this.type = Ce), (this.input = t));
        }
        static parse(t, r) {
          if (t.length !== 2)
            return r.error(
              `Expected 1 argument, but found ${t.length - 1} instead.`,
            );
          const o = r.parse(t[1], 1);
          return o
            ? o.type.kind !== "array" &&
              o.type.kind !== "string" &&
              o.type.kind !== "value"
              ? r.error(
                  `Expected argument of type string or array, but found ${zt(o.type)} instead.`,
                )
              : new Jn(o)
            : null;
        }
        evaluate(t) {
          const r = this.input.evaluate(t);
          if (typeof r == "string") return [...r].length;
          if (Array.isArray(r)) return r.length;
          throw new Lt(
            `Expected value to be of type string or array, but found ${zt(Kt(r))} instead.`,
          );
        }
        eachChild(t) {
          t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const Sr = 8192;
      function Vl(n, t) {
        const r = (180 + n[0]) / 360,
          o =
            (180 -
              (180 / Math.PI) *
                Math.log(Math.tan(Math.PI / 4 + (n[1] * Math.PI) / 360))) /
            360,
          l = Math.pow(2, t.z);
        return [Math.round(r * l * Sr), Math.round(o * l * Sr)];
      }
      function ws(n, t) {
        const r = Math.pow(2, t.z);
        return [
          ((l = (n[0] / Sr + t.x) / r), 360 * l - 180),
          ((o = (n[1] / Sr + t.y) / r),
          (360 / Math.PI) *
            Math.atan(Math.exp(((180 - 360 * o) * Math.PI) / 180)) -
            90),
        ];
        var o, l;
      }
      function Bo(n, t) {
        ((n[0] = Math.min(n[0], t[0])),
          (n[1] = Math.min(n[1], t[1])),
          (n[2] = Math.max(n[2], t[0])),
          (n[3] = Math.max(n[3], t[1])));
      }
      function Qn(n, t) {
        return !(n[0] <= t[0] || n[2] >= t[2] || n[1] <= t[1] || n[3] >= t[3]);
      }
      function nc(n, t, r) {
        const o = n[0] - t[0],
          l = n[1] - t[1],
          d = n[0] - r[0],
          p = n[1] - r[1];
        return o * p - d * l == 0 && o * d <= 0 && l * p <= 0;
      }
      function Cs(n, t, r, o) {
        return (
          (l = [o[0] - r[0], o[1] - r[1]])[0] *
            (d = [t[0] - n[0], t[1] - n[1]])[1] -
            l[1] * d[0] !=
            0 && !(!Aa(n, t, r, o) || !Aa(r, o, n, t))
        );
        var l, d;
      }
      function oc(n, t, r) {
        for (const o of r)
          for (let l = 0; l < o.length - 1; ++l)
            if (Cs(n, t, o[l], o[l + 1])) return !0;
        return !1;
      }
      function eo(n, t, r = !1) {
        let o = !1;
        for (const m of t)
          for (let _ = 0; _ < m.length - 1; _++) {
            if (nc(n, m[_], m[_ + 1])) return r;
            (d = m[_])[1] > (l = n)[1] != (p = m[_ + 1])[1] > l[1] &&
              l[0] < ((p[0] - d[0]) * (l[1] - d[1])) / (p[1] - d[1]) + d[0] &&
              (o = !o);
          }
        var l, d, p;
        return o;
      }
      function sc(n, t) {
        for (const r of t) if (eo(n, r)) return !0;
        return !1;
      }
      function Ea(n, t) {
        for (const r of n) if (!eo(r, t)) return !1;
        for (let r = 0; r < n.length - 1; ++r)
          if (oc(n[r], n[r + 1], t)) return !1;
        return !0;
      }
      function Ul(n, t) {
        for (const r of t) if (Ea(n, r)) return !0;
        return !1;
      }
      function Aa(n, t, r, o) {
        const l = o[0] - r[0],
          d = o[1] - r[1],
          p = (n[0] - r[0]) * d - l * (n[1] - r[1]),
          m = (t[0] - r[0]) * d - l * (t[1] - r[1]);
        return (p > 0 && m < 0) || (p < 0 && m > 0);
      }
      function Ta(n, t, r) {
        const o = [];
        for (let l = 0; l < n.length; l++) {
          const d = [];
          for (let p = 0; p < n[l].length; p++) {
            const m = Vl(n[l][p], r);
            (Bo(t, m), d.push(m));
          }
          o.push(d);
        }
        return o;
      }
      function $l(n, t, r) {
        const o = [];
        for (let l = 0; l < n.length; l++) {
          const d = Ta(n[l], t, r);
          o.push(d);
        }
        return o;
      }
      function Zl(n, t, r, o) {
        if (n[0] < r[0] || n[0] > r[2]) {
          const l = 0.5 * o;
          let d = n[0] - r[0] > l ? -o : r[0] - n[0] > l ? o : 0;
          (d === 0 && (d = n[0] - r[2] > l ? -o : r[2] - n[0] > l ? o : 0),
            (n[0] += d));
        }
        Bo(t, n);
      }
      function Es(n, t, r, o) {
        const l = Math.pow(2, o.z) * Sr,
          d = [o.x * Sr, o.y * Sr],
          p = [];
        for (const m of n)
          for (const _ of m) {
            const x = [_.x + d[0], _.y + d[1]];
            (Zl(x, t, r, l), p.push(x));
          }
        return p;
      }
      function Gl(n, t, r, o) {
        const l = Math.pow(2, o.z) * Sr,
          d = [o.x * Sr, o.y * Sr],
          p = [];
        for (const _ of n) {
          const x = [];
          for (const b of _) {
            const w = [b.x + d[0], b.y + d[1]];
            (Bo(t, w), x.push(w));
          }
          p.push(x);
        }
        if (t[2] - t[0] <= l / 2) {
          (((m = t)[0] = m[1] = 1 / 0), (m[2] = m[3] = -1 / 0));
          for (const _ of p) for (const x of _) Zl(x, t, r, l);
        }
        var m;
        return p;
      }
      class In {
        constructor(t, r) {
          ((this.type = Ve), (this.geojson = t), (this.geometries = r));
        }
        static parse(t, r) {
          if (t.length !== 2)
            return r.error(
              `'within' expression requires exactly one argument, but found ${t.length - 1} instead.`,
            );
          if (Wn(t[1])) {
            const o = t[1];
            if (o.type === "FeatureCollection") {
              const l = [];
              for (const d of o.features) {
                const { type: p, coordinates: m } = d.geometry;
                (p === "Polygon" && l.push(m),
                  p === "MultiPolygon" && l.push(...m));
              }
              if (l.length)
                return new In(o, { type: "MultiPolygon", coordinates: l });
            } else if (o.type === "Feature") {
              const l = o.geometry.type;
              if (l === "Polygon" || l === "MultiPolygon")
                return new In(o, o.geometry);
            } else if (o.type === "Polygon" || o.type === "MultiPolygon")
              return new In(o, o);
          }
          return r.error(
            "'within' expression requires valid geojson object that contains polygon geometry type.",
          );
        }
        evaluate(t) {
          if (t.geometry() != null && t.canonicalID() != null) {
            if (t.geometryDollarType() === "Point")
              return (function (r, o) {
                const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  d = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = r.canonicalID();
                if (o.type === "Polygon") {
                  const m = Ta(o.coordinates, d, p),
                    _ = Es(r.geometry(), l, d, p);
                  if (!Qn(l, d)) return !1;
                  for (const x of _) if (!eo(x, m)) return !1;
                }
                if (o.type === "MultiPolygon") {
                  const m = $l(o.coordinates, d, p),
                    _ = Es(r.geometry(), l, d, p);
                  if (!Qn(l, d)) return !1;
                  for (const x of _) if (!sc(x, m)) return !1;
                }
                return !0;
              })(t, this.geometries);
            if (t.geometryDollarType() === "LineString")
              return (function (r, o) {
                const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  d = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = r.canonicalID();
                if (o.type === "Polygon") {
                  const m = Ta(o.coordinates, d, p),
                    _ = Gl(r.geometry(), l, d, p);
                  if (!Qn(l, d)) return !1;
                  for (const x of _) if (!Ea(x, m)) return !1;
                }
                if (o.type === "MultiPolygon") {
                  const m = $l(o.coordinates, d, p),
                    _ = Gl(r.geometry(), l, d, p);
                  if (!Qn(l, d)) return !1;
                  for (const x of _) if (!Ul(x, m)) return !1;
                }
                return !0;
              })(t, this.geometries);
          }
          return !1;
        }
        eachChild() {}
        outputDefined() {
          return !0;
        }
      }
      let ql = class {
        constructor(n = [], t = (r, o) => (r < o ? -1 : r > o ? 1 : 0)) {
          if (
            ((this.data = n),
            (this.length = this.data.length),
            (this.compare = t),
            this.length > 0)
          )
            for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r);
        }
        push(n) {
          (this.data.push(n), this._up(this.length++));
        }
        pop() {
          if (this.length === 0) return;
          const n = this.data[0],
            t = this.data.pop();
          return (--this.length > 0 && ((this.data[0] = t), this._down(0)), n);
        }
        peek() {
          return this.data[0];
        }
        _up(n) {
          const { data: t, compare: r } = this,
            o = t[n];
          for (; n > 0; ) {
            const l = (n - 1) >> 1,
              d = t[l];
            if (r(o, d) >= 0) break;
            ((t[n] = d), (n = l));
          }
          t[n] = o;
        }
        _down(n) {
          const { data: t, compare: r } = this,
            o = this.length >> 1,
            l = t[n];
          for (; n < o; ) {
            let d = 1 + (n << 1);
            const p = d + 1;
            if (
              (p < this.length && r(t[p], t[d]) < 0 && (d = p), r(t[d], l) >= 0)
            )
              break;
            ((t[n] = t[d]), (n = d));
          }
          t[n] = l;
        }
      };
      const Fa = 1 / 298.257223563,
        Pa = Fa * (2 - Fa),
        Hl = Math.PI / 180;
      class Sa {
        constructor(t) {
          const r = 6378.137 * Hl * 1e3,
            o = Math.cos(t * Hl),
            l = 1 / (1 - Pa * (1 - o * o)),
            d = Math.sqrt(l);
          ((this.kx = r * d * o), (this.ky = r * d * l * (1 - Pa)));
        }
        distance(t, r) {
          const o = this.wrap(t[0] - r[0]) * this.kx,
            l = (t[1] - r[1]) * this.ky;
          return Math.sqrt(o * o + l * l);
        }
        pointOnLine(t, r) {
          let o,
            l,
            d,
            p,
            m = 1 / 0;
          for (let _ = 0; _ < t.length - 1; _++) {
            let x = t[_][0],
              b = t[_][1],
              w = this.wrap(t[_ + 1][0] - x) * this.kx,
              F = (t[_ + 1][1] - b) * this.ky,
              S = 0;
            ((w === 0 && F === 0) ||
              ((S =
                (this.wrap(r[0] - x) * this.kx * w + (r[1] - b) * this.ky * F) /
                (w * w + F * F)),
              S > 1
                ? ((x = t[_ + 1][0]), (b = t[_ + 1][1]))
                : S > 0 &&
                  ((x += (w / this.kx) * S), (b += (F / this.ky) * S))),
              (w = this.wrap(r[0] - x) * this.kx),
              (F = (r[1] - b) * this.ky));
            const D = w * w + F * F;
            D < m && ((m = D), (o = x), (l = b), (d = _), (p = S));
          }
          return { point: [o, l], index: d, t: Math.max(0, Math.min(1, p)) };
        }
        wrap(t) {
          for (; t < -180; ) t += 360;
          for (; t > 180; ) t -= 360;
          return t;
        }
      }
      function Da(n, t) {
        return t[0] - n[0];
      }
      function ko(n) {
        return n[1] - n[0] + 1;
      }
      function Nr(n, t) {
        return n[1] >= n[0] && n[1] < t;
      }
      function Ma(n, t) {
        if (n[0] > n[1]) return [null, null];
        const r = ko(n);
        if (t) {
          if (r === 2) return [n, null];
          const l = Math.floor(r / 2);
          return [
            [n[0], n[0] + l],
            [n[0] + l, n[1]],
          ];
        }
        if (r === 1) return [n, null];
        const o = Math.floor(r / 2) - 1;
        return [
          [n[0], n[0] + o],
          [n[0] + o + 1, n[1]],
        ];
      }
      function Ia(n, t) {
        if (!Nr(t, n.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let o = t[0]; o <= t[1]; ++o) Bo(r, n[o]);
        return r;
      }
      function As(n) {
        const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const r of n) for (const o of r) Bo(t, o);
        return t;
      }
      function Xl(n) {
        return (
          n[0] !== -1 / 0 && n[1] !== -1 / 0 && n[2] !== 1 / 0 && n[3] !== 1 / 0
        );
      }
      function Ba(n, t, r) {
        if (!Xl(n) || !Xl(t)) return NaN;
        let o = 0,
          l = 0;
        return (
          n[2] < t[0] && (o = t[0] - n[2]),
          n[0] > t[2] && (o = n[0] - t[2]),
          n[1] > t[3] && (l = n[1] - t[3]),
          n[3] < t[1] && (l = t[1] - n[3]),
          r.distance([0, 0], [o, l])
        );
      }
      function Bn(n, t, r) {
        const o = r.pointOnLine(t, n);
        return r.distance(n, o.point);
      }
      function ka(n, t, r, o, l) {
        const d = Math.min(Bn(n, [r, o], l), Bn(t, [r, o], l)),
          p = Math.min(Bn(r, [n, t], l), Bn(o, [n, t], l));
        return Math.min(d, p);
      }
      function Ct(n, t, r, o, l) {
        if (!Nr(t, n.length) || !Nr(o, r.length)) return 1 / 0;
        let d = 1 / 0;
        for (let p = t[0]; p < t[1]; ++p) {
          const m = n[p],
            _ = n[p + 1];
          for (let x = o[0]; x < o[1]; ++x) {
            const b = r[x],
              w = r[x + 1];
            if (Cs(m, _, b, w)) return 0;
            d = Math.min(d, ka(m, _, b, w, l));
          }
        }
        return d;
      }
      function ac(n, t, r, o, l) {
        if (!Nr(t, n.length) || !Nr(o, r.length)) return NaN;
        let d = 1 / 0;
        for (let p = t[0]; p <= t[1]; ++p)
          for (let m = o[0]; m <= o[1]; ++m)
            if (((d = Math.min(d, l.distance(n[p], r[m]))), d === 0)) return d;
        return d;
      }
      function lc(n, t, r) {
        if (eo(n, t, !0)) return 0;
        let o = 1 / 0;
        for (const l of t) {
          const d = l[0],
            p = l[l.length - 1];
          if (d !== p && ((o = Math.min(o, Bn(n, [p, d], r))), o === 0))
            return o;
          const m = r.pointOnLine(l, n);
          if (((o = Math.min(o, r.distance(n, m.point))), o === 0)) return o;
        }
        return o;
      }
      function uc(n, t, r, o) {
        if (!Nr(t, n.length)) return NaN;
        for (let d = t[0]; d <= t[1]; ++d) if (eo(n[d], r, !0)) return 0;
        let l = 1 / 0;
        for (let d = t[0]; d < t[1]; ++d) {
          const p = n[d],
            m = n[d + 1];
          for (const _ of r)
            for (let x = 0, b = _.length, w = b - 1; x < b; w = x++) {
              const F = _[w],
                S = _[x];
              if (Cs(p, m, F, S)) return 0;
              l = Math.min(l, ka(p, m, F, S, o));
            }
        }
        return l;
      }
      function Wl(n, t) {
        for (const r of n) for (const o of r) if (eo(o, t, !0)) return !0;
        return !1;
      }
      function cc(n, t, r, o = 1 / 0) {
        const l = As(n),
          d = As(t);
        if (o !== 1 / 0 && Ba(l, d, r) >= o) return o;
        if (Qn(l, d)) {
          if (Wl(n, t)) return 0;
        } else if (Wl(t, n)) return 0;
        let p = 1 / 0;
        for (const m of n)
          for (let _ = 0, x = m.length, b = x - 1; _ < x; b = _++) {
            const w = m[b],
              F = m[_];
            for (const S of t)
              for (let D = 0, I = S.length, O = I - 1; D < I; O = D++) {
                const Z = S[O],
                  ne = S[D];
                if (Cs(w, F, Z, ne)) return 0;
                p = Math.min(p, ka(w, F, Z, ne, r));
              }
          }
        return p;
      }
      function Kl(n, t, r, o, l, d) {
        if (!d) return;
        const p = Ba(Ia(o, d), l, r);
        p < t && n.push([p, d, [0, 0]]);
      }
      function Ts(n, t, r, o, l, d, p) {
        if (!d || !p) return;
        const m = Ba(Ia(o, d), Ia(l, p), r);
        m < t && n.push([m, d, p]);
      }
      function Fs(n, t, r, o, l = 1 / 0) {
        let d = Math.min(o.distance(n[0], r[0][0]), l);
        if (d === 0) return d;
        const p = new ql([[0, [0, n.length - 1], [0, 0]]], Da),
          m = As(r);
        for (; p.length > 0; ) {
          const _ = p.pop();
          if (_[0] >= d) continue;
          const x = _[1],
            b = t ? 50 : 100;
          if (ko(x) <= b) {
            if (!Nr(x, n.length)) return NaN;
            if (t) {
              const w = uc(n, x, r, o);
              if (isNaN(w) || w === 0) return w;
              d = Math.min(d, w);
            } else
              for (let w = x[0]; w <= x[1]; ++w) {
                const F = lc(n[w], r, o);
                if (((d = Math.min(d, F)), d === 0)) return 0;
              }
          } else {
            const w = Ma(x, t);
            (Kl(p, d, o, n, m, w[0]), Kl(p, d, o, n, m, w[1]));
          }
        }
        return d;
      }
      function Ps(n, t, r, o, l, d = 1 / 0) {
        let p = Math.min(d, l.distance(n[0], r[0]));
        if (p === 0) return p;
        const m = new ql([[0, [0, n.length - 1], [0, r.length - 1]]], Da);
        for (; m.length > 0; ) {
          const _ = m.pop();
          if (_[0] >= p) continue;
          const x = _[1],
            b = _[2],
            w = t ? 50 : 100,
            F = o ? 50 : 100;
          if (ko(x) <= w && ko(b) <= F) {
            if (!Nr(x, n.length) && Nr(b, r.length)) return NaN;
            let S;
            if (t && o) ((S = Ct(n, x, r, b, l)), (p = Math.min(p, S)));
            else if (t && !o) {
              const D = n.slice(x[0], x[1] + 1);
              for (let I = b[0]; I <= b[1]; ++I)
                if (((S = Bn(r[I], D, l)), (p = Math.min(p, S)), p === 0))
                  return p;
            } else if (!t && o) {
              const D = r.slice(b[0], b[1] + 1);
              for (let I = x[0]; I <= x[1]; ++I)
                if (((S = Bn(n[I], D, l)), (p = Math.min(p, S)), p === 0))
                  return p;
            } else ((S = ac(n, x, r, b, l)), (p = Math.min(p, S)));
          } else {
            const S = Ma(x, t),
              D = Ma(b, o);
            (Ts(m, p, l, n, r, S[0], D[0]),
              Ts(m, p, l, n, r, S[0], D[1]),
              Ts(m, p, l, n, r, S[1], D[0]),
              Ts(m, p, l, n, r, S[1], D[1]));
          }
        }
        return p;
      }
      function za(n) {
        return n.type === "MultiPolygon"
          ? n.coordinates.map((t) => ({ type: "Polygon", coordinates: t }))
          : n.type === "MultiLineString"
            ? n.coordinates.map((t) => ({ type: "LineString", coordinates: t }))
            : n.type === "MultiPoint"
              ? n.coordinates.map((t) => ({ type: "Point", coordinates: t }))
              : [n];
      }
      class kn {
        constructor(t, r) {
          ((this.type = Ce), (this.geojson = t), (this.geometries = r));
        }
        static parse(t, r) {
          if (t.length !== 2)
            return r.error(
              `'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`,
            );
          if (Wn(t[1])) {
            const o = t[1];
            if (o.type === "FeatureCollection")
              return new kn(o, o.features.map((l) => za(l.geometry)).flat());
            if (o.type === "Feature") return new kn(o, za(o.geometry));
            if ("type" in o && "coordinates" in o) return new kn(o, za(o));
          }
          return r.error(
            "'distance' expression requires valid geojson object that contains polygon geometry type.",
          );
        }
        evaluate(t) {
          if (t.geometry() != null && t.canonicalID() != null) {
            if (t.geometryType() === "Point")
              return (function (r, o) {
                const l = r.geometry(),
                  d = l.flat().map((_) => ws([_.x, _.y], r.canonical));
                if (l.length === 0) return NaN;
                const p = new Sa(d[0][1]);
                let m = 1 / 0;
                for (const _ of o) {
                  switch (_.type) {
                    case "Point":
                      m = Math.min(m, Ps(d, !1, [_.coordinates], !1, p, m));
                      break;
                    case "LineString":
                      m = Math.min(m, Ps(d, !1, _.coordinates, !0, p, m));
                      break;
                    case "Polygon":
                      m = Math.min(m, Fs(d, !1, _.coordinates, p, m));
                  }
                  if (m === 0) return m;
                }
                return m;
              })(t, this.geometries);
            if (t.geometryType() === "LineString")
              return (function (r, o) {
                const l = r.geometry(),
                  d = l.flat().map((_) => ws([_.x, _.y], r.canonical));
                if (l.length === 0) return NaN;
                const p = new Sa(d[0][1]);
                let m = 1 / 0;
                for (const _ of o) {
                  switch (_.type) {
                    case "Point":
                      m = Math.min(m, Ps(d, !0, [_.coordinates], !1, p, m));
                      break;
                    case "LineString":
                      m = Math.min(m, Ps(d, !0, _.coordinates, !0, p, m));
                      break;
                    case "Polygon":
                      m = Math.min(m, Fs(d, !0, _.coordinates, p, m));
                  }
                  if (m === 0) return m;
                }
                return m;
              })(t, this.geometries);
            if (t.geometryType() === "Polygon")
              return (function (r, o) {
                const l = r.geometry();
                if (l.length === 0 || l[0].length === 0) return NaN;
                const d = Kn(l, 0).map((_) =>
                    _.map((x) => x.map((b) => ws([b.x, b.y], r.canonical))),
                  ),
                  p = new Sa(d[0][0][0][1]);
                let m = 1 / 0;
                for (const _ of o)
                  for (const x of d) {
                    switch (_.type) {
                      case "Point":
                        m = Math.min(m, Fs([_.coordinates], !1, x, p, m));
                        break;
                      case "LineString":
                        m = Math.min(m, Fs(_.coordinates, !0, x, p, m));
                        break;
                      case "Polygon":
                        m = Math.min(m, cc(x, _.coordinates, p, m));
                    }
                    if (m === 0) return m;
                  }
                return m;
              })(t, this.geometries);
          }
          return NaN;
        }
        eachChild() {}
        outputDefined() {
          return !0;
        }
      }
      const to = {
        "==": ys,
        "!=": yr,
        ">": xs,
        "<": Nl,
        ">=": ba,
        "<=": rc,
        array: Fi,
        at: ds,
        boolean: Fi,
        case: ps,
        coalesce: Mn,
        collator: vs,
        format: bs,
        image: Ca,
        in: So,
        "index-of": Do,
        interpolate: zi,
        "interpolate-hcl": zi,
        "interpolate-lab": zi,
        length: Jn,
        let: Yn,
        literal: Pn,
        match: va,
        number: Fi,
        "number-format": wa,
        object: Fi,
        slice: Mo,
        step: oi,
        string: Fi,
        "to-boolean": Or,
        "to-color": Or,
        "to-number": Or,
        "to-string": Or,
        var: Dn,
        within: In,
        distance: kn,
      };
      class ur {
        constructor(t, r, o, l) {
          ((this.name = t),
            (this.type = r),
            (this._evaluate = o),
            (this.args = l));
        }
        evaluate(t) {
          return this._evaluate(t, this.args);
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return !1;
        }
        static parse(t, r) {
          const o = t[0],
            l = ur.definitions[o];
          if (!l)
            return r.error(
              `Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`,
              0,
            );
          const d = Array.isArray(l) ? l[0] : l.type,
            p = Array.isArray(l) ? [[l[1], l[2]]] : l.overloads,
            m = p.filter(
              ([x]) => !Array.isArray(x) || x.length === t.length - 1,
            );
          let _ = null;
          for (const [x, b] of m) {
            _ = new lr(r.registry, Ss, r.path, null, r.scope);
            const w = [];
            let F = !1;
            for (let S = 1; S < t.length; S++) {
              const D = t[S],
                I = Array.isArray(x) ? x[S - 1] : x.type,
                O = _.parse(D, 1 + w.length, I);
              if (!O) {
                F = !0;
                break;
              }
              w.push(O);
            }
            if (!F)
              if (Array.isArray(x) && x.length !== w.length)
                _.error(
                  `Expected ${x.length} arguments, but found ${w.length} instead.`,
                );
              else {
                for (let S = 0; S < w.length; S++) {
                  const D = Array.isArray(x) ? x[S] : x.type,
                    I = w[S];
                  _.concat(S + 1).checkSubtype(D, I.type);
                }
                if (_.errors.length === 0) return new ur(o, d, b, w);
              }
          }
          if (m.length === 1) r.errors.push(..._.errors);
          else {
            const x = (m.length ? m : p)
                .map(([w]) => {
                  return (
                    (F = w),
                    Array.isArray(F)
                      ? `(${F.map(zt).join(", ")})`
                      : `(${zt(F.type)}...)`
                  );
                  var F;
                })
                .join(" | "),
              b = [];
            for (let w = 1; w < t.length; w++) {
              const F = r.parse(t[w], 1 + b.length);
              if (!F) return null;
              b.push(zt(F.type));
            }
            r.error(
              `Expected arguments of type ${x}, but found (${b.join(", ")}) instead.`,
            );
          }
          return null;
        }
        static register(t, r) {
          ur.definitions = r;
          for (const o in r) t[o] = ur;
        }
      }
      function Yl(n, [t, r, o, l]) {
        ((t = t.evaluate(n)), (r = r.evaluate(n)), (o = o.evaluate(n)));
        const d = l ? l.evaluate(n) : 1,
          p = Po(t, r, o, d);
        if (p) throw new Lt(p);
        return new ct(t / 255, r / 255, o / 255, d, !1);
      }
      function Jl(n, t) {
        return n in t;
      }
      function La(n, t) {
        const r = t[n];
        return r === void 0 ? null : r;
      }
      function zn(n) {
        return { type: n };
      }
      function Ss(n) {
        if (n instanceof Dn) return Ss(n.boundExpression);
        if (
          (n instanceof ur && n.name === "error") ||
          n instanceof vs ||
          n instanceof In ||
          n instanceof kn
        )
          return !1;
        const t = n instanceof Or || n instanceof Fi;
        let r = !0;
        return (
          n.eachChild((o) => {
            r = t ? r && Ss(o) : r && o instanceof Pn;
          }),
          !!r &&
            Ds(n) &&
            Ms(n, [
              "zoom",
              "heatmap-density",
              "line-progress",
              "accumulated",
              "is-supported-script",
            ])
        );
      }
      function Ds(n) {
        if (
          (n instanceof ur &&
            ((n.name === "get" && n.args.length === 1) ||
              n.name === "feature-state" ||
              (n.name === "has" && n.args.length === 1) ||
              n.name === "properties" ||
              n.name === "geometry-type" ||
              n.name === "id" ||
              /^filter-/.test(n.name))) ||
          n instanceof In ||
          n instanceof kn
        )
          return !1;
        let t = !0;
        return (
          n.eachChild((r) => {
            t && !Ds(r) && (t = !1);
          }),
          t
        );
      }
      function zo(n) {
        if (n instanceof ur && n.name === "feature-state") return !1;
        let t = !0;
        return (
          n.eachChild((r) => {
            t && !zo(r) && (t = !1);
          }),
          t
        );
      }
      function Ms(n, t) {
        if (n instanceof ur && t.indexOf(n.name) >= 0) return !1;
        let r = !0;
        return (
          n.eachChild((o) => {
            r && !Ms(o, t) && (r = !1);
          }),
          r
        );
      }
      function Ql(n) {
        return { result: "success", value: n };
      }
      function io(n) {
        return { result: "error", value: n };
      }
      function ro(n) {
        return (
          n["property-type"] === "data-driven" ||
          n["property-type"] === "cross-faded-data-driven"
        );
      }
      function eu(n) {
        return !!n.expression && n.expression.parameters.indexOf("zoom") > -1;
      }
      function Ra(n) {
        return !!n.expression && n.expression.interpolated;
      }
      function yt(n) {
        return n instanceof Number
          ? "number"
          : n instanceof String
            ? "string"
            : n instanceof Boolean
              ? "boolean"
              : Array.isArray(n)
                ? "array"
                : n === null
                  ? "null"
                  : typeof n;
      }
      function Is(n) {
        return typeof n == "object" && n !== null && !Array.isArray(n);
      }
      function hc(n) {
        return n;
      }
      function tu(n, t) {
        const r = t.type === "color",
          o = n.stops && typeof n.stops[0][0] == "object",
          l = o || !(o || n.property !== void 0),
          d = n.type || (Ra(t) ? "exponential" : "interval");
        if (r || t.type === "padding") {
          const b = r ? ct.parse : Zt.parse;
          ((n = ke({}, n)).stops &&
            (n.stops = n.stops.map((w) => [w[0], b(w[1])])),
            (n.default = b(n.default ? n.default : t.default)));
        }
        if (
          n.colorSpace &&
          (p = n.colorSpace) !== "rgb" &&
          p !== "hcl" &&
          p !== "lab"
        )
          throw new Error(`Unknown color space: "${n.colorSpace}"`);
        var p;
        let m, _, x;
        if (d === "exponential") m = iu;
        else if (d === "interval") m = dc;
        else if (d === "categorical") {
          ((m = Oa), (_ = Object.create(null)));
          for (const b of n.stops) _[b[0]] = b[1];
          x = typeof n.stops[0][0];
        } else {
          if (d !== "identity") throw new Error(`Unknown function type "${d}"`);
          m = pc;
        }
        if (o) {
          const b = {},
            w = [];
          for (let D = 0; D < n.stops.length; D++) {
            const I = n.stops[D],
              O = I[0].zoom;
            (b[O] === void 0 &&
              ((b[O] = {
                zoom: O,
                type: n.type,
                property: n.property,
                default: n.default,
                stops: [],
              }),
              w.push(O)),
              b[O].stops.push([I[0].value, I[1]]));
          }
          const F = [];
          for (const D of w) F.push([b[D].zoom, tu(b[D], t)]);
          const S = { name: "linear" };
          return {
            kind: "composite",
            interpolationType: S,
            interpolationFactor: zi.interpolationFactor.bind(void 0, S),
            zoomStops: F.map((D) => D[0]),
            evaluate: ({ zoom: D }, I) =>
              iu({ stops: F, base: n.base }, t, D).evaluate(D, I),
          };
        }
        if (l) {
          const b =
            d === "exponential"
              ? { name: "exponential", base: n.base !== void 0 ? n.base : 1 }
              : null;
          return {
            kind: "camera",
            interpolationType: b,
            interpolationFactor: zi.interpolationFactor.bind(void 0, b),
            zoomStops: n.stops.map((w) => w[0]),
            evaluate: ({ zoom: w }) => m(n, t, w, _, x),
          };
        }
        return {
          kind: "source",
          evaluate(b, w) {
            const F = w && w.properties ? w.properties[n.property] : void 0;
            return F === void 0 ? Lo(n.default, t.default) : m(n, t, F, _, x);
          },
        };
      }
      function Lo(n, t, r) {
        return n !== void 0 ? n : t !== void 0 ? t : r !== void 0 ? r : void 0;
      }
      function Oa(n, t, r, o, l) {
        return Lo(typeof r === l ? o[r] : void 0, n.default, t.default);
      }
      function dc(n, t, r) {
        if (yt(r) !== "number") return Lo(n.default, t.default);
        const o = n.stops.length;
        if (o === 1 || r <= n.stops[0][0]) return n.stops[0][1];
        if (r >= n.stops[o - 1][0]) return n.stops[o - 1][1];
        const l = rn(
          n.stops.map((d) => d[0]),
          r,
        );
        return n.stops[l][1];
      }
      function iu(n, t, r) {
        const o = n.base !== void 0 ? n.base : 1;
        if (yt(r) !== "number") return Lo(n.default, t.default);
        const l = n.stops.length;
        if (l === 1 || r <= n.stops[0][0]) return n.stops[0][1];
        if (r >= n.stops[l - 1][0]) return n.stops[l - 1][1];
        const d = rn(
            n.stops.map((b) => b[0]),
            r,
          ),
          p = (function (b, w, F, S) {
            const D = S - F,
              I = b - F;
            return D === 0
              ? 0
              : w === 1
                ? I / D
                : (Math.pow(w, I) - 1) / (Math.pow(w, D) - 1);
          })(r, o, n.stops[d][0], n.stops[d + 1][0]),
          m = n.stops[d][1],
          _ = n.stops[d + 1][1],
          x = Pr[t.type] || hc;
        return typeof m.evaluate == "function"
          ? {
              evaluate(...b) {
                const w = m.evaluate.apply(void 0, b),
                  F = _.evaluate.apply(void 0, b);
                if (w !== void 0 && F !== void 0)
                  return x(w, F, p, n.colorSpace);
              },
            }
          : x(m, _, p, n.colorSpace);
      }
      function pc(n, t, r) {
        switch (t.type) {
          case "color":
            r = ct.parse(r);
            break;
          case "formatted":
            r = ki.fromString(r.toString());
            break;
          case "resolvedImage":
            r = Ui.fromString(r.toString());
            break;
          case "padding":
            r = Zt.parse(r);
            break;
          default:
            yt(r) === t.type ||
              (t.type === "enum" && t.values[r]) ||
              (r = void 0);
        }
        return Lo(r, n.default, t.default);
      }
      ur.register(to, {
        error: [
          { kind: "error" },
          [ze],
          (n, [t]) => {
            throw new Lt(t.evaluate(n));
          },
        ],
        typeof: [ze, [je], (n, [t]) => zt(Kt(t.evaluate(n)))],
        "to-rgba": [
          Qi(Ce, 4),
          [lt],
          (n, [t]) => {
            const [r, o, l, d] = t.evaluate(n).rgb;
            return [255 * r, 255 * o, 255 * l, d];
          },
        ],
        rgb: [lt, [Ce, Ce, Ce], Yl],
        rgba: [lt, [Ce, Ce, Ce, Ce], Yl],
        has: {
          type: Ve,
          overloads: [
            [[ze], (n, [t]) => Jl(t.evaluate(n), n.properties())],
            [[ze, it], (n, [t, r]) => Jl(t.evaluate(n), r.evaluate(n))],
          ],
        },
        get: {
          type: je,
          overloads: [
            [[ze], (n, [t]) => La(t.evaluate(n), n.properties())],
            [[ze, it], (n, [t, r]) => La(t.evaluate(n), r.evaluate(n))],
          ],
        },
        "feature-state": [
          je,
          [ze],
          (n, [t]) => La(t.evaluate(n), n.featureState || {}),
        ],
        properties: [it, [], (n) => n.properties()],
        "geometry-type": [ze, [], (n) => n.geometryType()],
        id: [je, [], (n) => n.id()],
        zoom: [Ce, [], (n) => n.globals.zoom],
        "heatmap-density": [Ce, [], (n) => n.globals.heatmapDensity || 0],
        "line-progress": [Ce, [], (n) => n.globals.lineProgress || 0],
        accumulated: [
          je,
          [],
          (n) =>
            n.globals.accumulated === void 0 ? null : n.globals.accumulated,
        ],
        "+": [
          Ce,
          zn(Ce),
          (n, t) => {
            let r = 0;
            for (const o of t) r += o.evaluate(n);
            return r;
          },
        ],
        "*": [
          Ce,
          zn(Ce),
          (n, t) => {
            let r = 1;
            for (const o of t) r *= o.evaluate(n);
            return r;
          },
        ],
        "-": {
          type: Ce,
          overloads: [
            [[Ce, Ce], (n, [t, r]) => t.evaluate(n) - r.evaluate(n)],
            [[Ce], (n, [t]) => -t.evaluate(n)],
          ],
        },
        "/": [Ce, [Ce, Ce], (n, [t, r]) => t.evaluate(n) / r.evaluate(n)],
        "%": [Ce, [Ce, Ce], (n, [t, r]) => t.evaluate(n) % r.evaluate(n)],
        ln2: [Ce, [], () => Math.LN2],
        pi: [Ce, [], () => Math.PI],
        e: [Ce, [], () => Math.E],
        "^": [
          Ce,
          [Ce, Ce],
          (n, [t, r]) => Math.pow(t.evaluate(n), r.evaluate(n)),
        ],
        sqrt: [Ce, [Ce], (n, [t]) => Math.sqrt(t.evaluate(n))],
        log10: [Ce, [Ce], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN10],
        ln: [Ce, [Ce], (n, [t]) => Math.log(t.evaluate(n))],
        log2: [Ce, [Ce], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN2],
        sin: [Ce, [Ce], (n, [t]) => Math.sin(t.evaluate(n))],
        cos: [Ce, [Ce], (n, [t]) => Math.cos(t.evaluate(n))],
        tan: [Ce, [Ce], (n, [t]) => Math.tan(t.evaluate(n))],
        asin: [Ce, [Ce], (n, [t]) => Math.asin(t.evaluate(n))],
        acos: [Ce, [Ce], (n, [t]) => Math.acos(t.evaluate(n))],
        atan: [Ce, [Ce], (n, [t]) => Math.atan(t.evaluate(n))],
        min: [Ce, zn(Ce), (n, t) => Math.min(...t.map((r) => r.evaluate(n)))],
        max: [Ce, zn(Ce), (n, t) => Math.max(...t.map((r) => r.evaluate(n)))],
        abs: [Ce, [Ce], (n, [t]) => Math.abs(t.evaluate(n))],
        round: [
          Ce,
          [Ce],
          (n, [t]) => {
            const r = t.evaluate(n);
            return r < 0 ? -Math.round(-r) : Math.round(r);
          },
        ],
        floor: [Ce, [Ce], (n, [t]) => Math.floor(t.evaluate(n))],
        ceil: [Ce, [Ce], (n, [t]) => Math.ceil(t.evaluate(n))],
        "filter-==": [
          Ve,
          [ze, je],
          (n, [t, r]) => n.properties()[t.value] === r.value,
        ],
        "filter-id-==": [Ve, [je], (n, [t]) => n.id() === t.value],
        "filter-type-==": [
          Ve,
          [ze],
          (n, [t]) => n.geometryDollarType() === t.value,
        ],
        "filter-<": [
          Ve,
          [ze, je],
          (n, [t, r]) => {
            const o = n.properties()[t.value],
              l = r.value;
            return typeof o == typeof l && o < l;
          },
        ],
        "filter-id-<": [
          Ve,
          [je],
          (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r < o;
          },
        ],
        "filter->": [
          Ve,
          [ze, je],
          (n, [t, r]) => {
            const o = n.properties()[t.value],
              l = r.value;
            return typeof o == typeof l && o > l;
          },
        ],
        "filter-id->": [
          Ve,
          [je],
          (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r > o;
          },
        ],
        "filter-<=": [
          Ve,
          [ze, je],
          (n, [t, r]) => {
            const o = n.properties()[t.value],
              l = r.value;
            return typeof o == typeof l && o <= l;
          },
        ],
        "filter-id-<=": [
          Ve,
          [je],
          (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r <= o;
          },
        ],
        "filter->=": [
          Ve,
          [ze, je],
          (n, [t, r]) => {
            const o = n.properties()[t.value],
              l = r.value;
            return typeof o == typeof l && o >= l;
          },
        ],
        "filter-id->=": [
          Ve,
          [je],
          (n, [t]) => {
            const r = n.id(),
              o = t.value;
            return typeof r == typeof o && r >= o;
          },
        ],
        "filter-has": [Ve, [je], (n, [t]) => t.value in n.properties()],
        "filter-has-id": [Ve, [], (n) => n.id() !== null && n.id() !== void 0],
        "filter-type-in": [
          Ve,
          [Qi(ze)],
          (n, [t]) => t.value.indexOf(n.geometryDollarType()) >= 0,
        ],
        "filter-id-in": [
          Ve,
          [Qi(je)],
          (n, [t]) => t.value.indexOf(n.id()) >= 0,
        ],
        "filter-in-small": [
          Ve,
          [ze, Qi(je)],
          (n, [t, r]) => r.value.indexOf(n.properties()[t.value]) >= 0,
        ],
        "filter-in-large": [
          Ve,
          [ze, Qi(je)],
          (n, [t, r]) =>
            (function (o, l, d, p) {
              for (; d <= p; ) {
                const m = (d + p) >> 1;
                if (l[m] === o) return !0;
                l[m] > o ? (p = m - 1) : (d = m + 1);
              }
              return !1;
            })(n.properties()[t.value], r.value, 0, r.value.length - 1),
        ],
        all: {
          type: Ve,
          overloads: [
            [[Ve, Ve], (n, [t, r]) => t.evaluate(n) && r.evaluate(n)],
            [
              zn(Ve),
              (n, t) => {
                for (const r of t) if (!r.evaluate(n)) return !1;
                return !0;
              },
            ],
          ],
        },
        any: {
          type: Ve,
          overloads: [
            [[Ve, Ve], (n, [t, r]) => t.evaluate(n) || r.evaluate(n)],
            [
              zn(Ve),
              (n, t) => {
                for (const r of t) if (r.evaluate(n)) return !0;
                return !1;
              },
            ],
          ],
        },
        "!": [Ve, [Ve], (n, [t]) => !t.evaluate(n)],
        "is-supported-script": [
          Ve,
          [ze],
          (n, [t]) => {
            const r = n.globals && n.globals.isSupportedScript;
            return !r || r(t.evaluate(n));
          },
        ],
        upcase: [ze, [ze], (n, [t]) => t.evaluate(n).toUpperCase()],
        downcase: [ze, [ze], (n, [t]) => t.evaluate(n).toLowerCase()],
        concat: [
          ze,
          zn(je),
          (n, t) => t.map((r) => _r(r.evaluate(n))).join(""),
        ],
        "resolved-locale": [
          ze,
          [Ht],
          (n, [t]) => t.evaluate(n).resolvedLocale(),
        ],
      });
      class Bs {
        constructor(t, r) {
          var o;
          ((this.expression = t),
            (this._warningHistory = {}),
            (this._evaluator = new hs()),
            (this._defaultValue = r
              ? (o = r).type === "color" && Is(o.default)
                ? new ct(0, 0, 0, 0)
                : o.type === "color"
                  ? ct.parse(o.default) || null
                  : o.type === "padding"
                    ? Zt.parse(o.default) || null
                    : o.type === "variableAnchorOffsetCollection"
                      ? Ti.parse(o.default) || null
                      : o.type === "projectionDefinition"
                        ? xi.parse(o.default) || null
                        : o.default === void 0
                          ? null
                          : o.default
              : null),
            (this._enumValues = r && r.type === "enum" ? r.values : null));
        }
        evaluateWithoutErrorHandling(t, r, o, l, d, p) {
          return (
            (this._evaluator.globals = t),
            (this._evaluator.feature = r),
            (this._evaluator.featureState = o),
            (this._evaluator.canonical = l),
            (this._evaluator.availableImages = d || null),
            (this._evaluator.formattedSection = p),
            this.expression.evaluate(this._evaluator)
          );
        }
        evaluate(t, r, o, l, d, p) {
          ((this._evaluator.globals = t),
            (this._evaluator.feature = r || null),
            (this._evaluator.featureState = o || null),
            (this._evaluator.canonical = l),
            (this._evaluator.availableImages = d || null),
            (this._evaluator.formattedSection = p || null));
          try {
            const m = this.expression.evaluate(this._evaluator);
            if (m == null || (typeof m == "number" && m != m))
              return this._defaultValue;
            if (this._enumValues && !(m in this._enumValues))
              throw new Lt(
                `Expected value to be one of ${Object.keys(this._enumValues)
                  .map((_) => JSON.stringify(_))
                  .join(", ")}, but found ${JSON.stringify(m)} instead.`,
              );
            return m;
          } catch (m) {
            return (
              this._warningHistory[m.message] ||
                ((this._warningHistory[m.message] = !0),
                typeof console < "u" && console.warn(m.message)),
              this._defaultValue
            );
          }
        }
      }
      function ks(n) {
        return (
          Array.isArray(n) &&
          n.length > 0 &&
          typeof n[0] == "string" &&
          n[0] in to
        );
      }
      function zs(n, t) {
        const r = new lr(
            to,
            Ss,
            [],
            t
              ? (function (l) {
                  const d = {
                    color: lt,
                    string: ze,
                    number: Ce,
                    enum: ze,
                    boolean: Ve,
                    formatted: en,
                    padding: ci,
                    projectionDefinition: mt,
                    resolvedImage: ni,
                    variableAnchorOffsetCollection: kt,
                  };
                  return l.type === "array"
                    ? Qi(d[l.value] || je, l.length)
                    : d[l.type];
                })(t)
              : void 0,
          ),
          o = r.parse(
            n,
            void 0,
            void 0,
            void 0,
            t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0,
          );
        return o ? Ql(new Bs(o, t)) : io(r.errors);
      }
      class no {
        constructor(t, r) {
          ((this.kind = t),
            (this._styleExpression = r),
            (this.isStateDependent = t !== "constant" && !zo(r.expression)));
        }
        evaluateWithoutErrorHandling(t, r, o, l, d, p) {
          return this._styleExpression.evaluateWithoutErrorHandling(
            t,
            r,
            o,
            l,
            d,
            p,
          );
        }
        evaluate(t, r, o, l, d, p) {
          return this._styleExpression.evaluate(t, r, o, l, d, p);
        }
      }
      class Ls {
        constructor(t, r, o, l) {
          ((this.kind = t),
            (this.zoomStops = o),
            (this._styleExpression = r),
            (this.isStateDependent = t !== "camera" && !zo(r.expression)),
            (this.interpolationType = l));
        }
        evaluateWithoutErrorHandling(t, r, o, l, d, p) {
          return this._styleExpression.evaluateWithoutErrorHandling(
            t,
            r,
            o,
            l,
            d,
            p,
          );
        }
        evaluate(t, r, o, l, d, p) {
          return this._styleExpression.evaluate(t, r, o, l, d, p);
        }
        interpolationFactor(t, r, o) {
          return this.interpolationType
            ? zi.interpolationFactor(this.interpolationType, t, r, o)
            : 0;
        }
      }
      function ru(n, t) {
        const r = zs(n, t);
        if (r.result === "error") return r;
        const o = r.value.expression,
          l = Ds(o);
        if (!l && !ro(t))
          return io([new Ie("", "data expressions not supported")]);
        const d = Ms(o, ["zoom"]);
        if (!d && !eu(t))
          return io([new Ie("", "zoom expressions not supported")]);
        const p = Os(o);
        return p || d
          ? p instanceof Ie
            ? io([p])
            : p instanceof zi && !Ra(t)
              ? io([
                  new Ie(
                    "",
                    "\"interpolate\" expressions cannot be used with this property",
                  ),
                ])
              : Ql(
                  p
                    ? new Ls(
                        l ? "camera" : "composite",
                        r.value,
                        p.labels,
                        p instanceof zi ? p.interpolation : void 0,
                      )
                    : new no(l ? "constant" : "source", r.value),
                )
          : io([
              new Ie(
                "",
                "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.",
              ),
            ]);
      }
      class Rs {
        constructor(t, r) {
          ((this._parameters = t),
            (this._specification = r),
            ke(this, tu(this._parameters, this._specification)));
        }
        static deserialize(t) {
          return new Rs(t._parameters, t._specification);
        }
        static serialize(t) {
          return {
            _parameters: t._parameters,
            _specification: t._specification,
          };
        }
      }
      function Os(n) {
        let t = null;
        if (n instanceof Yn) t = Os(n.result);
        else if (n instanceof Mn) {
          for (const r of n.args) if (((t = Os(r)), t)) break;
        } else
          (n instanceof oi || n instanceof zi) &&
            n.input instanceof ur &&
            n.input.name === "zoom" &&
            (t = n);
        return (
          t instanceof Ie ||
            n.eachChild((r) => {
              const o = Os(r);
              o instanceof Ie
                ? (t = o)
                : !t && o
                  ? (t = new Ie(
                      "",
                      "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.",
                    ))
                  : t &&
                    o &&
                    t !== o &&
                    (t = new Ie(
                      "",
                      "Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.",
                    ));
            }),
          t
        );
      }
      function ja(n) {
        if (n === !0 || n === !1) return !0;
        if (!Array.isArray(n) || n.length === 0) return !1;
        switch (n[0]) {
          case "has":
            return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
          case "in":
            return (
              n.length >= 3 && (typeof n[1] != "string" || Array.isArray(n[2]))
            );
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2]);
          case "any":
          case "all":
            for (const t of n.slice(1))
              if (!ja(t) && typeof t != "boolean") return !1;
            return !0;
          default:
            return !0;
        }
      }
      const fc = {
        type: "boolean",
        default: !1,
        transition: !1,
        "property-type": "data-driven",
        expression: { interpolated: !1, parameters: ["zoom", "feature"] },
      };
      function js(n) {
        if (n == null) return { filter: () => !0, needGeometry: !1 };
        ja(n) || (n = Ns(n));
        const t = zs(n, fc);
        if (t.result === "error")
          throw new Error(
            t.value.map((r) => `${r.key}: ${r.message}`).join(", "),
          );
        return {
          filter: (r, o, l) => t.value.evaluate(r, o, {}, l),
          needGeometry: ou(n),
        };
      }
      function nu(n, t) {
        return n < t ? -1 : n > t ? 1 : 0;
      }
      function ou(n) {
        if (!Array.isArray(n)) return !1;
        if (
          n[0] === "within" ||
          n[0] === "distance" ||
          n[0] === "geometry-type"
        )
          return !0;
        for (let t = 1; t < n.length; t++) if (ou(n[t])) return !0;
        return !1;
      }
      function Ns(n) {
        if (!n) return !0;
        const t = n[0];
        return n.length <= 1
          ? t !== "any"
          : t === "=="
            ? Vs(n[1], n[2], "==")
            : t === "!="
              ? Ro(Vs(n[1], n[2], "=="))
              : t === "<" || t === ">" || t === "<=" || t === ">="
                ? Vs(n[1], n[2], t)
                : t === "any"
                  ? ((r = n.slice(1)), ["any"].concat(r.map(Ns)))
                  : t === "all"
                    ? ["all"].concat(n.slice(1).map(Ns))
                    : t === "none"
                      ? ["all"].concat(n.slice(1).map(Ns).map(Ro))
                      : t === "in"
                        ? Na(n[1], n.slice(2))
                        : t === "!in"
                          ? Ro(Na(n[1], n.slice(2)))
                          : t === "has"
                            ? Va(n[1])
                            : t !== "!has" || Ro(Va(n[1]));
        var r;
      }
      function Vs(n, t, r) {
        switch (n) {
          case "$type":
            return [`filter-type-${r}`, t];
          case "$id":
            return [`filter-id-${r}`, t];
          default:
            return [`filter-${r}`, n, t];
        }
      }
      function Na(n, t) {
        if (t.length === 0) return !1;
        switch (n) {
          case "$type":
            return ["filter-type-in", ["literal", t]];
          case "$id":
            return ["filter-id-in", ["literal", t]];
          default:
            return t.length > 200 && !t.some((r) => typeof r != typeof t[0])
              ? ["filter-in-large", n, ["literal", t.sort(nu)]]
              : ["filter-in-small", n, ["literal", t]];
        }
      }
      function Va(n) {
        switch (n) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", n];
        }
      }
      function Ro(n) {
        return ["!", n];
      }
      function Oo(n) {
        const t = typeof n;
        if (t === "number" || t === "boolean" || t === "string" || n == null)
          return JSON.stringify(n);
        if (Array.isArray(n)) {
          let l = "[";
          for (const d of n) l += `${Oo(d)},`;
          return `${l}]`;
        }
        const r = Object.keys(n).sort();
        let o = "{";
        for (let l = 0; l < r.length; l++)
          o += `${JSON.stringify(r[l])}:${Oo(n[r[l]])},`;
        return `${o}}`;
      }
      function Ua(n) {
        let t = "";
        for (const r of B) t += `/${Oo(n[r])}`;
        return t;
      }
      function Us(n) {
        const t = n.value;
        return t
          ? [new oe(n.key, t, "constants have been deprecated as of v8")]
          : [];
      }
      function Ot(n) {
        return n instanceof Number ||
          n instanceof String ||
          n instanceof Boolean
          ? n.valueOf()
          : n;
      }
      function Ln(n) {
        if (Array.isArray(n)) return n.map(Ln);
        if (
          n instanceof Object &&
          !(n instanceof Number || n instanceof String || n instanceof Boolean)
        ) {
          const t = {};
          for (const r in n) t[r] = Ln(n[r]);
          return t;
        }
        return Ot(n);
      }
      function cr(n) {
        const t = n.key,
          r = n.value,
          o = n.valueSpec || {},
          l = n.objectElementValidators || {},
          d = n.style,
          p = n.styleSpec,
          m = n.validateSpec;
        let _ = [];
        const x = yt(r);
        if (x !== "object")
          return [new oe(t, r, `object expected, ${x} found`)];
        for (const b in r) {
          const w = b.split(".")[0],
            F = o[w] || o["*"];
          let S;
          if (l[w]) S = l[w];
          else if (o[w]) S = m;
          else if (l["*"]) S = l["*"];
          else {
            if (!o["*"]) {
              _.push(new oe(t, r[b], `unknown property "${b}"`));
              continue;
            }
            S = m;
          }
          _ = _.concat(
            S(
              {
                key: (t && `${t}.`) + b,
                value: r[b],
                valueSpec: F,
                style: d,
                styleSpec: p,
                object: r,
                objectKey: b,
                validateSpec: m,
              },
              r,
            ),
          );
        }
        for (const b in o)
          l[b] ||
            (o[b].required &&
              o[b].default === void 0 &&
              r[b] === void 0 &&
              _.push(new oe(t, r, `missing required property "${b}"`)));
        return _;
      }
      function $a(n) {
        const t = n.value,
          r = n.valueSpec,
          o = n.style,
          l = n.styleSpec,
          d = n.key,
          p = n.arrayElementValidator || n.validateSpec;
        if (yt(t) !== "array")
          return [new oe(d, t, `array expected, ${yt(t)} found`)];
        if (r.length && t.length !== r.length)
          return [
            new oe(
              d,
              t,
              `array length ${r.length} expected, length ${t.length} found`,
            ),
          ];
        if (r["min-length"] && t.length < r["min-length"])
          return [
            new oe(
              d,
              t,
              `array length at least ${r["min-length"]} expected, length ${t.length} found`,
            ),
          ];
        let m = { type: r.value, values: r.values };
        (l.$version < 7 && (m.function = r.function),
          yt(r.value) === "object" && (m = r.value));
        let _ = [];
        for (let x = 0; x < t.length; x++)
          _ = _.concat(
            p({
              array: t,
              arrayIndex: x,
              value: t[x],
              valueSpec: m,
              validateSpec: n.validateSpec,
              style: o,
              styleSpec: l,
              key: `${d}[${x}]`,
            }),
          );
        return _;
      }
      function Za(n) {
        const t = n.key,
          r = n.value,
          o = n.valueSpec;
        let l = yt(r);
        return (
          l === "number" && r != r && (l = "NaN"),
          l !== "number"
            ? [new oe(t, r, `number expected, ${l} found`)]
            : "minimum" in o && r < o.minimum
              ? [
                  new oe(
                    t,
                    r,
                    `${r} is less than the minimum value ${o.minimum}`,
                  ),
                ]
              : "maximum" in o && r > o.maximum
                ? [
                    new oe(
                      t,
                      r,
                      `${r} is greater than the maximum value ${o.maximum}`,
                    ),
                  ]
                : []
        );
      }
      function su(n) {
        const t = n.valueSpec,
          r = Ot(n.value.type);
        let o,
          l,
          d,
          p = {};
        const m = r !== "categorical" && n.value.property === void 0,
          _ = !m,
          x =
            yt(n.value.stops) === "array" &&
            yt(n.value.stops[0]) === "array" &&
            yt(n.value.stops[0][0]) === "object",
          b = cr({
            key: n.key,
            value: n.value,
            valueSpec: n.styleSpec.function,
            validateSpec: n.validateSpec,
            style: n.style,
            styleSpec: n.styleSpec,
            objectElementValidators: {
              stops: function (S) {
                if (r === "identity")
                  return [
                    new oe(
                      S.key,
                      S.value,
                      "identity function may not have a \"stops\" property",
                    ),
                  ];
                let D = [];
                const I = S.value;
                return (
                  (D = D.concat(
                    $a({
                      key: S.key,
                      value: I,
                      valueSpec: S.valueSpec,
                      validateSpec: S.validateSpec,
                      style: S.style,
                      styleSpec: S.styleSpec,
                      arrayElementValidator: w,
                    }),
                  )),
                  yt(I) === "array" &&
                    I.length === 0 &&
                    D.push(
                      new oe(S.key, I, "array must have at least one stop"),
                    ),
                  D
                );
              },
              default: function (S) {
                return S.validateSpec({
                  key: S.key,
                  value: S.value,
                  valueSpec: t,
                  validateSpec: S.validateSpec,
                  style: S.style,
                  styleSpec: S.styleSpec,
                });
              },
            },
          });
        return (
          r === "identity" &&
            m &&
            b.push(
              new oe(n.key, n.value, "missing required property \"property\""),
            ),
          r === "identity" ||
            n.value.stops ||
            b.push(new oe(n.key, n.value, "missing required property \"stops\"")),
          r === "exponential" &&
            n.valueSpec.expression &&
            !Ra(n.valueSpec) &&
            b.push(
              new oe(n.key, n.value, "exponential functions not supported"),
            ),
          n.styleSpec.$version >= 8 &&
            (_ && !ro(n.valueSpec)
              ? b.push(
                  new oe(n.key, n.value, "property functions not supported"),
                )
              : m &&
                !eu(n.valueSpec) &&
                b.push(new oe(n.key, n.value, "zoom functions not supported"))),
          (r !== "categorical" && !x) ||
            n.value.property !== void 0 ||
            b.push(new oe(n.key, n.value, "\"property\" property is required")),
          b
        );
        function w(S) {
          let D = [];
          const I = S.value,
            O = S.key;
          if (yt(I) !== "array")
            return [new oe(O, I, `array expected, ${yt(I)} found`)];
          if (I.length !== 2)
            return [
              new oe(O, I, `array length 2 expected, length ${I.length} found`),
            ];
          if (x) {
            if (yt(I[0]) !== "object")
              return [new oe(O, I, `object expected, ${yt(I[0])} found`)];
            if (I[0].zoom === void 0)
              return [new oe(O, I, "object stop key must have zoom")];
            if (I[0].value === void 0)
              return [new oe(O, I, "object stop key must have value")];
            if (d && d > Ot(I[0].zoom))
              return [
                new oe(
                  O,
                  I[0].zoom,
                  "stop zoom values must appear in ascending order",
                ),
              ];
            (Ot(I[0].zoom) !== d &&
              ((d = Ot(I[0].zoom)), (l = void 0), (p = {})),
              (D = D.concat(
                cr({
                  key: `${O}[0]`,
                  value: I[0],
                  valueSpec: { zoom: {} },
                  validateSpec: S.validateSpec,
                  style: S.style,
                  styleSpec: S.styleSpec,
                  objectElementValidators: { zoom: Za, value: F },
                }),
              )));
          } else
            D = D.concat(
              F(
                {
                  key: `${O}[0]`,
                  value: I[0],
                  valueSpec: {},
                  validateSpec: S.validateSpec,
                  style: S.style,
                  styleSpec: S.styleSpec,
                },
                I,
              ),
            );
          return ks(Ln(I[1]))
            ? D.concat([
                new oe(
                  `${O}[1]`,
                  I[1],
                  "expressions are not allowed in function stops.",
                ),
              ])
            : D.concat(
                S.validateSpec({
                  key: `${O}[1]`,
                  value: I[1],
                  valueSpec: t,
                  validateSpec: S.validateSpec,
                  style: S.style,
                  styleSpec: S.styleSpec,
                }),
              );
        }
        function F(S, D) {
          const I = yt(S.value),
            O = Ot(S.value),
            Z = S.value !== null ? S.value : D;
          if (o) {
            if (I !== o)
              return [
                new oe(
                  S.key,
                  Z,
                  `${I} stop domain type must match previous stop domain type ${o}`,
                ),
              ];
          } else o = I;
          if (I !== "number" && I !== "string" && I !== "boolean")
            return [
              new oe(
                S.key,
                Z,
                "stop domain value must be a number, string, or boolean",
              ),
            ];
          if (I !== "number" && r !== "categorical") {
            let ne = `number expected, ${I} found`;
            return (
              ro(t) &&
                r === void 0 &&
                (ne +=
                  "\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`."),
              [new oe(S.key, Z, ne)]
            );
          }
          return r !== "categorical" ||
            I !== "number" ||
            (isFinite(O) && Math.floor(O) === O)
            ? r !== "categorical" && I === "number" && l !== void 0 && O < l
              ? [
                  new oe(
                    S.key,
                    Z,
                    "stop domain values must appear in ascending order",
                  ),
                ]
              : ((l = O),
                r === "categorical" && O in p
                  ? [new oe(S.key, Z, "stop domain values must be unique")]
                  : ((p[O] = !0), []))
            : [new oe(S.key, Z, `integer expected, found ${O}`)];
        }
      }
      function oo(n) {
        const t = (n.expressionContext === "property" ? ru : zs)(
          Ln(n.value),
          n.valueSpec,
        );
        if (t.result === "error")
          return t.value.map(
            (o) => new oe(`${n.key}${o.key}`, n.value, o.message),
          );
        const r = t.value.expression || t.value._styleExpression.expression;
        if (
          n.expressionContext === "property" &&
          n.propertyKey === "text-font" &&
          !r.outputDefined()
        )
          return [
            new oe(
              n.key,
              n.value,
              `Invalid data expression for "${n.propertyKey}". Output values must be contained as literals within the expression.`,
            ),
          ];
        if (
          n.expressionContext === "property" &&
          n.propertyType === "layout" &&
          !zo(r)
        )
          return [
            new oe(
              n.key,
              n.value,
              "\"feature-state\" data expressions are not supported with layout properties.",
            ),
          ];
        if (n.expressionContext === "filter" && !zo(r))
          return [
            new oe(
              n.key,
              n.value,
              "\"feature-state\" data expressions are not supported with filters.",
            ),
          ];
        if (
          n.expressionContext &&
          n.expressionContext.indexOf("cluster") === 0
        ) {
          if (!Ms(r, ["zoom", "feature-state"]))
            return [
              new oe(
                n.key,
                n.value,
                "\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.",
              ),
            ];
          if (n.expressionContext === "cluster-initial" && !Ds(r))
            return [
              new oe(
                n.key,
                n.value,
                "Feature data expressions are not supported with initial expression part of cluster properties.",
              ),
            ];
        }
        return [];
      }
      function so(n) {
        const t = n.key,
          r = n.value,
          o = n.valueSpec,
          l = [];
        return (
          Array.isArray(o.values)
            ? o.values.indexOf(Ot(r)) === -1 &&
              l.push(
                new oe(
                  t,
                  r,
                  `expected one of [${o.values.join(", ")}], ${JSON.stringify(r)} found`,
                ),
              )
            : Object.keys(o.values).indexOf(Ot(r)) === -1 &&
              l.push(
                new oe(
                  t,
                  r,
                  `expected one of [${Object.keys(o.values).join(", ")}], ${JSON.stringify(r)} found`,
                ),
              ),
          l
        );
      }
      function $s(n) {
        return ja(Ln(n.value))
          ? oo(
              ke({}, n, {
                expressionContext: "filter",
                valueSpec: { value: "boolean" },
              }),
            )
          : jo(n);
      }
      function jo(n) {
        const t = n.value,
          r = n.key;
        if (yt(t) !== "array")
          return [new oe(r, t, `array expected, ${yt(t)} found`)];
        const o = n.styleSpec;
        let l,
          d = [];
        if (t.length < 1)
          return [new oe(r, t, "filter array must have at least 1 element")];
        switch (
          ((d = d.concat(
            so({
              key: `${r}[0]`,
              value: t[0],
              valueSpec: o.filter_operator,
              style: n.style,
              styleSpec: n.styleSpec,
            }),
          )),
          Ot(t[0]))
        ) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            t.length >= 2 &&
              Ot(t[1]) === "$type" &&
              d.push(
                new oe(r, t, `"$type" cannot be use with operator "${t[0]}"`),
              );
          case "==":
          case "!=":
            t.length !== 3 &&
              d.push(
                new oe(
                  r,
                  t,
                  `filter array for operator "${t[0]}" must have 3 elements`,
                ),
              );
          case "in":
          case "!in":
            t.length >= 2 &&
              ((l = yt(t[1])),
              l !== "string" &&
                d.push(new oe(`${r}[1]`, t[1], `string expected, ${l} found`)));
            for (let p = 2; p < t.length; p++)
              ((l = yt(t[p])),
                Ot(t[1]) === "$type"
                  ? (d = d.concat(
                      so({
                        key: `${r}[${p}]`,
                        value: t[p],
                        valueSpec: o.geometry_type,
                        style: n.style,
                        styleSpec: n.styleSpec,
                      }),
                    ))
                  : l !== "string" &&
                    l !== "number" &&
                    l !== "boolean" &&
                    d.push(
                      new oe(
                        `${r}[${p}]`,
                        t[p],
                        `string, number, or boolean expected, ${l} found`,
                      ),
                    ));
            break;
          case "any":
          case "all":
          case "none":
            for (let p = 1; p < t.length; p++)
              d = d.concat(
                jo({
                  key: `${r}[${p}]`,
                  value: t[p],
                  style: n.style,
                  styleSpec: n.styleSpec,
                }),
              );
            break;
          case "has":
          case "!has":
            ((l = yt(t[1])),
              t.length !== 2
                ? d.push(
                    new oe(
                      r,
                      t,
                      `filter array for "${t[0]}" operator must have 2 elements`,
                    ),
                  )
                : l !== "string" &&
                  d.push(
                    new oe(`${r}[1]`, t[1], `string expected, ${l} found`),
                  ));
        }
        return d;
      }
      function au(n, t) {
        const r = n.key,
          o = n.validateSpec,
          l = n.style,
          d = n.styleSpec,
          p = n.value,
          m = n.objectKey,
          _ = d[`${t}_${n.layerType}`];
        if (!_) return [];
        const x = m.match(/^(.*)-transition$/);
        if (t === "paint" && x && _[x[1]] && _[x[1]].transition)
          return o({
            key: r,
            value: p,
            valueSpec: d.transition,
            style: l,
            styleSpec: d,
          });
        const b = n.valueSpec || _[m];
        if (!b) return [new oe(r, p, `unknown property "${m}"`)];
        let w;
        if (
          yt(p) === "string" &&
          ro(b) &&
          !b.tokens &&
          (w = /^{([^}]+)}$/.exec(p))
        )
          return [
            new oe(
              r,
              p,
              `"${m}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(w[1])} }\`.`,
            ),
          ];
        const F = [];
        return (
          n.layerType === "symbol" &&
            (m === "text-field" &&
              l &&
              !l.glyphs &&
              F.push(
                new oe(
                  r,
                  p,
                  "use of \"text-field\" requires a style \"glyphs\" property",
                ),
              ),
            m === "text-font" &&
              Is(Ln(p)) &&
              Ot(p.type) === "identity" &&
              F.push(
                new oe(r, p, "\"text-font\" does not support identity functions"),
              )),
          F.concat(
            o({
              key: n.key,
              value: p,
              valueSpec: b,
              style: l,
              styleSpec: d,
              expressionContext: "property",
              propertyType: t,
              propertyKey: m,
            }),
          )
        );
      }
      function Ga(n) {
        return au(n, "paint");
      }
      function qa(n) {
        return au(n, "layout");
      }
      function lu(n) {
        let t = [];
        const r = n.value,
          o = n.key,
          l = n.style,
          d = n.styleSpec;
        r.type ||
          r.ref ||
          t.push(new oe(o, r, "either \"type\" or \"ref\" is required"));
        let p = Ot(r.type);
        const m = Ot(r.ref);
        if (r.id) {
          const _ = Ot(r.id);
          for (let x = 0; x < n.arrayIndex; x++) {
            const b = l.layers[x];
            Ot(b.id) === _ &&
              t.push(
                new oe(
                  o,
                  r.id,
                  `duplicate layer id "${r.id}", previously used at line ${b.id.__line__}`,
                ),
              );
          }
        }
        if ("ref" in r) {
          let _;
          (["type", "source", "source-layer", "filter", "layout"].forEach(
            (x) => {
              x in r &&
                t.push(new oe(o, r[x], `"${x}" is prohibited for ref layers`));
            },
          ),
            l.layers.forEach((x) => {
              Ot(x.id) === m && (_ = x);
            }),
            _
              ? _.ref
                ? t.push(
                    new oe(o, r.ref, "ref cannot reference another ref layer"),
                  )
                : (p = Ot(_.type))
              : t.push(new oe(o, r.ref, `ref layer "${m}" not found`)));
        } else if (p !== "background")
          if (r.source) {
            const _ = l.sources && l.sources[r.source],
              x = _ && Ot(_.type);
            _
              ? x === "vector" && p === "raster"
                ? t.push(
                    new oe(
                      o,
                      r.source,
                      `layer "${r.id}" requires a raster source`,
                    ),
                  )
                : x !== "raster-dem" && p === "hillshade"
                  ? t.push(
                      new oe(
                        o,
                        r.source,
                        `layer "${r.id}" requires a raster-dem source`,
                      ),
                    )
                  : x === "raster" && p !== "raster"
                    ? t.push(
                        new oe(
                          o,
                          r.source,
                          `layer "${r.id}" requires a vector source`,
                        ),
                      )
                    : x !== "vector" || r["source-layer"]
                      ? x === "raster-dem" && p !== "hillshade"
                        ? t.push(
                            new oe(
                              o,
                              r.source,
                              "raster-dem source can only be used with layer type 'hillshade'.",
                            ),
                          )
                        : p !== "line" ||
                          !r.paint ||
                          !r.paint["line-gradient"] ||
                          (x === "geojson" && _.lineMetrics) ||
                          t.push(
                            new oe(
                              o,
                              r,
                              `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`,
                            ),
                          )
                      : t.push(
                          new oe(
                            o,
                            r,
                            `layer "${r.id}" must specify a "source-layer"`,
                          ),
                        )
              : t.push(new oe(o, r.source, `source "${r.source}" not found`));
          } else t.push(new oe(o, r, "missing required property \"source\""));
        return (
          (t = t.concat(
            cr({
              key: o,
              value: r,
              valueSpec: d.layer,
              style: n.style,
              styleSpec: n.styleSpec,
              validateSpec: n.validateSpec,
              objectElementValidators: {
                "*": () => [],
                type: () =>
                  n.validateSpec({
                    key: `${o}.type`,
                    value: r.type,
                    valueSpec: d.layer.type,
                    style: n.style,
                    styleSpec: n.styleSpec,
                    validateSpec: n.validateSpec,
                    object: r,
                    objectKey: "type",
                  }),
                filter: $s,
                layout: (_) =>
                  cr({
                    layer: r,
                    key: _.key,
                    value: _.value,
                    style: _.style,
                    styleSpec: _.styleSpec,
                    validateSpec: _.validateSpec,
                    objectElementValidators: {
                      "*": (x) => qa(ke({ layerType: p }, x)),
                    },
                  }),
                paint: (_) =>
                  cr({
                    layer: r,
                    key: _.key,
                    value: _.value,
                    style: _.style,
                    styleSpec: _.styleSpec,
                    validateSpec: _.validateSpec,
                    objectElementValidators: {
                      "*": (x) => Ga(ke({ layerType: p }, x)),
                    },
                  }),
              },
            }),
          )),
          t
        );
      }
      function nn(n) {
        const t = n.value,
          r = n.key,
          o = yt(t);
        return o !== "string"
          ? [new oe(r, t, `string expected, ${o} found`)]
          : [];
      }
      const Ha = {
        promoteId: function ({ key: n, value: t }) {
          if (yt(t) === "string") return nn({ key: n, value: t });
          {
            const r = [];
            for (const o in t) r.push(...nn({ key: `${n}.${o}`, value: t[o] }));
            return r;
          }
        },
      };
      function ao(n) {
        const t = n.value,
          r = n.key,
          o = n.styleSpec,
          l = n.style,
          d = n.validateSpec;
        if (!t.type) return [new oe(r, t, "\"type\" is required")];
        const p = Ot(t.type);
        let m;
        switch (p) {
          case "vector":
          case "raster":
            return (
              (m = cr({
                key: r,
                value: t,
                valueSpec: o[`source_${p.replace("-", "_")}`],
                style: n.style,
                styleSpec: o,
                objectElementValidators: Ha,
                validateSpec: d,
              })),
              m
            );
          case "raster-dem":
            return (
              (m = (function (_) {
                var x;
                const b = (x = _.sourceName) !== null && x !== void 0 ? x : "",
                  w = _.value,
                  F = _.styleSpec,
                  S = F.source_raster_dem,
                  D = _.style;
                let I = [];
                const O = yt(w);
                if (w === void 0) return I;
                if (O !== "object")
                  return (
                    I.push(
                      new oe(
                        "source_raster_dem",
                        w,
                        `object expected, ${O} found`,
                      ),
                    ),
                    I
                  );
                const Z = Ot(w.encoding) === "custom",
                  ne = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  H = _.value.encoding ? `"${_.value.encoding}"` : "Default";
                for (const P in w)
                  !Z && ne.includes(P)
                    ? I.push(
                        new oe(
                          P,
                          w[P],
                          `In "${b}": "${P}" is only valid when "encoding" is set to "custom". ${H} encoding found`,
                        ),
                      )
                    : S[P]
                      ? (I = I.concat(
                          _.validateSpec({
                            key: P,
                            value: w[P],
                            valueSpec: S[P],
                            validateSpec: _.validateSpec,
                            style: D,
                            styleSpec: F,
                          }),
                        ))
                      : I.push(new oe(P, w[P], `unknown property "${P}"`));
                return I;
              })({
                sourceName: r,
                value: t,
                style: n.style,
                styleSpec: o,
                validateSpec: d,
              })),
              m
            );
          case "geojson":
            if (
              ((m = cr({
                key: r,
                value: t,
                valueSpec: o.source_geojson,
                style: l,
                styleSpec: o,
                validateSpec: d,
                objectElementValidators: Ha,
              })),
              t.cluster)
            )
              for (const _ in t.clusterProperties) {
                const [x, b] = t.clusterProperties[_],
                  w =
                    typeof x == "string" ? [x, ["accumulated"], ["get", _]] : x;
                (m.push(
                  ...oo({
                    key: `${r}.${_}.map`,
                    value: b,
                    validateSpec: d,
                    expressionContext: "cluster-map",
                  }),
                ),
                  m.push(
                    ...oo({
                      key: `${r}.${_}.reduce`,
                      value: w,
                      validateSpec: d,
                      expressionContext: "cluster-reduce",
                    }),
                  ));
              }
            return m;
          case "video":
            return cr({
              key: r,
              value: t,
              valueSpec: o.source_video,
              style: l,
              validateSpec: d,
              styleSpec: o,
            });
          case "image":
            return cr({
              key: r,
              value: t,
              valueSpec: o.source_image,
              style: l,
              validateSpec: d,
              styleSpec: o,
            });
          case "canvas":
            return [
              new oe(
                r,
                null,
                "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.",
                "source.canvas",
              ),
            ];
          default:
            return so({
              key: `${r}.type`,
              value: t.type,
              valueSpec: {
                values: [
                  "vector",
                  "raster",
                  "raster-dem",
                  "geojson",
                  "video",
                  "image",
                ],
              },
              style: l,
              validateSpec: d,
              styleSpec: o,
            });
        }
      }
      function uu(n) {
        const t = n.value,
          r = n.styleSpec,
          o = r.light,
          l = n.style;
        let d = [];
        const p = yt(t);
        if (t === void 0) return d;
        if (p !== "object")
          return (
            (d = d.concat([new oe("light", t, `object expected, ${p} found`)])),
            d
          );
        for (const m in t) {
          const _ = m.match(/^(.*)-transition$/);
          d = d.concat(
            _ && o[_[1]] && o[_[1]].transition
              ? n.validateSpec({
                  key: m,
                  value: t[m],
                  valueSpec: r.transition,
                  validateSpec: n.validateSpec,
                  style: l,
                  styleSpec: r,
                })
              : o[m]
                ? n.validateSpec({
                    key: m,
                    value: t[m],
                    valueSpec: o[m],
                    validateSpec: n.validateSpec,
                    style: l,
                    styleSpec: r,
                  })
                : [new oe(m, t[m], `unknown property "${m}"`)],
          );
        }
        return d;
      }
      function cu(n) {
        const t = n.value,
          r = n.styleSpec,
          o = r.sky,
          l = n.style,
          d = yt(t);
        if (t === void 0) return [];
        if (d !== "object")
          return [new oe("sky", t, `object expected, ${d} found`)];
        let p = [];
        for (const m in t)
          p = p.concat(
            o[m]
              ? n.validateSpec({
                  key: m,
                  value: t[m],
                  valueSpec: o[m],
                  style: l,
                  styleSpec: r,
                })
              : [new oe(m, t[m], `unknown property "${m}"`)],
          );
        return p;
      }
      function hu(n) {
        const t = n.value,
          r = n.styleSpec,
          o = r.terrain,
          l = n.style;
        let d = [];
        const p = yt(t);
        if (t === void 0) return d;
        if (p !== "object")
          return (
            (d = d.concat([
              new oe("terrain", t, `object expected, ${p} found`),
            ])),
            d
          );
        for (const m in t)
          d = d.concat(
            o[m]
              ? n.validateSpec({
                  key: m,
                  value: t[m],
                  valueSpec: o[m],
                  validateSpec: n.validateSpec,
                  style: l,
                  styleSpec: r,
                })
              : [new oe(m, t[m], `unknown property "${m}"`)],
          );
        return d;
      }
      function du(n) {
        let t = [];
        const r = n.value,
          o = n.key;
        if (Array.isArray(r)) {
          const l = [],
            d = [];
          for (const p in r)
            (r[p].id &&
              l.includes(r[p].id) &&
              t.push(
                new oe(
                  o,
                  r,
                  `all the sprites' ids must be unique, but ${r[p].id} is duplicated`,
                ),
              ),
              l.push(r[p].id),
              r[p].url &&
                d.includes(r[p].url) &&
                t.push(
                  new oe(
                    o,
                    r,
                    `all the sprites' URLs must be unique, but ${r[p].url} is duplicated`,
                  ),
                ),
              d.push(r[p].url),
              (t = t.concat(
                cr({
                  key: `${o}[${p}]`,
                  value: r[p],
                  valueSpec: {
                    id: { type: "string", required: !0 },
                    url: { type: "string", required: !0 },
                  },
                  validateSpec: n.validateSpec,
                }),
              )));
          return t;
        }
        return nn({ key: o, value: r });
      }
      const pu = {
        "*": () => [],
        array: $a,
        boolean: function (n) {
          const t = n.value,
            r = n.key,
            o = yt(t);
          return o !== "boolean"
            ? [new oe(r, t, `boolean expected, ${o} found`)]
            : [];
        },
        number: Za,
        color: function (n) {
          const t = n.key,
            r = n.value,
            o = yt(r);
          return o !== "string"
            ? [new oe(t, r, `color expected, ${o} found`)]
            : ct.parse(String(r))
              ? []
              : [new oe(t, r, `color expected, "${r}" found`)];
        },
        constants: Us,
        enum: so,
        filter: $s,
        function: su,
        layer: lu,
        object: cr,
        source: ao,
        light: uu,
        sky: cu,
        terrain: hu,
        projection: function (n) {
          const t = n.value,
            r = n.styleSpec,
            o = r.projection,
            l = n.style,
            d = yt(t);
          if (t === void 0) return [];
          if (d !== "object")
            return [new oe("projection", t, `object expected, ${d} found`)];
          let p = [];
          for (const m in t)
            p = p.concat(
              o[m]
                ? n.validateSpec({
                    key: m,
                    value: t[m],
                    valueSpec: o[m],
                    style: l,
                    styleSpec: r,
                  })
                : [new oe(m, t[m], `unknown property "${m}"`)],
            );
          return p;
        },
        projectionDefinition: function (n) {
          const t = n.key;
          let r = n.value;
          r = r instanceof String ? r.valueOf() : r;
          const o = yt(r);
          return o !== "array" ||
            (function (l) {
              return (
                Array.isArray(l) &&
                l.length === 3 &&
                typeof l[0] == "string" &&
                typeof l[1] == "string" &&
                typeof l[2] == "number"
              );
            })(r) ||
            (function (l) {
              return !!["interpolate", "step", "literal"].includes(l[0]);
            })(r)
            ? ["array", "string"].includes(o)
              ? []
              : [new oe(t, r, `projection expected, invalid type "${o}" found`)]
            : [
                new oe(
                  t,
                  r,
                  `projection expected, invalid array ${JSON.stringify(r)} found`,
                ),
              ];
        },
        string: nn,
        formatted: function (n) {
          return nn(n).length === 0 ? [] : oo(n);
        },
        resolvedImage: function (n) {
          return nn(n).length === 0 ? [] : oo(n);
        },
        padding: function (n) {
          const t = n.key,
            r = n.value;
          if (yt(r) === "array") {
            if (r.length < 1 || r.length > 4)
              return [
                new oe(
                  t,
                  r,
                  `padding requires 1 to 4 values; ${r.length} values found`,
                ),
              ];
            const o = { type: "number" };
            let l = [];
            for (let d = 0; d < r.length; d++)
              l = l.concat(
                n.validateSpec({
                  key: `${t}[${d}]`,
                  value: r[d],
                  validateSpec: n.validateSpec,
                  valueSpec: o,
                }),
              );
            return l;
          }
          return Za({ key: t, value: r, valueSpec: {} });
        },
        variableAnchorOffsetCollection: function (n) {
          const t = n.key,
            r = n.value,
            o = yt(r),
            l = n.styleSpec;
          if (o !== "array" || r.length < 1 || r.length % 2 != 0)
            return [
              new oe(
                t,
                r,
                "variableAnchorOffsetCollection requires a non-empty array of even length",
              ),
            ];
          let d = [];
          for (let p = 0; p < r.length; p += 2)
            ((d = d.concat(
              so({
                key: `${t}[${p}]`,
                value: r[p],
                valueSpec: l.layout_symbol["text-anchor"],
              }),
            )),
              (d = d.concat(
                $a({
                  key: `${t}[${p + 1}]`,
                  value: r[p + 1],
                  valueSpec: { length: 2, value: "number" },
                  validateSpec: n.validateSpec,
                  style: n.style,
                  styleSpec: l,
                }),
              )));
          return d;
        },
        sprite: du,
      };
      function No(n) {
        const t = n.value,
          r = n.valueSpec,
          o = n.styleSpec;
        return (
          (n.validateSpec = No),
          r.expression && Is(Ot(t))
            ? su(n)
            : r.expression && ks(Ln(t))
              ? oo(n)
              : r.type && pu[r.type]
                ? pu[r.type](n)
                : cr(ke({}, n, { valueSpec: r.type ? o[r.type] : r }))
        );
      }
      function lo(n) {
        const t = n.value,
          r = n.key,
          o = nn(n);
        return (
          o.length ||
            (t.indexOf("{fontstack}") === -1 &&
              o.push(
                new oe(r, t, "\"glyphs\" url must include a \"{fontstack}\" token"),
              ),
            t.indexOf("{range}") === -1 &&
              o.push(
                new oe(r, t, "\"glyphs\" url must include a \"{range}\" token"),
              )),
          o
        );
      }
      function Li(n, t = j) {
        let r = [];
        return (
          (r = r.concat(
            No({
              key: "",
              value: n,
              valueSpec: t.$root,
              styleSpec: t,
              style: n,
              validateSpec: No,
              objectElementValidators: { glyphs: lo, "*": () => [] },
            }),
          )),
          n.constants &&
            (r = r.concat(
              Us({
                key: "constants",
                value: n.constants,
                style: n,
                styleSpec: t,
                validateSpec: No,
              }),
            )),
          uo(r)
        );
      }
      function Yt(n) {
        return function (t) {
          return n({ ...t, validateSpec: No });
        };
      }
      function uo(n) {
        return [].concat(n).sort((t, r) => t.line - r.line);
      }
      function xr(n) {
        return function (...t) {
          return uo(n.apply(this, t));
        };
      }
      ((Li.source = xr(Yt(ao))),
        (Li.sprite = xr(Yt(du))),
        (Li.glyphs = xr(Yt(lo))),
        (Li.light = xr(Yt(uu))),
        (Li.sky = xr(Yt(cu))),
        (Li.terrain = xr(Yt(hu))),
        (Li.layer = xr(Yt(lu))),
        (Li.filter = xr(Yt($s))),
        (Li.paintProperty = xr(Yt(Ga))),
        (Li.layoutProperty = xr(Yt(qa))));
      const co = Li,
        mc = co.light,
        Vo = co.sky,
        fu = co.paintProperty,
        Xa = co.layoutProperty;
      function mu(n, t) {
        let r = !1;
        if (t && t.length)
          for (const o of t) (n.fire(new To(new Error(o.message))), (r = !0));
        return r;
      }
      class Rn {
        constructor(t, r, o) {
          const l = (this.cells = []);
          if (t instanceof ArrayBuffer) {
            this.arrayBuffer = t;
            const p = new Int32Array(this.arrayBuffer);
            ((t = p[0]), (this.d = (r = p[1]) + 2 * (o = p[2])));
            for (let _ = 0; _ < this.d * this.d; _++) {
              const x = p[3 + _],
                b = p[3 + _ + 1];
              l.push(x === b ? null : p.subarray(x, b));
            }
            const m = p[3 + l.length + 1];
            ((this.keys = p.subarray(p[3 + l.length], m)),
              (this.bboxes = p.subarray(m)),
              (this.insert = this._insertReadonly));
          } else {
            this.d = r + 2 * o;
            for (let p = 0; p < this.d * this.d; p++) l.push([]);
            ((this.keys = []), (this.bboxes = []));
          }
          ((this.n = r),
            (this.extent = t),
            (this.padding = o),
            (this.scale = r / t),
            (this.uid = 0));
          const d = (o / r) * t;
          ((this.min = -d), (this.max = t + d));
        }
        insert(t, r, o, l, d) {
          (this._forEachCell(
            r,
            o,
            l,
            d,
            this._insertCell,
            this.uid++,
            void 0,
            void 0,
          ),
            this.keys.push(t),
            this.bboxes.push(r),
            this.bboxes.push(o),
            this.bboxes.push(l),
            this.bboxes.push(d));
        }
        _insertReadonly() {
          throw new Error(
            "Cannot insert into a GridIndex created from an ArrayBuffer.",
          );
        }
        _insertCell(t, r, o, l, d, p) {
          this.cells[d].push(p);
        }
        query(t, r, o, l, d) {
          const p = this.min,
            m = this.max;
          if (t <= p && r <= p && m <= o && m <= l && !d)
            return Array.prototype.slice.call(this.keys);
          {
            const _ = [];
            return (
              this._forEachCell(t, r, o, l, this._queryCell, _, {}, d),
              _
            );
          }
        }
        _queryCell(t, r, o, l, d, p, m, _) {
          const x = this.cells[d];
          if (x !== null) {
            const b = this.keys,
              w = this.bboxes;
            for (let F = 0; F < x.length; F++) {
              const S = x[F];
              if (m[S] === void 0) {
                const D = 4 * S;
                (
                  _
                    ? _(w[D + 0], w[D + 1], w[D + 2], w[D + 3])
                    : t <= w[D + 2] &&
                      r <= w[D + 3] &&
                      o >= w[D + 0] &&
                      l >= w[D + 1]
                )
                  ? ((m[S] = !0), p.push(b[S]))
                  : (m[S] = !1);
              }
            }
          }
        }
        _forEachCell(t, r, o, l, d, p, m, _) {
          const x = this._convertToCellCoord(t),
            b = this._convertToCellCoord(r),
            w = this._convertToCellCoord(o),
            F = this._convertToCellCoord(l);
          for (let S = x; S <= w; S++)
            for (let D = b; D <= F; D++) {
              const I = this.d * D + S;
              if (
                (!_ ||
                  _(
                    this._convertFromCellCoord(S),
                    this._convertFromCellCoord(D),
                    this._convertFromCellCoord(S + 1),
                    this._convertFromCellCoord(D + 1),
                  )) &&
                d.call(this, t, r, o, l, I, p, m, _)
              )
                return;
            }
        }
        _convertFromCellCoord(t) {
          return (t - this.padding) / this.scale;
        }
        _convertToCellCoord(t) {
          return Math.max(
            0,
            Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding),
          );
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const t = this.cells,
            r = 3 + this.cells.length + 1 + 1;
          let o = 0;
          for (let p = 0; p < this.cells.length; p++) o += this.cells[p].length;
          const l = new Int32Array(
            r + o + this.keys.length + this.bboxes.length,
          );
          ((l[0] = this.extent), (l[1] = this.n), (l[2] = this.padding));
          let d = r;
          for (let p = 0; p < t.length; p++) {
            const m = t[p];
            ((l[3 + p] = d), l.set(m, d), (d += m.length));
          }
          return (
            (l[3 + t.length] = d),
            l.set(this.keys, d),
            (d += this.keys.length),
            (l[3 + t.length + 1] = d),
            l.set(this.bboxes, d),
            (d += this.bboxes.length),
            l.buffer
          );
        }
        static serialize(t, r) {
          const o = t.toArrayBuffer();
          return (r && r.push(o), { buffer: o });
        }
        static deserialize(t) {
          return new Rn(t.buffer);
        }
      }
      const Vr = {};
      function Re(n, t, r = {}) {
        if (Vr[n]) throw new Error(`${n} is already registered.`);
        (Object.defineProperty(t, "_classRegistryKey", {
          value: n,
          writeable: !1,
        }),
          (Vr[n] = { klass: t, omit: r.omit || [], shallow: r.shallow || [] }));
      }
      (Re("Object", Object),
        Re("TransferableGridIndex", Rn),
        Re("Color", ct),
        Re("Error", Error),
        Re("AJAXError", Lr),
        Re("ResolvedImage", Ui),
        Re("StylePropertyFunction", Rs),
        Re("StyleExpression", Bs, { omit: ["_evaluator"] }),
        Re("ZoomDependentExpression", Ls),
        Re("ZoomConstantExpression", no),
        Re("CompoundExpression", ur, { omit: ["_evaluate"] }));
      for (const n in to)
        to[n]._classRegistryKey || Re(`Expression_${n}`, to[n]);
      function gu(n) {
        return (
          n &&
          typeof ArrayBuffer < "u" &&
          (n instanceof ArrayBuffer ||
            (n.constructor && n.constructor.name === "ArrayBuffer"))
        );
      }
      function On(n) {
        return n.$name || n.constructor._classRegistryKey;
      }
      function _u(n) {
        return (
          !(function (t) {
            if (t === null || typeof t != "object") return !1;
            const r = On(t);
            return !(!r || r === "Object");
          })(n) &&
          (n == null ||
            typeof n == "boolean" ||
            typeof n == "number" ||
            typeof n == "string" ||
            n instanceof Boolean ||
            n instanceof Number ||
            n instanceof String ||
            n instanceof Date ||
            n instanceof RegExp ||
            n instanceof Blob ||
            n instanceof Error ||
            gu(n) ||
            gn(n) ||
            ArrayBuffer.isView(n) ||
            n instanceof ImageData)
        );
      }
      function Uo(n, t) {
        if (_u(n))
          return (
            (gu(n) || gn(n)) && t && t.push(n),
            ArrayBuffer.isView(n) && t && t.push(n.buffer),
            n instanceof ImageData && t && t.push(n.data.buffer),
            n
          );
        if (Array.isArray(n)) {
          const d = [];
          for (const p of n) d.push(Uo(p, t));
          return d;
        }
        if (typeof n != "object")
          throw new Error("can't serialize object of type " + typeof n);
        const r = On(n);
        if (!r)
          throw new Error(
            `can't serialize object of unregistered class ${n.constructor.name}`,
          );
        if (!Vr[r]) throw new Error(`${r} is not registered.`);
        const { klass: o } = Vr[r],
          l = o.serialize ? o.serialize(n, t) : {};
        if (o.serialize) {
          if (t && l === t[t.length - 1])
            throw new Error(
              "statically serialized object won't survive transfer of $name property",
            );
        } else {
          for (const d in n) {
            if (!n.hasOwnProperty(d) || Vr[r].omit.indexOf(d) >= 0) continue;
            const p = n[d];
            l[d] = Vr[r].shallow.indexOf(d) >= 0 ? p : Uo(p, t);
          }
          n instanceof Error && (l.message = n.message);
        }
        if (l.$name)
          throw new Error(
            "$name property is reserved for worker serialization logic.",
          );
        return (r !== "Object" && (l.$name = r), l);
      }
      function on(n) {
        if (_u(n)) return n;
        if (Array.isArray(n)) return n.map(on);
        if (typeof n != "object")
          throw new Error("can't deserialize object of type " + typeof n);
        const t = On(n) || "Object";
        if (!Vr[t])
          throw new Error(`can't deserialize unregistered class ${t}`);
        const { klass: r } = Vr[t];
        if (!r) throw new Error(`can't deserialize unregistered class ${t}`);
        if (r.deserialize) return r.deserialize(n);
        const o = Object.create(r.prototype);
        for (const l of Object.keys(n)) {
          if (l === "$name") continue;
          const d = n[l];
          o[l] = Vr[t].shallow.indexOf(l) >= 0 ? d : on(d);
        }
        return o;
      }
      class yu {
        constructor() {
          this.first = !0;
        }
        update(t, r) {
          const o = Math.floor(t);
          return this.first
            ? ((this.first = !1),
              (this.lastIntegerZoom = o),
              (this.lastIntegerZoomTime = 0),
              (this.lastZoom = t),
              (this.lastFloorZoom = o),
              !0)
            : (this.lastFloorZoom > o
                ? ((this.lastIntegerZoom = o + 1),
                  (this.lastIntegerZoomTime = r))
                : this.lastFloorZoom < o &&
                  ((this.lastIntegerZoom = o), (this.lastIntegerZoomTime = r)),
              t !== this.lastZoom &&
                ((this.lastZoom = t), (this.lastFloorZoom = o), !0));
        }
      }
      const ht = {
        "Latin-1 Supplement": (n) => n >= 128 && n <= 255,
        "Hangul Jamo": (n) => n >= 4352 && n <= 4607,
        Khmer: (n) => n >= 6016 && n <= 6143,
        "General Punctuation": (n) => n >= 8192 && n <= 8303,
        "Letterlike Symbols": (n) => n >= 8448 && n <= 8527,
        "Number Forms": (n) => n >= 8528 && n <= 8591,
        "Miscellaneous Technical": (n) => n >= 8960 && n <= 9215,
        "Control Pictures": (n) => n >= 9216 && n <= 9279,
        "Optical Character Recognition": (n) => n >= 9280 && n <= 9311,
        "Enclosed Alphanumerics": (n) => n >= 9312 && n <= 9471,
        "Geometric Shapes": (n) => n >= 9632 && n <= 9727,
        "Miscellaneous Symbols": (n) => n >= 9728 && n <= 9983,
        "Miscellaneous Symbols and Arrows": (n) => n >= 11008 && n <= 11263,
        "Ideographic Description Characters": (n) => n >= 12272 && n <= 12287,
        "CJK Symbols and Punctuation": (n) => n >= 12288 && n <= 12351,
        Katakana: (n) => n >= 12448 && n <= 12543,
        Kanbun: (n) => n >= 12688 && n <= 12703,
        "CJK Strokes": (n) => n >= 12736 && n <= 12783,
        "Enclosed CJK Letters and Months": (n) => n >= 12800 && n <= 13055,
        "CJK Compatibility": (n) => n >= 13056 && n <= 13311,
        "Yijing Hexagram Symbols": (n) => n >= 19904 && n <= 19967,
        "Private Use Area": (n) => n >= 57344 && n <= 63743,
        "Vertical Forms": (n) => n >= 65040 && n <= 65055,
        "CJK Compatibility Forms": (n) => n >= 65072 && n <= 65103,
        "Small Form Variants": (n) => n >= 65104 && n <= 65135,
        "Halfwidth and Fullwidth Forms": (n) => n >= 65280 && n <= 65519,
      };
      function ho(n) {
        for (const t of n) if (qs(t.charCodeAt(0))) return !0;
        return !1;
      }
      function xu(n) {
        for (const t of n) if (!bu(t.charCodeAt(0))) return !1;
        return !0;
      }
      function Zs(n) {
        const t = n
          .map((r) => {
            try {
              return new RegExp(`\\p{sc=${r}}`, "u").source;
            } catch {
              return null;
            }
          })
          .filter((r) => r);
        return new RegExp(t.join("|"), "u");
      }
      const vu = Zs(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function bu(n) {
        return !vu.test(String.fromCodePoint(n));
      }
      const Gs = Zs([
        "Bopo",
        "Hani",
        "Hira",
        "Kana",
        "Kits",
        "Nshu",
        "Tang",
        "Yiii",
      ]);
      function qs(n) {
        return !(
          n !== 746 &&
          n !== 747 &&
          (n < 4352 ||
            !(
              (ht["CJK Compatibility Forms"](n) &&
                !(n >= 65097 && n <= 65103)) ||
              ht["CJK Compatibility"](n) ||
              ht["CJK Strokes"](n) ||
              !(
                !ht["CJK Symbols and Punctuation"](n) ||
                (n >= 12296 && n <= 12305) ||
                (n >= 12308 && n <= 12319) ||
                n === 12336
              ) ||
              ht["Enclosed CJK Letters and Months"](n) ||
              ht["Ideographic Description Characters"](n) ||
              ht.Kanbun(n) ||
              (ht.Katakana(n) && n !== 12540) ||
              !(
                !ht["Halfwidth and Fullwidth Forms"](n) ||
                n === 65288 ||
                n === 65289 ||
                n === 65293 ||
                (n >= 65306 && n <= 65310) ||
                n === 65339 ||
                n === 65341 ||
                n === 65343 ||
                (n >= 65371 && n <= 65503) ||
                n === 65507 ||
                (n >= 65512 && n <= 65519)
              ) ||
              !(
                !ht["Small Form Variants"](n) ||
                (n >= 65112 && n <= 65118) ||
                (n >= 65123 && n <= 65126)
              ) ||
              ht["Vertical Forms"](n) ||
              ht["Yijing Hexagram Symbols"](n) ||
              /\p{sc=Cans}/u.test(String.fromCodePoint(n)) ||
              /\p{sc=Hang}/u.test(String.fromCodePoint(n)) ||
              Gs.test(String.fromCodePoint(n))
            ))
        );
      }
      function wu(n) {
        return !(
          qs(n) ||
          (function (t) {
            return !!(
              (ht["Latin-1 Supplement"](t) &&
                (t === 167 ||
                  t === 169 ||
                  t === 174 ||
                  t === 177 ||
                  t === 188 ||
                  t === 189 ||
                  t === 190 ||
                  t === 215 ||
                  t === 247)) ||
              (ht["General Punctuation"](t) &&
                (t === 8214 ||
                  t === 8224 ||
                  t === 8225 ||
                  t === 8240 ||
                  t === 8241 ||
                  t === 8251 ||
                  t === 8252 ||
                  t === 8258 ||
                  t === 8263 ||
                  t === 8264 ||
                  t === 8265 ||
                  t === 8273)) ||
              ht["Letterlike Symbols"](t) ||
              ht["Number Forms"](t) ||
              (ht["Miscellaneous Technical"](t) &&
                ((t >= 8960 && t <= 8967) ||
                  (t >= 8972 && t <= 8991) ||
                  (t >= 8996 && t <= 9e3) ||
                  t === 9003 ||
                  (t >= 9085 && t <= 9114) ||
                  (t >= 9150 && t <= 9165) ||
                  t === 9167 ||
                  (t >= 9169 && t <= 9179) ||
                  (t >= 9186 && t <= 9215))) ||
              (ht["Control Pictures"](t) && t !== 9251) ||
              ht["Optical Character Recognition"](t) ||
              ht["Enclosed Alphanumerics"](t) ||
              ht["Geometric Shapes"](t) ||
              (ht["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759)) ||
              (ht["Miscellaneous Symbols and Arrows"](t) &&
                ((t >= 11026 && t <= 11055) ||
                  (t >= 11088 && t <= 11097) ||
                  (t >= 11192 && t <= 11243))) ||
              ht["CJK Symbols and Punctuation"](t) ||
              ht.Katakana(t) ||
              ht["Private Use Area"](t) ||
              ht["CJK Compatibility Forms"](t) ||
              ht["Small Form Variants"](t) ||
              ht["Halfwidth and Fullwidth Forms"](t) ||
              t === 8734 ||
              t === 8756 ||
              t === 8757 ||
              (t >= 9984 && t <= 10087) ||
              (t >= 10102 && t <= 10131) ||
              t === 65532 ||
              t === 65533
            );
          })(n)
        );
      }
      const Cu = Zs([
        "Adlm",
        "Arab",
        "Armi",
        "Avst",
        "Chrs",
        "Cprt",
        "Egyp",
        "Elym",
        "Gara",
        "Hatr",
        "Hebr",
        "Hung",
        "Khar",
        "Lydi",
        "Mand",
        "Mani",
        "Mend",
        "Merc",
        "Mero",
        "Narb",
        "Nbat",
        "Nkoo",
        "Orkh",
        "Palm",
        "Phli",
        "Phlp",
        "Phnx",
        "Prti",
        "Rohg",
        "Samr",
        "Sarb",
        "Sogo",
        "Syrc",
        "Thaa",
        "Todr",
        "Yezi",
      ]);
      function Eu(n) {
        return Cu.test(String.fromCodePoint(n));
      }
      function Au(n, t) {
        return !(
          (!t && Eu(n)) ||
          (n >= 2304 && n <= 3583) ||
          (n >= 3840 && n <= 4255) ||
          ht.Khmer(n)
        );
      }
      function Tu(n) {
        for (const t of n) if (Eu(t.charCodeAt(0))) return !0;
        return !1;
      }
      const Ur = new (class {
        constructor() {
          ((this.TIMEOUT = 5e3),
            (this.applyArabicShaping = null),
            (this.processBidirectionalText = null),
            (this.processStyledBidirectionalText = null),
            (this.pluginStatus = "unavailable"),
            (this.pluginURL = null),
            (this.loadScriptResolve = () => {}));
        }
        setState(n) {
          ((this.pluginStatus = n.pluginStatus),
            (this.pluginURL = n.pluginURL));
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(n) {
          if (Ur.isParsed())
            throw new Error("RTL text plugin already registered.");
          ((this.applyArabicShaping = n.applyArabicShaping),
            (this.processBidirectionalText = n.processBidirectionalText),
            (this.processStyledBidirectionalText =
              n.processStyledBidirectionalText),
            this.loadScriptResolve());
        }
        isParsed() {
          return (
            this.applyArabicShaping != null &&
            this.processBidirectionalText != null &&
            this.processStyledBidirectionalText != null
          );
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
        syncState(n, t) {
          return u(this, void 0, void 0, function* () {
            if (this.isParsed()) return this.getState();
            if (n.pluginStatus !== "loading") return (this.setState(n), n);
            const r = n.pluginURL,
              o = new Promise((d) => {
                this.loadScriptResolve = d;
              });
            t(r);
            const l = new Promise((d) => setTimeout(() => d(), this.TIMEOUT));
            if ((yield Promise.race([o, l]), this.isParsed())) {
              const d = { pluginStatus: "loaded", pluginURL: r };
              return (this.setState(d), d);
            }
            throw (
              this.setState({ pluginStatus: "error", pluginURL: "" }),
              new Error(`RTL Text Plugin failed to import scripts from ${r}`)
            );
          });
        }
      })();
      class jt {
        constructor(t, r) {
          ((this.zoom = t),
            r
              ? ((this.now = r.now),
                (this.fadeDuration = r.fadeDuration),
                (this.zoomHistory = r.zoomHistory),
                (this.transition = r.transition))
              : ((this.now = 0),
                (this.fadeDuration = 0),
                (this.zoomHistory = new yu()),
                (this.transition = {})));
        }
        isSupportedScript(t) {
          return (function (r, o) {
            for (const l of r) if (!Au(l.charCodeAt(0), o)) return !1;
            return !0;
          })(t, Ur.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0
            ? 1
            : Math.min(
                (this.now - this.zoomHistory.lastIntegerZoomTime) /
                  this.fadeDuration,
                1,
              );
        }
        getCrossfadeParameters() {
          const t = this.zoom,
            r = t - Math.floor(t),
            o = this.crossFadingFactor();
          return t > this.zoomHistory.lastIntegerZoom
            ? { fromScale: 2, toScale: 1, t: r + (1 - r) * o }
            : { fromScale: 0.5, toScale: 1, t: 1 - (1 - o) * r };
        }
      }
      class Hs {
        constructor(t, r) {
          ((this.property = t),
            (this.value = r),
            (this.expression = (function (o, l) {
              if (Is(o)) return new Rs(o, l);
              if (ks(o)) {
                const d = ru(o, l);
                if (d.result === "error")
                  throw new Error(
                    d.value.map((p) => `${p.key}: ${p.message}`).join(", "),
                  );
                return d.value;
              }
              {
                let d = o;
                return (
                  l.type === "color" && typeof o == "string"
                    ? (d = ct.parse(o))
                    : l.type !== "padding" ||
                        (typeof o != "number" && !Array.isArray(o))
                      ? l.type === "variableAnchorOffsetCollection" &&
                        Array.isArray(o)
                        ? (d = Ti.parse(o))
                        : l.type === "projectionDefinition" &&
                          typeof o == "string" &&
                          (d = xi.parse(o))
                      : (d = Zt.parse(o)),
                  { kind: "constant", evaluate: () => d }
                );
              }
            })(r === void 0 ? t.specification.default : r, t.specification)));
        }
        isDataDriven() {
          return (
            this.expression.kind === "source" ||
            this.expression.kind === "composite"
          );
        }
        possiblyEvaluate(t, r, o) {
          return this.property.possiblyEvaluate(this, t, r, o);
        }
      }
      class Xs {
        constructor(t) {
          ((this.property = t), (this.value = new Hs(t, void 0)));
        }
        transitioned(t, r) {
          return new Ka(
            this.property,
            this.value,
            r,
            yi({}, t.transition, this.transition),
            t.now,
          );
        }
        untransitioned() {
          return new Ka(this.property, this.value, null, {}, 0);
        }
      }
      class Wa {
        constructor(t) {
          ((this._properties = t),
            (this._values = Object.create(
              t.defaultTransitionablePropertyValues,
            )));
        }
        getValue(t) {
          return Yi(this._values[t].value.value);
        }
        setValue(t, r) {
          (Object.prototype.hasOwnProperty.call(this._values, t) ||
            (this._values[t] = new Xs(this._values[t].property)),
            (this._values[t].value = new Hs(
              this._values[t].property,
              r === null ? void 0 : Yi(r),
            )));
        }
        getTransition(t) {
          return Yi(this._values[t].transition);
        }
        setTransition(t, r) {
          (Object.prototype.hasOwnProperty.call(this._values, t) ||
            (this._values[t] = new Xs(this._values[t].property)),
            (this._values[t].transition = Yi(r) || void 0));
        }
        serialize() {
          const t = {};
          for (const r of Object.keys(this._values)) {
            const o = this.getValue(r);
            o !== void 0 && (t[r] = o);
            const l = this.getTransition(r);
            l !== void 0 && (t[`${r}-transition`] = l);
          }
          return t;
        }
        transitioned(t, r) {
          const o = new Ya(this._properties);
          for (const l of Object.keys(this._values))
            o._values[l] = this._values[l].transitioned(t, r._values[l]);
          return o;
        }
        untransitioned() {
          const t = new Ya(this._properties);
          for (const r of Object.keys(this._values))
            t._values[r] = this._values[r].untransitioned();
          return t;
        }
      }
      class Ka {
        constructor(t, r, o, l, d) {
          ((this.property = t),
            (this.value = r),
            (this.begin = d + l.delay || 0),
            (this.end = this.begin + l.duration || 0),
            t.specification.transition &&
              (l.delay || l.duration) &&
              (this.prior = o));
        }
        possiblyEvaluate(t, r, o) {
          const l = t.now || 0,
            d = this.value.possiblyEvaluate(t, r, o),
            p = this.prior;
          if (p) {
            if (l > this.end) return ((this.prior = null), d);
            if (this.value.isDataDriven()) return ((this.prior = null), d);
            if (l < this.begin) return p.possiblyEvaluate(t, r, o);
            {
              const m = (l - this.begin) / (this.end - this.begin);
              return this.property.interpolate(
                p.possiblyEvaluate(t, r, o),
                d,
                $t(m),
              );
            }
          }
          return d;
        }
      }
      class Ya {
        constructor(t) {
          ((this._properties = t),
            (this._values = Object.create(
              t.defaultTransitioningPropertyValues,
            )));
        }
        possiblyEvaluate(t, r, o) {
          const l = new po(this._properties);
          for (const d of Object.keys(this._values))
            l._values[d] = this._values[d].possiblyEvaluate(t, r, o);
          return l;
        }
        hasTransition() {
          for (const t of Object.keys(this._values))
            if (this._values[t].prior) return !0;
          return !1;
        }
      }
      class Ws {
        constructor(t) {
          ((this._properties = t),
            (this._values = Object.create(t.defaultPropertyValues)));
        }
        hasValue(t) {
          return this._values[t].value !== void 0;
        }
        getValue(t) {
          return Yi(this._values[t].value);
        }
        setValue(t, r) {
          this._values[t] = new Hs(
            this._values[t].property,
            r === null ? void 0 : Yi(r),
          );
        }
        serialize() {
          const t = {};
          for (const r of Object.keys(this._values)) {
            const o = this.getValue(r);
            o !== void 0 && (t[r] = o);
          }
          return t;
        }
        possiblyEvaluate(t, r, o) {
          const l = new po(this._properties);
          for (const d of Object.keys(this._values))
            l._values[d] = this._values[d].possiblyEvaluate(t, r, o);
          return l;
        }
      }
      class Dr {
        constructor(t, r, o) {
          ((this.property = t), (this.value = r), (this.parameters = o));
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(t) {
          return this.value.kind === "constant" ? this.value.value : t;
        }
        evaluate(t, r, o, l) {
          return this.property.evaluate(
            this.value,
            this.parameters,
            t,
            r,
            o,
            l,
          );
        }
      }
      class po {
        constructor(t) {
          ((this._properties = t),
            (this._values = Object.create(t.defaultPossiblyEvaluatedValues)));
        }
        get(t) {
          return this._values[t];
        }
      }
      class He {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, r) {
          if (t.isDataDriven())
            throw new Error("Value should not be data driven");
          return t.expression.evaluate(r);
        }
        interpolate(t, r, o) {
          const l = Pr[this.specification.type];
          return l ? l(t, r, o) : t;
        }
      }
      class et {
        constructor(t, r) {
          ((this.specification = t), (this.overrides = r));
        }
        possiblyEvaluate(t, r, o, l) {
          return new Dr(
            this,
            t.expression.kind === "constant" || t.expression.kind === "camera"
              ? {
                  kind: "constant",
                  value: t.expression.evaluate(r, null, {}, o, l),
                }
              : t.expression,
            r,
          );
        }
        interpolate(t, r, o) {
          if (t.value.kind !== "constant" || r.value.kind !== "constant")
            return t;
          if (t.value.value === void 0 || r.value.value === void 0)
            return new Dr(
              this,
              { kind: "constant", value: void 0 },
              t.parameters,
            );
          const l = Pr[this.specification.type];
          if (l) {
            const d = l(t.value.value, r.value.value, o);
            return new Dr(this, { kind: "constant", value: d }, t.parameters);
          }
          return t;
        }
        evaluate(t, r, o, l, d, p) {
          return t.kind === "constant" ? t.value : t.evaluate(r, o, l, d, p);
        }
      }
      class $o extends et {
        possiblyEvaluate(t, r, o, l) {
          if (t.value === void 0)
            return new Dr(this, { kind: "constant", value: void 0 }, r);
          if (t.expression.kind === "constant") {
            const d = t.expression.evaluate(r, null, {}, o, l),
              p =
                t.property.specification.type === "resolvedImage" &&
                typeof d != "string"
                  ? d.name
                  : d,
              m = this._calculate(p, p, p, r);
            return new Dr(this, { kind: "constant", value: m }, r);
          }
          if (t.expression.kind === "camera") {
            const d = this._calculate(
              t.expression.evaluate({ zoom: r.zoom - 1 }),
              t.expression.evaluate({ zoom: r.zoom }),
              t.expression.evaluate({ zoom: r.zoom + 1 }),
              r,
            );
            return new Dr(this, { kind: "constant", value: d }, r);
          }
          return new Dr(this, t.expression, r);
        }
        evaluate(t, r, o, l, d, p) {
          if (t.kind === "source") {
            const m = t.evaluate(r, o, l, d, p);
            return this._calculate(m, m, m, r);
          }
          return t.kind === "composite"
            ? this._calculate(
                t.evaluate({ zoom: Math.floor(r.zoom) - 1 }, o, l),
                t.evaluate({ zoom: Math.floor(r.zoom) }, o, l),
                t.evaluate({ zoom: Math.floor(r.zoom) + 1 }, o, l),
                r,
              )
            : t.value;
        }
        _calculate(t, r, o, l) {
          return l.zoom > l.zoomHistory.lastIntegerZoom
            ? { from: t, to: r }
            : { from: o, to: r };
        }
        interpolate(t) {
          return t;
        }
      }
      class Ks {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, r, o, l) {
          if (t.value !== void 0) {
            if (t.expression.kind === "constant") {
              const d = t.expression.evaluate(r, null, {}, o, l);
              return this._calculate(d, d, d, r);
            }
            return this._calculate(
              t.expression.evaluate(new jt(Math.floor(r.zoom - 1), r)),
              t.expression.evaluate(new jt(Math.floor(r.zoom), r)),
              t.expression.evaluate(new jt(Math.floor(r.zoom + 1), r)),
              r,
            );
          }
        }
        _calculate(t, r, o, l) {
          return l.zoom > l.zoomHistory.lastIntegerZoom
            ? { from: t, to: r }
            : { from: o, to: r };
        }
        interpolate(t) {
          return t;
        }
      }
      class Ys {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, r, o, l) {
          return !!t.expression.evaluate(r, null, {}, o, l);
        }
        interpolate() {
          return !1;
        }
      }
      class $i {
        constructor(t) {
          ((this.properties = t),
            (this.defaultPropertyValues = {}),
            (this.defaultTransitionablePropertyValues = {}),
            (this.defaultTransitioningPropertyValues = {}),
            (this.defaultPossiblyEvaluatedValues = {}),
            (this.overridableProperties = []));
          for (const r in t) {
            const o = t[r];
            o.specification.overridable && this.overridableProperties.push(r);
            const l = (this.defaultPropertyValues[r] = new Hs(o, void 0)),
              d = (this.defaultTransitionablePropertyValues[r] = new Xs(o));
            ((this.defaultTransitioningPropertyValues[r] = d.untransitioned()),
              (this.defaultPossiblyEvaluatedValues[r] = l.possiblyEvaluate(
                {},
              )));
          }
        }
      }
      (Re("DataDrivenProperty", et),
        Re("DataConstantProperty", He),
        Re("CrossFadedDataDrivenProperty", $o),
        Re("CrossFadedProperty", Ks),
        Re("ColorRampProperty", Ys));
      const Fu = "-transition";
      class Mr extends Qr {
        constructor(t, r) {
          if (
            (super(),
            (this.id = t.id),
            (this.type = t.type),
            (this._featureFilter = { filter: () => !0, needGeometry: !1 }),
            t.type !== "custom" &&
              ((this.metadata = t.metadata),
              (this.minzoom = t.minzoom),
              (this.maxzoom = t.maxzoom),
              t.type !== "background" &&
                ((this.source = t.source),
                (this.sourceLayer = t["source-layer"]),
                (this.filter = t.filter)),
              r.layout && (this._unevaluatedLayout = new Ws(r.layout)),
              r.paint))
          ) {
            this._transitionablePaint = new Wa(r.paint);
            for (const o in t.paint)
              this.setPaintProperty(o, t.paint[o], { validate: !1 });
            for (const o in t.layout)
              this.setLayoutProperty(o, t.layout[o], { validate: !1 });
            ((this._transitioningPaint =
              this._transitionablePaint.untransitioned()),
              (this.paint = new po(r.paint)));
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(t) {
          return t === "visibility"
            ? this.visibility
            : this._unevaluatedLayout.getValue(t);
        }
        setLayoutProperty(t, r, o = {}) {
          (r != null &&
            this._validate(Xa, `layers.${this.id}.layout.${t}`, t, r, o)) ||
            (t !== "visibility"
              ? this._unevaluatedLayout.setValue(t, r)
              : (this.visibility = r));
        }
        getPaintProperty(t) {
          return t.endsWith(Fu)
            ? this._transitionablePaint.getTransition(t.slice(0, -11))
            : this._transitionablePaint.getValue(t);
        }
        setPaintProperty(t, r, o = {}) {
          if (
            r != null &&
            this._validate(fu, `layers.${this.id}.paint.${t}`, t, r, o)
          )
            return !1;
          if (t.endsWith(Fu))
            return (
              this._transitionablePaint.setTransition(
                t.slice(0, -11),
                r || void 0,
              ),
              !1
            );
          {
            const l = this._transitionablePaint._values[t],
              d =
                l.property.specification["property-type"] ===
                "cross-faded-data-driven",
              p = l.value.isDataDriven(),
              m = l.value;
            (this._transitionablePaint.setValue(t, r),
              this._handleSpecialPaintPropertyUpdate(t));
            const _ = this._transitionablePaint._values[t].value;
            return (
              _.isDataDriven() ||
              p ||
              d ||
              this._handleOverridablePaintPropertyUpdate(t, m, _)
            );
          }
        }
        _handleSpecialPaintPropertyUpdate(t) {}
        _handleOverridablePaintPropertyUpdate(t, r, o) {
          return !1;
        }
        isHidden(t) {
          return (
            !!(this.minzoom && t < this.minzoom) ||
            !!(this.maxzoom && t >= this.maxzoom) ||
            this.visibility === "none"
          );
        }
        updateTransitions(t) {
          this._transitioningPaint = this._transitionablePaint.transitioned(
            t,
            this._transitioningPaint,
          );
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t, r) {
          (t.getCrossfadeParameters &&
            (this._crossfadeParameters = t.getCrossfadeParameters()),
            this._unevaluatedLayout &&
              (this.layout = this._unevaluatedLayout.possiblyEvaluate(
                t,
                void 0,
                r,
              )),
            (this.paint = this._transitioningPaint.possiblyEvaluate(
              t,
              void 0,
              r,
            )));
        }
        serialize() {
          const t = {
            id: this.id,
            type: this.type,
            source: this.source,
            "source-layer": this.sourceLayer,
            metadata: this.metadata,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            filter: this.filter,
            layout:
              this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
            paint:
              this._transitionablePaint &&
              this._transitionablePaint.serialize(),
          };
          return (
            this.visibility &&
              ((t.layout = t.layout || {}),
              (t.layout.visibility = this.visibility)),
            mn(
              t,
              (r, o) =>
                !(
                  r === void 0 ||
                  (o === "layout" && !Object.keys(r).length) ||
                  (o === "paint" && !Object.keys(r).length)
                ),
            )
          );
        }
        _validate(t, r, o, l, d = {}) {
          return (
            (!d || d.validate !== !1) &&
            mu(
              this,
              t.call(co, {
                key: r,
                layerType: this.type,
                objectKey: o,
                value: l,
                styleSpec: j,
                style: { glyphs: !0, sprite: !0 },
              }),
            )
          );
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {}
        isStateDependent() {
          for (const t in this.paint._values) {
            const r = this.paint.get(t);
            if (
              r instanceof Dr &&
              ro(r.property.specification) &&
              (r.value.kind === "source" || r.value.kind === "composite") &&
              r.value.isStateDependent
            )
              return !0;
          }
          return !1;
        }
      }
      const gc = {
        Int8: Int8Array,
        Uint8: Uint8Array,
        Int16: Int16Array,
        Uint16: Uint16Array,
        Int32: Int32Array,
        Uint32: Uint32Array,
        Float32: Float32Array,
      };
      class Zo {
        constructor(t, r) {
          ((this._structArray = t),
            (this._pos1 = r * this.size),
            (this._pos2 = this._pos1 / 2),
            (this._pos4 = this._pos1 / 4),
            (this._pos8 = this._pos1 / 8));
        }
      }
      class Mt {
        constructor() {
          ((this.isTransferred = !1), (this.capacity = -1), this.resize(0));
        }
        static serialize(t, r) {
          return (
            t._trim(),
            r && ((t.isTransferred = !0), r.push(t.arrayBuffer)),
            { length: t.length, arrayBuffer: t.arrayBuffer }
          );
        }
        static deserialize(t) {
          const r = Object.create(this.prototype);
          return (
            (r.arrayBuffer = t.arrayBuffer),
            (r.length = t.length),
            (r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement),
            r._refreshViews(),
            r
          );
        }
        _trim() {
          this.length !== this.capacity &&
            ((this.capacity = this.length),
            (this.arrayBuffer = this.arrayBuffer.slice(
              0,
              this.length * this.bytesPerElement,
            )),
            this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t) {
          (this.reserve(t), (this.length = t));
        }
        reserve(t) {
          if (t > this.capacity) {
            ((this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128)),
              (this.arrayBuffer = new ArrayBuffer(
                this.capacity * this.bytesPerElement,
              )));
            const r = this.uint8;
            (this._refreshViews(), r && this.uint8.set(r));
          }
        }
        _refreshViews() {
          throw new Error(
            "_refreshViews() must be implemented by each concrete StructArray layout",
          );
        }
      }
      function ii(n, t = 1) {
        let r = 0,
          o = 0;
        return {
          members: n.map((l) => {
            const d = gc[l.type].BYTES_PER_ELEMENT,
              p = (r = Pu(r, Math.max(t, d))),
              m = l.components || 1;
            return (
              (o = Math.max(o, d)),
              (r += d * m),
              { name: l.name, type: l.type, components: m, offset: p }
            );
          }),
          size: Pu(r, Math.max(o, t)),
          alignment: t,
        };
      }
      function Pu(n, t) {
        return Math.ceil(n / t) * t;
      }
      class Go extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r) {
          const o = this.length;
          return (this.resize(o + 1), this.emplace(o, t, r));
        }
        emplace(t, r, o) {
          const l = 2 * t;
          return ((this.int16[l + 0] = r), (this.int16[l + 1] = o), t);
        }
      }
      ((Go.prototype.bytesPerElement = 4), Re("StructArrayLayout2i4", Go));
      class qo extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o) {
          const l = this.length;
          return (this.resize(l + 1), this.emplace(l, t, r, o));
        }
        emplace(t, r, o, l) {
          const d = 3 * t;
          return (
            (this.int16[d + 0] = r),
            (this.int16[d + 1] = o),
            (this.int16[d + 2] = l),
            t
          );
        }
      }
      ((qo.prototype.bytesPerElement = 6), Re("StructArrayLayout3i6", qo));
      class Ja extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o, l) {
          const d = this.length;
          return (this.resize(d + 1), this.emplace(d, t, r, o, l));
        }
        emplace(t, r, o, l, d) {
          const p = 4 * t;
          return (
            (this.int16[p + 0] = r),
            (this.int16[p + 1] = o),
            (this.int16[p + 2] = l),
            (this.int16[p + 3] = d),
            t
          );
        }
      }
      ((Ja.prototype.bytesPerElement = 8), Re("StructArrayLayout4i8", Ja));
      class Qa extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o, l, d, p) {
          const m = this.length;
          return (this.resize(m + 1), this.emplace(m, t, r, o, l, d, p));
        }
        emplace(t, r, o, l, d, p, m) {
          const _ = 6 * t;
          return (
            (this.int16[_ + 0] = r),
            (this.int16[_ + 1] = o),
            (this.int16[_ + 2] = l),
            (this.int16[_ + 3] = d),
            (this.int16[_ + 4] = p),
            (this.int16[_ + 5] = m),
            t
          );
        }
      }
      ((Qa.prototype.bytesPerElement = 12), Re("StructArrayLayout2i4i12", Qa));
      class $r extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o, l, d, p) {
          const m = this.length;
          return (this.resize(m + 1), this.emplace(m, t, r, o, l, d, p));
        }
        emplace(t, r, o, l, d, p, m) {
          const _ = 4 * t,
            x = 8 * t;
          return (
            (this.int16[_ + 0] = r),
            (this.int16[_ + 1] = o),
            (this.uint8[x + 4] = l),
            (this.uint8[x + 5] = d),
            (this.uint8[x + 6] = p),
            (this.uint8[x + 7] = m),
            t
          );
        }
      }
      (($r.prototype.bytesPerElement = 8), Re("StructArrayLayout2i4ub8", $r));
      class fo extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer)));
        }
        emplaceBack(t, r) {
          const o = this.length;
          return (this.resize(o + 1), this.emplace(o, t, r));
        }
        emplace(t, r, o) {
          const l = 2 * t;
          return ((this.float32[l + 0] = r), (this.float32[l + 1] = o), t);
        }
      }
      ((fo.prototype.bytesPerElement = 8), Re("StructArrayLayout2f8", fo));
      class Ho extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o, l, d, p, m, _, x, b) {
          const w = this.length;
          return (
            this.resize(w + 1),
            this.emplace(w, t, r, o, l, d, p, m, _, x, b)
          );
        }
        emplace(t, r, o, l, d, p, m, _, x, b, w) {
          const F = 10 * t;
          return (
            (this.uint16[F + 0] = r),
            (this.uint16[F + 1] = o),
            (this.uint16[F + 2] = l),
            (this.uint16[F + 3] = d),
            (this.uint16[F + 4] = p),
            (this.uint16[F + 5] = m),
            (this.uint16[F + 6] = _),
            (this.uint16[F + 7] = x),
            (this.uint16[F + 8] = b),
            (this.uint16[F + 9] = w),
            t
          );
        }
      }
      ((Ho.prototype.bytesPerElement = 20), Re("StructArrayLayout10ui20", Ho));
      class Js extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o, l, d, p, m, _, x, b, w, F) {
          const S = this.length;
          return (
            this.resize(S + 1),
            this.emplace(S, t, r, o, l, d, p, m, _, x, b, w, F)
          );
        }
        emplace(t, r, o, l, d, p, m, _, x, b, w, F, S) {
          const D = 12 * t;
          return (
            (this.int16[D + 0] = r),
            (this.int16[D + 1] = o),
            (this.int16[D + 2] = l),
            (this.int16[D + 3] = d),
            (this.uint16[D + 4] = p),
            (this.uint16[D + 5] = m),
            (this.uint16[D + 6] = _),
            (this.uint16[D + 7] = x),
            (this.int16[D + 8] = b),
            (this.int16[D + 9] = w),
            (this.int16[D + 10] = F),
            (this.int16[D + 11] = S),
            t
          );
        }
      }
      ((Js.prototype.bytesPerElement = 24),
        Re("StructArrayLayout4i4ui4i24", Js));
      class Xo extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o) {
          const l = this.length;
          return (this.resize(l + 1), this.emplace(l, t, r, o));
        }
        emplace(t, r, o, l) {
          const d = 3 * t;
          return (
            (this.float32[d + 0] = r),
            (this.float32[d + 1] = o),
            (this.float32[d + 2] = l),
            t
          );
        }
      }
      ((Xo.prototype.bytesPerElement = 12), Re("StructArrayLayout3f12", Xo));
      class el extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint32 = new Uint32Array(this.arrayBuffer)));
        }
        emplaceBack(t) {
          const r = this.length;
          return (this.resize(r + 1), this.emplace(r, t));
        }
        emplace(t, r) {
          return ((this.uint32[1 * t + 0] = r), t);
        }
      }
      ((el.prototype.bytesPerElement = 4), Re("StructArrayLayout1ul4", el));
      class mo extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)),
            (this.uint32 = new Uint32Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o, l, d, p, m, _, x) {
          const b = this.length;
          return (
            this.resize(b + 1),
            this.emplace(b, t, r, o, l, d, p, m, _, x)
          );
        }
        emplace(t, r, o, l, d, p, m, _, x, b) {
          const w = 10 * t,
            F = 5 * t;
          return (
            (this.int16[w + 0] = r),
            (this.int16[w + 1] = o),
            (this.int16[w + 2] = l),
            (this.int16[w + 3] = d),
            (this.int16[w + 4] = p),
            (this.int16[w + 5] = m),
            (this.uint32[F + 3] = _),
            (this.uint16[w + 8] = x),
            (this.uint16[w + 9] = b),
            t
          );
        }
      }
      ((mo.prototype.bytesPerElement = 20),
        Re("StructArrayLayout6i1ul2ui20", mo));
      class jn extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o, l, d, p) {
          const m = this.length;
          return (this.resize(m + 1), this.emplace(m, t, r, o, l, d, p));
        }
        emplace(t, r, o, l, d, p, m) {
          const _ = 6 * t;
          return (
            (this.int16[_ + 0] = r),
            (this.int16[_ + 1] = o),
            (this.int16[_ + 2] = l),
            (this.int16[_ + 3] = d),
            (this.int16[_ + 4] = p),
            (this.int16[_ + 5] = m),
            t
          );
        }
      }
      ((jn.prototype.bytesPerElement = 12),
        Re("StructArrayLayout2i2i2i12", jn));
      class tl extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o, l, d) {
          const p = this.length;
          return (this.resize(p + 1), this.emplace(p, t, r, o, l, d));
        }
        emplace(t, r, o, l, d, p) {
          const m = 4 * t,
            _ = 8 * t;
          return (
            (this.float32[m + 0] = r),
            (this.float32[m + 1] = o),
            (this.float32[m + 2] = l),
            (this.int16[_ + 6] = d),
            (this.int16[_ + 7] = p),
            t
          );
        }
      }
      ((tl.prototype.bytesPerElement = 16),
        Re("StructArrayLayout2f1f2i16", tl));
      class Qs extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o, l, d, p) {
          const m = this.length;
          return (this.resize(m + 1), this.emplace(m, t, r, o, l, d, p));
        }
        emplace(t, r, o, l, d, p, m) {
          const _ = 16 * t,
            x = 4 * t,
            b = 8 * t;
          return (
            (this.uint8[_ + 0] = r),
            (this.uint8[_ + 1] = o),
            (this.float32[x + 1] = l),
            (this.float32[x + 2] = d),
            (this.int16[b + 6] = p),
            (this.int16[b + 7] = m),
            t
          );
        }
      }
      ((Qs.prototype.bytesPerElement = 16),
        Re("StructArrayLayout2ub2f2i16", Qs));
      class sn extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o) {
          const l = this.length;
          return (this.resize(l + 1), this.emplace(l, t, r, o));
        }
        emplace(t, r, o, l) {
          const d = 3 * t;
          return (
            (this.uint16[d + 0] = r),
            (this.uint16[d + 1] = o),
            (this.uint16[d + 2] = l),
            t
          );
        }
      }
      ((sn.prototype.bytesPerElement = 6), Re("StructArrayLayout3ui6", sn));
      class il extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)),
            (this.uint32 = new Uint32Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o, l, d, p, m, _, x, b, w, F, S, D, I, O, Z) {
          const ne = this.length;
          return (
            this.resize(ne + 1),
            this.emplace(ne, t, r, o, l, d, p, m, _, x, b, w, F, S, D, I, O, Z)
          );
        }
        emplace(t, r, o, l, d, p, m, _, x, b, w, F, S, D, I, O, Z, ne) {
          const H = 24 * t,
            P = 12 * t,
            R = 48 * t;
          return (
            (this.int16[H + 0] = r),
            (this.int16[H + 1] = o),
            (this.uint16[H + 2] = l),
            (this.uint16[H + 3] = d),
            (this.uint32[P + 2] = p),
            (this.uint32[P + 3] = m),
            (this.uint32[P + 4] = _),
            (this.uint16[H + 10] = x),
            (this.uint16[H + 11] = b),
            (this.uint16[H + 12] = w),
            (this.float32[P + 7] = F),
            (this.float32[P + 8] = S),
            (this.uint8[R + 36] = D),
            (this.uint8[R + 37] = I),
            (this.uint8[R + 38] = O),
            (this.uint32[P + 10] = Z),
            (this.int16[H + 22] = ne),
            t
          );
        }
      }
      ((il.prototype.bytesPerElement = 48),
        Re("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", il));
      class rl extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)),
            (this.uint32 = new Uint32Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer)));
        }
        emplaceBack(
          t,
          r,
          o,
          l,
          d,
          p,
          m,
          _,
          x,
          b,
          w,
          F,
          S,
          D,
          I,
          O,
          Z,
          ne,
          H,
          P,
          R,
          W,
          de,
          Te,
          ge,
          xe,
          Se,
          Pe,
        ) {
          const De = this.length;
          return (
            this.resize(De + 1),
            this.emplace(
              De,
              t,
              r,
              o,
              l,
              d,
              p,
              m,
              _,
              x,
              b,
              w,
              F,
              S,
              D,
              I,
              O,
              Z,
              ne,
              H,
              P,
              R,
              W,
              de,
              Te,
              ge,
              xe,
              Se,
              Pe,
            )
          );
        }
        emplace(
          t,
          r,
          o,
          l,
          d,
          p,
          m,
          _,
          x,
          b,
          w,
          F,
          S,
          D,
          I,
          O,
          Z,
          ne,
          H,
          P,
          R,
          W,
          de,
          Te,
          ge,
          xe,
          Se,
          Pe,
          De,
        ) {
          const we = 32 * t,
            Ne = 16 * t;
          return (
            (this.int16[we + 0] = r),
            (this.int16[we + 1] = o),
            (this.int16[we + 2] = l),
            (this.int16[we + 3] = d),
            (this.int16[we + 4] = p),
            (this.int16[we + 5] = m),
            (this.int16[we + 6] = _),
            (this.int16[we + 7] = x),
            (this.uint16[we + 8] = b),
            (this.uint16[we + 9] = w),
            (this.uint16[we + 10] = F),
            (this.uint16[we + 11] = S),
            (this.uint16[we + 12] = D),
            (this.uint16[we + 13] = I),
            (this.uint16[we + 14] = O),
            (this.uint16[we + 15] = Z),
            (this.uint16[we + 16] = ne),
            (this.uint16[we + 17] = H),
            (this.uint16[we + 18] = P),
            (this.uint16[we + 19] = R),
            (this.uint16[we + 20] = W),
            (this.uint16[we + 21] = de),
            (this.uint16[we + 22] = Te),
            (this.uint32[Ne + 12] = ge),
            (this.float32[Ne + 13] = xe),
            (this.float32[Ne + 14] = Se),
            (this.uint16[we + 30] = Pe),
            (this.uint16[we + 31] = De),
            t
          );
        }
      }
      ((rl.prototype.bytesPerElement = 64),
        Re("StructArrayLayout8i15ui1ul2f2ui64", rl));
      class Wo extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer)));
        }
        emplaceBack(t) {
          const r = this.length;
          return (this.resize(r + 1), this.emplace(r, t));
        }
        emplace(t, r) {
          return ((this.float32[1 * t + 0] = r), t);
        }
      }
      ((Wo.prototype.bytesPerElement = 4), Re("StructArrayLayout1f4", Wo));
      class nl extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o) {
          const l = this.length;
          return (this.resize(l + 1), this.emplace(l, t, r, o));
        }
        emplace(t, r, o, l) {
          const d = 3 * t;
          return (
            (this.uint16[6 * t + 0] = r),
            (this.float32[d + 1] = o),
            (this.float32[d + 2] = l),
            t
          );
        }
      }
      ((nl.prototype.bytesPerElement = 12), Re("StructArrayLayout1ui2f12", nl));
      class c extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint32 = new Uint32Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o) {
          const l = this.length;
          return (this.resize(l + 1), this.emplace(l, t, r, o));
        }
        emplace(t, r, o, l) {
          const d = 4 * t;
          return (
            (this.uint32[2 * t + 0] = r),
            (this.uint16[d + 2] = o),
            (this.uint16[d + 3] = l),
            t
          );
        }
      }
      ((c.prototype.bytesPerElement = 8), Re("StructArrayLayout1ul2ui8", c));
      class e extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)));
        }
        emplaceBack(t, r) {
          const o = this.length;
          return (this.resize(o + 1), this.emplace(o, t, r));
        }
        emplace(t, r, o) {
          const l = 2 * t;
          return ((this.uint16[l + 0] = r), (this.uint16[l + 1] = o), t);
        }
      }
      ((e.prototype.bytesPerElement = 4), Re("StructArrayLayout2ui4", e));
      class i extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)));
        }
        emplaceBack(t) {
          const r = this.length;
          return (this.resize(r + 1), this.emplace(r, t));
        }
        emplace(t, r) {
          return ((this.uint16[1 * t + 0] = r), t);
        }
      }
      ((i.prototype.bytesPerElement = 2), Re("StructArrayLayout1ui2", i));
      class s extends Mt {
        _refreshViews() {
          ((this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer)));
        }
        emplaceBack(t, r, o, l) {
          const d = this.length;
          return (this.resize(d + 1), this.emplace(d, t, r, o, l));
        }
        emplace(t, r, o, l, d) {
          const p = 4 * t;
          return (
            (this.float32[p + 0] = r),
            (this.float32[p + 1] = o),
            (this.float32[p + 2] = l),
            (this.float32[p + 3] = d),
            t
          );
        }
      }
      ((s.prototype.bytesPerElement = 16), Re("StructArrayLayout4f16", s));
      class a extends Zo {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new Ze(this.anchorPointX, this.anchorPointY);
        }
      }
      a.prototype.size = 20;
      class h extends mo {
        get(t) {
          return new a(this, t);
        }
      }
      Re("CollisionBoxArray", h);
      class f extends Zo {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(t) {
          this._structArray.uint8[this._pos1 + 37] = t;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(t) {
          this._structArray.uint8[this._pos1 + 38] = t;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 10] = t;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      f.prototype.size = 48;
      class g extends il {
        get(t) {
          return new f(this, t);
        }
      }
      Re("PlacedSymbolArray", g);
      class y extends Zo {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 12] = t;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      y.prototype.size = 64;
      class v extends rl {
        get(t) {
          return new y(this, t);
        }
      }
      Re("SymbolInstanceArray", v);
      class C extends Wo {
        getoffsetX(t) {
          return this.float32[1 * t + 0];
        }
      }
      Re("GlyphOffsetArray", C);
      class A extends qo {
        getx(t) {
          return this.int16[3 * t + 0];
        }
        gety(t) {
          return this.int16[3 * t + 1];
        }
        gettileUnitDistanceFromAnchor(t) {
          return this.int16[3 * t + 2];
        }
      }
      Re("SymbolLineVertexArray", A);
      class T extends Zo {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      T.prototype.size = 12;
      class M extends nl {
        get(t) {
          return new T(this, t);
        }
      }
      Re("TextAnchorOffsetArray", M);
      class k extends Zo {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      k.prototype.size = 8;
      class V extends c {
        get(t) {
          return new k(this, t);
        }
      }
      Re("FeatureIndexArray", V);
      class N extends Go {}
      class $ extends Go {}
      class G extends Go {}
      class Y extends Qa {}
      class Q extends $r {}
      class ee extends fo {}
      class re extends Ho {}
      class ie extends Js {}
      class he extends Xo {}
      class pe extends el {}
      class be extends jn {}
      class Ee extends Qs {}
      class ye extends sn {}
      class Be extends e {}
      const Me = ii([{ name: "a_pos", components: 2, type: "Int16" }], 4),
        { members: Fe } = Me;
      class Le {
        constructor(t = []) {
          ((this._forceNewSegmentOnNextPrepare = !1), (this.segments = t));
        }
        prepareSegment(t, r, o, l) {
          const d = this.segments[this.segments.length - 1];
          return (
            t > Le.MAX_VERTEX_ARRAY_LENGTH &&
              Ai(
                `Max vertices per segment is ${Le.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Le.MAX_VERTEX_ARRAY_LENGTH} vertices.`,
              ),
            this._forceNewSegmentOnNextPrepare ||
            !d ||
            d.vertexLength + t > Le.MAX_VERTEX_ARRAY_LENGTH ||
            d.sortKey !== l
              ? this.createNewSegment(r, o, l)
              : d
          );
        }
        createNewSegment(t, r, o) {
          const l = {
            vertexOffset: t.length,
            primitiveOffset: r.length,
            vertexLength: 0,
            primitiveLength: 0,
            vaos: {},
          };
          return (
            o !== void 0 && (l.sortKey = o),
            (this._forceNewSegmentOnNextPrepare = !1),
            this.segments.push(l),
            l
          );
        }
        getOrCreateLatestSegment(t, r, o) {
          return this.prepareSegment(0, t, r, o);
        }
        forceNewSegmentOnNextPrepare() {
          this._forceNewSegmentOnNextPrepare = !0;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t of this.segments)
            for (const r in t.vaos) t.vaos[r].destroy();
        }
        static simpleSegment(t, r, o, l) {
          return new Le([
            {
              vertexOffset: t,
              primitiveOffset: r,
              vertexLength: o,
              primitiveLength: l,
              vaos: {},
              sortKey: 0,
            },
          ]);
        }
      }
      function st(n, t) {
        return (
          256 * (n = Bi(Math.floor(n), 0, 255)) + Bi(Math.floor(t), 0, 255)
        );
      }
      ((Le.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1),
        Re("SegmentVector", Le));
      const gt = ii([
        { name: "a_pattern_from", components: 4, type: "Uint16" },
        { name: "a_pattern_to", components: 4, type: "Uint16" },
        { name: "a_pixel_ratio_from", components: 1, type: "Uint16" },
        { name: "a_pixel_ratio_to", components: 1, type: "Uint16" },
      ]);
      var Nt,
        Tt,
        Vt,
        Ft = { exports: {} },
        At = { exports: {} },
        Pt = { exports: {} },
        vi = (function () {
          if (Vt) return Ft.exports;
          Vt = 1;
          var n =
              (Nt ||
                ((Nt = 1),
                (At.exports = function (r, o) {
                  var l, d, p, m, _, x, b, w;
                  for (
                    d = r.length - (l = 3 & r.length),
                      p = o,
                      _ = 3432918353,
                      x = 461845907,
                      w = 0;
                    w < d;

                  )
                    ((b =
                      (255 & r.charCodeAt(w)) |
                      ((255 & r.charCodeAt(++w)) << 8) |
                      ((255 & r.charCodeAt(++w)) << 16) |
                      ((255 & r.charCodeAt(++w)) << 24)),
                      ++w,
                      (p =
                        27492 +
                        (65535 &
                          (m =
                            (5 *
                              (65535 &
                                (p =
                                  ((p ^= b =
                                    ((65535 &
                                      (b =
                                        ((b =
                                          ((65535 & b) * _ +
                                            ((((b >>> 16) * _) & 65535) <<
                                              16)) &
                                          4294967295) <<
                                          15) |
                                        (b >>> 17))) *
                                      x +
                                      ((((b >>> 16) * x) & 65535) << 16)) &
                                    4294967295) <<
                                    13) |
                                  (p >>> 19))) +
                              (((5 * (p >>> 16)) & 65535) << 16)) &
                            4294967295)) +
                        (((58964 + (m >>> 16)) & 65535) << 16)));
                  switch (((b = 0), l)) {
                    case 3:
                      b ^= (255 & r.charCodeAt(w + 2)) << 16;
                    case 2:
                      b ^= (255 & r.charCodeAt(w + 1)) << 8;
                    case 1:
                      p ^= b =
                        ((65535 &
                          (b =
                            ((b =
                              ((65535 & (b ^= 255 & r.charCodeAt(w))) * _ +
                                ((((b >>> 16) * _) & 65535) << 16)) &
                              4294967295) <<
                              15) |
                            (b >>> 17))) *
                          x +
                          ((((b >>> 16) * x) & 65535) << 16)) &
                        4294967295;
                  }
                  return (
                    (p ^= r.length),
                    (p =
                      (2246822507 * (65535 & (p ^= p >>> 16)) +
                        (((2246822507 * (p >>> 16)) & 65535) << 16)) &
                      4294967295),
                    (p =
                      (3266489909 * (65535 & (p ^= p >>> 13)) +
                        (((3266489909 * (p >>> 16)) & 65535) << 16)) &
                      4294967295),
                    (p ^= p >>> 16) >>> 0
                  );
                })),
              At.exports),
            t =
              (Tt ||
                ((Tt = 1),
                (Pt.exports = function (r, o) {
                  for (var l, d = r.length, p = o ^ d, m = 0; d >= 4; )
                    ((l =
                      1540483477 *
                        (65535 &
                          (l =
                            (255 & r.charCodeAt(m)) |
                            ((255 & r.charCodeAt(++m)) << 8) |
                            ((255 & r.charCodeAt(++m)) << 16) |
                            ((255 & r.charCodeAt(++m)) << 24))) +
                      (((1540483477 * (l >>> 16)) & 65535) << 16)),
                      (p =
                        (1540483477 * (65535 & p) +
                          (((1540483477 * (p >>> 16)) & 65535) << 16)) ^
                        (l =
                          1540483477 * (65535 & (l ^= l >>> 24)) +
                          (((1540483477 * (l >>> 16)) & 65535) << 16))),
                      (d -= 4),
                      ++m);
                  switch (d) {
                    case 3:
                      p ^= (255 & r.charCodeAt(m + 2)) << 16;
                    case 2:
                      p ^= (255 & r.charCodeAt(m + 1)) << 8;
                    case 1:
                      p =
                        1540483477 * (65535 & (p ^= 255 & r.charCodeAt(m))) +
                        (((1540483477 * (p >>> 16)) & 65535) << 16);
                  }
                  return (
                    (p =
                      1540483477 * (65535 & (p ^= p >>> 13)) +
                      (((1540483477 * (p >>> 16)) & 65535) << 16)),
                    (p ^= p >>> 15) >>> 0
                  );
                })),
              Pt.exports);
          return (
            (Ft.exports = n),
            (Ft.exports.murmur3 = n),
            (Ft.exports.murmur2 = t),
            Ft.exports
          );
        })(),
        si = Ue(vi);
      class ai {
        constructor() {
          ((this.ids = []), (this.positions = []), (this.indexed = !1));
        }
        add(t, r, o, l) {
          (this.ids.push(Ri(t)), this.positions.push(r, o, l));
        }
        getPositions(t) {
          if (!this.indexed)
            throw new Error(
              "Trying to get index, but feature positions are not indexed",
            );
          const r = Ri(t);
          let o = 0,
            l = this.ids.length - 1;
          for (; o < l; ) {
            const p = (o + l) >> 1;
            this.ids[p] >= r ? (l = p) : (o = p + 1);
          }
          const d = [];
          for (; this.ids[o] === r; )
            (d.push({
              index: this.positions[3 * o],
              start: this.positions[3 * o + 1],
              end: this.positions[3 * o + 2],
            }),
              o++);
          return d;
        }
        static serialize(t, r) {
          const o = new Float64Array(t.ids),
            l = new Uint32Array(t.positions);
          return (
            Zr(o, l, 0, o.length - 1),
            r && r.push(o.buffer, l.buffer),
            { ids: o, positions: l }
          );
        }
        static deserialize(t) {
          const r = new ai();
          return (
            (r.ids = t.ids),
            (r.positions = t.positions),
            (r.indexed = !0),
            r
          );
        }
      }
      function Ri(n) {
        const t = +n;
        return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : si(String(n));
      }
      function Zr(n, t, r, o) {
        for (; r < o; ) {
          const l = n[(r + o) >> 1];
          let d = r - 1,
            p = o + 1;
          for (;;) {
            do d++;
            while (n[d] < l);
            do p--;
            while (n[p] > l);
            if (d >= p) break;
            (Ir(n, d, p),
              Ir(t, 3 * d, 3 * p),
              Ir(t, 3 * d + 1, 3 * p + 1),
              Ir(t, 3 * d + 2, 3 * p + 2));
          }
          p - r < o - p
            ? (Zr(n, t, r, p), (r = p + 1))
            : (Zr(n, t, p + 1, o), (o = p));
        }
      }
      function Ir(n, t, r) {
        const o = n[t];
        ((n[t] = n[r]), (n[r] = o));
      }
      Re("FeaturePositionMap", ai);
      class er {
        constructor(t, r) {
          ((this.gl = t.gl), (this.location = r));
        }
      }
      class Gr extends er {
        constructor(t, r) {
          (super(t, r), (this.current = 0));
        }
        set(t) {
          this.current !== t &&
            ((this.current = t), this.gl.uniform1f(this.location, t));
        }
      }
      class Ko extends er {
        constructor(t, r) {
          (super(t, r), (this.current = [0, 0, 0, 0]));
        }
        set(t) {
          (t[0] === this.current[0] &&
            t[1] === this.current[1] &&
            t[2] === this.current[2] &&
            t[3] === this.current[3]) ||
            ((this.current = t),
            this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
        }
      }
      class Yo extends er {
        constructor(t, r) {
          (super(t, r), (this.current = ct.transparent));
        }
        set(t) {
          (t.r === this.current.r &&
            t.g === this.current.g &&
            t.b === this.current.b &&
            t.a === this.current.a) ||
            ((this.current = t),
            this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
        }
      }
      const go = new Float32Array(16);
      function Zi(n) {
        return [st(255 * n.r, 255 * n.g), st(255 * n.b, 255 * n.a)];
      }
      class hr {
        constructor(t, r, o) {
          ((this.value = t),
            (this.uniformNames = r.map((l) => `u_${l}`)),
            (this.type = o));
        }
        setUniform(t, r, o) {
          t.set(o.constantOr(this.value));
        }
        getBinding(t, r, o) {
          return this.type === "color" ? new Yo(t, r) : new Gr(t, r);
        }
      }
      class dr {
        constructor(t, r) {
          ((this.uniformNames = r.map((o) => `u_${o}`)),
            (this.patternFrom = null),
            (this.patternTo = null),
            (this.pixelRatioFrom = 1),
            (this.pixelRatioTo = 1));
        }
        setConstantPatternPositions(t, r) {
          ((this.pixelRatioFrom = r.pixelRatio),
            (this.pixelRatioTo = t.pixelRatio),
            (this.patternFrom = r.tlbr),
            (this.patternTo = t.tlbr));
        }
        setUniform(t, r, o, l) {
          const d =
            l === "u_pattern_to"
              ? this.patternTo
              : l === "u_pattern_from"
                ? this.patternFrom
                : l === "u_pixel_ratio_to"
                  ? this.pixelRatioTo
                  : l === "u_pixel_ratio_from"
                    ? this.pixelRatioFrom
                    : null;
          d && t.set(d);
        }
        getBinding(t, r, o) {
          return o.substr(0, 9) === "u_pattern" ? new Ko(t, r) : new Gr(t, r);
        }
      }
      class tr {
        constructor(t, r, o, l) {
          ((this.expression = t),
            (this.type = o),
            (this.maxValue = 0),
            (this.paintVertexAttributes = r.map((d) => ({
              name: `a_${d}`,
              type: "Float32",
              components: o === "color" ? 2 : 1,
              offset: 0,
            }))),
            (this.paintVertexArray = new l()));
        }
        populatePaintArray(t, r, o, l, d) {
          const p = this.paintVertexArray.length,
            m = this.expression.evaluate(new jt(0), r, {}, l, [], d);
          (this.paintVertexArray.resize(t), this._setPaintValue(p, t, m));
        }
        updatePaintArray(t, r, o, l) {
          const d = this.expression.evaluate({ zoom: 0 }, o, l);
          this._setPaintValue(t, r, d);
        }
        _setPaintValue(t, r, o) {
          if (this.type === "color") {
            const l = Zi(o);
            for (let d = t; d < r; d++)
              this.paintVertexArray.emplace(d, l[0], l[1]);
          } else {
            for (let l = t; l < r; l++) this.paintVertexArray.emplace(l, o);
            this.maxValue = Math.max(this.maxValue, Math.abs(o));
          }
        }
        upload(t) {
          this.paintVertexArray &&
            this.paintVertexArray.arrayBuffer &&
            (this.paintVertexBuffer && this.paintVertexBuffer.buffer
              ? this.paintVertexBuffer.updateData(this.paintVertexArray)
              : (this.paintVertexBuffer = t.createVertexBuffer(
                  this.paintVertexArray,
                  this.paintVertexAttributes,
                  this.expression.isStateDependent,
                )));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class St {
        constructor(t, r, o, l, d, p) {
          ((this.expression = t),
            (this.uniformNames = r.map((m) => `u_${m}_t`)),
            (this.type = o),
            (this.useIntegerZoom = l),
            (this.zoom = d),
            (this.maxValue = 0),
            (this.paintVertexAttributes = r.map((m) => ({
              name: `a_${m}`,
              type: "Float32",
              components: o === "color" ? 4 : 2,
              offset: 0,
            }))),
            (this.paintVertexArray = new p()));
        }
        populatePaintArray(t, r, o, l, d) {
          const p = this.expression.evaluate(
              new jt(this.zoom),
              r,
              {},
              l,
              [],
              d,
            ),
            m = this.expression.evaluate(
              new jt(this.zoom + 1),
              r,
              {},
              l,
              [],
              d,
            ),
            _ = this.paintVertexArray.length;
          (this.paintVertexArray.resize(t), this._setPaintValue(_, t, p, m));
        }
        updatePaintArray(t, r, o, l) {
          const d = this.expression.evaluate({ zoom: this.zoom }, o, l),
            p = this.expression.evaluate({ zoom: this.zoom + 1 }, o, l);
          this._setPaintValue(t, r, d, p);
        }
        _setPaintValue(t, r, o, l) {
          if (this.type === "color") {
            const d = Zi(o),
              p = Zi(l);
            for (let m = t; m < r; m++)
              this.paintVertexArray.emplace(m, d[0], d[1], p[0], p[1]);
          } else {
            for (let d = t; d < r; d++) this.paintVertexArray.emplace(d, o, l);
            this.maxValue = Math.max(this.maxValue, Math.abs(o), Math.abs(l));
          }
        }
        upload(t) {
          this.paintVertexArray &&
            this.paintVertexArray.arrayBuffer &&
            (this.paintVertexBuffer && this.paintVertexBuffer.buffer
              ? this.paintVertexBuffer.updateData(this.paintVertexArray)
              : (this.paintVertexBuffer = t.createVertexBuffer(
                  this.paintVertexArray,
                  this.paintVertexAttributes,
                  this.expression.isStateDependent,
                )));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t, r) {
          const o = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
            l = Bi(
              this.expression.interpolationFactor(o, this.zoom, this.zoom + 1),
              0,
              1,
            );
          t.set(l);
        }
        getBinding(t, r, o) {
          return new Gr(t, r);
        }
      }
      class Ut {
        constructor(t, r, o, l, d, p) {
          ((this.expression = t),
            (this.type = r),
            (this.useIntegerZoom = o),
            (this.zoom = l),
            (this.layerId = p),
            (this.zoomInPaintVertexArray = new d()),
            (this.zoomOutPaintVertexArray = new d()));
        }
        populatePaintArray(t, r, o) {
          const l = this.zoomInPaintVertexArray.length;
          (this.zoomInPaintVertexArray.resize(t),
            this.zoomOutPaintVertexArray.resize(t),
            this._setPaintValues(
              l,
              t,
              r.patterns && r.patterns[this.layerId],
              o,
            ));
        }
        updatePaintArray(t, r, o, l, d) {
          this._setPaintValues(t, r, o.patterns && o.patterns[this.layerId], d);
        }
        _setPaintValues(t, r, o, l) {
          if (!l || !o) return;
          const { min: d, mid: p, max: m } = o,
            _ = l[d],
            x = l[p],
            b = l[m];
          if (_ && x && b)
            for (let w = t; w < r; w++)
              (this.zoomInPaintVertexArray.emplace(
                w,
                x.tl[0],
                x.tl[1],
                x.br[0],
                x.br[1],
                _.tl[0],
                _.tl[1],
                _.br[0],
                _.br[1],
                x.pixelRatio,
                _.pixelRatio,
              ),
                this.zoomOutPaintVertexArray.emplace(
                  w,
                  x.tl[0],
                  x.tl[1],
                  x.br[0],
                  x.br[1],
                  b.tl[0],
                  b.tl[1],
                  b.br[0],
                  b.br[1],
                  x.pixelRatio,
                  b.pixelRatio,
                ));
        }
        upload(t) {
          this.zoomInPaintVertexArray &&
            this.zoomInPaintVertexArray.arrayBuffer &&
            this.zoomOutPaintVertexArray &&
            this.zoomOutPaintVertexArray.arrayBuffer &&
            ((this.zoomInPaintVertexBuffer = t.createVertexBuffer(
              this.zoomInPaintVertexArray,
              gt.members,
              this.expression.isStateDependent,
            )),
            (this.zoomOutPaintVertexBuffer = t.createVertexBuffer(
              this.zoomOutPaintVertexArray,
              gt.members,
              this.expression.isStateDependent,
            )));
        }
        destroy() {
          (this.zoomOutPaintVertexBuffer &&
            this.zoomOutPaintVertexBuffer.destroy(),
            this.zoomInPaintVertexBuffer &&
              this.zoomInPaintVertexBuffer.destroy());
        }
      }
      class ir {
        constructor(t, r, o) {
          ((this.binders = {}), (this._buffers = []));
          const l = [];
          for (const d in t.paint._values) {
            if (!o(d)) continue;
            const p = t.paint.get(d);
            if (!(p instanceof Dr && ro(p.property.specification))) continue;
            const m = _c(d, t.type),
              _ = p.value,
              x = p.property.specification.type,
              b = p.property.useIntegerZoom,
              w = p.property.specification["property-type"],
              F = w === "cross-faded" || w === "cross-faded-data-driven";
            if (_.kind === "constant")
              ((this.binders[d] = F
                ? new dr(_.value, m)
                : new hr(_.value, m, x)),
                l.push(`/u_${d}`));
            else if (_.kind === "source" || F) {
              const S = Su(d, x, "source");
              ((this.binders[d] = F
                ? new Ut(_, x, b, r, S, t.id)
                : new tr(_, m, x, S)),
                l.push(`/a_${d}`));
            } else {
              const S = Su(d, x, "composite");
              ((this.binders[d] = new St(_, m, x, b, r, S)), l.push(`/z_${d}`));
            }
          }
          this.cacheKey = l.sort().join("");
        }
        getMaxValue(t) {
          const r = this.binders[t];
          return r instanceof tr || r instanceof St ? r.maxValue : 0;
        }
        populatePaintArrays(t, r, o, l, d) {
          for (const p in this.binders) {
            const m = this.binders[p];
            (m instanceof tr || m instanceof St || m instanceof Ut) &&
              m.populatePaintArray(t, r, o, l, d);
          }
        }
        setConstantPatternPositions(t, r) {
          for (const o in this.binders) {
            const l = this.binders[o];
            l instanceof dr && l.setConstantPatternPositions(t, r);
          }
        }
        updatePaintArrays(t, r, o, l, d) {
          let p = !1;
          for (const m in t) {
            const _ = r.getPositions(m);
            for (const x of _) {
              const b = o.feature(x.index);
              for (const w in this.binders) {
                const F = this.binders[w];
                if (
                  (F instanceof tr || F instanceof St || F instanceof Ut) &&
                  F.expression.isStateDependent === !0
                ) {
                  const S = l.paint.get(w);
                  ((F.expression = S.value),
                    F.updatePaintArray(x.start, x.end, b, t[m], d),
                    (p = !0));
                }
              }
            }
          }
          return p;
        }
        defines() {
          const t = [];
          for (const r in this.binders) {
            const o = this.binders[r];
            (o instanceof hr || o instanceof dr) &&
              t.push(...o.uniformNames.map((l) => `#define HAS_UNIFORM_${l}`));
          }
          return t;
        }
        getBinderAttributes() {
          const t = [];
          for (const r in this.binders) {
            const o = this.binders[r];
            if (o instanceof tr || o instanceof St)
              for (let l = 0; l < o.paintVertexAttributes.length; l++)
                t.push(o.paintVertexAttributes[l].name);
            else if (o instanceof Ut)
              for (let l = 0; l < gt.members.length; l++)
                t.push(gt.members[l].name);
          }
          return t;
        }
        getBinderUniforms() {
          const t = [];
          for (const r in this.binders) {
            const o = this.binders[r];
            if (o instanceof hr || o instanceof dr || o instanceof St)
              for (const l of o.uniformNames) t.push(l);
          }
          return t;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t, r) {
          const o = [];
          for (const l in this.binders) {
            const d = this.binders[l];
            if (d instanceof hr || d instanceof dr || d instanceof St) {
              for (const p of d.uniformNames)
                if (r[p]) {
                  const m = d.getBinding(t, r[p], p);
                  o.push({ name: p, property: l, binding: m });
                }
            }
          }
          return o;
        }
        setUniforms(t, r, o, l) {
          for (const { name: d, property: p, binding: m } of r)
            this.binders[p].setUniform(m, l, o.get(p), d);
        }
        updatePaintBuffers(t) {
          this._buffers = [];
          for (const r in this.binders) {
            const o = this.binders[r];
            if (t && o instanceof Ut) {
              const l =
                t.fromScale === 2
                  ? o.zoomInPaintVertexBuffer
                  : o.zoomOutPaintVertexBuffer;
              l && this._buffers.push(l);
            } else
              (o instanceof tr || o instanceof St) &&
                o.paintVertexBuffer &&
                this._buffers.push(o.paintVertexBuffer);
          }
        }
        upload(t) {
          for (const r in this.binders) {
            const o = this.binders[r];
            (o instanceof tr || o instanceof St || o instanceof Ut) &&
              o.upload(t);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t in this.binders) {
            const r = this.binders[t];
            (r instanceof tr || r instanceof St || r instanceof Ut) &&
              r.destroy();
          }
        }
      }
      class Gt {
        constructor(t, r, o = () => !0) {
          this.programConfigurations = {};
          for (const l of t) this.programConfigurations[l.id] = new ir(l, r, o);
          ((this.needsUpload = !1),
            (this._featureMap = new ai()),
            (this._bufferOffset = 0));
        }
        populatePaintArrays(t, r, o, l, d, p) {
          for (const m in this.programConfigurations)
            this.programConfigurations[m].populatePaintArrays(t, r, l, d, p);
          (r.id !== void 0 &&
            this._featureMap.add(r.id, o, this._bufferOffset, t),
            (this._bufferOffset = t),
            (this.needsUpload = !0));
        }
        updatePaintArrays(t, r, o, l) {
          for (const d of o)
            this.needsUpload =
              this.programConfigurations[d.id].updatePaintArrays(
                t,
                this._featureMap,
                r,
                d,
                l,
              ) || this.needsUpload;
        }
        get(t) {
          return this.programConfigurations[t];
        }
        upload(t) {
          if (this.needsUpload) {
            for (const r in this.programConfigurations)
              this.programConfigurations[r].upload(t);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const t in this.programConfigurations)
            this.programConfigurations[t].destroy();
        }
      }
      function _c(n, t) {
        return (
          {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-pattern": [
              "pattern_to",
              "pattern_from",
              "pixel_ratio_to",
              "pixel_ratio_from",
            ],
            "fill-pattern": [
              "pattern_to",
              "pattern_from",
              "pixel_ratio_to",
              "pixel_ratio_from",
            ],
            "fill-extrusion-pattern": [
              "pattern_to",
              "pattern_from",
              "pixel_ratio_to",
              "pixel_ratio_from",
            ],
          }[n] || [n.replace(`${t}-`, "").replace(/-/g, "_")]
        );
      }
      function Su(n, t, r) {
        const o = {
            color: { source: fo, composite: s },
            number: { source: Wo, composite: fo },
          },
          l = (function (d) {
            return {
              "line-pattern": { source: re, composite: re },
              "fill-pattern": { source: re, composite: re },
              "fill-extrusion-pattern": { source: re, composite: re },
            }[d];
          })(n);
        return (l && l[r]) || o[t][r];
      }
      (Re("ConstantBinder", hr),
        Re("CrossFadedConstantBinder", dr),
        Re("SourceExpressionBinder", tr),
        Re("CrossFadedCompositeBinder", Ut),
        Re("CompositeExpressionBinder", St),
        Re("ProgramConfiguration", ir, { omit: ["_buffers"] }),
        Re("ProgramConfigurationSet", Gt));
      const ol = Math.pow(2, 14) - 1,
        Du = -ol - 1;
      function Nn(n) {
        const t = qe / n.extent,
          r = n.loadGeometry();
        for (let o = 0; o < r.length; o++) {
          const l = r[o];
          for (let d = 0; d < l.length; d++) {
            const p = l[d],
              m = Math.round(p.x * t),
              _ = Math.round(p.y * t);
            ((p.x = Bi(m, Du, ol)),
              (p.y = Bi(_, Du, ol)),
              (m < p.x || m > p.x + 1 || _ < p.y || _ > p.y + 1) &&
                Ai(
                  "Geometry exceeds allowed extent, reduce your vector tile buffer size",
                ));
          }
        }
        return r;
      }
      function Vn(n, t) {
        return {
          type: n.type,
          id: n.id,
          properties: n.properties,
          geometry: t ? Nn(n) : [],
        };
      }
      const an = -32768;
      function Mu(n, t, r, o, l) {
        n.emplaceBack(an + 8 * t + o, an + 8 * r + l);
      }
      class ea {
        constructor(t) {
          ((this.zoom = t.zoom),
            (this.overscaling = t.overscaling),
            (this.layers = t.layers),
            (this.layerIds = this.layers.map((r) => r.id)),
            (this.index = t.index),
            (this.hasPattern = !1),
            (this.layoutVertexArray = new $()),
            (this.indexArray = new ye()),
            (this.segments = new Le()),
            (this.programConfigurations = new Gt(t.layers, t.zoom)),
            (this.stateDependentLayerIds = this.layers
              .filter((r) => r.isStateDependent())
              .map((r) => r.id)));
        }
        populate(t, r, o) {
          const l = this.layers[0],
            d = [];
          let p = null,
            m = !1,
            _ = l.type === "heatmap";
          if (l.type === "circle") {
            const b = l;
            ((p = b.layout.get("circle-sort-key")),
              (m = !p.isConstant()),
              (_ = _ || b.paint.get("circle-pitch-alignment") === "map"));
          }
          const x = _ ? r.subdivisionGranularity.circle : 1;
          for (const {
            feature: b,
            id: w,
            index: F,
            sourceLayerIndex: S,
          } of t) {
            const D = this.layers[0]._featureFilter.needGeometry,
              I = Vn(b, D);
            if (!this.layers[0]._featureFilter.filter(new jt(this.zoom), I, o))
              continue;
            const O = m ? p.evaluate(I, {}, o) : void 0,
              Z = {
                id: w,
                properties: b.properties,
                type: b.type,
                sourceLayerIndex: S,
                index: F,
                geometry: D ? I.geometry : Nn(b),
                patterns: {},
                sortKey: O,
              };
            d.push(Z);
          }
          m && d.sort((b, w) => b.sortKey - w.sortKey);
          for (const b of d) {
            const { geometry: w, index: F, sourceLayerIndex: S } = b,
              D = t[F].feature;
            (this.addFeature(b, w, F, o, x),
              r.featureIndex.insert(D, w, F, S, this.index));
          }
        }
        update(t, r, o) {
          this.stateDependentLayers.length &&
            this.programConfigurations.updatePaintArrays(
              t,
              r,
              this.stateDependentLayers,
              o,
            );
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          (this.uploaded ||
            ((this.layoutVertexBuffer = t.createVertexBuffer(
              this.layoutVertexArray,
              Fe,
            )),
            (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
            this.programConfigurations.upload(t),
            (this.uploaded = !0));
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.programConfigurations.destroy(),
            this.segments.destroy());
        }
        addFeature(t, r, o, l, d = 1) {
          let p;
          switch (d) {
            case 1:
              p = [0, 7];
              break;
            case 3:
              p = [0, 2, 5, 7];
              break;
            case 5:
              p = [0, 1, 3, 4, 6, 7];
              break;
            case 7:
              p = [0, 1, 2, 3, 4, 5, 6, 7];
              break;
            default:
              throw new Error(
                `Invalid circle bucket granularity: ${d}; valid values are 1, 3, 5, 7.`,
              );
          }
          const m = p.length;
          for (const _ of r)
            for (const x of _) {
              const b = x.x,
                w = x.y;
              if (b < 0 || b >= qe || w < 0 || w >= qe) continue;
              const F = this.segments.prepareSegment(
                  m * m,
                  this.layoutVertexArray,
                  this.indexArray,
                  t.sortKey,
                ),
                S = F.vertexLength;
              for (let D = 0; D < m; D++)
                for (let I = 0; I < m; I++)
                  Mu(this.layoutVertexArray, b, w, p[I], p[D]);
              for (let D = 0; D < m - 1; D++)
                for (let I = 0; I < m - 1; I++) {
                  const O = S + D * m + I,
                    Z = S + (D + 1) * m + I;
                  (this.indexArray.emplaceBack(O, Z + 1, O + 1),
                    this.indexArray.emplaceBack(O, Z, Z + 1));
                }
              ((F.vertexLength += m * m),
                (F.primitiveLength += (m - 1) * (m - 1) * 2));
            }
          this.programConfigurations.populatePaintArrays(
            this.layoutVertexArray.length,
            t,
            o,
            {},
            l,
          );
        }
      }
      function sl(n, t) {
        for (let r = 0; r < n.length; r++) if (ta(t, n[r])) return !0;
        for (let r = 0; r < t.length; r++) if (ta(n, t[r])) return !0;
        return !!yc(n, t);
      }
      function al(n, t, r) {
        return !!ta(n, t) || !!xc(t, n, r);
      }
      function ll(n, t) {
        if (n.length === 1) return hh(t, n[0]);
        for (let r = 0; r < t.length; r++) {
          const o = t[r];
          for (let l = 0; l < o.length; l++) if (ta(n, o[l])) return !0;
        }
        for (let r = 0; r < n.length; r++) if (hh(t, n[r])) return !0;
        for (let r = 0; r < t.length; r++) if (yc(n, t[r])) return !0;
        return !1;
      }
      function ul(n, t, r) {
        if (n.length > 1) {
          if (yc(n, t)) return !0;
          for (let o = 0; o < t.length; o++) if (xc(t[o], n, r)) return !0;
        }
        for (let o = 0; o < n.length; o++) if (xc(n[o], t, r)) return !0;
        return !1;
      }
      function yc(n, t) {
        if (n.length === 0 || t.length === 0) return !1;
        for (let r = 0; r < n.length - 1; r++) {
          const o = n[r],
            l = n[r + 1];
          for (let d = 0; d < t.length - 1; d++)
            if (rp(o, l, t[d], t[d + 1])) return !0;
        }
        return !1;
      }
      function rp(n, t, r, o) {
        return ui(n, r, o) !== ui(t, r, o) && ui(n, t, r) !== ui(n, t, o);
      }
      function xc(n, t, r) {
        const o = r * r;
        if (t.length === 1) return n.distSqr(t[0]) < o;
        for (let l = 1; l < t.length; l++)
          if (ch(n, t[l - 1], t[l]) < o) return !0;
        return !1;
      }
      function ch(n, t, r) {
        const o = t.distSqr(r);
        if (o === 0) return n.distSqr(t);
        const l = ((n.x - t.x) * (r.x - t.x) + (n.y - t.y) * (r.y - t.y)) / o;
        return n.distSqr(l < 0 ? t : l > 1 ? r : r.sub(t)._mult(l)._add(t));
      }
      function hh(n, t) {
        let r,
          o,
          l,
          d = !1;
        for (let p = 0; p < n.length; p++) {
          r = n[p];
          for (let m = 0, _ = r.length - 1; m < r.length; _ = m++)
            ((o = r[m]),
              (l = r[_]),
              o.y > t.y != l.y > t.y &&
                t.x < ((l.x - o.x) * (t.y - o.y)) / (l.y - o.y) + o.x &&
                (d = !d));
        }
        return d;
      }
      function ta(n, t) {
        let r = !1;
        for (let o = 0, l = n.length - 1; o < n.length; l = o++) {
          const d = n[o],
            p = n[l];
          d.y > t.y != p.y > t.y &&
            t.x < ((p.x - d.x) * (t.y - d.y)) / (p.y - d.y) + d.x &&
            (r = !r);
        }
        return r;
      }
      function np(n, t, r) {
        const o = r[0],
          l = r[2];
        if (
          (n.x < o.x && t.x < o.x) ||
          (n.x > l.x && t.x > l.x) ||
          (n.y < o.y && t.y < o.y) ||
          (n.y > l.y && t.y > l.y)
        )
          return !1;
        const d = ui(n, t, r[0]);
        return (
          d !== ui(n, t, r[1]) || d !== ui(n, t, r[2]) || d !== ui(n, t, r[3])
        );
      }
      function cl(n, t, r) {
        const o = t.paint.get(n).value;
        return o.kind === "constant"
          ? o.value
          : r.programConfigurations.get(t.id).getMaxValue(n);
      }
      function Iu(n) {
        return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
      }
      function Bu(n, t, r, o, l) {
        if (!t[0] && !t[1]) return n;
        const d = Ze.convert(t)._mult(l);
        r === "viewport" && d._rotate(-o);
        const p = [];
        for (let m = 0; m < n.length; m++) p.push(n[m].sub(d));
        return p;
      }
      let dh, ph;
      Re("CircleBucket", ea, { omit: ["layers"] });
      var op = {
        get paint() {
          return (ph =
            ph ||
            new $i({
              "circle-radius": new et(j.paint_circle["circle-radius"]),
              "circle-color": new et(j.paint_circle["circle-color"]),
              "circle-blur": new et(j.paint_circle["circle-blur"]),
              "circle-opacity": new et(j.paint_circle["circle-opacity"]),
              "circle-translate": new He(j.paint_circle["circle-translate"]),
              "circle-translate-anchor": new He(
                j.paint_circle["circle-translate-anchor"],
              ),
              "circle-pitch-scale": new He(
                j.paint_circle["circle-pitch-scale"],
              ),
              "circle-pitch-alignment": new He(
                j.paint_circle["circle-pitch-alignment"],
              ),
              "circle-stroke-width": new et(
                j.paint_circle["circle-stroke-width"],
              ),
              "circle-stroke-color": new et(
                j.paint_circle["circle-stroke-color"],
              ),
              "circle-stroke-opacity": new et(
                j.paint_circle["circle-stroke-opacity"],
              ),
            }));
        },
        get layout() {
          return (dh =
            dh ||
            new $i({
              "circle-sort-key": new et(j.layout_circle["circle-sort-key"]),
            }));
        },
      };
      class sp extends Mr {
        constructor(t) {
          super(t, op);
        }
        createBucket(t) {
          return new ea(t);
        }
        queryRadius(t) {
          const r = t;
          return (
            cl("circle-radius", this, r) +
            cl("circle-stroke-width", this, r) +
            Iu(this.paint.get("circle-translate"))
          );
        }
        queryIntersectsFeature({
          queryGeometry: t,
          feature: r,
          featureState: o,
          geometry: l,
          transform: d,
          pixelsToTileUnits: p,
          pixelPosMatrix: m,
        }) {
          const _ = Bu(
              t,
              this.paint.get("circle-translate"),
              this.paint.get("circle-translate-anchor"),
              -d.bearingInRadians,
              p,
            ),
            x =
              this.paint.get("circle-radius").evaluate(r, o) +
              this.paint.get("circle-stroke-width").evaluate(r, o),
            b = this.paint.get("circle-pitch-alignment") === "map",
            w = b
              ? _
              : (function (S, D) {
                  return S.map((I) => fh(I, D));
                })(_, m),
            F = b ? x * p : x;
          for (const S of l)
            for (const D of S) {
              const I = b ? D : fh(D, m);
              let O = F;
              const Z = sr([], [D.x, D.y, 0, 1], m);
              if (
                (this.paint.get("circle-pitch-scale") === "viewport" &&
                this.paint.get("circle-pitch-alignment") === "map"
                  ? (O *= Z[3] / d.cameraToCenterDistance)
                  : this.paint.get("circle-pitch-scale") === "map" &&
                    this.paint.get("circle-pitch-alignment") === "viewport" &&
                    (O *= d.cameraToCenterDistance / Z[3]),
                al(w, I, O))
              )
                return !0;
            }
          return !1;
        }
      }
      function fh(n, t) {
        const r = sr([], [n.x, n.y, 0, 1], t);
        return new Ze(r[0] / r[3], r[1] / r[3]);
      }
      class mh extends ea {}
      let gh;
      Re("HeatmapBucket", mh, { omit: ["layers"] });
      var ap = {
        get paint() {
          return (gh =
            gh ||
            new $i({
              "heatmap-radius": new et(j.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new et(j.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new He(j.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new Ys(j.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new He(j.paint_heatmap["heatmap-opacity"]),
            }));
        },
      };
      function vc(n, { width: t, height: r }, o, l) {
        if (l) {
          if (l instanceof Uint8ClampedArray) l = new Uint8Array(l.buffer);
          else if (l.length !== t * r * o)
            throw new RangeError(
              `mismatched image size. expected: ${l.length} but got: ${t * r * o}`,
            );
        } else l = new Uint8Array(t * r * o);
        return ((n.width = t), (n.height = r), (n.data = l), n);
      }
      function _h(n, { width: t, height: r }, o) {
        if (t === n.width && r === n.height) return;
        const l = vc({}, { width: t, height: r }, o);
        (bc(
          n,
          l,
          { x: 0, y: 0 },
          { x: 0, y: 0 },
          { width: Math.min(n.width, t), height: Math.min(n.height, r) },
          o,
        ),
          (n.width = t),
          (n.height = r),
          (n.data = l.data));
      }
      function bc(n, t, r, o, l, d) {
        if (l.width === 0 || l.height === 0) return t;
        if (
          l.width > n.width ||
          l.height > n.height ||
          r.x > n.width - l.width ||
          r.y > n.height - l.height
        )
          throw new RangeError(
            "out of range source coordinates for image copy",
          );
        if (
          l.width > t.width ||
          l.height > t.height ||
          o.x > t.width - l.width ||
          o.y > t.height - l.height
        )
          throw new RangeError(
            "out of range destination coordinates for image copy",
          );
        const p = n.data,
          m = t.data;
        if (p === m)
          throw new Error("srcData equals dstData, so image is already copied");
        for (let _ = 0; _ < l.height; _++) {
          const x = ((r.y + _) * n.width + r.x) * d,
            b = ((o.y + _) * t.width + o.x) * d;
          for (let w = 0; w < l.width * d; w++) m[b + w] = p[x + w];
        }
        return t;
      }
      class hl {
        constructor(t, r) {
          vc(this, t, 1, r);
        }
        resize(t) {
          _h(this, t, 1);
        }
        clone() {
          return new hl(
            { width: this.width, height: this.height },
            new Uint8Array(this.data),
          );
        }
        static copy(t, r, o, l, d) {
          bc(t, r, o, l, d, 1);
        }
      }
      class vr {
        constructor(t, r) {
          vc(this, t, 4, r);
        }
        resize(t) {
          _h(this, t, 4);
        }
        replace(t, r) {
          r
            ? this.data.set(t)
            : (this.data =
                t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t);
        }
        clone() {
          return new vr(
            { width: this.width, height: this.height },
            new Uint8Array(this.data),
          );
        }
        static copy(t, r, o, l, d) {
          bc(t, r, o, l, d, 4);
        }
      }
      function yh(n) {
        const t = {},
          r = n.resolution || 256,
          o = n.clips ? n.clips.length : 1,
          l = n.image || new vr({ width: r, height: o });
        if ((Math.log(r) / Math.LN2) % 1 != 0)
          throw new Error(`width is not a power of 2 - ${r}`);
        const d = (p, m, _) => {
          t[n.evaluationKey] = _;
          const x = n.expression.evaluate(t);
          ((l.data[p + m + 0] = Math.floor((255 * x.r) / x.a)),
            (l.data[p + m + 1] = Math.floor((255 * x.g) / x.a)),
            (l.data[p + m + 2] = Math.floor((255 * x.b) / x.a)),
            (l.data[p + m + 3] = Math.floor(255 * x.a)));
        };
        if (n.clips)
          for (let p = 0, m = 0; p < o; ++p, m += 4 * r)
            for (let _ = 0, x = 0; _ < r; _++, x += 4) {
              const b = _ / (r - 1),
                { start: w, end: F } = n.clips[p];
              d(m, x, w * (1 - b) + F * b);
            }
        else for (let p = 0, m = 0; p < r; p++, m += 4) d(0, m, p / (r - 1));
        return l;
      }
      (Re("AlphaImage", hl), Re("RGBAImage", vr));
      const wc = "big-fb";
      class lp extends Mr {
        createBucket(t) {
          return new mh(t);
        }
        constructor(t) {
          (super(t, ap),
            (this.heatmapFbos = new Map()),
            this._updateColorRamp());
        }
        _handleSpecialPaintPropertyUpdate(t) {
          t === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          ((this.colorRamp = yh({
            expression:
              this._transitionablePaint._values["heatmap-color"].value
                .expression,
            evaluationKey: "heatmapDensity",
            image: this.colorRamp,
          })),
            (this.colorRampTexture = null));
        }
        resize() {
          this.heatmapFbos.has(wc) && this.heatmapFbos.delete(wc);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return (
            this.paint.get("heatmap-opacity") !== 0 &&
            this.visibility !== "none"
          );
        }
      }
      let xh;
      var up = {
        get paint() {
          return (xh =
            xh ||
            new $i({
              "hillshade-illumination-direction": new He(
                j.paint_hillshade["hillshade-illumination-direction"],
              ),
              "hillshade-illumination-anchor": new He(
                j.paint_hillshade["hillshade-illumination-anchor"],
              ),
              "hillshade-exaggeration": new He(
                j.paint_hillshade["hillshade-exaggeration"],
              ),
              "hillshade-shadow-color": new He(
                j.paint_hillshade["hillshade-shadow-color"],
              ),
              "hillshade-highlight-color": new He(
                j.paint_hillshade["hillshade-highlight-color"],
              ),
              "hillshade-accent-color": new He(
                j.paint_hillshade["hillshade-accent-color"],
              ),
            }));
        },
      };
      class cp extends Mr {
        constructor(t) {
          super(t, up);
        }
        hasOffscreenPass() {
          return (
            this.paint.get("hillshade-exaggeration") !== 0 &&
            this.visibility !== "none"
          );
        }
      }
      const hp = ii([{ name: "a_pos", components: 2, type: "Int16" }], 4),
        { members: dp } = hp;
      function Cc(n, t, r) {
        const o = r.patternDependencies;
        let l = !1;
        for (const d of t) {
          const p = d.paint.get(`${n}-pattern`);
          p.isConstant() || (l = !0);
          const m = p.constantOr(null);
          m && ((l = !0), (o[m.to] = !0), (o[m.from] = !0));
        }
        return l;
      }
      function Ec(n, t, r, o, l) {
        const d = l.patternDependencies;
        for (const p of t) {
          const m = p.paint.get(`${n}-pattern`).value;
          if (m.kind !== "constant") {
            let _ = m.evaluate({ zoom: o - 1 }, r, {}, l.availableImages),
              x = m.evaluate({ zoom: o }, r, {}, l.availableImages),
              b = m.evaluate({ zoom: o + 1 }, r, {}, l.availableImages);
            ((_ = _ && _.name ? _.name : _),
              (x = x && x.name ? x.name : x),
              (b = b && b.name ? b.name : b),
              (d[_] = !0),
              (d[x] = !0),
              (d[b] = !0),
              (r.patterns[p.id] = { min: _, mid: x, max: b }));
          }
        }
        return r;
      }
      function vh(n, t, r, o, l) {
        let d;
        if (
          l ===
          (function (p, m, _, x) {
            let b = 0;
            for (let w = m, F = _ - x; w < _; w += x)
              ((b += (p[F] - p[w]) * (p[w + 1] + p[F + 1])), (F = w));
            return b;
          })(n, t, r, o) >
            0
        )
          for (let p = t; p < r; p += o) d = Eh((p / o) | 0, n[p], n[p + 1], d);
        else
          for (let p = r - o; p >= t; p -= o)
            d = Eh((p / o) | 0, n[p], n[p + 1], d);
        return (d && ia(d, d.next) && (ml(d), (d = d.next)), d);
      }
      function Jo(n, t) {
        if (!n) return n;
        t || (t = n);
        let r,
          o = n;
        do
          if (
            ((r = !1),
            o.steiner || (!ia(o, o.next) && ri(o.prev, o, o.next) !== 0))
          )
            o = o.next;
          else {
            if ((ml(o), (o = t = o.prev), o === o.next)) break;
            r = !0;
          }
        while (r || o !== t);
        return t;
      }
      function dl(n, t, r, o, l, d, p) {
        if (!n) return;
        !p &&
          d &&
          (function (_, x, b, w) {
            let F = _;
            do
              (F.z === 0 && (F.z = Ac(F.x, F.y, x, b, w)),
                (F.prevZ = F.prev),
                (F.nextZ = F.next),
                (F = F.next));
            while (F !== _);
            ((F.prevZ.nextZ = null),
              (F.prevZ = null),
              (function (S) {
                let D,
                  I = 1;
                do {
                  let O,
                    Z = S;
                  S = null;
                  let ne = null;
                  for (D = 0; Z; ) {
                    D++;
                    let H = Z,
                      P = 0;
                    for (let W = 0; W < I && (P++, (H = H.nextZ), H); W++);
                    let R = I;
                    for (; P > 0 || (R > 0 && H); )
                      (P !== 0 && (R === 0 || !H || Z.z <= H.z)
                        ? ((O = Z), (Z = Z.nextZ), P--)
                        : ((O = H), (H = H.nextZ), R--),
                        ne ? (ne.nextZ = O) : (S = O),
                        (O.prevZ = ne),
                        (ne = O));
                    Z = H;
                  }
                  ((ne.nextZ = null), (I *= 2));
                } while (D > 1);
              })(F));
          })(n, o, l, d);
        let m = n;
        for (; n.prev !== n.next; ) {
          const _ = n.prev,
            x = n.next;
          if (d ? fp(n, o, l, d) : pp(n))
            (t.push(_.i, n.i, x.i), ml(n), (n = x.next), (m = x.next));
          else if ((n = x) === m) {
            p
              ? p === 1
                ? dl((n = mp(Jo(n), t)), t, r, o, l, d, 2)
                : p === 2 && gp(n, t, r, o, l, d)
              : dl(Jo(n), t, r, o, l, d, 1);
            break;
          }
        }
      }
      function pp(n) {
        const t = n.prev,
          r = n,
          o = n.next;
        if (ri(t, r, o) >= 0) return !1;
        const l = t.x,
          d = r.x,
          p = o.x,
          m = t.y,
          _ = r.y,
          x = o.y,
          b = Math.min(l, d, p),
          w = Math.min(m, _, x),
          F = Math.max(l, d, p),
          S = Math.max(m, _, x);
        let D = o.next;
        for (; D !== t; ) {
          if (
            D.x >= b &&
            D.x <= F &&
            D.y >= w &&
            D.y <= S &&
            pl(l, m, d, _, p, x, D.x, D.y) &&
            ri(D.prev, D, D.next) >= 0
          )
            return !1;
          D = D.next;
        }
        return !0;
      }
      function fp(n, t, r, o) {
        const l = n.prev,
          d = n,
          p = n.next;
        if (ri(l, d, p) >= 0) return !1;
        const m = l.x,
          _ = d.x,
          x = p.x,
          b = l.y,
          w = d.y,
          F = p.y,
          S = Math.min(m, _, x),
          D = Math.min(b, w, F),
          I = Math.max(m, _, x),
          O = Math.max(b, w, F),
          Z = Ac(S, D, t, r, o),
          ne = Ac(I, O, t, r, o);
        let H = n.prevZ,
          P = n.nextZ;
        for (; H && H.z >= Z && P && P.z <= ne; ) {
          if (
            (H.x >= S &&
              H.x <= I &&
              H.y >= D &&
              H.y <= O &&
              H !== l &&
              H !== p &&
              pl(m, b, _, w, x, F, H.x, H.y) &&
              ri(H.prev, H, H.next) >= 0) ||
            ((H = H.prevZ),
            P.x >= S &&
              P.x <= I &&
              P.y >= D &&
              P.y <= O &&
              P !== l &&
              P !== p &&
              pl(m, b, _, w, x, F, P.x, P.y) &&
              ri(P.prev, P, P.next) >= 0)
          )
            return !1;
          P = P.nextZ;
        }
        for (; H && H.z >= Z; ) {
          if (
            H.x >= S &&
            H.x <= I &&
            H.y >= D &&
            H.y <= O &&
            H !== l &&
            H !== p &&
            pl(m, b, _, w, x, F, H.x, H.y) &&
            ri(H.prev, H, H.next) >= 0
          )
            return !1;
          H = H.prevZ;
        }
        for (; P && P.z <= ne; ) {
          if (
            P.x >= S &&
            P.x <= I &&
            P.y >= D &&
            P.y <= O &&
            P !== l &&
            P !== p &&
            pl(m, b, _, w, x, F, P.x, P.y) &&
            ri(P.prev, P, P.next) >= 0
          )
            return !1;
          P = P.nextZ;
        }
        return !0;
      }
      function mp(n, t) {
        let r = n;
        do {
          const o = r.prev,
            l = r.next.next;
          (!ia(o, l) &&
            wh(o, r, r.next, l) &&
            fl(o, l) &&
            fl(l, o) &&
            (t.push(o.i, r.i, l.i), ml(r), ml(r.next), (r = n = l)),
            (r = r.next));
        } while (r !== n);
        return Jo(r);
      }
      function gp(n, t, r, o, l, d) {
        let p = n;
        do {
          let m = p.next.next;
          for (; m !== p.prev; ) {
            if (p.i !== m.i && bp(p, m)) {
              let _ = Ch(p, m);
              return (
                (p = Jo(p, p.next)),
                (_ = Jo(_, _.next)),
                dl(p, t, r, o, l, d, 0),
                void dl(_, t, r, o, l, d, 0)
              );
            }
            m = m.next;
          }
          p = p.next;
        } while (p !== n);
      }
      function _p(n, t) {
        let r = n.x - t.x;
        return (
          r === 0 &&
            ((r = n.y - t.y), r === 0) &&
            (r =
              (n.next.y - n.y) / (n.next.x - n.x) -
              (t.next.y - t.y) / (t.next.x - t.x)),
          r
        );
      }
      function yp(n, t) {
        const r = (function (l, d) {
          let p = d;
          const m = l.x,
            _ = l.y;
          let x,
            b = -1 / 0;
          if (ia(l, p)) return p;
          do {
            if (ia(l, p.next)) return p.next;
            if (_ <= p.y && _ >= p.next.y && p.next.y !== p.y) {
              const I = p.x + ((_ - p.y) * (p.next.x - p.x)) / (p.next.y - p.y);
              if (
                I <= m &&
                I > b &&
                ((b = I), (x = p.x < p.next.x ? p : p.next), I === m)
              )
                return x;
            }
            p = p.next;
          } while (p !== d);
          if (!x) return null;
          const w = x,
            F = x.x,
            S = x.y;
          let D = 1 / 0;
          p = x;
          do {
            if (
              m >= p.x &&
              p.x >= F &&
              m !== p.x &&
              bh(_ < S ? m : b, _, F, S, _ < S ? b : m, _, p.x, p.y)
            ) {
              const I = Math.abs(_ - p.y) / (m - p.x);
              fl(p, l) &&
                (I < D ||
                  (I === D && (p.x > x.x || (p.x === x.x && xp(x, p))))) &&
                ((x = p), (D = I));
            }
            p = p.next;
          } while (p !== w);
          return x;
        })(n, t);
        if (!r) return t;
        const o = Ch(r, n);
        return (Jo(o, o.next), Jo(r, r.next));
      }
      function xp(n, t) {
        return ri(n.prev, n, t.prev) < 0 && ri(t.next, n, n.next) < 0;
      }
      function Ac(n, t, r, o, l) {
        return (
          (n =
            1431655765 &
            ((n =
              858993459 &
              ((n =
                252645135 &
                ((n = 16711935 & ((n = ((n - r) * l) | 0) | (n << 8))) |
                  (n << 4))) |
                (n << 2))) |
              (n << 1))) |
          ((t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 &
                ((t = 16711935 & ((t = ((t - o) * l) | 0) | (t << 8))) |
                  (t << 4))) |
                (t << 2))) |
              (t << 1))) <<
            1)
        );
      }
      function vp(n) {
        let t = n,
          r = n;
        do ((t.x < r.x || (t.x === r.x && t.y < r.y)) && (r = t), (t = t.next));
        while (t !== n);
        return r;
      }
      function bh(n, t, r, o, l, d, p, m) {
        return (
          (l - p) * (t - m) >= (n - p) * (d - m) &&
          (n - p) * (o - m) >= (r - p) * (t - m) &&
          (r - p) * (d - m) >= (l - p) * (o - m)
        );
      }
      function pl(n, t, r, o, l, d, p, m) {
        return !(n === p && t === m) && bh(n, t, r, o, l, d, p, m);
      }
      function bp(n, t) {
        return (
          n.next.i !== t.i &&
          n.prev.i !== t.i &&
          !(function (r, o) {
            let l = r;
            do {
              if (
                l.i !== r.i &&
                l.next.i !== r.i &&
                l.i !== o.i &&
                l.next.i !== o.i &&
                wh(l, l.next, r, o)
              )
                return !0;
              l = l.next;
            } while (l !== r);
            return !1;
          })(n, t) &&
          ((fl(n, t) &&
            fl(t, n) &&
            (function (r, o) {
              let l = r,
                d = !1;
              const p = (r.x + o.x) / 2,
                m = (r.y + o.y) / 2;
              do
                (l.y > m != l.next.y > m &&
                  l.next.y !== l.y &&
                  p < ((l.next.x - l.x) * (m - l.y)) / (l.next.y - l.y) + l.x &&
                  (d = !d),
                  (l = l.next));
              while (l !== r);
              return d;
            })(n, t) &&
            (ri(n.prev, n, t.prev) || ri(n, t.prev, t))) ||
            (ia(n, t) &&
              ri(n.prev, n, n.next) > 0 &&
              ri(t.prev, t, t.next) > 0))
        );
      }
      function ri(n, t, r) {
        return (t.y - n.y) * (r.x - t.x) - (t.x - n.x) * (r.y - t.y);
      }
      function ia(n, t) {
        return n.x === t.x && n.y === t.y;
      }
      function wh(n, t, r, o) {
        const l = zu(ri(n, t, r)),
          d = zu(ri(n, t, o)),
          p = zu(ri(r, o, n)),
          m = zu(ri(r, o, t));
        return (
          (l !== d && p !== m) ||
          !(l !== 0 || !ku(n, r, t)) ||
          !(d !== 0 || !ku(n, o, t)) ||
          !(p !== 0 || !ku(r, n, o)) ||
          !(m !== 0 || !ku(r, t, o))
        );
      }
      function ku(n, t, r) {
        return (
          t.x <= Math.max(n.x, r.x) &&
          t.x >= Math.min(n.x, r.x) &&
          t.y <= Math.max(n.y, r.y) &&
          t.y >= Math.min(n.y, r.y)
        );
      }
      function zu(n) {
        return n > 0 ? 1 : n < 0 ? -1 : 0;
      }
      function fl(n, t) {
        return ri(n.prev, n, n.next) < 0
          ? ri(n, t, n.next) >= 0 && ri(n, n.prev, t) >= 0
          : ri(n, t, n.prev) < 0 || ri(n, n.next, t) < 0;
      }
      function Ch(n, t) {
        const r = Tc(n.i, n.x, n.y),
          o = Tc(t.i, t.x, t.y),
          l = n.next,
          d = t.prev;
        return (
          (n.next = t),
          (t.prev = n),
          (r.next = l),
          (l.prev = r),
          (o.next = r),
          (r.prev = o),
          (d.next = o),
          (o.prev = d),
          o
        );
      }
      function Eh(n, t, r, o) {
        const l = Tc(n, t, r);
        return (
          o
            ? ((l.next = o.next), (l.prev = o), (o.next.prev = l), (o.next = l))
            : ((l.prev = l), (l.next = l)),
          l
        );
      }
      function ml(n) {
        ((n.next.prev = n.prev),
          (n.prev.next = n.next),
          n.prevZ && (n.prevZ.nextZ = n.nextZ),
          n.nextZ && (n.nextZ.prevZ = n.prevZ));
      }
      function Tc(n, t, r) {
        return {
          i: n,
          x: t,
          y: r,
          prev: null,
          next: null,
          z: 0,
          prevZ: null,
          nextZ: null,
          steiner: !1,
        };
      }
      class ra {
        constructor(t, r) {
          if (r > t)
            throw new Error(
              "Min granularity must not be greater than base granularity.",
            );
          ((this._baseZoomGranularity = t), (this._minGranularity = r));
        }
        getGranularityForZoomLevel(t) {
          return Math.max(
            Math.floor(this._baseZoomGranularity / (1 << t)),
            this._minGranularity,
            1,
          );
        }
      }
      class Lu {
        constructor(t) {
          ((this.fill = t.fill),
            (this.line = t.line),
            (this.tile = t.tile),
            (this.stencil = t.stencil),
            (this.circle = t.circle));
        }
      }
      ((Lu.noSubdivision = new Lu({
        fill: new ra(0, 0),
        line: new ra(0, 0),
        tile: new ra(0, 0),
        stencil: new ra(0, 0),
        circle: 1,
      })),
        Re("SubdivisionGranularityExpression", ra),
        Re("SubdivisionGranularitySetting", Lu));
      const na = -32768,
        gl = 32767;
      class wp {
        constructor(t, r) {
          ((this._vertexBuffer = []),
            (this._vertexDictionary = new Map()),
            (this._used = !1),
            (this._granularity = t),
            (this._granularityCellSize = qe / t),
            (this._canonical = r));
        }
        _getKey(t, r) {
          return ((t += 32768) << 16) | ((r += 32768) << 0);
        }
        _vertexToIndex(t, r) {
          if (t < -32768 || r < -32768 || t > 32767 || r > 32767)
            throw new Error(
              "Vertex coordinates are out of signed 16 bit integer range.",
            );
          const o = 0 | Math.round(t),
            l = 0 | Math.round(r),
            d = this._getKey(o, l);
          if (this._vertexDictionary.has(d))
            return this._vertexDictionary.get(d);
          const p = this._vertexBuffer.length / 2;
          return (
            this._vertexDictionary.set(d, p),
            this._vertexBuffer.push(o, l),
            p
          );
        }
        _subdivideTrianglesScanline(t) {
          if (this._granularity < 2)
            return (function (l, d) {
              const p = [];
              for (let m = 0; m < d.length; m += 3) {
                const _ = d[m],
                  x = d[m + 1],
                  b = d[m + 2],
                  w = l[2 * _],
                  F = l[2 * _ + 1];
                (l[2 * x] - w) * (l[2 * b + 1] - F) -
                  (l[2 * x + 1] - F) * (l[2 * b] - w) >
                0
                  ? (p.push(_), p.push(b), p.push(x))
                  : (p.push(_), p.push(x), p.push(b));
              }
              return p;
            })(this._vertexBuffer, t);
          const r = [],
            o = t.length;
          for (let l = 0; l < o; l += 3) {
            const d = [t[l + 0], t[l + 1], t[l + 2]],
              p = [
                this._vertexBuffer[2 * t[l + 0] + 0],
                this._vertexBuffer[2 * t[l + 0] + 1],
                this._vertexBuffer[2 * t[l + 1] + 0],
                this._vertexBuffer[2 * t[l + 1] + 1],
                this._vertexBuffer[2 * t[l + 2] + 0],
                this._vertexBuffer[2 * t[l + 2] + 1],
              ];
            let m = 1 / 0,
              _ = 1 / 0,
              x = -1 / 0,
              b = -1 / 0;
            for (let I = 0; I < 3; I++) {
              const O = p[2 * I],
                Z = p[2 * I + 1];
              ((m = Math.min(m, O)),
                (x = Math.max(x, O)),
                (_ = Math.min(_, Z)),
                (b = Math.max(b, Z)));
            }
            if (m === x || _ === b) continue;
            const w = Math.floor(m / this._granularityCellSize),
              F = Math.ceil(x / this._granularityCellSize),
              S = Math.floor(_ / this._granularityCellSize),
              D = Math.ceil(b / this._granularityCellSize);
            if (w !== F || S !== D)
              for (let I = S; I < D; I++) {
                const O = this._scanlineGenerateVertexRingForCellRow(I, p, d);
                Cp(this._vertexBuffer, O, r);
              }
            else r.push(...d);
          }
          return r;
        }
        _scanlineGenerateVertexRingForCellRow(t, r, o) {
          const l = t * this._granularityCellSize,
            d = l + this._granularityCellSize,
            p = [];
          for (let m = 0; m < 3; m++) {
            const _ = r[2 * m],
              x = r[2 * m + 1],
              b = r[(2 * (m + 1)) % 6],
              w = r[(2 * (m + 1) + 1) % 6],
              F = r[(2 * (m + 2)) % 6],
              S = r[(2 * (m + 2) + 1) % 6],
              D = b - _,
              I = w - x,
              O = D === 0,
              Z = I === 0,
              ne = (l - x) / I,
              H = (d - x) / I,
              P = Math.min(ne, H),
              R = Math.max(ne, H);
            if ((!Z && (P >= 1 || R <= 0)) || (Z && (x < l || x > d))) {
              w >= l && w <= d && p.push(o[(m + 1) % 3]);
              continue;
            }
            !Z && P > 0 && p.push(this._vertexToIndex(_ + D * P, x + I * P));
            const W = _ + D * Math.max(P, 0),
              de = _ + D * Math.min(R, 1);
            (O || this._generateIntraEdgeVertices(p, _, x, b, w, W, de),
              !Z && R < 1 && p.push(this._vertexToIndex(_ + D * R, x + I * R)),
              (Z || (w >= l && w <= d)) && p.push(o[(m + 1) % 3]),
              !Z &&
                (w <= l || w >= d) &&
                this._generateInterEdgeVertices(p, _, x, b, w, F, S, de, l, d));
          }
          return p;
        }
        _generateIntraEdgeVertices(t, r, o, l, d, p, m) {
          const _ = l - r,
            x = d - o,
            b = x === 0,
            w = b ? Math.min(r, l) : Math.min(p, m),
            F = b ? Math.max(r, l) : Math.max(p, m),
            S = Math.floor(w / this._granularityCellSize) + 1,
            D = Math.ceil(F / this._granularityCellSize) - 1;
          if (b ? r < l : p < m)
            for (let I = S; I <= D; I++) {
              const O = I * this._granularityCellSize;
              t.push(this._vertexToIndex(O, o + (x * (O - r)) / _));
            }
          else
            for (let I = D; I >= S; I--) {
              const O = I * this._granularityCellSize;
              t.push(this._vertexToIndex(O, o + (x * (O - r)) / _));
            }
        }
        _generateInterEdgeVertices(t, r, o, l, d, p, m, _, x, b) {
          const w = d - o,
            F = p - l,
            S = m - d,
            D = (x - d) / S,
            I = (b - d) / S,
            O = Math.min(D, I),
            Z = Math.max(D, I),
            ne = l + F * O;
          let H = Math.floor(Math.min(ne, _) / this._granularityCellSize) + 1,
            P = Math.ceil(Math.max(ne, _) / this._granularityCellSize) - 1,
            R = _ < ne;
          const W = S === 0;
          if (W && (m === x || m === b)) return;
          if (W || O >= 1 || Z <= 0) {
            const Te = o - m,
              ge = p + (r - p) * Math.min((x - m) / Te, (b - m) / Te);
            ((H = Math.floor(Math.min(ge, _) / this._granularityCellSize) + 1),
              (P = Math.ceil(Math.max(ge, _) / this._granularityCellSize) - 1),
              (R = _ < ge));
          }
          const de = w > 0 ? b : x;
          if (R)
            for (let Te = H; Te <= P; Te++)
              t.push(this._vertexToIndex(Te * this._granularityCellSize, de));
          else
            for (let Te = P; Te >= H; Te--)
              t.push(this._vertexToIndex(Te * this._granularityCellSize, de));
        }
        _generateOutline(t) {
          const r = [];
          for (const o of t) {
            const l = Qo(o, this._granularity, !0),
              d = this._pointArrayToIndices(l),
              p = [];
            for (let m = 1; m < d.length; m++) (p.push(d[m - 1]), p.push(d[m]));
            r.push(p);
          }
          return r;
        }
        _handlePoles(t) {
          let r = !1,
            o = !1;
          (this._canonical &&
            (this._canonical.y === 0 && (r = !0),
            this._canonical.y === (1 << this._canonical.z) - 1 && (o = !0)),
            (r || o) && this._fillPoles(t, r, o));
        }
        _ensureNoPoleVertices() {
          const t = this._vertexBuffer;
          for (let r = 0; r < t.length; r += 2) {
            const o = t[r + 1];
            (o === na && (t[r + 1] = -32767), o === gl && (t[r + 1] = 32766));
          }
        }
        _generatePoleQuad(t, r, o, l, d, p) {
          l > d != (p === na)
            ? (t.push(r),
              t.push(o),
              t.push(this._vertexToIndex(l, p)),
              t.push(o),
              t.push(this._vertexToIndex(d, p)),
              t.push(this._vertexToIndex(l, p)))
            : (t.push(o),
              t.push(r),
              t.push(this._vertexToIndex(l, p)),
              t.push(this._vertexToIndex(d, p)),
              t.push(o),
              t.push(this._vertexToIndex(l, p)));
        }
        _fillPoles(t, r, o) {
          const l = this._vertexBuffer,
            d = qe,
            p = t.length;
          for (let m = 2; m < p; m += 3) {
            const _ = t[m - 2],
              x = t[m - 1],
              b = t[m],
              w = l[2 * _],
              F = l[2 * _ + 1],
              S = l[2 * x],
              D = l[2 * x + 1],
              I = l[2 * b],
              O = l[2 * b + 1];
            (r &&
              (F === 0 && D === 0 && this._generatePoleQuad(t, _, x, w, S, na),
              D === 0 && O === 0 && this._generatePoleQuad(t, x, b, S, I, na),
              O === 0 && F === 0 && this._generatePoleQuad(t, b, _, I, w, na)),
              o &&
                (F === d &&
                  D === d &&
                  this._generatePoleQuad(t, _, x, w, S, gl),
                D === d && O === d && this._generatePoleQuad(t, x, b, S, I, gl),
                O === d &&
                  F === d &&
                  this._generatePoleQuad(t, b, _, I, w, gl)));
          }
        }
        _initializeVertices(t) {
          for (let r = 0; r < t.length; r += 2)
            this._vertexToIndex(t[r], t[r + 1]);
        }
        subdividePolygonInternal(t, r) {
          if (this._used)
            throw new Error("Subdivision: multiple use not allowed.");
          this._used = !0;
          const { flattened: o, holeIndices: l } = (function (m) {
            const _ = [],
              x = [];
            for (const b of m)
              if (b.length !== 0) {
                b !== m[0] && _.push(x.length / 2);
                for (let w = 0; w < b.length; w++)
                  (x.push(b[w].x), x.push(b[w].y));
              }
            return { flattened: x, holeIndices: _ };
          })(t);
          let d;
          this._initializeVertices(o);
          try {
            const m = (function (x, b, w = 2) {
                const F = b && b.length,
                  S = F ? b[0] * w : x.length;
                let D = vh(x, 0, S, w, !0);
                const I = [];
                if (!D || D.next === D.prev) return I;
                let O, Z, ne;
                if (
                  (F &&
                    (D = (function (H, P, R, W) {
                      const de = [];
                      for (let Te = 0, ge = P.length; Te < ge; Te++) {
                        const xe = vh(
                          H,
                          P[Te] * W,
                          Te < ge - 1 ? P[Te + 1] * W : H.length,
                          W,
                          !1,
                        );
                        (xe === xe.next && (xe.steiner = !0), de.push(vp(xe)));
                      }
                      de.sort(_p);
                      for (let Te = 0; Te < de.length; Te++) R = yp(de[Te], R);
                      return R;
                    })(x, b, D, w)),
                  x.length > 80 * w)
                ) {
                  ((O = 1 / 0), (Z = 1 / 0));
                  let H = -1 / 0,
                    P = -1 / 0;
                  for (let R = w; R < S; R += w) {
                    const W = x[R],
                      de = x[R + 1];
                    (W < O && (O = W),
                      de < Z && (Z = de),
                      W > H && (H = W),
                      de > P && (P = de));
                  }
                  ((ne = Math.max(H - O, P - Z)),
                    (ne = ne !== 0 ? 32767 / ne : 0));
                }
                return (dl(D, I, w, O, Z, ne, 0), I);
              })(o, l),
              _ = this._convertIndices(o, m);
            d = this._subdivideTrianglesScanline(_);
          } catch (m) {
            console.error(m);
          }
          let p = [];
          return (
            r && (p = this._generateOutline(t)),
            this._ensureNoPoleVertices(),
            this._handlePoles(d),
            {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: d,
              indicesLineList: p,
            }
          );
        }
        _convertIndices(t, r) {
          const o = [];
          for (let l = 0; l < r.length; l++)
            o.push(this._vertexToIndex(t[2 * r[l]], t[2 * r[l] + 1]));
          return o;
        }
        _pointArrayToIndices(t) {
          const r = [];
          for (let o = 0; o < t.length; o++) {
            const l = t[o];
            r.push(this._vertexToIndex(l.x, l.y));
          }
          return r;
        }
      }
      function Ah(n, t, r, o = !0) {
        return new wp(r, t).subdividePolygonInternal(n, o);
      }
      function Qo(n, t, r = !1) {
        if (!n || n.length < 1) return [];
        if (n.length < 2) return [];
        const o = n[0],
          l = n[n.length - 1],
          d = r && (o.x !== l.x || o.y !== l.y);
        if (t < 2) return d ? [...n, n[0]] : [...n];
        const p = Math.floor(qe / t),
          m = [];
        m.push(new Ze(n[0].x, n[0].y));
        const _ = n.length,
          x = d ? _ : _ - 1;
        for (let b = 0; b < x; b++) {
          const w = n[b],
            F = b < _ - 1 ? n[b + 1] : n[0],
            S = w.x,
            D = w.y,
            I = F.x,
            O = F.y,
            Z = S !== I,
            ne = D !== O;
          if (!Z && !ne) continue;
          const H = I - S,
            P = O - D,
            R = Math.abs(H),
            W = Math.abs(P);
          let de = S,
            Te = D;
          for (;;) {
            const xe =
                H > 0
                  ? (Math.floor(de / p) + 1) * p
                  : (Math.ceil(de / p) - 1) * p,
              Se =
                P > 0
                  ? (Math.floor(Te / p) + 1) * p
                  : (Math.ceil(Te / p) - 1) * p,
              Pe = Math.abs(de - xe),
              De = Math.abs(Te - Se),
              we = Math.abs(de - I),
              Ne = Math.abs(Te - O),
              Ke = Z ? Pe / R : Number.POSITIVE_INFINITY,
              We = ne ? De / W : Number.POSITIVE_INFINITY;
            if ((we <= Pe || !Z) && (Ne <= De || !ne)) break;
            if ((Ke < We && Z) || !ne) {
              ((de = xe), (Te += P * Ke));
              const Ge = new Ze(de, Math.round(Te));
              (m[m.length - 1].x === Ge.x && m[m.length - 1].y === Ge.y) ||
                m.push(Ge);
            } else {
              ((de += H * We), (Te = Se));
              const Ge = new Ze(Math.round(de), Te);
              (m[m.length - 1].x === Ge.x && m[m.length - 1].y === Ge.y) ||
                m.push(Ge);
            }
          }
          const ge = new Ze(I, O);
          (m[m.length - 1].x === ge.x && m[m.length - 1].y === ge.y) ||
            m.push(ge);
        }
        return m;
      }
      function Cp(n, t, r) {
        if (t.length === 0)
          throw new Error("Subdivision vertex ring is empty.");
        let o = 0,
          l = n[2 * t[0]];
        for (let _ = 1; _ < t.length; _++) {
          const x = n[2 * t[_]];
          x < l && ((l = x), (o = _));
        }
        const d = t.length;
        let p = o,
          m = (p + 1) % d;
        for (;;) {
          const _ = p - 1 >= 0 ? p - 1 : d - 1,
            x = (m + 1) % d,
            b = n[2 * t[_]],
            w = n[2 * t[x]],
            F = n[2 * t[p]],
            S = n[2 * t[p] + 1],
            D = n[2 * t[m] + 1];
          let I = !1;
          if (b < w) I = !0;
          else if (b > w) I = !1;
          else {
            const O = D - S,
              Z = -(n[2 * t[m]] - F),
              ne = S < D ? 1 : -1;
            ((b - F) * O + (n[2 * t[_] + 1] - S) * Z) * ne >
              ((w - F) * O + (n[2 * t[x] + 1] - S) * Z) * ne && (I = !0);
          }
          if (I) {
            const O = t[_],
              Z = t[p],
              ne = t[m];
            (O !== Z && O !== ne && Z !== ne && r.push(ne, Z, O),
              p--,
              p < 0 && (p = d - 1));
          } else {
            const O = t[x],
              Z = t[p],
              ne = t[m];
            (O !== Z && O !== ne && Z !== ne && r.push(ne, Z, O),
              m++,
              m >= d && (m = 0));
          }
          if (_ === x) break;
        }
      }
      function Th(n, t, r, o, l, d, p, m, _) {
        const x = l.length / 2,
          b = p && m && _;
        if (x < Le.MAX_VERTEX_ARRAY_LENGTH) {
          const w = t.prepareSegment(x, r, o),
            F = w.vertexLength;
          for (let I = 0; I < d.length; I += 3)
            o.emplaceBack(F + d[I], F + d[I + 1], F + d[I + 2]);
          let S, D;
          ((w.vertexLength += x),
            (w.primitiveLength += d.length / 3),
            b &&
              ((D = p.prepareSegment(x, r, m)),
              (S = D.vertexLength),
              (D.vertexLength += x)));
          for (let I = 0; I < l.length; I += 2) n(l[I], l[I + 1]);
          if (b)
            for (let I = 0; I < _.length; I++) {
              const O = _[I];
              for (let Z = 1; Z < O.length; Z += 2)
                m.emplaceBack(S + O[Z - 1], S + O[Z]);
              D.primitiveLength += O.length / 2;
            }
        } else
          ((function (w, F, S, D, I, O) {
            const Z = [];
            for (let W = 0; W < D.length / 2; W++) Z.push(-1);
            const ne = { count: 0 };
            let H = 0,
              P = w.getOrCreateLatestSegment(F, S),
              R = P.vertexLength;
            for (let W = 2; W < I.length; W += 3) {
              const de = I[W - 2],
                Te = I[W - 1],
                ge = I[W];
              let xe = Z[de] < H,
                Se = Z[Te] < H,
                Pe = Z[ge] < H;
              P.vertexLength + ((xe ? 1 : 0) + (Se ? 1 : 0) + (Pe ? 1 : 0)) >
                Le.MAX_VERTEX_ARRAY_LENGTH &&
                ((P = w.createNewSegment(F, S)),
                (H = ne.count),
                (xe = !0),
                (Se = !0),
                (Pe = !0),
                (R = 0));
              const De = _l(Z, D, O, ne, de, xe, P),
                we = _l(Z, D, O, ne, Te, Se, P),
                Ne = _l(Z, D, O, ne, ge, Pe, P);
              (S.emplaceBack(R + De - H, R + we - H, R + Ne - H),
                P.primitiveLength++);
            }
          })(t, r, o, l, d, n),
            b &&
              (function (w, F, S, D, I, O) {
                const Z = [];
                for (let W = 0; W < D.length / 2; W++) Z.push(-1);
                const ne = { count: 0 };
                let H = 0,
                  P = w.getOrCreateLatestSegment(F, S),
                  R = P.vertexLength;
                for (let W = 0; W < I.length; W++) {
                  const de = I[W];
                  for (let Te = 1; Te < I[W].length; Te += 2) {
                    const ge = de[Te - 1],
                      xe = de[Te];
                    let Se = Z[ge] < H,
                      Pe = Z[xe] < H;
                    P.vertexLength + ((Se ? 1 : 0) + (Pe ? 1 : 0)) >
                      Le.MAX_VERTEX_ARRAY_LENGTH &&
                      ((P = w.createNewSegment(F, S)),
                      (H = ne.count),
                      (Se = !0),
                      (Pe = !0),
                      (R = 0));
                    const De = _l(Z, D, O, ne, ge, Se, P),
                      we = _l(Z, D, O, ne, xe, Pe, P);
                    (S.emplaceBack(R + De - H, R + we - H),
                      P.primitiveLength++);
                  }
                }
              })(p, r, m, l, _, n),
            t.forceNewSegmentOnNextPrepare(),
            p == null || p.forceNewSegmentOnNextPrepare());
      }
      function _l(n, t, r, o, l, d, p) {
        if (d) {
          const m = o.count;
          return (
            r(t[2 * l], t[2 * l + 1]),
            (n[l] = o.count),
            o.count++,
            p.vertexLength++,
            m
          );
        }
        return n[l];
      }
      class Fc {
        constructor(t) {
          ((this.zoom = t.zoom),
            (this.overscaling = t.overscaling),
            (this.layers = t.layers),
            (this.layerIds = this.layers.map((r) => r.id)),
            (this.index = t.index),
            (this.hasPattern = !1),
            (this.patternFeatures = []),
            (this.layoutVertexArray = new G()),
            (this.indexArray = new ye()),
            (this.indexArray2 = new Be()),
            (this.programConfigurations = new Gt(t.layers, t.zoom)),
            (this.segments = new Le()),
            (this.segments2 = new Le()),
            (this.stateDependentLayerIds = this.layers
              .filter((r) => r.isStateDependent())
              .map((r) => r.id)));
        }
        populate(t, r, o) {
          this.hasPattern = Cc("fill", this.layers, r);
          const l = this.layers[0].layout.get("fill-sort-key"),
            d = !l.isConstant(),
            p = [];
          for (const {
            feature: m,
            id: _,
            index: x,
            sourceLayerIndex: b,
          } of t) {
            const w = this.layers[0]._featureFilter.needGeometry,
              F = Vn(m, w);
            if (!this.layers[0]._featureFilter.filter(new jt(this.zoom), F, o))
              continue;
            const S = d ? l.evaluate(F, {}, o, r.availableImages) : void 0,
              D = {
                id: _,
                properties: m.properties,
                type: m.type,
                sourceLayerIndex: b,
                index: x,
                geometry: w ? F.geometry : Nn(m),
                patterns: {},
                sortKey: S,
              };
            p.push(D);
          }
          d && p.sort((m, _) => m.sortKey - _.sortKey);
          for (const m of p) {
            const { geometry: _, index: x, sourceLayerIndex: b } = m;
            if (this.hasPattern) {
              const w = Ec("fill", this.layers, m, this.zoom, r);
              this.patternFeatures.push(w);
            } else this.addFeature(m, _, x, o, {}, r.subdivisionGranularity);
            r.featureIndex.insert(t[x].feature, _, x, b, this.index);
          }
        }
        update(t, r, o) {
          this.stateDependentLayers.length &&
            this.programConfigurations.updatePaintArrays(
              t,
              r,
              this.stateDependentLayers,
              o,
            );
        }
        addFeatures(t, r, o) {
          for (const l of this.patternFeatures)
            this.addFeature(
              l,
              l.geometry,
              l.index,
              r,
              o,
              t.subdivisionGranularity,
            );
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          (this.uploaded ||
            ((this.layoutVertexBuffer = t.createVertexBuffer(
              this.layoutVertexArray,
              dp,
            )),
            (this.indexBuffer = t.createIndexBuffer(this.indexArray)),
            (this.indexBuffer2 = t.createIndexBuffer(this.indexArray2))),
            this.programConfigurations.upload(t),
            (this.uploaded = !0));
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.indexBuffer2.destroy(),
            this.programConfigurations.destroy(),
            this.segments.destroy(),
            this.segments2.destroy());
        }
        addFeature(t, r, o, l, d, p) {
          for (const m of Kn(r, 500)) {
            const _ = Ah(m, l, p.fill.getGranularityForZoomLevel(l.z)),
              x = this.layoutVertexArray;
            Th(
              (b, w) => {
                x.emplaceBack(b, w);
              },
              this.segments,
              this.layoutVertexArray,
              this.indexArray,
              _.verticesFlattened,
              _.indicesTriangles,
              this.segments2,
              this.indexArray2,
              _.indicesLineList,
            );
          }
          this.programConfigurations.populatePaintArrays(
            this.layoutVertexArray.length,
            t,
            o,
            d,
            l,
          );
        }
      }
      let Fh, Ph;
      Re("FillBucket", Fc, { omit: ["layers", "patternFeatures"] });
      var Ep = {
        get paint() {
          return (Ph =
            Ph ||
            new $i({
              "fill-antialias": new He(j.paint_fill["fill-antialias"]),
              "fill-opacity": new et(j.paint_fill["fill-opacity"]),
              "fill-color": new et(j.paint_fill["fill-color"]),
              "fill-outline-color": new et(j.paint_fill["fill-outline-color"]),
              "fill-translate": new He(j.paint_fill["fill-translate"]),
              "fill-translate-anchor": new He(
                j.paint_fill["fill-translate-anchor"],
              ),
              "fill-pattern": new $o(j.paint_fill["fill-pattern"]),
            }));
        },
        get layout() {
          return (Fh =
            Fh ||
            new $i({
              "fill-sort-key": new et(j.layout_fill["fill-sort-key"]),
            }));
        },
      };
      class Ap extends Mr {
        constructor(t) {
          super(t, Ep);
        }
        recalculate(t, r) {
          super.recalculate(t, r);
          const o = this.paint._values["fill-outline-color"];
          o.value.kind === "constant" &&
            o.value.value === void 0 &&
            (this.paint._values["fill-outline-color"] =
              this.paint._values["fill-color"]);
        }
        createBucket(t) {
          return new Fc(t);
        }
        queryRadius() {
          return Iu(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature({
          queryGeometry: t,
          geometry: r,
          transform: o,
          pixelsToTileUnits: l,
        }) {
          return ll(
            Bu(
              t,
              this.paint.get("fill-translate"),
              this.paint.get("fill-translate-anchor"),
              -o.bearingInRadians,
              l,
            ),
            r,
          );
        }
        isTileClipped() {
          return !0;
        }
      }
      const Tp = ii(
          [
            { name: "a_pos", components: 2, type: "Int16" },
            { name: "a_normal_ed", components: 4, type: "Int16" },
          ],
          4,
        ),
        Fp = ii([{ name: "a_centroid", components: 2, type: "Int16" }], 4),
        { members: Pp } = Tp;
      var Pc,
        Sh,
        Sc,
        Dh,
        Dc,
        Mh,
        Ih,
        Ru = {};
      function Bh() {
        if (Sh) return Pc;
        Sh = 1;
        var n = li();
        function t(l, d, p, m, _) {
          ((this.properties = {}),
            (this.extent = p),
            (this.type = 0),
            (this._pbf = l),
            (this._geometry = -1),
            (this._keys = m),
            (this._values = _),
            l.readFields(r, this, d));
        }
        function r(l, d, p) {
          l == 1
            ? (d.id = p.readVarint())
            : l == 2
              ? (function (m, _) {
                  for (var x = m.readVarint() + m.pos; m.pos < x; ) {
                    var b = _._keys[m.readVarint()],
                      w = _._values[m.readVarint()];
                    _.properties[b] = w;
                  }
                })(p, d)
              : l == 3
                ? (d.type = p.readVarint())
                : l == 4 && (d._geometry = p.pos);
        }
        function o(l) {
          for (var d, p, m = 0, _ = 0, x = l.length, b = x - 1; _ < x; b = _++)
            m += ((p = l[b]).x - (d = l[_]).x) * (d.y + p.y);
          return m;
        }
        return (
          (Pc = t),
          (t.types = ["Unknown", "Point", "LineString", "Polygon"]),
          (t.prototype.loadGeometry = function () {
            var l = this._pbf;
            l.pos = this._geometry;
            for (
              var d,
                p = l.readVarint() + l.pos,
                m = 1,
                _ = 0,
                x = 0,
                b = 0,
                w = [];
              l.pos < p;

            ) {
              if (_ <= 0) {
                var F = l.readVarint();
                ((m = 7 & F), (_ = F >> 3));
              }
              if ((_--, m === 1 || m === 2))
                ((x += l.readSVarint()),
                  (b += l.readSVarint()),
                  m === 1 && (d && w.push(d), (d = [])),
                  d.push(new n(x, b)));
              else {
                if (m !== 7) throw new Error("unknown command " + m);
                d && d.push(d[0].clone());
              }
            }
            return (d && w.push(d), w);
          }),
          (t.prototype.bbox = function () {
            var l = this._pbf;
            l.pos = this._geometry;
            for (
              var d = l.readVarint() + l.pos,
                p = 1,
                m = 0,
                _ = 0,
                x = 0,
                b = 1 / 0,
                w = -1 / 0,
                F = 1 / 0,
                S = -1 / 0;
              l.pos < d;

            ) {
              if (m <= 0) {
                var D = l.readVarint();
                ((p = 7 & D), (m = D >> 3));
              }
              if ((m--, p === 1 || p === 2))
                ((_ += l.readSVarint()) < b && (b = _),
                  _ > w && (w = _),
                  (x += l.readSVarint()) < F && (F = x),
                  x > S && (S = x));
              else if (p !== 7) throw new Error("unknown command " + p);
            }
            return [b, F, w, S];
          }),
          (t.prototype.toGeoJSON = function (l, d, p) {
            var m,
              _,
              x = this.extent * Math.pow(2, p),
              b = this.extent * l,
              w = this.extent * d,
              F = this.loadGeometry(),
              S = t.types[this.type];
            function D(Z) {
              for (var ne = 0; ne < Z.length; ne++) {
                var H = Z[ne];
                Z[ne] = [
                  (360 * (H.x + b)) / x - 180,
                  (360 / Math.PI) *
                    Math.atan(
                      Math.exp(((180 - (360 * (H.y + w)) / x) * Math.PI) / 180),
                    ) -
                    90,
                ];
              }
            }
            switch (this.type) {
              case 1:
                var I = [];
                for (m = 0; m < F.length; m++) I[m] = F[m][0];
                D((F = I));
                break;
              case 2:
                for (m = 0; m < F.length; m++) D(F[m]);
                break;
              case 3:
                for (
                  F = (function (Z) {
                    var ne = Z.length;
                    if (ne <= 1) return [Z];
                    for (var H, P, R = [], W = 0; W < ne; W++) {
                      var de = o(Z[W]);
                      de !== 0 &&
                        (P === void 0 && (P = de < 0),
                        P === de < 0
                          ? (H && R.push(H), (H = [Z[W]]))
                          : H.push(Z[W]));
                    }
                    return (H && R.push(H), R);
                  })(F),
                    m = 0;
                  m < F.length;
                  m++
                )
                  for (_ = 0; _ < F[m].length; _++) D(F[m][_]);
            }
            F.length === 1 ? (F = F[0]) : (S = "Multi" + S);
            var O = {
              type: "Feature",
              geometry: { type: S, coordinates: F },
              properties: this.properties,
            };
            return ("id" in this && (O.id = this.id), O);
          }),
          Pc
        );
      }
      function kh() {
        if (Dh) return Sc;
        Dh = 1;
        var n = Bh();
        function t(o, l) {
          ((this.version = 1),
            (this.name = null),
            (this.extent = 4096),
            (this.length = 0),
            (this._pbf = o),
            (this._keys = []),
            (this._values = []),
            (this._features = []),
            o.readFields(r, this, l),
            (this.length = this._features.length));
        }
        function r(o, l, d) {
          o === 15
            ? (l.version = d.readVarint())
            : o === 1
              ? (l.name = d.readString())
              : o === 5
                ? (l.extent = d.readVarint())
                : o === 2
                  ? l._features.push(d.pos)
                  : o === 3
                    ? l._keys.push(d.readString())
                    : o === 4 &&
                      l._values.push(
                        (function (p) {
                          for (
                            var m = null, _ = p.readVarint() + p.pos;
                            p.pos < _;

                          ) {
                            var x = p.readVarint() >> 3;
                            m =
                              x === 1
                                ? p.readString()
                                : x === 2
                                  ? p.readFloat()
                                  : x === 3
                                    ? p.readDouble()
                                    : x === 4
                                      ? p.readVarint64()
                                      : x === 5
                                        ? p.readVarint()
                                        : x === 6
                                          ? p.readSVarint()
                                          : x === 7
                                            ? p.readBoolean()
                                            : null;
                          }
                          return m;
                        })(d),
                      );
        }
        return (
          (Sc = t),
          (t.prototype.feature = function (o) {
            if (o < 0 || o >= this._features.length)
              throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[o];
            var l = this._pbf.readVarint() + this._pbf.pos;
            return new n(this._pbf, l, this.extent, this._keys, this._values);
          }),
          Sc
        );
      }
      function zh() {
        return (
          Ih ||
            ((Ih = 1),
            (Ru.VectorTile = (function () {
              if (Mh) return Dc;
              Mh = 1;
              var n = kh();
              function t(r, o, l) {
                if (r === 3) {
                  var d = new n(l, l.readVarint() + l.pos);
                  d.length && (o[d.name] = d);
                }
              }
              return (
                (Dc = function (r, o) {
                  this.layers = r.readFields(t, {}, o);
                }),
                Dc
              );
            })()),
            (Ru.VectorTileFeature = Bh()),
            (Ru.VectorTileLayer = kh())),
          Ru
        );
      }
      var yl = Ue(zh());
      const Sp = yl.VectorTileFeature.types,
        Mc = Math.pow(2, 13);
      function xl(n, t, r, o, l, d, p, m) {
        n.emplaceBack(
          t,
          r,
          2 * Math.floor(o * Mc) + p,
          l * Mc * 2,
          d * Mc * 2,
          Math.round(m),
        );
      }
      class Ic {
        constructor(t) {
          ((this.zoom = t.zoom),
            (this.overscaling = t.overscaling),
            (this.layers = t.layers),
            (this.layerIds = this.layers.map((r) => r.id)),
            (this.index = t.index),
            (this.hasPattern = !1),
            (this.layoutVertexArray = new Y()),
            (this.centroidVertexArray = new N()),
            (this.indexArray = new ye()),
            (this.programConfigurations = new Gt(t.layers, t.zoom)),
            (this.segments = new Le()),
            (this.stateDependentLayerIds = this.layers
              .filter((r) => r.isStateDependent())
              .map((r) => r.id)));
        }
        populate(t, r, o) {
          ((this.features = []),
            (this.hasPattern = Cc("fill-extrusion", this.layers, r)));
          for (const {
            feature: l,
            id: d,
            index: p,
            sourceLayerIndex: m,
          } of t) {
            const _ = this.layers[0]._featureFilter.needGeometry,
              x = Vn(l, _);
            if (!this.layers[0]._featureFilter.filter(new jt(this.zoom), x, o))
              continue;
            const b = {
              id: d,
              sourceLayerIndex: m,
              index: p,
              geometry: _ ? x.geometry : Nn(l),
              properties: l.properties,
              type: l.type,
              patterns: {},
            };
            (this.hasPattern
              ? this.features.push(
                  Ec("fill-extrusion", this.layers, b, this.zoom, r),
                )
              : this.addFeature(
                  b,
                  b.geometry,
                  p,
                  o,
                  {},
                  r.subdivisionGranularity,
                ),
              r.featureIndex.insert(l, b.geometry, p, m, this.index, !0));
          }
        }
        addFeatures(t, r, o) {
          for (const l of this.features) {
            const { geometry: d } = l;
            this.addFeature(l, d, l.index, r, o, t.subdivisionGranularity);
          }
        }
        update(t, r, o) {
          this.stateDependentLayers.length &&
            this.programConfigurations.updatePaintArrays(
              t,
              r,
              this.stateDependentLayers,
              o,
            );
        }
        isEmpty() {
          return (
            this.layoutVertexArray.length === 0 &&
            this.centroidVertexArray.length === 0
          );
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          (this.uploaded ||
            ((this.layoutVertexBuffer = t.createVertexBuffer(
              this.layoutVertexArray,
              Pp,
            )),
            (this.centroidVertexBuffer = t.createVertexBuffer(
              this.centroidVertexArray,
              Fp.members,
              !0,
            )),
            (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
            this.programConfigurations.upload(t),
            (this.uploaded = !0));
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.programConfigurations.destroy(),
            this.segments.destroy(),
            this.centroidVertexBuffer.destroy());
        }
        addFeature(t, r, o, l, d, p) {
          for (const m of Kn(r, 500)) {
            const _ = { x: 0, y: 0, sampleCount: 0 },
              x = this.layoutVertexArray.length;
            this.processPolygon(_, l, t, m, p);
            const b = this.layoutVertexArray.length - x,
              w = Math.floor(_.x / _.sampleCount),
              F = Math.floor(_.y / _.sampleCount);
            for (let S = 0; S < b; S++)
              this.centroidVertexArray.emplaceBack(w, F);
          }
          this.programConfigurations.populatePaintArrays(
            this.layoutVertexArray.length,
            t,
            o,
            d,
            l,
          );
        }
        processPolygon(t, r, o, l, d) {
          if (l.length < 1 || Lh(l[0])) return;
          for (const w of l) w.length !== 0 && Dp(t, w);
          const p = {
              segment: this.segments.prepareSegment(
                4,
                this.layoutVertexArray,
                this.indexArray,
              ),
            },
            m = d.fill.getGranularityForZoomLevel(r.z),
            _ = Sp[o.type] === "Polygon";
          for (const w of l) {
            if (w.length === 0 || Lh(w)) continue;
            const F = Qo(w, m, _);
            this._generateSideFaces(F, p);
          }
          if (!_) return;
          const x = Ah(l, r, m, !1),
            b = this.layoutVertexArray;
          Th(
            (w, F) => {
              xl(b, w, F, 0, 0, 1, 1, 0);
            },
            this.segments,
            this.layoutVertexArray,
            this.indexArray,
            x.verticesFlattened,
            x.indicesTriangles,
          );
        }
        _generateSideFaces(t, r) {
          let o = 0;
          for (let l = 1; l < t.length; l++) {
            const d = t[l],
              p = t[l - 1];
            if (Mp(d, p)) continue;
            r.segment.vertexLength + 4 > Le.MAX_VERTEX_ARRAY_LENGTH &&
              (r.segment = this.segments.prepareSegment(
                4,
                this.layoutVertexArray,
                this.indexArray,
              ));
            const m = d.sub(p)._perp()._unit(),
              _ = p.dist(d);
            (o + _ > 32768 && (o = 0),
              xl(this.layoutVertexArray, d.x, d.y, m.x, m.y, 0, 0, o),
              xl(this.layoutVertexArray, d.x, d.y, m.x, m.y, 0, 1, o),
              (o += _),
              xl(this.layoutVertexArray, p.x, p.y, m.x, m.y, 0, 0, o),
              xl(this.layoutVertexArray, p.x, p.y, m.x, m.y, 0, 1, o));
            const x = r.segment.vertexLength;
            (this.indexArray.emplaceBack(x, x + 2, x + 1),
              this.indexArray.emplaceBack(x + 1, x + 2, x + 3),
              (r.segment.vertexLength += 4),
              (r.segment.primitiveLength += 2));
          }
        }
      }
      function Dp(n, t) {
        for (let r = 0; r < t.length; r++) {
          const o = t[r];
          (r === t.length - 1 && t[0].x === o.x && t[0].y === o.y) ||
            ((n.x += o.x), (n.y += o.y), n.sampleCount++);
        }
      }
      function Mp(n, t) {
        return (
          (n.x === t.x && (n.x < 0 || n.x > qe)) ||
          (n.y === t.y && (n.y < 0 || n.y > qe))
        );
      }
      function Lh(n) {
        return (
          n.every((t) => t.x < 0) ||
          n.every((t) => t.x > qe) ||
          n.every((t) => t.y < 0) ||
          n.every((t) => t.y > qe)
        );
      }
      let Rh;
      Re("FillExtrusionBucket", Ic, { omit: ["layers", "features"] });
      var Ip = {
        get paint() {
          return (Rh =
            Rh ||
            new $i({
              "fill-extrusion-opacity": new He(
                j["paint_fill-extrusion"]["fill-extrusion-opacity"],
              ),
              "fill-extrusion-color": new et(
                j["paint_fill-extrusion"]["fill-extrusion-color"],
              ),
              "fill-extrusion-translate": new He(
                j["paint_fill-extrusion"]["fill-extrusion-translate"],
              ),
              "fill-extrusion-translate-anchor": new He(
                j["paint_fill-extrusion"]["fill-extrusion-translate-anchor"],
              ),
              "fill-extrusion-pattern": new $o(
                j["paint_fill-extrusion"]["fill-extrusion-pattern"],
              ),
              "fill-extrusion-height": new et(
                j["paint_fill-extrusion"]["fill-extrusion-height"],
              ),
              "fill-extrusion-base": new et(
                j["paint_fill-extrusion"]["fill-extrusion-base"],
              ),
              "fill-extrusion-vertical-gradient": new He(
                j["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"],
              ),
            }));
        },
      };
      class Bp extends Mr {
        constructor(t) {
          super(t, Ip);
        }
        createBucket(t) {
          return new Ic(t);
        }
        queryRadius() {
          return Iu(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature({
          queryGeometry: t,
          feature: r,
          featureState: o,
          geometry: l,
          transform: d,
          pixelsToTileUnits: p,
          pixelPosMatrix: m,
        }) {
          const _ = Bu(
              t,
              this.paint.get("fill-extrusion-translate"),
              this.paint.get("fill-extrusion-translate-anchor"),
              -d.bearingInRadians,
              p,
            ),
            x = this.paint.get("fill-extrusion-height").evaluate(r, o),
            b = this.paint.get("fill-extrusion-base").evaluate(r, o),
            w = (function (S, D, I) {
              const O = [];
              for (const Z of S) {
                const ne = [Z.x, Z.y, 0, 1];
                (sr(ne, ne, D), O.push(new Ze(ne[0] / ne[3], ne[1] / ne[3])));
              }
              return O;
            })(_, m),
            F = (function (S, D, I, O) {
              const Z = [],
                ne = [],
                H = O[8] * D,
                P = O[9] * D,
                R = O[10] * D,
                W = O[11] * D,
                de = O[8] * I,
                Te = O[9] * I,
                ge = O[10] * I,
                xe = O[11] * I;
              for (const Se of S) {
                const Pe = [],
                  De = [];
                for (const we of Se) {
                  const Ne = we.x,
                    Ke = we.y,
                    We = O[0] * Ne + O[4] * Ke + O[12],
                    Ge = O[1] * Ne + O[5] * Ke + O[13],
                    dt = O[2] * Ne + O[6] * Ke + O[14],
                    Xt = O[3] * Ne + O[7] * Ke + O[15],
                    di = dt + R,
                    bi = Xt + W,
                    Br = We + de,
                    Gi = Ge + Te,
                    wi = dt + ge,
                    Si = Xt + xe,
                    Jt = new Ze((We + H) / bi, (Ge + P) / bi);
                  ((Jt.z = di / bi), Pe.push(Jt));
                  const pi = new Ze(Br / Si, Gi / Si);
                  ((pi.z = wi / Si), De.push(pi));
                }
                (Z.push(Pe), ne.push(De));
              }
              return [Z, ne];
            })(l, b, x, m);
          return (function (S, D, I) {
            let O = 1 / 0;
            ll(I, D) && (O = Oh(I, D[0]));
            for (let Z = 0; Z < D.length; Z++) {
              const ne = D[Z],
                H = S[Z];
              for (let P = 0; P < ne.length - 1; P++) {
                const R = ne[P],
                  W = [R, ne[P + 1], H[P + 1], H[P], R];
                sl(I, W) && (O = Math.min(O, Oh(I, W)));
              }
            }
            return O !== 1 / 0 && O;
          })(F[0], F[1], w);
        }
      }
      function vl(n, t) {
        return n.x * t.x + n.y * t.y;
      }
      function Oh(n, t) {
        if (n.length === 1) {
          let r = 0;
          const o = t[r++];
          let l;
          for (; !l || o.equals(l); ) if (((l = t[r++]), !l)) return 1 / 0;
          for (; r < t.length; r++) {
            const d = t[r],
              p = n[0],
              m = l.sub(o),
              _ = d.sub(o),
              x = p.sub(o),
              b = vl(m, m),
              w = vl(m, _),
              F = vl(_, _),
              S = vl(x, m),
              D = vl(x, _),
              I = b * F - w * w,
              O = (F * S - w * D) / I,
              Z = (b * D - w * S) / I,
              ne = o.z * (1 - O - Z) + l.z * O + d.z * Z;
            if (isFinite(ne)) return ne;
          }
          return 1 / 0;
        }
        {
          let r = 1 / 0;
          for (const o of t) r = Math.min(r, o.z);
          return r;
        }
      }
      const kp = ii(
          [
            { name: "a_pos_normal", components: 2, type: "Int16" },
            { name: "a_data", components: 4, type: "Uint8" },
          ],
          4,
        ),
        { members: zp } = kp,
        Lp = ii([
          { name: "a_uv_x", components: 1, type: "Float32" },
          { name: "a_split_index", components: 1, type: "Float32" },
        ]),
        { members: Rp } = Lp,
        Op = yl.VectorTileFeature.types,
        jp = Math.cos((Math.PI / 180) * 37.5),
        jh = Math.pow(2, 14) / 0.5;
      class Bc {
        constructor(t) {
          ((this.zoom = t.zoom),
            (this.overscaling = t.overscaling),
            (this.layers = t.layers),
            (this.layerIds = this.layers.map((r) => r.id)),
            (this.index = t.index),
            (this.hasPattern = !1),
            (this.patternFeatures = []),
            (this.lineClipsArray = []),
            (this.gradients = {}),
            this.layers.forEach((r) => {
              this.gradients[r.id] = {};
            }),
            (this.layoutVertexArray = new Q()),
            (this.layoutVertexArray2 = new ee()),
            (this.indexArray = new ye()),
            (this.programConfigurations = new Gt(t.layers, t.zoom)),
            (this.segments = new Le()),
            (this.maxLineLength = 0),
            (this.stateDependentLayerIds = this.layers
              .filter((r) => r.isStateDependent())
              .map((r) => r.id)));
        }
        populate(t, r, o) {
          this.hasPattern = Cc("line", this.layers, r);
          const l = this.layers[0].layout.get("line-sort-key"),
            d = !l.isConstant(),
            p = [];
          for (const {
            feature: m,
            id: _,
            index: x,
            sourceLayerIndex: b,
          } of t) {
            const w = this.layers[0]._featureFilter.needGeometry,
              F = Vn(m, w);
            if (!this.layers[0]._featureFilter.filter(new jt(this.zoom), F, o))
              continue;
            const S = d ? l.evaluate(F, {}, o) : void 0,
              D = {
                id: _,
                properties: m.properties,
                type: m.type,
                sourceLayerIndex: b,
                index: x,
                geometry: w ? F.geometry : Nn(m),
                patterns: {},
                sortKey: S,
              };
            p.push(D);
          }
          d && p.sort((m, _) => m.sortKey - _.sortKey);
          for (const m of p) {
            const { geometry: _, index: x, sourceLayerIndex: b } = m;
            if (this.hasPattern) {
              const w = Ec("line", this.layers, m, this.zoom, r);
              this.patternFeatures.push(w);
            } else this.addFeature(m, _, x, o, {}, r.subdivisionGranularity);
            r.featureIndex.insert(t[x].feature, _, x, b, this.index);
          }
        }
        update(t, r, o) {
          this.stateDependentLayers.length &&
            this.programConfigurations.updatePaintArrays(
              t,
              r,
              this.stateDependentLayers,
              o,
            );
        }
        addFeatures(t, r, o) {
          for (const l of this.patternFeatures)
            this.addFeature(
              l,
              l.geometry,
              l.index,
              r,
              o,
              t.subdivisionGranularity,
            );
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          (this.uploaded ||
            (this.layoutVertexArray2.length !== 0 &&
              (this.layoutVertexBuffer2 = t.createVertexBuffer(
                this.layoutVertexArray2,
                Rp,
              )),
            (this.layoutVertexBuffer = t.createVertexBuffer(
              this.layoutVertexArray,
              zp,
            )),
            (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
            this.programConfigurations.upload(t),
            (this.uploaded = !0));
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.programConfigurations.destroy(),
            this.segments.destroy());
        }
        lineFeatureClips(t) {
          if (
            t.properties &&
            Object.prototype.hasOwnProperty.call(
              t.properties,
              "mapbox_clip_start",
            ) &&
            Object.prototype.hasOwnProperty.call(
              t.properties,
              "mapbox_clip_end",
            )
          )
            return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end,
            };
        }
        addFeature(t, r, o, l, d, p) {
          const m = this.layers[0].layout,
            _ = m.get("line-join").evaluate(t, {}),
            x = m.get("line-cap"),
            b = m.get("line-miter-limit"),
            w = m.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t);
          for (const F of r) this.addLine(F, t, _, x, b, w, l, p);
          this.programConfigurations.populatePaintArrays(
            this.layoutVertexArray.length,
            t,
            o,
            d,
            l,
          );
        }
        addLine(t, r, o, l, d, p, m, _) {
          if (
            ((this.distance = 0),
            (this.scaledDistance = 0),
            (this.totalDistance = 0),
            (t = Qo(t, m ? _.line.getGranularityForZoomLevel(m.z) : 1)),
            this.lineClips)
          ) {
            this.lineClipsArray.push(this.lineClips);
            for (let H = 0; H < t.length - 1; H++)
              this.totalDistance += t[H].dist(t[H + 1]);
            (this.updateScaledDistance(),
              (this.maxLineLength = Math.max(
                this.maxLineLength,
                this.totalDistance,
              )));
          }
          const x = Op[r.type] === "Polygon";
          let b = t.length;
          for (; b >= 2 && t[b - 1].equals(t[b - 2]); ) b--;
          let w = 0;
          for (; w < b - 1 && t[w].equals(t[w + 1]); ) w++;
          if (b < (x ? 3 : 2)) return;
          o === "bevel" && (d = 1.05);
          const F =
              this.overscaling <= 16 ? (15 * qe) / (512 * this.overscaling) : 0,
            S = this.segments.prepareSegment(
              10 * b,
              this.layoutVertexArray,
              this.indexArray,
            );
          let D, I, O, Z, ne;
          ((this.e1 = this.e2 = -1),
            x && ((D = t[b - 2]), (ne = t[w].sub(D)._unit()._perp())));
          for (let H = w; H < b; H++) {
            if (
              ((O = H === b - 1 ? (x ? t[w + 1] : void 0) : t[H + 1]),
              O && t[H].equals(O))
            )
              continue;
            (ne && (Z = ne),
              D && (I = D),
              (D = t[H]),
              (ne = O ? O.sub(D)._unit()._perp() : Z),
              (Z = Z || ne));
            let P = Z.add(ne);
            (P.x === 0 && P.y === 0) || P._unit();
            const R = Z.x * ne.x + Z.y * ne.y,
              W = P.x * ne.x + P.y * ne.y,
              de = W !== 0 ? 1 / W : 1 / 0,
              Te = 2 * Math.sqrt(2 - 2 * W),
              ge = W < jp && I && O,
              xe = Z.x * ne.y - Z.y * ne.x > 0;
            if (ge && H > w) {
              const De = D.dist(I);
              if (De > 2 * F) {
                const we = D.sub(
                  D.sub(I)
                    ._mult(F / De)
                    ._round(),
                );
                (this.updateDistance(I, we),
                  this.addCurrentVertex(we, Z, 0, 0, S),
                  (I = we));
              }
            }
            const Se = I && O;
            let Pe = Se ? o : x ? "butt" : l;
            if (
              (Se &&
                Pe === "round" &&
                (de < p ? (Pe = "miter") : de <= 2 && (Pe = "fakeround")),
              Pe === "miter" && de > d && (Pe = "bevel"),
              Pe === "bevel" &&
                (de > 2 && (Pe = "flipbevel"), de < d && (Pe = "miter")),
              I && this.updateDistance(I, D),
              Pe === "miter")
            )
              (P._mult(de), this.addCurrentVertex(D, P, 0, 0, S));
            else if (Pe === "flipbevel") {
              if (de > 100) P = ne.mult(-1);
              else {
                const De = (de * Z.add(ne).mag()) / Z.sub(ne).mag();
                P._perp()._mult(De * (xe ? -1 : 1));
              }
              (this.addCurrentVertex(D, P, 0, 0, S),
                this.addCurrentVertex(D, P.mult(-1), 0, 0, S));
            } else if (Pe === "bevel" || Pe === "fakeround") {
              const De = -Math.sqrt(de * de - 1),
                we = xe ? De : 0,
                Ne = xe ? 0 : De;
              if (
                (I && this.addCurrentVertex(D, Z, we, Ne, S),
                Pe === "fakeround")
              ) {
                const Ke = Math.round((180 * Te) / Math.PI / 20);
                for (let We = 1; We < Ke; We++) {
                  let Ge = We / Ke;
                  if (Ge !== 0.5) {
                    const Xt = Ge - 0.5;
                    Ge +=
                      Ge *
                      Xt *
                      (Ge - 1) *
                      ((1.0904 + R * (R * (3.55645 - 1.43519 * R) - 3.2452)) *
                        Xt *
                        Xt +
                        (0.848013 + R * (0.215638 * R - 1.06021)));
                  }
                  const dt = ne
                    .sub(Z)
                    ._mult(Ge)
                    ._add(Z)
                    ._unit()
                    ._mult(xe ? -1 : 1);
                  this.addHalfVertex(D, dt.x, dt.y, !1, xe, 0, S);
                }
              }
              O && this.addCurrentVertex(D, ne, -we, -Ne, S);
            } else if (Pe === "butt") this.addCurrentVertex(D, P, 0, 0, S);
            else if (Pe === "square") {
              const De = I ? 1 : -1;
              this.addCurrentVertex(D, P, De, De, S);
            } else
              Pe === "round" &&
                (I &&
                  (this.addCurrentVertex(D, Z, 0, 0, S),
                  this.addCurrentVertex(D, Z, 1, 1, S, !0)),
                O &&
                  (this.addCurrentVertex(D, ne, -1, -1, S, !0),
                  this.addCurrentVertex(D, ne, 0, 0, S)));
            if (ge && H < b - 1) {
              const De = D.dist(O);
              if (De > 2 * F) {
                const we = D.add(
                  O.sub(D)
                    ._mult(F / De)
                    ._round(),
                );
                (this.updateDistance(D, we),
                  this.addCurrentVertex(we, ne, 0, 0, S),
                  (D = we));
              }
            }
          }
        }
        addCurrentVertex(t, r, o, l, d, p = !1) {
          const m = r.y * l - r.x,
            _ = -r.y - r.x * l;
          (this.addHalfVertex(t, r.x + r.y * o, r.y - r.x * o, p, !1, o, d),
            this.addHalfVertex(t, m, _, p, !0, -l, d),
            this.distance > jh / 2 &&
              this.totalDistance === 0 &&
              ((this.distance = 0),
              this.updateScaledDistance(),
              this.addCurrentVertex(t, r, o, l, d, p)));
        }
        addHalfVertex({ x: t, y: r }, o, l, d, p, m, _) {
          const x =
            0.5 *
            (this.lineClips
              ? this.scaledDistance * (jh - 1)
              : this.scaledDistance);
          (this.layoutVertexArray.emplaceBack(
            (t << 1) + (d ? 1 : 0),
            (r << 1) + (p ? 1 : 0),
            Math.round(63 * o) + 128,
            Math.round(63 * l) + 128,
            (1 + (m === 0 ? 0 : m < 0 ? -1 : 1)) | ((63 & x) << 2),
            x >> 6,
          ),
            this.lineClips &&
              this.layoutVertexArray2.emplaceBack(
                (this.scaledDistance - this.lineClips.start) /
                  (this.lineClips.end - this.lineClips.start),
                this.lineClipsArray.length,
              ));
          const b = _.vertexLength++;
          (this.e1 >= 0 &&
            this.e2 >= 0 &&
            (this.indexArray.emplaceBack(this.e1, b, this.e2),
            _.primitiveLength++),
            p ? (this.e2 = b) : (this.e1 = b));
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips
            ? this.lineClips.start +
              ((this.lineClips.end - this.lineClips.start) * this.distance) /
                this.totalDistance
            : this.distance;
        }
        updateDistance(t, r) {
          ((this.distance += t.dist(r)), this.updateScaledDistance());
        }
      }
      let Nh, Vh;
      Re("LineBucket", Bc, { omit: ["layers", "patternFeatures"] });
      var Uh = {
        get paint() {
          return (Vh =
            Vh ||
            new $i({
              "line-opacity": new et(j.paint_line["line-opacity"]),
              "line-color": new et(j.paint_line["line-color"]),
              "line-translate": new He(j.paint_line["line-translate"]),
              "line-translate-anchor": new He(
                j.paint_line["line-translate-anchor"],
              ),
              "line-width": new et(j.paint_line["line-width"]),
              "line-gap-width": new et(j.paint_line["line-gap-width"]),
              "line-offset": new et(j.paint_line["line-offset"]),
              "line-blur": new et(j.paint_line["line-blur"]),
              "line-dasharray": new Ks(j.paint_line["line-dasharray"]),
              "line-pattern": new $o(j.paint_line["line-pattern"]),
              "line-gradient": new Ys(j.paint_line["line-gradient"]),
            }));
        },
        get layout() {
          return (Nh =
            Nh ||
            new $i({
              "line-cap": new He(j.layout_line["line-cap"]),
              "line-join": new et(j.layout_line["line-join"]),
              "line-miter-limit": new He(j.layout_line["line-miter-limit"]),
              "line-round-limit": new He(j.layout_line["line-round-limit"]),
              "line-sort-key": new et(j.layout_line["line-sort-key"]),
            }));
        },
      };
      class Np extends et {
        possiblyEvaluate(t, r) {
          return (
            (r = new jt(Math.floor(r.zoom), {
              now: r.now,
              fadeDuration: r.fadeDuration,
              zoomHistory: r.zoomHistory,
              transition: r.transition,
            })),
            super.possiblyEvaluate(t, r)
          );
        }
        evaluate(t, r, o, l) {
          return (
            (r = yi({}, r, { zoom: Math.floor(r.zoom) })),
            super.evaluate(t, r, o, l)
          );
        }
      }
      let Ou;
      class Vp extends Mr {
        constructor(t) {
          (super(t, Uh),
            (this.gradientVersion = 0),
            Ou ||
              ((Ou = new Np(Uh.paint.properties["line-width"].specification)),
              (Ou.useIntegerZoom = !0)));
        }
        _handleSpecialPaintPropertyUpdate(t) {
          if (t === "line-gradient") {
            const r = this.gradientExpression();
            ((this.stepInterpolant =
              !!(function (o) {
                return o._styleExpression !== void 0;
              })(r) && r._styleExpression.expression instanceof oi),
              (this.gradientVersion =
                (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER));
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value
            .expression;
        }
        recalculate(t, r) {
          (super.recalculate(t, r),
            (this.paint._values["line-floorwidth"] = Ou.possiblyEvaluate(
              this._transitioningPaint._values["line-width"].value,
              t,
            )));
        }
        createBucket(t) {
          return new Bc(t);
        }
        queryRadius(t) {
          const r = t,
            o = $h(cl("line-width", this, r), cl("line-gap-width", this, r)),
            l = cl("line-offset", this, r);
          return o / 2 + Math.abs(l) + Iu(this.paint.get("line-translate"));
        }
        queryIntersectsFeature({
          queryGeometry: t,
          feature: r,
          featureState: o,
          geometry: l,
          transform: d,
          pixelsToTileUnits: p,
        }) {
          const m = Bu(
              t,
              this.paint.get("line-translate"),
              this.paint.get("line-translate-anchor"),
              -d.bearingInRadians,
              p,
            ),
            _ =
              (p / 2) *
              $h(
                this.paint.get("line-width").evaluate(r, o),
                this.paint.get("line-gap-width").evaluate(r, o),
              ),
            x = this.paint.get("line-offset").evaluate(r, o);
          return (
            x &&
              (l = (function (b, w) {
                const F = [];
                for (let S = 0; S < b.length; S++) {
                  const D = b[S],
                    I = [];
                  for (let O = 0; O < D.length; O++) {
                    const Z = D[O - 1],
                      ne = D[O],
                      H = D[O + 1],
                      P = O === 0 ? new Ze(0, 0) : ne.sub(Z)._unit()._perp(),
                      R =
                        O === D.length - 1
                          ? new Ze(0, 0)
                          : H.sub(ne)._unit()._perp(),
                      W = P._add(R)._unit(),
                      de = W.x * R.x + W.y * R.y;
                    (de !== 0 && W._mult(1 / de), I.push(W._mult(w)._add(ne)));
                  }
                  F.push(I);
                }
                return F;
              })(l, x * p)),
            (function (b, w, F) {
              for (let S = 0; S < w.length; S++) {
                const D = w[S];
                if (b.length >= 3) {
                  for (let I = 0; I < D.length; I++) if (ta(b, D[I])) return !0;
                }
                if (ul(b, D, F)) return !0;
              }
              return !1;
            })(m, l, _)
          );
        }
        isTileClipped() {
          return !0;
        }
      }
      function $h(n, t) {
        return t > 0 ? t + 2 * n : n;
      }
      const Up = ii(
          [
            { name: "a_pos_offset", components: 4, type: "Int16" },
            { name: "a_data", components: 4, type: "Uint16" },
            { name: "a_pixeloffset", components: 4, type: "Int16" },
          ],
          4,
        ),
        $p = ii(
          [{ name: "a_projected_pos", components: 3, type: "Float32" }],
          4,
        );
      ii([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const Zp = ii([
        { name: "a_placed", components: 2, type: "Uint8" },
        { name: "a_shift", components: 2, type: "Float32" },
        { name: "a_box_real", components: 2, type: "Int16" },
      ]);
      ii([
        { type: "Int16", name: "anchorPointX" },
        { type: "Int16", name: "anchorPointY" },
        { type: "Int16", name: "x1" },
        { type: "Int16", name: "y1" },
        { type: "Int16", name: "x2" },
        { type: "Int16", name: "y2" },
        { type: "Uint32", name: "featureIndex" },
        { type: "Uint16", name: "sourceLayerIndex" },
        { type: "Uint16", name: "bucketIndex" },
      ]);
      const Zh = ii(
          [
            { name: "a_pos", components: 2, type: "Int16" },
            { name: "a_anchor_pos", components: 2, type: "Int16" },
            { name: "a_extrude", components: 2, type: "Int16" },
          ],
          4,
        ),
        Gp = ii(
          [
            { name: "a_pos", components: 2, type: "Float32" },
            { name: "a_radius", components: 1, type: "Float32" },
            { name: "a_flags", components: 2, type: "Int16" },
          ],
          4,
        );
      function qp(n, t, r) {
        return (
          n.sections.forEach((o) => {
            o.text = (function (l, d, p) {
              const m = d.layout.get("text-transform").evaluate(p, {});
              return (
                m === "uppercase"
                  ? (l = l.toLocaleUpperCase())
                  : m === "lowercase" && (l = l.toLocaleLowerCase()),
                Ur.applyArabicShaping && (l = Ur.applyArabicShaping(l)),
                l
              );
            })(o.text, t, r);
          }),
          n
        );
      }
      (ii([{ name: "triangle", components: 3, type: "Uint16" }]),
        ii([
          { type: "Int16", name: "anchorX" },
          { type: "Int16", name: "anchorY" },
          { type: "Uint16", name: "glyphStartIndex" },
          { type: "Uint16", name: "numGlyphs" },
          { type: "Uint32", name: "vertexStartIndex" },
          { type: "Uint32", name: "lineStartIndex" },
          { type: "Uint32", name: "lineLength" },
          { type: "Uint16", name: "segment" },
          { type: "Uint16", name: "lowerSize" },
          { type: "Uint16", name: "upperSize" },
          { type: "Float32", name: "lineOffsetX" },
          { type: "Float32", name: "lineOffsetY" },
          { type: "Uint8", name: "writingMode" },
          { type: "Uint8", name: "placedOrientation" },
          { type: "Uint8", name: "hidden" },
          { type: "Uint32", name: "crossTileID" },
          { type: "Int16", name: "associatedIconIndex" },
        ]),
        ii([
          { type: "Int16", name: "anchorX" },
          { type: "Int16", name: "anchorY" },
          { type: "Int16", name: "rightJustifiedTextSymbolIndex" },
          { type: "Int16", name: "centerJustifiedTextSymbolIndex" },
          { type: "Int16", name: "leftJustifiedTextSymbolIndex" },
          { type: "Int16", name: "verticalPlacedTextSymbolIndex" },
          { type: "Int16", name: "placedIconSymbolIndex" },
          { type: "Int16", name: "verticalPlacedIconSymbolIndex" },
          { type: "Uint16", name: "key" },
          { type: "Uint16", name: "textBoxStartIndex" },
          { type: "Uint16", name: "textBoxEndIndex" },
          { type: "Uint16", name: "verticalTextBoxStartIndex" },
          { type: "Uint16", name: "verticalTextBoxEndIndex" },
          { type: "Uint16", name: "iconBoxStartIndex" },
          { type: "Uint16", name: "iconBoxEndIndex" },
          { type: "Uint16", name: "verticalIconBoxStartIndex" },
          { type: "Uint16", name: "verticalIconBoxEndIndex" },
          { type: "Uint16", name: "featureIndex" },
          { type: "Uint16", name: "numHorizontalGlyphVertices" },
          { type: "Uint16", name: "numVerticalGlyphVertices" },
          { type: "Uint16", name: "numIconVertices" },
          { type: "Uint16", name: "numVerticalIconVertices" },
          { type: "Uint16", name: "useRuntimeCollisionCircles" },
          { type: "Uint32", name: "crossTileID" },
          { type: "Float32", name: "textBoxScale" },
          { type: "Float32", name: "collisionCircleDiameter" },
          { type: "Uint16", name: "textAnchorOffsetStartIndex" },
          { type: "Uint16", name: "textAnchorOffsetEndIndex" },
        ]),
        ii([{ type: "Float32", name: "offsetX" }]),
        ii([
          { type: "Int16", name: "x" },
          { type: "Int16", name: "y" },
          { type: "Int16", name: "tileUnitDistanceFromAnchor" },
        ]),
        ii([
          { type: "Uint16", name: "textAnchor" },
          { type: "Float32", components: 2, name: "textOffset" },
        ]));
      const bl = {
        "!": "\uFE15",
        "#": "\uFF03",
        $: "\uFF04",
        "%": "\uFF05",
        "&": "\uFF06",
        "(": "\uFE35",
        ")": "\uFE36",
        "*": "\uFF0A",
        "+": "\uFF0B",
        ",": "\uFE10",
        "-": "\uFE32",
        ".": "\u30FB",
        "/": "\uFF0F",
        ":": "\uFE13",
        ";": "\uFE14",
        "<": "\uFE3F",
        "=": "\uFF1D",
        ">": "\uFE40",
        "?": "\uFE16",
        "@": "\uFF20",
        "[": "\uFE47",
        "\\": "\uFF3C",
        "]": "\uFE48",
        "^": "\uFF3E",
        _: "\uFE33",
        "`": "\uFF40",
        "{": "\uFE37",
        "|": "\u2015",
        "}": "\uFE38",
        "~": "\uFF5E",
        "\xA2": "\uFFE0",
        "\xA3": "\uFFE1",
        "\xA5": "\uFFE5",
        "\xA6": "\uFFE4",
        "\xAC": "\uFFE2",
        "\xAF": "\uFFE3",
        "\u2013": "\uFE32",
        "\u2014": "\uFE31",
        "\u2018": "\uFE43",
        "\u2019": "\uFE44",
        "\u201C": "\uFE41",
        "\u201D": "\uFE42",
        "\u2026": "\uFE19",
        "\u2027": "\u30FB",
        "\u20A9": "\uFFE6",
        "\u3001": "\uFE11",
        "\u3002": "\uFE12",
        "\u3008": "\uFE3F",
        "\u3009": "\uFE40",
        "\u300A": "\uFE3D",
        "\u300B": "\uFE3E",
        "\u300C": "\uFE41",
        "\u300D": "\uFE42",
        "\u300E": "\uFE43",
        "\u300F": "\uFE44",
        "\u3010": "\uFE3B",
        "\u3011": "\uFE3C",
        "\u3014": "\uFE39",
        "\u3015": "\uFE3A",
        "\u3016": "\uFE17",
        "\u3017": "\uFE18",
        "\uFF01": "\uFE15",
        "\uFF08": "\uFE35",
        "\uFF09": "\uFE36",
        "\uFF0C": "\uFE10",
        "\uFF0D": "\uFE32",
        "\uFF0E": "\u30FB",
        "\uFF1A": "\uFE13",
        "\uFF1B": "\uFE14",
        "\uFF1C": "\uFE3F",
        "\uFF1E": "\uFE40",
        "\uFF1F": "\uFE16",
        "\uFF3B": "\uFE47",
        "\uFF3D": "\uFE48",
        "\uFF3F": "\uFE33",
        "\uFF5B": "\uFE37",
        "\uFF5C": "\u2015",
        "\uFF5D": "\uFE38",
        "\uFF5F": "\uFE35",
        "\uFF60": "\uFE36",
        "\uFF61": "\uFE12",
        "\uFF62": "\uFE41",
        "\uFF63": "\uFE42",
      };
      var Gh,
        kc,
        qh,
        hi = 24,
        zc = {};
      function Hp() {
        return (
          Gh ||
            ((Gh = 1),
            (zc.read = function (n, t, r, o, l) {
              var d,
                p,
                m = 8 * l - o - 1,
                _ = (1 << m) - 1,
                x = _ >> 1,
                b = -7,
                w = r ? l - 1 : 0,
                F = r ? -1 : 1,
                S = n[t + w];
              for (
                w += F, d = S & ((1 << -b) - 1), S >>= -b, b += m;
                b > 0;
                d = 256 * d + n[t + w], w += F, b -= 8
              );
              for (
                p = d & ((1 << -b) - 1), d >>= -b, b += o;
                b > 0;
                p = 256 * p + n[t + w], w += F, b -= 8
              );
              if (d === 0) d = 1 - x;
              else {
                if (d === _) return p ? NaN : (1 / 0) * (S ? -1 : 1);
                ((p += Math.pow(2, o)), (d -= x));
              }
              return (S ? -1 : 1) * p * Math.pow(2, d - o);
            }),
            (zc.write = function (n, t, r, o, l, d) {
              var p,
                m,
                _,
                x = 8 * d - l - 1,
                b = (1 << x) - 1,
                w = b >> 1,
                F = l === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                S = o ? 0 : d - 1,
                D = o ? 1 : -1,
                I = t < 0 || (t === 0 && 1 / t < 0) ? 1 : 0;
              for (
                t = Math.abs(t),
                  isNaN(t) || t === 1 / 0
                    ? ((m = isNaN(t) ? 1 : 0), (p = b))
                    : ((p = Math.floor(Math.log(t) / Math.LN2)),
                      t * (_ = Math.pow(2, -p)) < 1 && (p--, (_ *= 2)),
                      (t += p + w >= 1 ? F / _ : F * Math.pow(2, 1 - w)) * _ >=
                        2 && (p++, (_ /= 2)),
                      p + w >= b
                        ? ((m = 0), (p = b))
                        : p + w >= 1
                          ? ((m = (t * _ - 1) * Math.pow(2, l)), (p += w))
                          : ((m = t * Math.pow(2, w - 1) * Math.pow(2, l)),
                            (p = 0)));
                l >= 8;
                n[r + S] = 255 & m, S += D, m /= 256, l -= 8
              );
              for (
                p = (p << l) | m, x += l;
                x > 0;
                n[r + S] = 255 & p, S += D, p /= 256, x -= 8
              );
              n[r + S - D] |= 128 * I;
            })),
          zc
        );
      }
      function Hh() {
        if (qh) return kc;
        ((qh = 1), (kc = t));
        var n = Hp();
        function t(P) {
          ((this.buf =
            ArrayBuffer.isView && ArrayBuffer.isView(P)
              ? P
              : new Uint8Array(P || 0)),
            (this.pos = 0),
            (this.type = 0),
            (this.length = this.buf.length));
        }
        ((t.Varint = 0), (t.Fixed64 = 1), (t.Bytes = 2), (t.Fixed32 = 5));
        var r = 4294967296,
          o = 1 / r,
          l = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        function d(P) {
          return P.type === t.Bytes ? P.readVarint() + P.pos : P.pos + 1;
        }
        function p(P, R, W) {
          return W
            ? 4294967296 * R + (P >>> 0)
            : 4294967296 * (R >>> 0) + (P >>> 0);
        }
        function m(P, R, W) {
          var de =
            R <= 16383
              ? 1
              : R <= 2097151
                ? 2
                : R <= 268435455
                  ? 3
                  : Math.floor(Math.log(R) / (7 * Math.LN2));
          W.realloc(de);
          for (var Te = W.pos - 1; Te >= P; Te--) W.buf[Te + de] = W.buf[Te];
        }
        function _(P, R) {
          for (var W = 0; W < P.length; W++) R.writeVarint(P[W]);
        }
        function x(P, R) {
          for (var W = 0; W < P.length; W++) R.writeSVarint(P[W]);
        }
        function b(P, R) {
          for (var W = 0; W < P.length; W++) R.writeFloat(P[W]);
        }
        function w(P, R) {
          for (var W = 0; W < P.length; W++) R.writeDouble(P[W]);
        }
        function F(P, R) {
          for (var W = 0; W < P.length; W++) R.writeBoolean(P[W]);
        }
        function S(P, R) {
          for (var W = 0; W < P.length; W++) R.writeFixed32(P[W]);
        }
        function D(P, R) {
          for (var W = 0; W < P.length; W++) R.writeSFixed32(P[W]);
        }
        function I(P, R) {
          for (var W = 0; W < P.length; W++) R.writeFixed64(P[W]);
        }
        function O(P, R) {
          for (var W = 0; W < P.length; W++) R.writeSFixed64(P[W]);
        }
        function Z(P, R) {
          return (
            (P[R] | (P[R + 1] << 8) | (P[R + 2] << 16)) + 16777216 * P[R + 3]
          );
        }
        function ne(P, R, W) {
          ((P[W] = R),
            (P[W + 1] = R >>> 8),
            (P[W + 2] = R >>> 16),
            (P[W + 3] = R >>> 24));
        }
        function H(P, R) {
          return (P[R] | (P[R + 1] << 8) | (P[R + 2] << 16)) + (P[R + 3] << 24);
        }
        return (
          (t.prototype = {
            destroy: function () {
              this.buf = null;
            },
            readFields: function (P, R, W) {
              for (W = W || this.length; this.pos < W; ) {
                var de = this.readVarint(),
                  Te = de >> 3,
                  ge = this.pos;
                ((this.type = 7 & de),
                  P(Te, R, this),
                  this.pos === ge && this.skip(de));
              }
              return R;
            },
            readMessage: function (P, R) {
              return this.readFields(P, R, this.readVarint() + this.pos);
            },
            readFixed32: function () {
              var P = Z(this.buf, this.pos);
              return ((this.pos += 4), P);
            },
            readSFixed32: function () {
              var P = H(this.buf, this.pos);
              return ((this.pos += 4), P);
            },
            readFixed64: function () {
              var P = Z(this.buf, this.pos) + Z(this.buf, this.pos + 4) * r;
              return ((this.pos += 8), P);
            },
            readSFixed64: function () {
              var P = Z(this.buf, this.pos) + H(this.buf, this.pos + 4) * r;
              return ((this.pos += 8), P);
            },
            readFloat: function () {
              var P = n.read(this.buf, this.pos, !0, 23, 4);
              return ((this.pos += 4), P);
            },
            readDouble: function () {
              var P = n.read(this.buf, this.pos, !0, 52, 8);
              return ((this.pos += 8), P);
            },
            readVarint: function (P) {
              var R,
                W,
                de = this.buf;
              return (
                (R = 127 & (W = de[this.pos++])),
                W < 128
                  ? R
                  : ((R |= (127 & (W = de[this.pos++])) << 7),
                    W < 128
                      ? R
                      : ((R |= (127 & (W = de[this.pos++])) << 14),
                        W < 128
                          ? R
                          : ((R |= (127 & (W = de[this.pos++])) << 21),
                            W < 128
                              ? R
                              : (function (Te, ge, xe) {
                                  var Se,
                                    Pe,
                                    De = xe.buf;
                                  if (
                                    ((Se = (112 & (Pe = De[xe.pos++])) >> 4),
                                    Pe < 128 ||
                                      ((Se |= (127 & (Pe = De[xe.pos++])) << 3),
                                      Pe < 128) ||
                                      ((Se |=
                                        (127 & (Pe = De[xe.pos++])) << 10),
                                      Pe < 128) ||
                                      ((Se |=
                                        (127 & (Pe = De[xe.pos++])) << 17),
                                      Pe < 128) ||
                                      ((Se |=
                                        (127 & (Pe = De[xe.pos++])) << 24),
                                      Pe < 128) ||
                                      ((Se |= (1 & (Pe = De[xe.pos++])) << 31),
                                      Pe < 128))
                                  )
                                    return p(Te, Se, ge);
                                  throw new Error(
                                    "Expected varint not more than 10 bytes",
                                  );
                                })(
                                  (R |= (15 & (W = de[this.pos])) << 28),
                                  P,
                                  this,
                                ))))
              );
            },
            readVarint64: function () {
              return this.readVarint(!0);
            },
            readSVarint: function () {
              var P = this.readVarint();
              return P % 2 == 1 ? (P + 1) / -2 : P / 2;
            },
            readBoolean: function () {
              return Boolean(this.readVarint());
            },
            readString: function () {
              var P = this.readVarint() + this.pos,
                R = this.pos;
              return (
                (this.pos = P),
                P - R >= 12 && l
                  ? (function (W, de, Te) {
                      return l.decode(W.subarray(de, Te));
                    })(this.buf, R, P)
                  : (function (W, de, Te) {
                      for (var ge = "", xe = de; xe < Te; ) {
                        var Se,
                          Pe,
                          De,
                          we = W[xe],
                          Ne = null,
                          Ke = we > 239 ? 4 : we > 223 ? 3 : we > 191 ? 2 : 1;
                        if (xe + Ke > Te) break;
                        (Ke === 1
                          ? we < 128 && (Ne = we)
                          : Ke === 2
                            ? (192 & (Se = W[xe + 1])) == 128 &&
                              (Ne = ((31 & we) << 6) | (63 & Se)) <= 127 &&
                              (Ne = null)
                            : Ke === 3
                              ? ((Pe = W[xe + 2]),
                                (192 & (Se = W[xe + 1])) == 128 &&
                                  (192 & Pe) == 128 &&
                                  ((Ne =
                                    ((15 & we) << 12) |
                                    ((63 & Se) << 6) |
                                    (63 & Pe)) <= 2047 ||
                                    (Ne >= 55296 && Ne <= 57343)) &&
                                  (Ne = null))
                              : Ke === 4 &&
                                ((Pe = W[xe + 2]),
                                (De = W[xe + 3]),
                                (192 & (Se = W[xe + 1])) == 128 &&
                                  (192 & Pe) == 128 &&
                                  (192 & De) == 128 &&
                                  ((Ne =
                                    ((15 & we) << 18) |
                                    ((63 & Se) << 12) |
                                    ((63 & Pe) << 6) |
                                    (63 & De)) <= 65535 ||
                                    Ne >= 1114112) &&
                                  (Ne = null)),
                          Ne === null
                            ? ((Ne = 65533), (Ke = 1))
                            : Ne > 65535 &&
                              ((Ne -= 65536),
                              (ge += String.fromCharCode(
                                ((Ne >>> 10) & 1023) | 55296,
                              )),
                              (Ne = 56320 | (1023 & Ne))),
                          (ge += String.fromCharCode(Ne)),
                          (xe += Ke));
                      }
                      return ge;
                    })(this.buf, R, P)
              );
            },
            readBytes: function () {
              var P = this.readVarint() + this.pos,
                R = this.buf.subarray(this.pos, P);
              return ((this.pos = P), R);
            },
            readPackedVarint: function (P, R) {
              if (this.type !== t.Bytes) return P.push(this.readVarint(R));
              var W = d(this);
              for (P = P || []; this.pos < W; ) P.push(this.readVarint(R));
              return P;
            },
            readPackedSVarint: function (P) {
              if (this.type !== t.Bytes) return P.push(this.readSVarint());
              var R = d(this);
              for (P = P || []; this.pos < R; ) P.push(this.readSVarint());
              return P;
            },
            readPackedBoolean: function (P) {
              if (this.type !== t.Bytes) return P.push(this.readBoolean());
              var R = d(this);
              for (P = P || []; this.pos < R; ) P.push(this.readBoolean());
              return P;
            },
            readPackedFloat: function (P) {
              if (this.type !== t.Bytes) return P.push(this.readFloat());
              var R = d(this);
              for (P = P || []; this.pos < R; ) P.push(this.readFloat());
              return P;
            },
            readPackedDouble: function (P) {
              if (this.type !== t.Bytes) return P.push(this.readDouble());
              var R = d(this);
              for (P = P || []; this.pos < R; ) P.push(this.readDouble());
              return P;
            },
            readPackedFixed32: function (P) {
              if (this.type !== t.Bytes) return P.push(this.readFixed32());
              var R = d(this);
              for (P = P || []; this.pos < R; ) P.push(this.readFixed32());
              return P;
            },
            readPackedSFixed32: function (P) {
              if (this.type !== t.Bytes) return P.push(this.readSFixed32());
              var R = d(this);
              for (P = P || []; this.pos < R; ) P.push(this.readSFixed32());
              return P;
            },
            readPackedFixed64: function (P) {
              if (this.type !== t.Bytes) return P.push(this.readFixed64());
              var R = d(this);
              for (P = P || []; this.pos < R; ) P.push(this.readFixed64());
              return P;
            },
            readPackedSFixed64: function (P) {
              if (this.type !== t.Bytes) return P.push(this.readSFixed64());
              var R = d(this);
              for (P = P || []; this.pos < R; ) P.push(this.readSFixed64());
              return P;
            },
            skip: function (P) {
              var R = 7 & P;
              if (R === t.Varint) for (; this.buf[this.pos++] > 127; );
              else if (R === t.Bytes) this.pos = this.readVarint() + this.pos;
              else if (R === t.Fixed32) this.pos += 4;
              else {
                if (R !== t.Fixed64)
                  throw new Error("Unimplemented type: " + R);
                this.pos += 8;
              }
            },
            writeTag: function (P, R) {
              this.writeVarint((P << 3) | R);
            },
            realloc: function (P) {
              for (var R = this.length || 16; R < this.pos + P; ) R *= 2;
              if (R !== this.length) {
                var W = new Uint8Array(R);
                (W.set(this.buf), (this.buf = W), (this.length = R));
              }
            },
            finish: function () {
              return (
                (this.length = this.pos),
                (this.pos = 0),
                this.buf.subarray(0, this.length)
              );
            },
            writeFixed32: function (P) {
              (this.realloc(4), ne(this.buf, P, this.pos), (this.pos += 4));
            },
            writeSFixed32: function (P) {
              (this.realloc(4), ne(this.buf, P, this.pos), (this.pos += 4));
            },
            writeFixed64: function (P) {
              (this.realloc(8),
                ne(this.buf, -1 & P, this.pos),
                ne(this.buf, Math.floor(P * o), this.pos + 4),
                (this.pos += 8));
            },
            writeSFixed64: function (P) {
              (this.realloc(8),
                ne(this.buf, -1 & P, this.pos),
                ne(this.buf, Math.floor(P * o), this.pos + 4),
                (this.pos += 8));
            },
            writeVarint: function (P) {
              (P = +P || 0) > 268435455 || P < 0
                ? (function (R, W) {
                    var de, Te;
                    if (
                      (R >= 0
                        ? ((de = R % 4294967296 | 0),
                          (Te = (R / 4294967296) | 0))
                        : ((Te = ~(-R / 4294967296)),
                          4294967295 ^ (de = ~(-R % 4294967296))
                            ? (de = (de + 1) | 0)
                            : ((de = 0), (Te = (Te + 1) | 0))),
                      R >= 18446744073709552e3 || R < -18446744073709552e3)
                    )
                      throw new Error("Given varint doesn't fit into 10 bytes");
                    (W.realloc(10),
                      (function (ge, xe, Se) {
                        ((Se.buf[Se.pos++] = (127 & ge) | 128),
                          (ge >>>= 7),
                          (Se.buf[Se.pos++] = (127 & ge) | 128),
                          (ge >>>= 7),
                          (Se.buf[Se.pos++] = (127 & ge) | 128),
                          (ge >>>= 7),
                          (Se.buf[Se.pos++] = (127 & ge) | 128),
                          (Se.buf[Se.pos] = 127 & (ge >>>= 7)));
                      })(de, 0, W),
                      (function (ge, xe) {
                        var Se = (7 & ge) << 4;
                        ((xe.buf[xe.pos++] |= Se | ((ge >>>= 3) ? 128 : 0)),
                          ge &&
                            ((xe.buf[xe.pos++] =
                              (127 & ge) | ((ge >>>= 7) ? 128 : 0)),
                            ge &&
                              ((xe.buf[xe.pos++] =
                                (127 & ge) | ((ge >>>= 7) ? 128 : 0)),
                              ge &&
                                ((xe.buf[xe.pos++] =
                                  (127 & ge) | ((ge >>>= 7) ? 128 : 0)),
                                ge &&
                                  ((xe.buf[xe.pos++] =
                                    (127 & ge) | ((ge >>>= 7) ? 128 : 0)),
                                  ge && (xe.buf[xe.pos++] = 127 & ge))))));
                      })(Te, W));
                  })(P, this)
                : (this.realloc(4),
                  (this.buf[this.pos++] = (127 & P) | (P > 127 ? 128 : 0)),
                  P <= 127 ||
                    ((this.buf[this.pos++] =
                      (127 & (P >>>= 7)) | (P > 127 ? 128 : 0)),
                    P <= 127 ||
                      ((this.buf[this.pos++] =
                        (127 & (P >>>= 7)) | (P > 127 ? 128 : 0)),
                      P <= 127 || (this.buf[this.pos++] = (P >>> 7) & 127))));
            },
            writeSVarint: function (P) {
              this.writeVarint(P < 0 ? 2 * -P - 1 : 2 * P);
            },
            writeBoolean: function (P) {
              this.writeVarint(Boolean(P));
            },
            writeString: function (P) {
              ((P = String(P)), this.realloc(4 * P.length), this.pos++);
              var R = this.pos;
              this.pos = (function (de, Te, ge) {
                for (var xe, Se, Pe = 0; Pe < Te.length; Pe++) {
                  if ((xe = Te.charCodeAt(Pe)) > 55295 && xe < 57344) {
                    if (!Se) {
                      xe > 56319 || Pe + 1 === Te.length
                        ? ((de[ge++] = 239), (de[ge++] = 191), (de[ge++] = 189))
                        : (Se = xe);
                      continue;
                    }
                    if (xe < 56320) {
                      ((de[ge++] = 239),
                        (de[ge++] = 191),
                        (de[ge++] = 189),
                        (Se = xe));
                      continue;
                    }
                    ((xe = ((Se - 55296) << 10) | (xe - 56320) | 65536),
                      (Se = null));
                  } else
                    Se &&
                      ((de[ge++] = 239),
                      (de[ge++] = 191),
                      (de[ge++] = 189),
                      (Se = null));
                  xe < 128
                    ? (de[ge++] = xe)
                    : (xe < 2048
                        ? (de[ge++] = (xe >> 6) | 192)
                        : (xe < 65536
                            ? (de[ge++] = (xe >> 12) | 224)
                            : ((de[ge++] = (xe >> 18) | 240),
                              (de[ge++] = ((xe >> 12) & 63) | 128)),
                          (de[ge++] = ((xe >> 6) & 63) | 128)),
                      (de[ge++] = (63 & xe) | 128));
                }
                return ge;
              })(this.buf, P, this.pos);
              var W = this.pos - R;
              (W >= 128 && m(R, W, this),
                (this.pos = R - 1),
                this.writeVarint(W),
                (this.pos += W));
            },
            writeFloat: function (P) {
              (this.realloc(4),
                n.write(this.buf, P, this.pos, !0, 23, 4),
                (this.pos += 4));
            },
            writeDouble: function (P) {
              (this.realloc(8),
                n.write(this.buf, P, this.pos, !0, 52, 8),
                (this.pos += 8));
            },
            writeBytes: function (P) {
              var R = P.length;
              (this.writeVarint(R), this.realloc(R));
              for (var W = 0; W < R; W++) this.buf[this.pos++] = P[W];
            },
            writeRawMessage: function (P, R) {
              this.pos++;
              var W = this.pos;
              P(R, this);
              var de = this.pos - W;
              (de >= 128 && m(W, de, this),
                (this.pos = W - 1),
                this.writeVarint(de),
                (this.pos += de));
            },
            writeMessage: function (P, R, W) {
              (this.writeTag(P, t.Bytes), this.writeRawMessage(R, W));
            },
            writePackedVarint: function (P, R) {
              R.length && this.writeMessage(P, _, R);
            },
            writePackedSVarint: function (P, R) {
              R.length && this.writeMessage(P, x, R);
            },
            writePackedBoolean: function (P, R) {
              R.length && this.writeMessage(P, F, R);
            },
            writePackedFloat: function (P, R) {
              R.length && this.writeMessage(P, b, R);
            },
            writePackedDouble: function (P, R) {
              R.length && this.writeMessage(P, w, R);
            },
            writePackedFixed32: function (P, R) {
              R.length && this.writeMessage(P, S, R);
            },
            writePackedSFixed32: function (P, R) {
              R.length && this.writeMessage(P, D, R);
            },
            writePackedFixed64: function (P, R) {
              R.length && this.writeMessage(P, I, R);
            },
            writePackedSFixed64: function (P, R) {
              R.length && this.writeMessage(P, O, R);
            },
            writeBytesField: function (P, R) {
              (this.writeTag(P, t.Bytes), this.writeBytes(R));
            },
            writeFixed32Field: function (P, R) {
              (this.writeTag(P, t.Fixed32), this.writeFixed32(R));
            },
            writeSFixed32Field: function (P, R) {
              (this.writeTag(P, t.Fixed32), this.writeSFixed32(R));
            },
            writeFixed64Field: function (P, R) {
              (this.writeTag(P, t.Fixed64), this.writeFixed64(R));
            },
            writeSFixed64Field: function (P, R) {
              (this.writeTag(P, t.Fixed64), this.writeSFixed64(R));
            },
            writeVarintField: function (P, R) {
              (this.writeTag(P, t.Varint), this.writeVarint(R));
            },
            writeSVarintField: function (P, R) {
              (this.writeTag(P, t.Varint), this.writeSVarint(R));
            },
            writeStringField: function (P, R) {
              (this.writeTag(P, t.Bytes), this.writeString(R));
            },
            writeFloatField: function (P, R) {
              (this.writeTag(P, t.Fixed32), this.writeFloat(R));
            },
            writeDoubleField: function (P, R) {
              (this.writeTag(P, t.Fixed64), this.writeDouble(R));
            },
            writeBooleanField: function (P, R) {
              this.writeVarintField(P, Boolean(R));
            },
          }),
          kc
        );
      }
      var Lc = Ue(Hh());
      const Rc = 3;
      function Xp(n, t, r) {
        n === 1 && r.readMessage(Wp, t);
      }
      function Wp(n, t, r) {
        if (n === 3) {
          const {
            id: o,
            bitmap: l,
            width: d,
            height: p,
            left: m,
            top: _,
            advance: x,
          } = r.readMessage(Kp, {});
          t.push({
            id: o,
            bitmap: new hl({ width: d + 2 * Rc, height: p + 2 * Rc }, l),
            metrics: { width: d, height: p, left: m, top: _, advance: x },
          });
        }
      }
      function Kp(n, t, r) {
        n === 1
          ? (t.id = r.readVarint())
          : n === 2
            ? (t.bitmap = r.readBytes())
            : n === 3
              ? (t.width = r.readVarint())
              : n === 4
                ? (t.height = r.readVarint())
                : n === 5
                  ? (t.left = r.readSVarint())
                  : n === 6
                    ? (t.top = r.readSVarint())
                    : n === 7 && (t.advance = r.readVarint());
      }
      const Xh = Rc;
      function Wh(n) {
        let t = 0,
          r = 0;
        for (const p of n) ((t += p.w * p.h), (r = Math.max(r, p.w)));
        n.sort((p, m) => m.h - p.h);
        const o = [
          {
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), r),
            h: 1 / 0,
          },
        ];
        let l = 0,
          d = 0;
        for (const p of n)
          for (let m = o.length - 1; m >= 0; m--) {
            const _ = o[m];
            if (!(p.w > _.w || p.h > _.h)) {
              if (
                ((p.x = _.x),
                (p.y = _.y),
                (d = Math.max(d, p.y + p.h)),
                (l = Math.max(l, p.x + p.w)),
                p.w === _.w && p.h === _.h)
              ) {
                const x = o.pop();
                m < o.length && (o[m] = x);
              } else
                p.h === _.h
                  ? ((_.x += p.w), (_.w -= p.w))
                  : p.w === _.w
                    ? ((_.y += p.h), (_.h -= p.h))
                    : (o.push({ x: _.x + p.w, y: _.y, w: _.w - p.w, h: p.h }),
                      (_.y += p.h),
                      (_.h -= p.h));
              break;
            }
          }
        return { w: l, h: d, fill: t / (l * d) || 0 };
      }
      const rr = 1;
      class Oc {
        constructor(
          t,
          {
            pixelRatio: r,
            version: o,
            stretchX: l,
            stretchY: d,
            content: p,
            textFitWidth: m,
            textFitHeight: _,
          },
        ) {
          ((this.paddedRect = t),
            (this.pixelRatio = r),
            (this.stretchX = l),
            (this.stretchY = d),
            (this.content = p),
            (this.version = o),
            (this.textFitWidth = m),
            (this.textFitHeight = _));
        }
        get tl() {
          return [this.paddedRect.x + rr, this.paddedRect.y + rr];
        }
        get br() {
          return [
            this.paddedRect.x + this.paddedRect.w - rr,
            this.paddedRect.y + this.paddedRect.h - rr,
          ];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [
            (this.paddedRect.w - 2 * rr) / this.pixelRatio,
            (this.paddedRect.h - 2 * rr) / this.pixelRatio,
          ];
        }
      }
      class Kh {
        constructor(t, r) {
          const o = {},
            l = {};
          this.haveRenderCallbacks = [];
          const d = [];
          (this.addImages(t, o, d), this.addImages(r, l, d));
          const { w: p, h: m } = Wh(d),
            _ = new vr({ width: p || 1, height: m || 1 });
          for (const x in t) {
            const b = t[x],
              w = o[x].paddedRect;
            vr.copy(
              b.data,
              _,
              { x: 0, y: 0 },
              { x: w.x + rr, y: w.y + rr },
              b.data,
            );
          }
          for (const x in r) {
            const b = r[x],
              w = l[x].paddedRect,
              F = w.x + rr,
              S = w.y + rr,
              D = b.data.width,
              I = b.data.height;
            (vr.copy(b.data, _, { x: 0, y: 0 }, { x: F, y: S }, b.data),
              vr.copy(
                b.data,
                _,
                { x: 0, y: I - 1 },
                { x: F, y: S - 1 },
                { width: D, height: 1 },
              ),
              vr.copy(
                b.data,
                _,
                { x: 0, y: 0 },
                { x: F, y: S + I },
                { width: D, height: 1 },
              ),
              vr.copy(
                b.data,
                _,
                { x: D - 1, y: 0 },
                { x: F - 1, y: S },
                { width: 1, height: I },
              ),
              vr.copy(
                b.data,
                _,
                { x: 0, y: 0 },
                { x: F + D, y: S },
                { width: 1, height: I },
              ));
          }
          ((this.image = _),
            (this.iconPositions = o),
            (this.patternPositions = l));
        }
        addImages(t, r, o) {
          for (const l in t) {
            const d = t[l],
              p = {
                x: 0,
                y: 0,
                w: d.data.width + 2 * rr,
                h: d.data.height + 2 * rr,
              };
            (o.push(p),
              (r[l] = new Oc(p, d)),
              d.hasRenderCallback && this.haveRenderCallbacks.push(l));
          }
        }
        patchUpdatedImages(t, r) {
          t.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const o in t.updatedImages)
            (this.patchUpdatedImage(this.iconPositions[o], t.getImage(o), r),
              this.patchUpdatedImage(
                this.patternPositions[o],
                t.getImage(o),
                r,
              ));
        }
        patchUpdatedImage(t, r, o) {
          if (!t || !r || t.version === r.version) return;
          t.version = r.version;
          const [l, d] = t.tl;
          o.update(r.data, void 0, { x: l, y: d });
        }
      }
      var _o;
      (Re("ImagePosition", Oc),
        Re("ImageAtlas", Kh),
        (E.ai = void 0),
        ((_o = E.ai || (E.ai = {}))[(_o.none = 0)] = "none"),
        (_o[(_o.horizontal = 1)] = "horizontal"),
        (_o[(_o.vertical = 2)] = "vertical"),
        (_o[(_o.horizontalOnly = 3)] = "horizontalOnly"));
      const wl = -17;
      class Cl {
        constructor() {
          ((this.scale = 1), (this.fontStack = ""), (this.imageName = null));
        }
        static forText(t, r) {
          const o = new Cl();
          return ((o.scale = t || 1), (o.fontStack = r), o);
        }
        static forImage(t) {
          const r = new Cl();
          return ((r.imageName = t), r);
        }
      }
      class oa {
        constructor() {
          ((this.text = ""),
            (this.sectionIndex = []),
            (this.sections = []),
            (this.imageSectionID = null));
        }
        static fromFeature(t, r) {
          const o = new oa();
          for (let l = 0; l < t.sections.length; l++) {
            const d = t.sections[l];
            d.image ? o.addImageSection(d) : o.addTextSection(d, r);
          }
          return o;
        }
        length() {
          return this.text.length;
        }
        getSection(t) {
          return this.sections[this.sectionIndex[t]];
        }
        getSectionIndex(t) {
          return this.sectionIndex[t];
        }
        getCharCode(t) {
          return this.text.charCodeAt(t);
        }
        verticalizePunctuation() {
          this.text = (function (t) {
            let r = "";
            for (let o = 0; o < t.length; o++) {
              const l = t.charCodeAt(o + 1) || null,
                d = t.charCodeAt(o - 1) || null;
              r +=
                (l && wu(l) && !bl[t[o + 1]]) ||
                (d && wu(d) && !bl[t[o - 1]]) ||
                !bl[t[o]]
                  ? t[o]
                  : bl[t[o]];
            }
            return r;
          })(this.text);
        }
        trim() {
          let t = 0;
          for (
            let o = 0;
            o < this.text.length && Nu[this.text.charCodeAt(o)];
            o++
          )
            t++;
          let r = this.text.length;
          for (
            let o = this.text.length - 1;
            o >= 0 && o >= t && Nu[this.text.charCodeAt(o)];
            o--
          )
            r--;
          ((this.text = this.text.substring(t, r)),
            (this.sectionIndex = this.sectionIndex.slice(t, r)));
        }
        substring(t, r) {
          const o = new oa();
          return (
            (o.text = this.text.substring(t, r)),
            (o.sectionIndex = this.sectionIndex.slice(t, r)),
            (o.sections = this.sections),
            o
          );
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce(
            (t, r) => Math.max(t, this.sections[r].scale),
            0,
          );
        }
        addTextSection(t, r) {
          ((this.text += t.text),
            this.sections.push(Cl.forText(t.scale, t.fontStack || r)));
          const o = this.sections.length - 1;
          for (let l = 0; l < t.text.length; ++l) this.sectionIndex.push(o);
        }
        addImageSection(t) {
          const r = t.image ? t.image.name : "";
          if (r.length === 0)
            return void Ai("Can't add FormattedSection with an empty image.");
          const o = this.getNextImageSectionCharCode();
          o
            ? ((this.text += String.fromCharCode(o)),
              this.sections.push(Cl.forImage(r)),
              this.sectionIndex.push(this.sections.length - 1))
            : Ai("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID
            ? this.imageSectionID >= 63743
              ? null
              : ++this.imageSectionID
            : ((this.imageSectionID = 57344), this.imageSectionID);
        }
      }
      function ju(n, t, r, o, l, d, p, m, _, x, b, w, F, S, D) {
        const I = oa.fromFeature(n, l);
        let O;
        w === E.ai.vertical && I.verticalizePunctuation();
        const {
          processBidirectionalText: Z,
          processStyledBidirectionalText: ne,
        } = Ur;
        if (Z && I.sections.length === 1) {
          O = [];
          const R = Z(I.toString(), jc(I, x, d, t, o, S));
          for (const W of R) {
            const de = new oa();
            ((de.text = W), (de.sections = I.sections));
            for (let Te = 0; Te < W.length; Te++) de.sectionIndex.push(0);
            O.push(de);
          }
        } else if (ne) {
          O = [];
          const R = ne(I.text, I.sectionIndex, jc(I, x, d, t, o, S));
          for (const W of R) {
            const de = new oa();
            ((de.text = W[0]),
              (de.sectionIndex = W[1]),
              (de.sections = I.sections),
              O.push(de));
          }
        } else
          O = (function (R, W) {
            const de = [],
              Te = R.text;
            let ge = 0;
            for (const xe of W) (de.push(R.substring(ge, xe)), (ge = xe));
            return (ge < Te.length && de.push(R.substring(ge, Te.length)), de);
          })(I, jc(I, x, d, t, o, S));
        const H = [],
          P = {
            positionedLines: H,
            text: I.toString(),
            top: b[1],
            bottom: b[1],
            left: b[0],
            right: b[0],
            writingMode: w,
            iconsInText: !1,
            verticalizable: !1,
          };
        return (
          (function (R, W, de, Te, ge, xe, Se, Pe, De, we, Ne, Ke) {
            let We = 0,
              Ge = wl,
              dt = 0,
              Xt = 0;
            const di = Pe === "right" ? 1 : Pe === "left" ? 0 : 0.5;
            let bi = 0;
            for (const Jt of ge) {
              Jt.trim();
              const pi = Jt.getMaxScale(),
                qi = (pi - 1) * hi,
                Hi = { positionedGlyphs: [], lineOffset: 0 };
              R.positionedLines[bi] = Hi;
              const Xi = Hi.positionedGlyphs;
              let fi = 0;
              if (!Jt.length()) {
                ((Ge += xe), ++bi);
                continue;
              }
              for (let nr = 0; nr < Jt.length(); nr++) {
                const bt = Jt.getSection(nr),
                  Di = Jt.getSectionIndex(nr),
                  qt = Jt.getCharCode(nr);
                let Wt = 0,
                  gi = null,
                  es = null,
                  Cr = null,
                  Xu = hi;
                const kr = !(
                  De === E.ai.horizontal ||
                  (!Ne && !qs(qt)) ||
                  (Ne &&
                    (Nu[qt] ||
                      ((Br = qt),
                      /\p{sc=Arab}/u.test(String.fromCodePoint(Br)))))
                );
                if (bt.imageName) {
                  const pr = Te[bt.imageName];
                  if (!pr) continue;
                  ((Cr = bt.imageName),
                    (R.iconsInText = R.iconsInText || !0),
                    (es = pr.paddedRect));
                  const Ci = pr.displaySize;
                  ((bt.scale = (bt.scale * hi) / Ke),
                    (gi = {
                      width: Ci[0],
                      height: Ci[1],
                      left: rr,
                      top: -Xh,
                      advance: kr ? Ci[1] : Ci[0],
                    }),
                    (Wt = qi + (hi - Ci[1] * bt.scale)),
                    (Xu = gi.advance));
                  const Er = kr
                    ? Ci[0] * bt.scale - hi * pi
                    : Ci[1] * bt.scale - hi * pi;
                  Er > 0 && Er > fi && (fi = Er);
                } else {
                  const pr = de[bt.fontStack],
                    Ci = pr && pr[qt];
                  if (Ci && Ci.rect) ((es = Ci.rect), (gi = Ci.metrics));
                  else {
                    const Er = W[bt.fontStack],
                      Un = Er && Er[qt];
                    if (!Un) continue;
                    gi = Un.metrics;
                  }
                  Wt = (pi - bt.scale) * hi;
                }
                kr
                  ? ((R.verticalizable = !0),
                    Xi.push({
                      glyph: qt,
                      imageName: Cr,
                      x: We,
                      y: Ge + Wt,
                      vertical: kr,
                      scale: bt.scale,
                      fontStack: bt.fontStack,
                      sectionIndex: Di,
                      metrics: gi,
                      rect: es,
                    }),
                    (We += Xu * bt.scale + we))
                  : (Xi.push({
                      glyph: qt,
                      imageName: Cr,
                      x: We,
                      y: Ge + Wt,
                      vertical: kr,
                      scale: bt.scale,
                      fontStack: bt.fontStack,
                      sectionIndex: Di,
                      metrics: gi,
                      rect: es,
                    }),
                    (We += gi.advance * bt.scale + we));
              }
              (Xi.length !== 0 &&
                ((dt = Math.max(We - we, dt)),
                ef(Xi, 0, Xi.length - 1, di, fi)),
                (We = 0));
              const wr = xe * pi + fi;
              ((Hi.lineOffset = Math.max(fi, qi)),
                (Ge += wr),
                (Xt = Math.max(wr, Xt)),
                ++bi);
            }
            var Br;
            const Gi = Ge - wl,
              { horizontalAlign: wi, verticalAlign: Si } = Nc(Se);
            ((function (Jt, pi, qi, Hi, Xi, fi, wr, nr, bt) {
              const Di = (pi - qi) * Xi;
              let qt = 0;
              qt = fi !== wr ? -nr * Hi - wl : (-Hi * bt + 0.5) * wr;
              for (const Wt of Jt)
                for (const gi of Wt.positionedGlyphs)
                  ((gi.x += Di), (gi.y += qt));
            })(R.positionedLines, di, wi, Si, dt, Xt, xe, Gi, ge.length),
              (R.top += -Si * Gi),
              (R.bottom = R.top + Gi),
              (R.left += -wi * dt),
              (R.right = R.left + dt));
          })(P, t, r, o, O, p, m, _, w, x, F, D),
          !(function (R) {
            for (const W of R) if (W.positionedGlyphs.length !== 0) return !1;
            return !0;
          })(H) && P
        );
      }
      const Nu = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
        Yp = {
          10: !0,
          32: !0,
          38: !0,
          41: !0,
          43: !0,
          45: !0,
          47: !0,
          173: !0,
          183: !0,
          8203: !0,
          8208: !0,
          8211: !0,
          8231: !0,
        },
        Jp = { 40: !0 };
      function Yh(n, t, r, o, l, d) {
        if (t.imageName) {
          const p = o[t.imageName];
          return p ? (p.displaySize[0] * t.scale * hi) / d + l : 0;
        }
        {
          const p = r[t.fontStack],
            m = p && p[n];
          return m ? m.metrics.advance * t.scale + l : 0;
        }
      }
      function Jh(n, t, r, o) {
        const l = Math.pow(n - t, 2);
        return o ? (n < t ? l / 2 : 2 * l) : l + Math.abs(r) * r;
      }
      function Qp(n, t, r) {
        let o = 0;
        return (
          n === 10 && (o -= 1e4),
          r && (o += 150),
          (n !== 40 && n !== 65288) || (o += 50),
          (t !== 41 && t !== 65289) || (o += 50),
          o
        );
      }
      function Qh(n, t, r, o, l, d) {
        let p = null,
          m = Jh(t, r, l, d);
        for (const _ of o) {
          const x = Jh(t - _.x, r, l, d) + _.badness;
          x <= m && ((p = _), (m = x));
        }
        return { index: n, x: t, priorBreak: p, badness: m };
      }
      function ed(n) {
        return n ? ed(n.priorBreak).concat(n.index) : [];
      }
      function jc(n, t, r, o, l, d) {
        if (!n) return [];
        const p = [],
          m = (function (w, F, S, D, I, O) {
            let Z = 0;
            for (let ne = 0; ne < w.length(); ne++) {
              const H = w.getSection(ne);
              Z += Yh(w.getCharCode(ne), H, D, I, F, O);
            }
            return Z / Math.max(1, Math.ceil(Z / S));
          })(n, t, r, o, l, d),
          _ = n.text.indexOf("\u200B") >= 0;
        let x = 0;
        for (let w = 0; w < n.length(); w++) {
          const F = n.getSection(w),
            S = n.getCharCode(w);
          if ((Nu[S] || (x += Yh(S, F, o, l, t, d)), w < n.length() - 1)) {
            const D =
              !((b = S) < 11904) &&
              (!!ht["CJK Compatibility Forms"](b) ||
                !!ht["CJK Compatibility"](b) ||
                !!ht["CJK Strokes"](b) ||
                !!ht["CJK Symbols and Punctuation"](b) ||
                !!ht["Enclosed CJK Letters and Months"](b) ||
                !!ht["Halfwidth and Fullwidth Forms"](b) ||
                !!ht["Ideographic Description Characters"](b) ||
                !!ht["Vertical Forms"](b) ||
                Gs.test(String.fromCodePoint(b)));
            (Yp[S] ||
              D ||
              F.imageName ||
              (w !== n.length() - 2 && Jp[n.getCharCode(w + 1)])) &&
              p.push(
                Qh(w + 1, x, m, p, Qp(S, n.getCharCode(w + 1), D && _), !1),
              );
          }
        }
        var b;
        return ed(Qh(n.length(), x, m, p, 0, !0));
      }
      function Nc(n) {
        let t = 0.5,
          r = 0.5;
        switch (n) {
          case "right":
          case "top-right":
          case "bottom-right":
            t = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            t = 0;
        }
        switch (n) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r = 0;
        }
        return { horizontalAlign: t, verticalAlign: r };
      }
      function ef(n, t, r, o, l) {
        if (!o && !l) return;
        const d = n[r],
          p = (n[r].x + d.metrics.advance * d.scale) * o;
        for (let m = t; m <= r; m++) ((n[m].x -= p), (n[m].y += l));
      }
      function tf(n, t, r) {
        const { horizontalAlign: o, verticalAlign: l } = Nc(r),
          d = t[0] - n.displaySize[0] * o,
          p = t[1] - n.displaySize[1] * l;
        return {
          image: n,
          top: p,
          bottom: p + n.displaySize[1],
          left: d,
          right: d + n.displaySize[0],
        };
      }
      function td(n) {
        var t, r;
        let o = n.left,
          l = n.top,
          d = n.right - o,
          p = n.bottom - l;
        const m =
            (t = n.image.textFitWidth) !== null && t !== void 0
              ? t
              : "stretchOrShrink",
          _ =
            (r = n.image.textFitHeight) !== null && r !== void 0
              ? r
              : "stretchOrShrink",
          x =
            (n.image.content[2] - n.image.content[0]) /
            (n.image.content[3] - n.image.content[1]);
        if (_ === "proportional") {
          if ((m === "stretchOnly" && d / p < x) || m === "proportional") {
            const b = Math.ceil(p * x);
            ((o *= b / d), (d = b));
          }
        } else if (
          m === "proportional" &&
          _ === "stretchOnly" &&
          x !== 0 &&
          d / p > x
        ) {
          const b = Math.ceil(d / x);
          ((l *= b / p), (p = b));
        }
        return { x1: o, y1: l, x2: o + d, y2: l + p };
      }
      function id(n, t, r, o, l, d) {
        const p = n.image;
        let m;
        if (p.content) {
          const O = p.content,
            Z = p.pixelRatio || 1;
          m = [
            O[0] / Z,
            O[1] / Z,
            p.displaySize[0] - O[2] / Z,
            p.displaySize[1] - O[3] / Z,
          ];
        }
        const _ = t.left * d,
          x = t.right * d;
        let b, w, F, S;
        r === "width" || r === "both"
          ? ((S = l[0] + _ - o[3]), (w = l[0] + x + o[1]))
          : ((S = l[0] + (_ + x - p.displaySize[0]) / 2),
            (w = S + p.displaySize[0]));
        const D = t.top * d,
          I = t.bottom * d;
        return (
          r === "height" || r === "both"
            ? ((b = l[1] + D - o[0]), (F = l[1] + I + o[2]))
            : ((b = l[1] + (D + I - p.displaySize[1]) / 2),
              (F = b + p.displaySize[1])),
          {
            image: p,
            top: b,
            right: w,
            bottom: F,
            left: S,
            collisionPadding: m,
          }
        );
      }
      const El = 255,
        ln = 128,
        yo = El * ln;
      function rd(n, t) {
        const { expression: r } = t;
        if (r.kind === "constant")
          return { kind: "constant", layoutSize: r.evaluate(new jt(n + 1)) };
        if (r.kind === "source") return { kind: "source" };
        {
          const { zoomStops: o, interpolationType: l } = r;
          let d = 0;
          for (; d < o.length && o[d] <= n; ) d++;
          d = Math.max(0, d - 1);
          let p = d;
          for (; p < o.length && o[p] < n + 1; ) p++;
          p = Math.min(o.length - 1, p);
          const m = o[d],
            _ = o[p];
          return r.kind === "composite"
            ? {
                kind: "composite",
                minZoom: m,
                maxZoom: _,
                interpolationType: l,
              }
            : {
                kind: "camera",
                minZoom: m,
                maxZoom: _,
                minSize: r.evaluate(new jt(m)),
                maxSize: r.evaluate(new jt(_)),
                interpolationType: l,
              };
        }
      }
      function Vc(n, t, r) {
        let o = "never";
        const l = n.get(t);
        return (l ? (o = l) : n.get(r) && (o = "always"), o);
      }
      const rf = yl.VectorTileFeature.types,
        nf = [
          { name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 },
        ];
      function Vu(n, t, r, o, l, d, p, m, _, x, b, w, F) {
        const S = m ? Math.min(yo, Math.round(m[0])) : 0,
          D = m ? Math.min(yo, Math.round(m[1])) : 0;
        n.emplaceBack(
          t,
          r,
          Math.round(32 * o),
          Math.round(32 * l),
          d,
          p,
          (S << 1) + (_ ? 1 : 0),
          D,
          16 * x,
          16 * b,
          256 * w,
          256 * F,
        );
      }
      function Uc(n, t, r) {
        (n.emplaceBack(t.x, t.y, r),
          n.emplaceBack(t.x, t.y, r),
          n.emplaceBack(t.x, t.y, r),
          n.emplaceBack(t.x, t.y, r));
      }
      function of(n) {
        for (const t of n.sections) if (Tu(t.text)) return !0;
        return !1;
      }
      class $c {
        constructor(t) {
          ((this.layoutVertexArray = new ie()),
            (this.indexArray = new ye()),
            (this.programConfigurations = t),
            (this.segments = new Le()),
            (this.dynamicLayoutVertexArray = new he()),
            (this.opacityVertexArray = new pe()),
            (this.hasVisibleVertices = !1),
            (this.placedSymbolArray = new g()));
        }
        isEmpty() {
          return (
            this.layoutVertexArray.length === 0 &&
            this.indexArray.length === 0 &&
            this.dynamicLayoutVertexArray.length === 0 &&
            this.opacityVertexArray.length === 0
          );
        }
        upload(t, r, o, l) {
          this.isEmpty() ||
            (o &&
              ((this.layoutVertexBuffer = t.createVertexBuffer(
                this.layoutVertexArray,
                Up.members,
              )),
              (this.indexBuffer = t.createIndexBuffer(this.indexArray, r)),
              (this.dynamicLayoutVertexBuffer = t.createVertexBuffer(
                this.dynamicLayoutVertexArray,
                $p.members,
                !0,
              )),
              (this.opacityVertexBuffer = t.createVertexBuffer(
                this.opacityVertexArray,
                nf,
                !0,
              )),
              (this.opacityVertexBuffer.itemSize = 1)),
            (o || l) && this.programConfigurations.upload(t));
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.programConfigurations.destroy(),
            this.segments.destroy(),
            this.dynamicLayoutVertexBuffer.destroy(),
            this.opacityVertexBuffer.destroy());
        }
      }
      Re("SymbolBuffers", $c);
      class Zc {
        constructor(t, r, o) {
          ((this.layoutVertexArray = new t()),
            (this.layoutAttributes = r),
            (this.indexArray = new o()),
            (this.segments = new Le()),
            (this.collisionVertexArray = new Ee()));
        }
        upload(t) {
          ((this.layoutVertexBuffer = t.createVertexBuffer(
            this.layoutVertexArray,
            this.layoutAttributes,
          )),
            (this.indexBuffer = t.createIndexBuffer(this.indexArray)),
            (this.collisionVertexBuffer = t.createVertexBuffer(
              this.collisionVertexArray,
              Zp.members,
              !0,
            )));
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.segments.destroy(),
            this.collisionVertexBuffer.destroy());
        }
      }
      Re("CollisionBuffers", Zc);
      class sa {
        constructor(t) {
          ((this.collisionBoxArray = t.collisionBoxArray),
            (this.zoom = t.zoom),
            (this.overscaling = t.overscaling),
            (this.layers = t.layers),
            (this.layerIds = this.layers.map((p) => p.id)),
            (this.index = t.index),
            (this.pixelRatio = t.pixelRatio),
            (this.sourceLayerIndex = t.sourceLayerIndex),
            (this.hasPattern = !1),
            (this.hasRTLText = !1),
            (this.sortKeyRanges = []),
            (this.collisionCircleArray = []));
          const r = this.layers[0]._unevaluatedLayout._values;
          ((this.textSizeData = rd(this.zoom, r["text-size"])),
            (this.iconSizeData = rd(this.zoom, r["icon-size"])));
          const o = this.layers[0].layout,
            l = o.get("symbol-sort-key"),
            d = o.get("symbol-z-order");
          ((this.canOverlap =
            Vc(o, "text-overlap", "text-allow-overlap") !== "never" ||
            Vc(o, "icon-overlap", "icon-allow-overlap") !== "never" ||
            o.get("text-ignore-placement") ||
            o.get("icon-ignore-placement")),
            (this.sortFeaturesByKey = d !== "viewport-y" && !l.isConstant()),
            (this.sortFeaturesByY =
              (d === "viewport-y" ||
                (d === "auto" && !this.sortFeaturesByKey)) &&
              this.canOverlap),
            o.get("symbol-placement") === "point" &&
              (this.writingModes = o
                .get("text-writing-mode")
                .map((p) => E.ai[p])),
            (this.stateDependentLayerIds = this.layers
              .filter((p) => p.isStateDependent())
              .map((p) => p.id)),
            (this.sourceID = t.sourceID));
        }
        createArrays() {
          ((this.text = new $c(
            new Gt(this.layers, this.zoom, (t) => /^text/.test(t)),
          )),
            (this.icon = new $c(
              new Gt(this.layers, this.zoom, (t) => /^icon/.test(t)),
            )),
            (this.glyphOffsetArray = new C()),
            (this.lineVertexArray = new A()),
            (this.symbolInstances = new v()),
            (this.textAnchorOffsets = new M()));
        }
        calculateGlyphDependencies(t, r, o, l, d) {
          for (let p = 0; p < t.length; p++)
            if (((r[t.charCodeAt(p)] = !0), (o || l) && d)) {
              const m = bl[t.charAt(p)];
              m && (r[m.charCodeAt(0)] = !0);
            }
        }
        populate(t, r, o) {
          const l = this.layers[0],
            d = l.layout,
            p = d.get("text-font"),
            m = d.get("text-field"),
            _ = d.get("icon-image"),
            x =
              (m.value.kind !== "constant" ||
                (m.value.value instanceof ki && !m.value.value.isEmpty()) ||
                m.value.value.toString().length > 0) &&
              (p.value.kind !== "constant" || p.value.value.length > 0),
            b =
              _.value.kind !== "constant" ||
              !!_.value.value ||
              Object.keys(_.parameters).length > 0,
            w = d.get("symbol-sort-key");
          if (((this.features = []), !x && !b)) return;
          const F = r.iconDependencies,
            S = r.glyphDependencies,
            D = r.availableImages,
            I = new jt(this.zoom);
          for (const {
            feature: O,
            id: Z,
            index: ne,
            sourceLayerIndex: H,
          } of t) {
            const P = l._featureFilter.needGeometry,
              R = Vn(O, P);
            if (!l._featureFilter.filter(I, R, o)) continue;
            let W, de;
            if ((P || (R.geometry = Nn(O)), x)) {
              const ge = l.getValueAndResolveTokens("text-field", R, o, D),
                xe = ki.factory(ge),
                Se = (this.hasRTLText = this.hasRTLText || of(xe));
              (!Se ||
                Ur.getRTLTextPluginStatus() === "unavailable" ||
                (Se && Ur.isParsed())) &&
                (W = qp(xe, l, R));
            }
            if (b) {
              const ge = l.getValueAndResolveTokens("icon-image", R, o, D);
              de = ge instanceof Ui ? ge : Ui.fromString(ge);
            }
            if (!W && !de) continue;
            const Te = this.sortFeaturesByKey ? w.evaluate(R, {}, o) : void 0;
            if (
              (this.features.push({
                id: Z,
                text: W,
                icon: de,
                index: ne,
                sourceLayerIndex: H,
                geometry: R.geometry,
                properties: O.properties,
                type: rf[O.type],
                sortKey: Te,
              }),
              de && (F[de.name] = !0),
              W)
            ) {
              const ge = p.evaluate(R, {}, o).join(","),
                xe =
                  d.get("text-rotation-alignment") !== "viewport" &&
                  d.get("symbol-placement") !== "point";
              this.allowVerticalPlacement =
                this.writingModes &&
                this.writingModes.indexOf(E.ai.vertical) >= 0;
              for (const Se of W.sections)
                if (Se.image) F[Se.image.name] = !0;
                else {
                  const Pe = ho(W.toString()),
                    De = Se.fontStack || ge,
                    we = (S[De] = S[De] || {});
                  this.calculateGlyphDependencies(
                    Se.text,
                    we,
                    xe,
                    this.allowVerticalPlacement,
                    Pe,
                  );
                }
            }
          }
          (d.get("symbol-placement") === "line" &&
            (this.features = (function (O) {
              const Z = {},
                ne = {},
                H = [];
              let P = 0;
              function R(ge) {
                (H.push(O[ge]), P++);
              }
              function W(ge, xe, Se) {
                const Pe = ne[ge];
                return (
                  delete ne[ge],
                  (ne[xe] = Pe),
                  H[Pe].geometry[0].pop(),
                  (H[Pe].geometry[0] = H[Pe].geometry[0].concat(Se[0])),
                  Pe
                );
              }
              function de(ge, xe, Se) {
                const Pe = Z[xe];
                return (
                  delete Z[xe],
                  (Z[ge] = Pe),
                  H[Pe].geometry[0].shift(),
                  (H[Pe].geometry[0] = Se[0].concat(H[Pe].geometry[0])),
                  Pe
                );
              }
              function Te(ge, xe, Se) {
                const Pe = Se ? xe[0][xe[0].length - 1] : xe[0][0];
                return `${ge}:${Pe.x}:${Pe.y}`;
              }
              for (let ge = 0; ge < O.length; ge++) {
                const xe = O[ge],
                  Se = xe.geometry,
                  Pe = xe.text ? xe.text.toString() : null;
                if (!Pe) {
                  R(ge);
                  continue;
                }
                const De = Te(Pe, Se),
                  we = Te(Pe, Se, !0);
                if (De in ne && we in Z && ne[De] !== Z[we]) {
                  const Ne = de(De, we, Se),
                    Ke = W(De, we, H[Ne].geometry);
                  (delete Z[De],
                    delete ne[we],
                    (ne[Te(Pe, H[Ke].geometry, !0)] = Ke),
                    (H[Ne].geometry = null));
                } else
                  De in ne
                    ? W(De, we, Se)
                    : we in Z
                      ? de(De, we, Se)
                      : (R(ge), (Z[De] = P - 1), (ne[we] = P - 1));
              }
              return H.filter((ge) => ge.geometry);
            })(this.features)),
            this.sortFeaturesByKey &&
              this.features.sort((O, Z) => O.sortKey - Z.sortKey));
        }
        update(t, r, o) {
          this.stateDependentLayers.length &&
            (this.text.programConfigurations.updatePaintArrays(
              t,
              r,
              this.layers,
              o,
            ),
            this.icon.programConfigurations.updatePaintArrays(
              t,
              r,
              this.layers,
              o,
            ));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return (
            !this.uploaded ||
            this.text.programConfigurations.needsUpload ||
            this.icon.programConfigurations.needsUpload
          );
        }
        upload(t) {
          (!this.uploaded &&
            this.hasDebugData() &&
            (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)),
            this.text.upload(
              t,
              this.sortFeaturesByY,
              !this.uploaded,
              this.text.programConfigurations.needsUpload,
            ),
            this.icon.upload(
              t,
              this.sortFeaturesByY,
              !this.uploaded,
              this.icon.programConfigurations.needsUpload,
            ),
            (this.uploaded = !0));
        }
        destroyDebugData() {
          (this.textCollisionBox.destroy(), this.iconCollisionBox.destroy());
        }
        destroy() {
          (this.text.destroy(),
            this.icon.destroy(),
            this.hasDebugData() && this.destroyDebugData());
        }
        addToLineVertexArray(t, r) {
          const o = this.lineVertexArray.length;
          if (t.segment !== void 0) {
            let l = t.dist(r[t.segment + 1]),
              d = t.dist(r[t.segment]);
            const p = {};
            for (let m = t.segment + 1; m < r.length; m++)
              ((p[m] = { x: r[m].x, y: r[m].y, tileUnitDistanceFromAnchor: l }),
                m < r.length - 1 && (l += r[m + 1].dist(r[m])));
            for (let m = t.segment || 0; m >= 0; m--)
              ((p[m] = { x: r[m].x, y: r[m].y, tileUnitDistanceFromAnchor: d }),
                m > 0 && (d += r[m - 1].dist(r[m])));
            for (let m = 0; m < r.length; m++) {
              const _ = p[m];
              this.lineVertexArray.emplaceBack(
                _.x,
                _.y,
                _.tileUnitDistanceFromAnchor,
              );
            }
          }
          return {
            lineStartIndex: o,
            lineLength: this.lineVertexArray.length - o,
          };
        }
        addSymbols(t, r, o, l, d, p, m, _, x, b, w, F) {
          const S = t.indexArray,
            D = t.layoutVertexArray,
            I = t.segments.prepareSegment(
              4 * r.length,
              D,
              S,
              this.canOverlap ? p.sortKey : void 0,
            ),
            O = this.glyphOffsetArray.length,
            Z = I.vertexLength,
            ne =
              this.allowVerticalPlacement && m === E.ai.vertical
                ? Math.PI / 2
                : 0,
            H = p.text && p.text.sections;
          for (let P = 0; P < r.length; P++) {
            const {
                tl: R,
                tr: W,
                bl: de,
                br: Te,
                tex: ge,
                pixelOffsetTL: xe,
                pixelOffsetBR: Se,
                minFontScaleX: Pe,
                minFontScaleY: De,
                glyphOffset: we,
                isSDF: Ne,
                sectionIndex: Ke,
              } = r[P],
              We = I.vertexLength,
              Ge = we[1];
            (Vu(
              D,
              _.x,
              _.y,
              R.x,
              Ge + R.y,
              ge.x,
              ge.y,
              o,
              Ne,
              xe.x,
              xe.y,
              Pe,
              De,
            ),
              Vu(
                D,
                _.x,
                _.y,
                W.x,
                Ge + W.y,
                ge.x + ge.w,
                ge.y,
                o,
                Ne,
                Se.x,
                xe.y,
                Pe,
                De,
              ),
              Vu(
                D,
                _.x,
                _.y,
                de.x,
                Ge + de.y,
                ge.x,
                ge.y + ge.h,
                o,
                Ne,
                xe.x,
                Se.y,
                Pe,
                De,
              ),
              Vu(
                D,
                _.x,
                _.y,
                Te.x,
                Ge + Te.y,
                ge.x + ge.w,
                ge.y + ge.h,
                o,
                Ne,
                Se.x,
                Se.y,
                Pe,
                De,
              ),
              Uc(t.dynamicLayoutVertexArray, _, ne),
              S.emplaceBack(We, We + 2, We + 1),
              S.emplaceBack(We + 1, We + 2, We + 3),
              (I.vertexLength += 4),
              (I.primitiveLength += 2),
              this.glyphOffsetArray.emplaceBack(we[0]),
              (P !== r.length - 1 && Ke === r[P + 1].sectionIndex) ||
                t.programConfigurations.populatePaintArrays(
                  D.length,
                  p,
                  p.index,
                  {},
                  F,
                  H && H[Ke],
                ));
          }
          t.placedSymbolArray.emplaceBack(
            _.x,
            _.y,
            O,
            this.glyphOffsetArray.length - O,
            Z,
            x,
            b,
            _.segment,
            o ? o[0] : 0,
            o ? o[1] : 0,
            l[0],
            l[1],
            m,
            0,
            !1,
            0,
            w,
          );
        }
        _addCollisionDebugVertex(t, r, o, l, d, p) {
          return (
            r.emplaceBack(0, 0),
            t.emplaceBack(o.x, o.y, l, d, Math.round(p.x), Math.round(p.y))
          );
        }
        addCollisionDebugVertices(t, r, o, l, d, p, m) {
          const _ = d.segments.prepareSegment(
              4,
              d.layoutVertexArray,
              d.indexArray,
            ),
            x = _.vertexLength,
            b = d.layoutVertexArray,
            w = d.collisionVertexArray,
            F = m.anchorX,
            S = m.anchorY;
          (this._addCollisionDebugVertex(b, w, p, F, S, new Ze(t, r)),
            this._addCollisionDebugVertex(b, w, p, F, S, new Ze(o, r)),
            this._addCollisionDebugVertex(b, w, p, F, S, new Ze(o, l)),
            this._addCollisionDebugVertex(b, w, p, F, S, new Ze(t, l)),
            (_.vertexLength += 4));
          const D = d.indexArray;
          (D.emplaceBack(x, x + 1),
            D.emplaceBack(x + 1, x + 2),
            D.emplaceBack(x + 2, x + 3),
            D.emplaceBack(x + 3, x),
            (_.primitiveLength += 4));
        }
        addDebugCollisionBoxes(t, r, o, l) {
          for (let d = t; d < r; d++) {
            const p = this.collisionBoxArray.get(d);
            this.addCollisionDebugVertices(
              p.x1,
              p.y1,
              p.x2,
              p.y2,
              l ? this.textCollisionBox : this.iconCollisionBox,
              p.anchorPoint,
              o,
            );
          }
        }
        generateCollisionDebugBuffers() {
          (this.hasDebugData() && this.destroyDebugData(),
            (this.textCollisionBox = new Zc(be, Zh.members, Be)),
            (this.iconCollisionBox = new Zc(be, Zh.members, Be)));
          for (let t = 0; t < this.symbolInstances.length; t++) {
            const r = this.symbolInstances.get(t);
            (this.addDebugCollisionBoxes(
              r.textBoxStartIndex,
              r.textBoxEndIndex,
              r,
              !0,
            ),
              this.addDebugCollisionBoxes(
                r.verticalTextBoxStartIndex,
                r.verticalTextBoxEndIndex,
                r,
                !0,
              ),
              this.addDebugCollisionBoxes(
                r.iconBoxStartIndex,
                r.iconBoxEndIndex,
                r,
                !1,
              ),
              this.addDebugCollisionBoxes(
                r.verticalIconBoxStartIndex,
                r.verticalIconBoxEndIndex,
                r,
                !1,
              ));
          }
        }
        _deserializeCollisionBoxesForSymbol(t, r, o, l, d, p, m, _, x) {
          const b = {};
          for (let w = r; w < o; w++) {
            const F = t.get(w);
            ((b.textBox = {
              x1: F.x1,
              y1: F.y1,
              x2: F.x2,
              y2: F.y2,
              anchorPointX: F.anchorPointX,
              anchorPointY: F.anchorPointY,
            }),
              (b.textFeatureIndex = F.featureIndex));
            break;
          }
          for (let w = l; w < d; w++) {
            const F = t.get(w);
            ((b.verticalTextBox = {
              x1: F.x1,
              y1: F.y1,
              x2: F.x2,
              y2: F.y2,
              anchorPointX: F.anchorPointX,
              anchorPointY: F.anchorPointY,
            }),
              (b.verticalTextFeatureIndex = F.featureIndex));
            break;
          }
          for (let w = p; w < m; w++) {
            const F = t.get(w);
            ((b.iconBox = {
              x1: F.x1,
              y1: F.y1,
              x2: F.x2,
              y2: F.y2,
              anchorPointX: F.anchorPointX,
              anchorPointY: F.anchorPointY,
            }),
              (b.iconFeatureIndex = F.featureIndex));
            break;
          }
          for (let w = _; w < x; w++) {
            const F = t.get(w);
            ((b.verticalIconBox = {
              x1: F.x1,
              y1: F.y1,
              x2: F.x2,
              y2: F.y2,
              anchorPointX: F.anchorPointX,
              anchorPointY: F.anchorPointY,
            }),
              (b.verticalIconFeatureIndex = F.featureIndex));
            break;
          }
          return b;
        }
        deserializeCollisionBoxes(t) {
          this.collisionArrays = [];
          for (let r = 0; r < this.symbolInstances.length; r++) {
            const o = this.symbolInstances.get(r);
            this.collisionArrays.push(
              this._deserializeCollisionBoxesForSymbol(
                t,
                o.textBoxStartIndex,
                o.textBoxEndIndex,
                o.verticalTextBoxStartIndex,
                o.verticalTextBoxEndIndex,
                o.iconBoxStartIndex,
                o.iconBoxEndIndex,
                o.verticalIconBoxStartIndex,
                o.verticalIconBoxEndIndex,
              ),
            );
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return (
            this.hasDebugData() &&
            this.textCollisionBox.segments.get().length > 0
          );
        }
        hasIconCollisionBoxData() {
          return (
            this.hasDebugData() &&
            this.iconCollisionBox.segments.get().length > 0
          );
        }
        addIndicesForPlacedSymbol(t, r) {
          const o = t.placedSymbolArray.get(r),
            l = o.vertexStartIndex + 4 * o.numGlyphs;
          for (let d = o.vertexStartIndex; d < l; d += 4)
            (t.indexArray.emplaceBack(d, d + 2, d + 1),
              t.indexArray.emplaceBack(d + 1, d + 2, d + 3));
        }
        getSortedSymbolIndexes(t) {
          if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0)
            return this.symbolInstanceIndexes;
          const r = Math.sin(t),
            o = Math.cos(t),
            l = [],
            d = [],
            p = [];
          for (let m = 0; m < this.symbolInstances.length; ++m) {
            p.push(m);
            const _ = this.symbolInstances.get(m);
            (l.push(0 | Math.round(r * _.anchorX + o * _.anchorY)),
              d.push(_.featureIndex));
          }
          return (p.sort((m, _) => l[m] - l[_] || d[_] - d[m]), p);
        }
        addToSortKeyRanges(t, r) {
          const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          o && o.sortKey === r
            ? (o.symbolInstanceEnd = t + 1)
            : this.sortKeyRanges.push({
                sortKey: r,
                symbolInstanceStart: t,
                symbolInstanceEnd: t + 1,
              });
        }
        sortFeatures(t) {
          if (
            this.sortFeaturesByY &&
            this.sortedAngle !== t &&
            !(
              this.text.segments.get().length > 1 ||
              this.icon.segments.get().length > 1
            )
          ) {
            ((this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t)),
              (this.sortedAngle = t),
              this.text.indexArray.clear(),
              this.icon.indexArray.clear(),
              (this.featureSortOrder = []));
            for (const r of this.symbolInstanceIndexes) {
              const o = this.symbolInstances.get(r);
              (this.featureSortOrder.push(o.featureIndex),
                [
                  o.rightJustifiedTextSymbolIndex,
                  o.centerJustifiedTextSymbolIndex,
                  o.leftJustifiedTextSymbolIndex,
                ].forEach((l, d, p) => {
                  l >= 0 &&
                    p.indexOf(l) === d &&
                    this.addIndicesForPlacedSymbol(this.text, l);
                }),
                o.verticalPlacedTextSymbolIndex >= 0 &&
                  this.addIndicesForPlacedSymbol(
                    this.text,
                    o.verticalPlacedTextSymbolIndex,
                  ),
                o.placedIconSymbolIndex >= 0 &&
                  this.addIndicesForPlacedSymbol(
                    this.icon,
                    o.placedIconSymbolIndex,
                  ),
                o.verticalPlacedIconSymbolIndex >= 0 &&
                  this.addIndicesForPlacedSymbol(
                    this.icon,
                    o.verticalPlacedIconSymbolIndex,
                  ));
            }
            (this.text.indexBuffer &&
              this.text.indexBuffer.updateData(this.text.indexArray),
              this.icon.indexBuffer &&
                this.icon.indexBuffer.updateData(this.icon.indexArray));
          }
        }
      }
      let nd, od;
      (Re("SymbolBucket", sa, {
        omit: ["layers", "collisionBoxArray", "features", "compareText"],
      }),
        (sa.MAX_GLYPHS = 65535),
        (sa.addDynamicAttributes = Uc));
      var Gc = {
        get paint() {
          return (od =
            od ||
            new $i({
              "icon-opacity": new et(j.paint_symbol["icon-opacity"]),
              "icon-color": new et(j.paint_symbol["icon-color"]),
              "icon-halo-color": new et(j.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new et(j.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new et(j.paint_symbol["icon-halo-blur"]),
              "icon-translate": new He(j.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new He(
                j.paint_symbol["icon-translate-anchor"],
              ),
              "text-opacity": new et(j.paint_symbol["text-opacity"]),
              "text-color": new et(j.paint_symbol["text-color"], {
                runtimeType: lt,
                getOverride: (n) => n.textColor,
                hasOverride: (n) => !!n.textColor,
              }),
              "text-halo-color": new et(j.paint_symbol["text-halo-color"]),
              "text-halo-width": new et(j.paint_symbol["text-halo-width"]),
              "text-halo-blur": new et(j.paint_symbol["text-halo-blur"]),
              "text-translate": new He(j.paint_symbol["text-translate"]),
              "text-translate-anchor": new He(
                j.paint_symbol["text-translate-anchor"],
              ),
            }));
        },
        get layout() {
          return (nd =
            nd ||
            new $i({
              "symbol-placement": new He(j.layout_symbol["symbol-placement"]),
              "symbol-spacing": new He(j.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new He(
                j.layout_symbol["symbol-avoid-edges"],
              ),
              "symbol-sort-key": new et(j.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new He(j.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new He(
                j.layout_symbol["icon-allow-overlap"],
              ),
              "icon-overlap": new He(j.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new He(
                j.layout_symbol["icon-ignore-placement"],
              ),
              "icon-optional": new He(j.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new He(
                j.layout_symbol["icon-rotation-alignment"],
              ),
              "icon-size": new et(j.layout_symbol["icon-size"]),
              "icon-text-fit": new He(j.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new He(
                j.layout_symbol["icon-text-fit-padding"],
              ),
              "icon-image": new et(j.layout_symbol["icon-image"]),
              "icon-rotate": new et(j.layout_symbol["icon-rotate"]),
              "icon-padding": new et(j.layout_symbol["icon-padding"]),
              "icon-keep-upright": new He(j.layout_symbol["icon-keep-upright"]),
              "icon-offset": new et(j.layout_symbol["icon-offset"]),
              "icon-anchor": new et(j.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new He(
                j.layout_symbol["icon-pitch-alignment"],
              ),
              "text-pitch-alignment": new He(
                j.layout_symbol["text-pitch-alignment"],
              ),
              "text-rotation-alignment": new He(
                j.layout_symbol["text-rotation-alignment"],
              ),
              "text-field": new et(j.layout_symbol["text-field"]),
              "text-font": new et(j.layout_symbol["text-font"]),
              "text-size": new et(j.layout_symbol["text-size"]),
              "text-max-width": new et(j.layout_symbol["text-max-width"]),
              "text-line-height": new He(j.layout_symbol["text-line-height"]),
              "text-letter-spacing": new et(
                j.layout_symbol["text-letter-spacing"],
              ),
              "text-justify": new et(j.layout_symbol["text-justify"]),
              "text-radial-offset": new et(
                j.layout_symbol["text-radial-offset"],
              ),
              "text-variable-anchor": new He(
                j.layout_symbol["text-variable-anchor"],
              ),
              "text-variable-anchor-offset": new et(
                j.layout_symbol["text-variable-anchor-offset"],
              ),
              "text-anchor": new et(j.layout_symbol["text-anchor"]),
              "text-max-angle": new He(j.layout_symbol["text-max-angle"]),
              "text-writing-mode": new He(j.layout_symbol["text-writing-mode"]),
              "text-rotate": new et(j.layout_symbol["text-rotate"]),
              "text-padding": new He(j.layout_symbol["text-padding"]),
              "text-keep-upright": new He(j.layout_symbol["text-keep-upright"]),
              "text-transform": new et(j.layout_symbol["text-transform"]),
              "text-offset": new et(j.layout_symbol["text-offset"]),
              "text-allow-overlap": new He(
                j.layout_symbol["text-allow-overlap"],
              ),
              "text-overlap": new He(j.layout_symbol["text-overlap"]),
              "text-ignore-placement": new He(
                j.layout_symbol["text-ignore-placement"],
              ),
              "text-optional": new He(j.layout_symbol["text-optional"]),
            }));
        },
      };
      class sd {
        constructor(t) {
          if (t.property.overrides === void 0)
            throw new Error(
              "overrides must be provided to instantiate FormatSectionOverride class",
            );
          ((this.type = t.property.overrides
            ? t.property.overrides.runtimeType
            : nt),
            (this.defaultValue = t));
        }
        evaluate(t) {
          if (t.formattedSection) {
            const r = this.defaultValue.property.overrides;
            if (r && r.hasOverride(t.formattedSection))
              return r.getOverride(t.formattedSection);
          }
          return t.feature && t.featureState
            ? this.defaultValue.evaluate(t.feature, t.featureState)
            : this.defaultValue.property.specification.default;
        }
        eachChild(t) {
          this.defaultValue.isConstant() ||
            t(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      Re("FormatSectionOverride", sd, { omit: ["defaultValue"] });
      class Uu extends Mr {
        constructor(t) {
          super(t, Gc);
        }
        recalculate(t, r) {
          if (
            (super.recalculate(t, r),
            this.layout.get("icon-rotation-alignment") === "auto" &&
              (this.layout._values["icon-rotation-alignment"] =
                this.layout.get("symbol-placement") !== "point"
                  ? "map"
                  : "viewport"),
            this.layout.get("text-rotation-alignment") === "auto" &&
              (this.layout._values["text-rotation-alignment"] =
                this.layout.get("symbol-placement") !== "point"
                  ? "map"
                  : "viewport"),
            this.layout.get("text-pitch-alignment") === "auto" &&
              (this.layout._values["text-pitch-alignment"] =
                this.layout.get("text-rotation-alignment") === "map"
                  ? "map"
                  : "viewport"),
            this.layout.get("icon-pitch-alignment") === "auto" &&
              (this.layout._values["icon-pitch-alignment"] = this.layout.get(
                "icon-rotation-alignment",
              )),
            this.layout.get("symbol-placement") === "point")
          ) {
            const o = this.layout.get("text-writing-mode");
            if (o) {
              const l = [];
              for (const d of o) l.indexOf(d) < 0 && l.push(d);
              this.layout._values["text-writing-mode"] = l;
            } else this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t, r, o, l) {
          const d = this.layout.get(t).evaluate(r, {}, o, l),
            p = this._unevaluatedLayout._values[t];
          return p.isDataDriven() || ks(p.value) || !d
            ? d
            : (function (m, _) {
                return _.replace(/{([^{}]+)}/g, (x, b) =>
                  m && b in m ? String(m[b]) : "",
                );
              })(r.properties, d);
        }
        createBucket(t) {
          return new sa(t);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const t of Gc.paint.overridableProperties) {
            if (!Uu.hasPaintOverride(this.layout, t)) continue;
            const r = this.paint.get(t),
              o = new sd(r),
              l = new Bs(o, r.property.specification);
            let d = null;
            ((d =
              r.value.kind === "constant" || r.value.kind === "source"
                ? new no("source", l)
                : new Ls("composite", l, r.value.zoomStops)),
              (this.paint._values[t] = new Dr(r.property, d, r.parameters)));
          }
        }
        _handleOverridablePaintPropertyUpdate(t, r, o) {
          return (
            !(!this.layout || r.isDataDriven() || o.isDataDriven()) &&
            Uu.hasPaintOverride(this.layout, t)
          );
        }
        static hasPaintOverride(t, r) {
          const o = t.get("text-field"),
            l = Gc.paint.properties[r];
          let d = !1;
          const p = (m) => {
            for (const _ of m)
              if (l.overrides && l.overrides.hasOverride(_))
                return void (d = !0);
          };
          if (o.value.kind === "constant" && o.value.value instanceof ki)
            p(o.value.value.sections);
          else if (o.value.kind === "source") {
            const m = (x) => {
                d ||
                  (x instanceof Pn && Kt(x.value) === en
                    ? p(x.value.sections)
                    : x instanceof bs
                      ? p(x.sections)
                      : x.eachChild(m));
              },
              _ = o.value;
            _._styleExpression && m(_._styleExpression.expression);
          }
          return d;
        }
      }
      let ad;
      var sf = {
        get paint() {
          return (ad =
            ad ||
            new $i({
              "background-color": new He(
                j.paint_background["background-color"],
              ),
              "background-pattern": new Ks(
                j.paint_background["background-pattern"],
              ),
              "background-opacity": new He(
                j.paint_background["background-opacity"],
              ),
            }));
        },
      };
      class af extends Mr {
        constructor(t) {
          super(t, sf);
        }
      }
      let ld;
      var lf = {
        get paint() {
          return (ld =
            ld ||
            new $i({
              "raster-opacity": new He(j.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new He(j.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new He(
                j.paint_raster["raster-brightness-min"],
              ),
              "raster-brightness-max": new He(
                j.paint_raster["raster-brightness-max"],
              ),
              "raster-saturation": new He(j.paint_raster["raster-saturation"]),
              "raster-contrast": new He(j.paint_raster["raster-contrast"]),
              "raster-resampling": new He(j.paint_raster["raster-resampling"]),
              "raster-fade-duration": new He(
                j.paint_raster["raster-fade-duration"],
              ),
            }));
        },
      };
      class uf extends Mr {
        constructor(t) {
          super(t, lf);
        }
      }
      class cf extends Mr {
        constructor(t) {
          (super(t, {}),
            (this.onAdd = (r) => {
              this.implementation.onAdd &&
                this.implementation.onAdd(r, r.painter.context.gl);
            }),
            (this.onRemove = (r) => {
              this.implementation.onRemove &&
                this.implementation.onRemove(r, r.painter.context.gl);
            }),
            (this.implementation = t));
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {}
        updateTransitions() {}
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class hf {
        constructor(t) {
          ((this._methodToThrottle = t),
            (this._triggered = !1),
            typeof MessageChannel < "u" &&
              ((this._channel = new MessageChannel()),
              (this._channel.port2.onmessage = () => {
                ((this._triggered = !1), this._methodToThrottle());
              })));
        }
        trigger() {
          this._triggered ||
            ((this._triggered = !0),
            this._channel
              ? this._channel.port1.postMessage(!0)
              : setTimeout(() => {
                  ((this._triggered = !1), this._methodToThrottle());
                }, 0));
        }
        remove() {
          (delete this._channel, (this._methodToThrottle = () => {}));
        }
      }
      const qc = 63710088e-1;
      class xo {
        constructor(t, r) {
          if (isNaN(t) || isNaN(r))
            throw new Error(`Invalid LngLat object: (${t}, ${r})`);
          if (
            ((this.lng = +t), (this.lat = +r), this.lat > 90 || this.lat < -90)
          )
            throw new Error(
              "Invalid LngLat latitude value: must be between -90 and 90",
            );
        }
        wrap() {
          return new xo(ar(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t) {
          const r = Math.PI / 180,
            o = this.lat * r,
            l = t.lat * r,
            d =
              Math.sin(o) * Math.sin(l) +
              Math.cos(o) * Math.cos(l) * Math.cos((t.lng - this.lng) * r);
          return qc * Math.acos(Math.min(d, 1));
        }
        static convert(t) {
          if (t instanceof xo) return t;
          if (Array.isArray(t) && (t.length === 2 || t.length === 3))
            return new xo(Number(t[0]), Number(t[1]));
          if (!Array.isArray(t) && typeof t == "object" && t !== null)
            return new xo(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
          throw new Error(
            "`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]",
          );
        }
      }
      const ud = 2 * Math.PI * qc;
      function cd(n) {
        return ud * Math.cos((n * Math.PI) / 180);
      }
      function hd(n) {
        return (180 + n) / 360;
      }
      function dd(n) {
        return (
          (180 -
            (180 / Math.PI) *
              Math.log(Math.tan(Math.PI / 4 + (n * Math.PI) / 360))) /
          360
        );
      }
      function pd(n, t) {
        return n / cd(t);
      }
      function Hc(n) {
        return (
          (360 / Math.PI) *
            Math.atan(Math.exp(((180 - 360 * n) * Math.PI) / 180)) -
          90
        );
      }
      function fd(n, t) {
        return n * cd(Hc(t));
      }
      class Al {
        constructor(t, r, o = 0) {
          ((this.x = +t), (this.y = +r), (this.z = +o));
        }
        static fromLngLat(t, r = 0) {
          const o = xo.convert(t);
          return new Al(hd(o.lng), dd(o.lat), pd(r, o.lat));
        }
        toLngLat() {
          return new xo(360 * this.x - 180, Hc(this.y));
        }
        toAltitude() {
          return fd(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return (
            (1 / ud) * ((t = Hc(this.y)), 1 / Math.cos((t * Math.PI) / 180))
          );
          var t;
        }
      }
      function md(n, t, r) {
        var o = (2 * Math.PI * 6378137) / 256 / Math.pow(2, r);
        return [
          n * o - (2 * Math.PI * 6378137) / 2,
          t * o - (2 * Math.PI * 6378137) / 2,
        ];
      }
      class Xc {
        constructor(t, r, o) {
          if (
            !(function (l, d, p) {
              return !(
                l < 0 ||
                l > 25 ||
                p < 0 ||
                p >= Math.pow(2, l) ||
                d < 0 ||
                d >= Math.pow(2, l)
              );
            })(t, r, o)
          )
            throw new Error(
              `x=${r}, y=${o}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `,
            );
          ((this.z = t),
            (this.x = r),
            (this.y = o),
            (this.key = aa(0, t, t, r, o)));
        }
        equals(t) {
          return this.z === t.z && this.x === t.x && this.y === t.y;
        }
        url(t, r, o) {
          const l =
            ((p = this.y),
            (m = this.z),
            (_ = md(256 * (d = this.x), 256 * (p = Math.pow(2, m) - p - 1), m)),
            (x = md(256 * (d + 1), 256 * (p + 1), m)),
            _[0] + "," + _[1] + "," + x[0] + "," + x[1]);
          var d, p, m, _, x;
          const b = (function (w, F, S) {
            let D,
              I = "";
            for (let O = w; O > 0; O--)
              ((D = 1 << (O - 1)), (I += (F & D ? 1 : 0) + (S & D ? 2 : 0)));
            return I;
          })(this.z, this.x, this.y);
          return t[(this.x + this.y) % t.length]
            .replace(
              /{prefix}/g,
              (this.x % 16).toString(16) + (this.y % 16).toString(16),
            )
            .replace(/{z}/g, String(this.z))
            .replace(/{x}/g, String(this.x))
            .replace(
              /{y}/g,
              String(o === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y),
            )
            .replace(/{ratio}/g, r > 1 ? "@2x" : "")
            .replace(/{quadkey}/g, b)
            .replace(/{bbox-epsg-3857}/g, l);
        }
        isChildOf(t) {
          const r = this.z - t.z;
          return r > 0 && t.x === this.x >> r && t.y === this.y >> r;
        }
        getTilePoint(t) {
          const r = Math.pow(2, this.z);
          return new Ze((t.x * r - this.x) * qe, (t.y * r - this.y) * qe);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class gd {
        constructor(t, r) {
          ((this.wrap = t),
            (this.canonical = r),
            (this.key = aa(t, r.z, r.z, r.x, r.y)));
        }
      }
      class br {
        constructor(t, r, o, l, d) {
          if (((this.terrainRttPosMatrix32f = null), t < o))
            throw new Error(
              `overscaledZ should be >= z; overscaledZ = ${t}; z = ${o}`,
            );
          ((this.overscaledZ = t),
            (this.wrap = r),
            (this.canonical = new Xc(o, +l, +d)),
            (this.key = aa(r, t, o, l, d)));
        }
        clone() {
          return new br(
            this.overscaledZ,
            this.wrap,
            this.canonical.z,
            this.canonical.x,
            this.canonical.y,
          );
        }
        equals(t) {
          return (
            this.overscaledZ === t.overscaledZ &&
            this.wrap === t.wrap &&
            this.canonical.equals(t.canonical)
          );
        }
        scaledTo(t) {
          if (t > this.overscaledZ)
            throw new Error(
              `targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`,
            );
          const r = this.canonical.z - t;
          return t > this.canonical.z
            ? new br(
                t,
                this.wrap,
                this.canonical.z,
                this.canonical.x,
                this.canonical.y,
              )
            : new br(
                t,
                this.wrap,
                t,
                this.canonical.x >> r,
                this.canonical.y >> r,
              );
        }
        calculateScaledKey(t, r) {
          if (t > this.overscaledZ)
            throw new Error(
              `targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`,
            );
          const o = this.canonical.z - t;
          return t > this.canonical.z
            ? aa(
                this.wrap * +r,
                t,
                this.canonical.z,
                this.canonical.x,
                this.canonical.y,
              )
            : aa(
                this.wrap * +r,
                t,
                t,
                this.canonical.x >> o,
                this.canonical.y >> o,
              );
        }
        isChildOf(t) {
          if (t.wrap !== this.wrap) return !1;
          const r = this.canonical.z - t.canonical.z;
          return (
            t.overscaledZ === 0 ||
            (t.overscaledZ < this.overscaledZ &&
              t.canonical.x === this.canonical.x >> r &&
              t.canonical.y === this.canonical.y >> r)
          );
        }
        children(t) {
          if (this.overscaledZ >= t)
            return [
              new br(
                this.overscaledZ + 1,
                this.wrap,
                this.canonical.z,
                this.canonical.x,
                this.canonical.y,
              ),
            ];
          const r = this.canonical.z + 1,
            o = 2 * this.canonical.x,
            l = 2 * this.canonical.y;
          return [
            new br(r, this.wrap, r, o, l),
            new br(r, this.wrap, r, o + 1, l),
            new br(r, this.wrap, r, o, l + 1),
            new br(r, this.wrap, r, o + 1, l + 1),
          ];
        }
        isLessThan(t) {
          return (
            this.wrap < t.wrap ||
            (!(this.wrap > t.wrap) &&
              (this.overscaledZ < t.overscaledZ ||
                (!(this.overscaledZ > t.overscaledZ) &&
                  (this.canonical.x < t.canonical.x ||
                    (!(this.canonical.x > t.canonical.x) &&
                      this.canonical.y < t.canonical.y)))))
          );
        }
        wrapped() {
          return new br(
            this.overscaledZ,
            0,
            this.canonical.z,
            this.canonical.x,
            this.canonical.y,
          );
        }
        unwrapTo(t) {
          return new br(
            this.overscaledZ,
            t,
            this.canonical.z,
            this.canonical.x,
            this.canonical.y,
          );
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new gd(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(t) {
          return this.canonical.getTilePoint(new Al(t.x - this.wrap, t.y));
        }
      }
      function aa(n, t, r, o, l) {
        (n *= 2) < 0 && (n = -1 * n - 1);
        const d = 1 << r;
        return (
          (d * d * n + d * l + o).toString(36) + r.toString(36) + t.toString(36)
        );
      }
      (Re("CanonicalTileID", Xc),
        Re("OverscaledTileID", br, { omit: ["terrainRttPosMatrix32f"] }));
      class _d {
        constructor(t, r, o, l = 1, d = 1, p = 1, m = 0) {
          if (((this.uid = t), r.height !== r.width))
            throw new RangeError("DEM tiles must be square");
          if (o && !["mapbox", "terrarium", "custom"].includes(o))
            return void Ai(
              `"${o}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`,
            );
          this.stride = r.height;
          const _ = (this.dim = r.height - 2);
          switch (((this.data = new Uint32Array(r.data.buffer)), o)) {
            case "terrarium":
              ((this.redFactor = 256),
                (this.greenFactor = 1),
                (this.blueFactor = 1 / 256),
                (this.baseShift = 32768));
              break;
            case "custom":
              ((this.redFactor = l),
                (this.greenFactor = d),
                (this.blueFactor = p),
                (this.baseShift = m));
              break;
            default:
              ((this.redFactor = 6553.6),
                (this.greenFactor = 25.6),
                (this.blueFactor = 0.1),
                (this.baseShift = 1e4));
          }
          for (let x = 0; x < _; x++)
            ((this.data[this._idx(-1, x)] = this.data[this._idx(0, x)]),
              (this.data[this._idx(_, x)] = this.data[this._idx(_ - 1, x)]),
              (this.data[this._idx(x, -1)] = this.data[this._idx(x, 0)]),
              (this.data[this._idx(x, _)] = this.data[this._idx(x, _ - 1)]));
          ((this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)]),
            (this.data[this._idx(_, -1)] = this.data[this._idx(_ - 1, 0)]),
            (this.data[this._idx(-1, _)] = this.data[this._idx(0, _ - 1)]),
            (this.data[this._idx(_, _)] = this.data[this._idx(_ - 1, _ - 1)]),
            (this.min = Number.MAX_SAFE_INTEGER),
            (this.max = Number.MIN_SAFE_INTEGER));
          for (let x = 0; x < _; x++)
            for (let b = 0; b < _; b++) {
              const w = this.get(x, b);
              (w > this.max && (this.max = w), w < this.min && (this.min = w));
            }
        }
        get(t, r) {
          const o = new Uint8Array(this.data.buffer),
            l = 4 * this._idx(t, r);
          return this.unpack(o[l], o[l + 1], o[l + 2]);
        }
        getUnpackVector() {
          return [
            this.redFactor,
            this.greenFactor,
            this.blueFactor,
            this.baseShift,
          ];
        }
        _idx(t, r) {
          if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1)
            throw new RangeError(
              "out of range source coordinates for DEM data",
            );
          return (r + 1) * this.stride + (t + 1);
        }
        unpack(t, r, o) {
          return (
            t * this.redFactor +
            r * this.greenFactor +
            o * this.blueFactor -
            this.baseShift
          );
        }
        getPixels() {
          return new vr(
            { width: this.stride, height: this.stride },
            new Uint8Array(this.data.buffer),
          );
        }
        backfillBorder(t, r, o) {
          if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
          let l = r * this.dim,
            d = r * this.dim + this.dim,
            p = o * this.dim,
            m = o * this.dim + this.dim;
          switch (r) {
            case -1:
              l = d - 1;
              break;
            case 1:
              d = l + 1;
          }
          switch (o) {
            case -1:
              p = m - 1;
              break;
            case 1:
              m = p + 1;
          }
          const _ = -r * this.dim,
            x = -o * this.dim;
          for (let b = p; b < m; b++)
            for (let w = l; w < d; w++)
              this.data[this._idx(w, b)] = t.data[this._idx(w + _, b + x)];
        }
      }
      Re("DEMData", _d);
      class yd {
        constructor(t) {
          ((this._stringToNumber = {}), (this._numberToString = []));
          for (let r = 0; r < t.length; r++) {
            const o = t[r];
            ((this._stringToNumber[o] = r), (this._numberToString[r] = o));
          }
        }
        encode(t) {
          return this._stringToNumber[t];
        }
        decode(t) {
          if (t >= this._numberToString.length)
            throw new Error(
              `Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`,
            );
          return this._numberToString[t];
        }
      }
      class xd {
        constructor(t, r, o, l, d) {
          ((this.type = "Feature"),
            (this._vectorTileFeature = t),
            (t._z = r),
            (t._x = o),
            (t._y = l),
            (this.properties = t.properties),
            (this.id = d));
        }
        get geometry() {
          return (
            this._geometry === void 0 &&
              (this._geometry = this._vectorTileFeature.toGeoJSON(
                this._vectorTileFeature._x,
                this._vectorTileFeature._y,
                this._vectorTileFeature._z,
              ).geometry),
            this._geometry
          );
        }
        set geometry(t) {
          this._geometry = t;
        }
        toJSON() {
          const t = { geometry: this.geometry };
          for (const r in this)
            r !== "_geometry" && r !== "_vectorTileFeature" && (t[r] = this[r]);
          return t;
        }
      }
      class vd {
        constructor(t, r) {
          ((this.tileID = t),
            (this.x = t.canonical.x),
            (this.y = t.canonical.y),
            (this.z = t.canonical.z),
            (this.grid = new Rn(qe, 16, 0)),
            (this.grid3D = new Rn(qe, 16, 0)),
            (this.featureIndexArray = new V()),
            (this.promoteId = r));
        }
        insert(t, r, o, l, d, p) {
          const m = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(o, l, d);
          const _ = p ? this.grid3D : this.grid;
          for (let x = 0; x < r.length; x++) {
            const b = r[x],
              w = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let F = 0; F < b.length; F++) {
              const S = b[F];
              ((w[0] = Math.min(w[0], S.x)),
                (w[1] = Math.min(w[1], S.y)),
                (w[2] = Math.max(w[2], S.x)),
                (w[3] = Math.max(w[3], S.y)));
            }
            w[0] < qe &&
              w[1] < qe &&
              w[2] >= 0 &&
              w[3] >= 0 &&
              _.insert(m, w[0], w[1], w[2], w[3]);
          }
        }
        loadVTLayers() {
          return (
            this.vtLayers ||
              ((this.vtLayers = new yl.VectorTile(
                new Lc(this.rawTileData),
              ).layers),
              (this.sourceLayerCoder = new yd(
                this.vtLayers
                  ? Object.keys(this.vtLayers).sort()
                  : ["_geojsonTileLayer"],
              ))),
            this.vtLayers
          );
        }
        query(t, r, o, l) {
          this.loadVTLayers();
          const d = t.params,
            p = qe / t.tileSize / t.scale,
            m = js(d.filter),
            _ = t.queryGeometry,
            x = t.queryPadding * p,
            b = wd(_),
            w = this.grid.query(b.minX - x, b.minY - x, b.maxX + x, b.maxY + x),
            F = wd(t.cameraQueryGeometry),
            S = this.grid3D.query(
              F.minX - x,
              F.minY - x,
              F.maxX + x,
              F.maxY + x,
              (O, Z, ne, H) =>
                (function (P, R, W, de, Te) {
                  for (const xe of P)
                    if (R <= xe.x && W <= xe.y && de >= xe.x && Te >= xe.y)
                      return !0;
                  const ge = [
                    new Ze(R, W),
                    new Ze(R, Te),
                    new Ze(de, Te),
                    new Ze(de, W),
                  ];
                  if (P.length > 2) {
                    for (const xe of ge) if (ta(P, xe)) return !0;
                  }
                  for (let xe = 0; xe < P.length - 1; xe++)
                    if (np(P[xe], P[xe + 1], ge)) return !0;
                  return !1;
                })(t.cameraQueryGeometry, O - x, Z - x, ne + x, H + x),
            );
          for (const O of S) w.push(O);
          w.sort(df);
          const D = {};
          let I;
          for (let O = 0; O < w.length; O++) {
            const Z = w[O];
            if (Z === I) continue;
            I = Z;
            const ne = this.featureIndexArray.get(Z);
            let H = null;
            this.loadMatchingFeature(
              D,
              ne.bucketIndex,
              ne.sourceLayerIndex,
              ne.featureIndex,
              m,
              d.layers,
              d.availableImages,
              r,
              o,
              l,
              (P, R, W) => (
                H || (H = Nn(P)),
                R.queryIntersectsFeature({
                  queryGeometry: _,
                  feature: P,
                  featureState: W,
                  geometry: H,
                  zoom: this.z,
                  transform: t.transform,
                  pixelsToTileUnits: p,
                  pixelPosMatrix: t.pixelPosMatrix,
                })
              ),
            );
          }
          return D;
        }
        loadMatchingFeature(t, r, o, l, d, p, m, _, x, b, w) {
          const F = this.bucketLayerIDs[r];
          if (p && !F.some((O) => p.has(O))) return;
          const S = this.sourceLayerCoder.decode(o),
            D = this.vtLayers[S].feature(l);
          if (d.needGeometry) {
            const O = Vn(D, !0);
            if (
              !d.filter(
                new jt(this.tileID.overscaledZ),
                O,
                this.tileID.canonical,
              )
            )
              return;
          } else if (!d.filter(new jt(this.tileID.overscaledZ), D)) return;
          const I = this.getId(D, S);
          for (let O = 0; O < F.length; O++) {
            const Z = F[O];
            if (p && !p.has(Z)) continue;
            const ne = _[Z];
            if (!ne) continue;
            let H = {};
            I &&
              b &&
              (H = b.getState(ne.sourceLayer || "_geojsonTileLayer", I));
            const P = yi({}, x[Z]);
            ((P.paint = bd(P.paint, ne.paint, D, H, m)),
              (P.layout = bd(P.layout, ne.layout, D, H, m)));
            const R = !w || w(D, ne, H);
            if (!R) continue;
            const W = new xd(D, this.z, this.x, this.y, I);
            W.layer = P;
            let de = t[Z];
            (de === void 0 && (de = t[Z] = []),
              de.push({ featureIndex: l, feature: W, intersectionZ: R }));
          }
        }
        lookupSymbolFeatures(t, r, o, l, d, p, m, _) {
          const x = {};
          this.loadVTLayers();
          const b = js(d);
          for (const w of t)
            this.loadMatchingFeature(x, o, l, w, b, p, m, _, r);
          return x;
        }
        hasLayer(t) {
          for (const r of this.bucketLayerIDs)
            for (const o of r) if (t === o) return !0;
          return !1;
        }
        getId(t, r) {
          var o;
          let l = t.id;
          return (
            this.promoteId &&
              ((l =
                t.properties[
                  typeof this.promoteId == "string"
                    ? this.promoteId
                    : this.promoteId[r]
                ]),
              typeof l == "boolean" && (l = Number(l)),
              l === void 0 &&
                ((o = t.properties) === null || o === void 0
                  ? void 0
                  : o.cluster) &&
                this.promoteId &&
                (l = Number(t.properties.cluster_id))),
            l
          );
        }
      }
      function bd(n, t, r, o, l) {
        return fn(n, (d, p) => {
          const m = t instanceof po ? t.get(p) : null;
          return m && m.evaluate ? m.evaluate(r, o, l) : m;
        });
      }
      function wd(n) {
        let t = 1 / 0,
          r = 1 / 0,
          o = -1 / 0,
          l = -1 / 0;
        for (const d of n)
          ((t = Math.min(t, d.x)),
            (r = Math.min(r, d.y)),
            (o = Math.max(o, d.x)),
            (l = Math.max(l, d.y)));
        return { minX: t, minY: r, maxX: o, maxY: l };
      }
      function df(n, t) {
        return t - n;
      }
      function Cd(n, t, r, o, l) {
        const d = [];
        for (let p = 0; p < n.length; p++) {
          const m = n[p];
          let _;
          for (let x = 0; x < m.length - 1; x++) {
            let b = m[x],
              w = m[x + 1];
            (b.x < t && w.x < t) ||
              (b.x < t
                ? (b = new Ze(
                    t,
                    b.y + ((t - b.x) / (w.x - b.x)) * (w.y - b.y),
                  )._round())
                : w.x < t &&
                  (w = new Ze(
                    t,
                    b.y + ((t - b.x) / (w.x - b.x)) * (w.y - b.y),
                  )._round()),
              (b.y < r && w.y < r) ||
                (b.y < r
                  ? (b = new Ze(
                      b.x + ((r - b.y) / (w.y - b.y)) * (w.x - b.x),
                      r,
                    )._round())
                  : w.y < r &&
                    (w = new Ze(
                      b.x + ((r - b.y) / (w.y - b.y)) * (w.x - b.x),
                      r,
                    )._round()),
                (b.x >= o && w.x >= o) ||
                  (b.x >= o
                    ? (b = new Ze(
                        o,
                        b.y + ((o - b.x) / (w.x - b.x)) * (w.y - b.y),
                      )._round())
                    : w.x >= o &&
                      (w = new Ze(
                        o,
                        b.y + ((o - b.x) / (w.x - b.x)) * (w.y - b.y),
                      )._round()),
                  (b.y >= l && w.y >= l) ||
                    (b.y >= l
                      ? (b = new Ze(
                          b.x + ((l - b.y) / (w.y - b.y)) * (w.x - b.x),
                          l,
                        )._round())
                      : w.y >= l &&
                        (w = new Ze(
                          b.x + ((l - b.y) / (w.y - b.y)) * (w.x - b.x),
                          l,
                        )._round()),
                    (_ && b.equals(_[_.length - 1])) || ((_ = [b]), d.push(_)),
                    _.push(w)))));
          }
        }
        return d;
      }
      Re("FeatureIndex", vd, { omit: ["rawTileData", "sourceLayerCoder"] });
      class vo extends Ze {
        constructor(t, r, o, l) {
          (super(t, r), (this.angle = o), l !== void 0 && (this.segment = l));
        }
        clone() {
          return new vo(this.x, this.y, this.angle, this.segment);
        }
      }
      function Ed(n, t, r, o, l) {
        if (t.segment === void 0 || r === 0) return !0;
        let d = t,
          p = t.segment + 1,
          m = 0;
        for (; m > -r / 2; ) {
          if ((p--, p < 0)) return !1;
          ((m -= n[p].dist(d)), (d = n[p]));
        }
        ((m += n[p].dist(n[p + 1])), p++);
        const _ = [];
        let x = 0;
        for (; m < r / 2; ) {
          const b = n[p],
            w = n[p + 1];
          if (!w) return !1;
          let F = n[p - 1].angleTo(b) - b.angleTo(w);
          for (
            F = Math.abs(((F + 3 * Math.PI) % (2 * Math.PI)) - Math.PI),
              _.push({ distance: m, angleDelta: F }),
              x += F;
            m - _[0].distance > o;

          )
            x -= _.shift().angleDelta;
          if (x > l) return !1;
          (p++, (m += b.dist(w)));
        }
        return !0;
      }
      function Ad(n) {
        let t = 0;
        for (let r = 0; r < n.length - 1; r++) t += n[r].dist(n[r + 1]);
        return t;
      }
      function Td(n, t, r) {
        return n ? 0.6 * t * r : 0;
      }
      function Fd(n, t) {
        return Math.max(n ? n.right - n.left : 0, t ? t.right - t.left : 0);
      }
      function pf(n, t, r, o, l, d) {
        const p = Td(r, l, d),
          m = Fd(r, o) * d;
        let _ = 0;
        const x = Ad(n) / 2;
        for (let b = 0; b < n.length - 1; b++) {
          const w = n[b],
            F = n[b + 1],
            S = w.dist(F);
          if (_ + S > x) {
            const D = (x - _) / S,
              I = Pr.number(w.x, F.x, D),
              O = Pr.number(w.y, F.y, D),
              Z = new vo(I, O, F.angleTo(w), b);
            return (Z._round(), !p || Ed(n, Z, m, p, t) ? Z : void 0);
          }
          _ += S;
        }
      }
      function ff(n, t, r, o, l, d, p, m, _) {
        const x = Td(o, d, p),
          b = Fd(o, l),
          w = b * p,
          F = n[0].x === 0 || n[0].x === _ || n[0].y === 0 || n[0].y === _;
        return (
          t - w < t / 4 && (t = w + t / 4),
          Pd(
            n,
            F ? ((t / 2) * m) % t : ((b / 2 + 2 * d) * p * m) % t,
            t,
            x,
            r,
            w,
            F,
            !1,
            _,
          )
        );
      }
      function Pd(n, t, r, o, l, d, p, m, _) {
        const x = d / 2,
          b = Ad(n);
        let w = 0,
          F = t - r,
          S = [];
        for (let D = 0; D < n.length - 1; D++) {
          const I = n[D],
            O = n[D + 1],
            Z = I.dist(O),
            ne = O.angleTo(I);
          for (; F + r < w + Z; ) {
            F += r;
            const H = (F - w) / Z,
              P = Pr.number(I.x, O.x, H),
              R = Pr.number(I.y, O.y, H);
            if (
              P >= 0 &&
              P < _ &&
              R >= 0 &&
              R < _ &&
              F - x >= 0 &&
              F + x <= b
            ) {
              const W = new vo(P, R, ne, D);
              (W._round(), (o && !Ed(n, W, d, o, l)) || S.push(W));
            }
          }
          w += Z;
        }
        return (
          m || S.length || p || (S = Pd(n, w / 2, r, o, l, d, p, !0, _)),
          S
        );
      }
      Re("Anchor", vo);
      const la = rr;
      function Sd(n, t, r, o) {
        const l = [],
          d = n.image,
          p = d.pixelRatio,
          m = d.paddedRect.w - 2 * la,
          _ = d.paddedRect.h - 2 * la;
        let x = { x1: n.left, y1: n.top, x2: n.right, y2: n.bottom };
        const b = d.stretchX || [[0, m]],
          w = d.stretchY || [[0, _]],
          F = (we, Ne) => we + Ne[1] - Ne[0],
          S = b.reduce(F, 0),
          D = w.reduce(F, 0),
          I = m - S,
          O = _ - D;
        let Z = 0,
          ne = S,
          H = 0,
          P = D,
          R = 0,
          W = I,
          de = 0,
          Te = O;
        if (d.content && o) {
          const we = d.content,
            Ne = we[2] - we[0],
            Ke = we[3] - we[1];
          ((d.textFitWidth || d.textFitHeight) && (x = td(n)),
            (Z = $u(b, 0, we[0])),
            (H = $u(w, 0, we[1])),
            (ne = $u(b, we[0], we[2])),
            (P = $u(w, we[1], we[3])),
            (R = we[0] - Z),
            (de = we[1] - H),
            (W = Ne - ne),
            (Te = Ke - P));
        }
        const ge = x.x1,
          xe = x.y1,
          Se = x.x2 - ge,
          Pe = x.y2 - xe,
          De = (we, Ne, Ke, We) => {
            const Ge = Zu(we.stretch - Z, ne, Se, ge),
              dt = Gu(we.fixed - R, W, we.stretch, S),
              Xt = Zu(Ne.stretch - H, P, Pe, xe),
              di = Gu(Ne.fixed - de, Te, Ne.stretch, D),
              bi = Zu(Ke.stretch - Z, ne, Se, ge),
              Br = Gu(Ke.fixed - R, W, Ke.stretch, S),
              Gi = Zu(We.stretch - H, P, Pe, xe),
              wi = Gu(We.fixed - de, Te, We.stretch, D),
              Si = new Ze(Ge, Xt),
              Jt = new Ze(bi, Xt),
              pi = new Ze(bi, Gi),
              qi = new Ze(Ge, Gi),
              Hi = new Ze(dt / p, di / p),
              Xi = new Ze(Br / p, wi / p),
              fi = (t * Math.PI) / 180;
            if (fi) {
              const bt = Math.sin(fi),
                Di = Math.cos(fi),
                qt = [Di, -bt, bt, Di];
              (Si._matMult(qt),
                Jt._matMult(qt),
                qi._matMult(qt),
                pi._matMult(qt));
            }
            const wr = we.stretch + we.fixed,
              nr = Ne.stretch + Ne.fixed;
            return {
              tl: Si,
              tr: Jt,
              bl: qi,
              br: pi,
              tex: {
                x: d.paddedRect.x + la + wr,
                y: d.paddedRect.y + la + nr,
                w: Ke.stretch + Ke.fixed - wr,
                h: We.stretch + We.fixed - nr,
              },
              writingMode: void 0,
              glyphOffset: [0, 0],
              sectionIndex: 0,
              pixelOffsetTL: Hi,
              pixelOffsetBR: Xi,
              minFontScaleX: W / p / Se,
              minFontScaleY: Te / p / Pe,
              isSDF: r,
            };
          };
        if (o && (d.stretchX || d.stretchY)) {
          const we = Dd(b, I, S),
            Ne = Dd(w, O, D);
          for (let Ke = 0; Ke < we.length - 1; Ke++) {
            const We = we[Ke],
              Ge = we[Ke + 1];
            for (let dt = 0; dt < Ne.length - 1; dt++)
              l.push(De(We, Ne[dt], Ge, Ne[dt + 1]));
          }
        } else
          l.push(
            De(
              { fixed: 0, stretch: -1 },
              { fixed: 0, stretch: -1 },
              { fixed: 0, stretch: m + 1 },
              { fixed: 0, stretch: _ + 1 },
            ),
          );
        return l;
      }
      function $u(n, t, r) {
        let o = 0;
        for (const l of n)
          o += Math.max(t, Math.min(r, l[1])) - Math.max(t, Math.min(r, l[0]));
        return o;
      }
      function Dd(n, t, r) {
        const o = [{ fixed: -la, stretch: 0 }];
        for (const [l, d] of n) {
          const p = o[o.length - 1];
          (o.push({ fixed: l - p.stretch, stretch: p.stretch }),
            o.push({ fixed: l - p.stretch, stretch: p.stretch + (d - l) }));
        }
        return (o.push({ fixed: t + la, stretch: r }), o);
      }
      function Zu(n, t, r, o) {
        return (n / t) * r + o;
      }
      function Gu(n, t, r, o) {
        return n - (t * r) / o;
      }
      class qu {
        constructor(t, r, o, l, d, p, m, _, x, b) {
          var w;
          if (((this.boxStartIndex = t.length), x)) {
            let F = p.top,
              S = p.bottom;
            const D = p.collisionPadding;
            D && ((F -= D[1]), (S += D[3]));
            let I = S - F;
            I > 0 && ((I = Math.max(10, I)), (this.circleDiameter = I));
          } else {
            const F =
              ((w = p.image) === null || w === void 0 ? void 0 : w.content) &&
              (p.image.textFitWidth || p.image.textFitHeight)
                ? td(p)
                : { x1: p.left, y1: p.top, x2: p.right, y2: p.bottom };
            ((F.y1 = F.y1 * m - _[0]),
              (F.y2 = F.y2 * m + _[2]),
              (F.x1 = F.x1 * m - _[3]),
              (F.x2 = F.x2 * m + _[1]));
            const S = p.collisionPadding;
            if (
              (S &&
                ((F.x1 -= S[0] * m),
                (F.y1 -= S[1] * m),
                (F.x2 += S[2] * m),
                (F.y2 += S[3] * m)),
              b)
            ) {
              const D = new Ze(F.x1, F.y1),
                I = new Ze(F.x2, F.y1),
                O = new Ze(F.x1, F.y2),
                Z = new Ze(F.x2, F.y2),
                ne = (b * Math.PI) / 180;
              (D._rotate(ne),
                I._rotate(ne),
                O._rotate(ne),
                Z._rotate(ne),
                (F.x1 = Math.min(D.x, I.x, O.x, Z.x)),
                (F.x2 = Math.max(D.x, I.x, O.x, Z.x)),
                (F.y1 = Math.min(D.y, I.y, O.y, Z.y)),
                (F.y2 = Math.max(D.y, I.y, O.y, Z.y)));
            }
            t.emplaceBack(r.x, r.y, F.x1, F.y1, F.x2, F.y2, o, l, d);
          }
          this.boxEndIndex = t.length;
        }
      }
      class mf {
        constructor(t = [], r = (o, l) => (o < l ? -1 : o > l ? 1 : 0)) {
          if (
            ((this.data = t),
            (this.length = this.data.length),
            (this.compare = r),
            this.length > 0)
          )
            for (let o = (this.length >> 1) - 1; o >= 0; o--) this._down(o);
        }
        push(t) {
          (this.data.push(t), this._up(this.length++));
        }
        pop() {
          if (this.length === 0) return;
          const t = this.data[0],
            r = this.data.pop();
          return (--this.length > 0 && ((this.data[0] = r), this._down(0)), t);
        }
        peek() {
          return this.data[0];
        }
        _up(t) {
          const { data: r, compare: o } = this,
            l = r[t];
          for (; t > 0; ) {
            const d = (t - 1) >> 1,
              p = r[d];
            if (o(l, p) >= 0) break;
            ((r[t] = p), (t = d));
          }
          r[t] = l;
        }
        _down(t) {
          const { data: r, compare: o } = this,
            l = this.length >> 1,
            d = r[t];
          for (; t < l; ) {
            let p = 1 + (t << 1);
            const m = p + 1;
            if (
              (m < this.length && o(r[m], r[p]) < 0 && (p = m), o(r[p], d) >= 0)
            )
              break;
            ((r[t] = r[p]), (t = p));
          }
          r[t] = d;
        }
      }
      function gf(n, t = 1, r = !1) {
        let o = 1 / 0,
          l = 1 / 0,
          d = -1 / 0,
          p = -1 / 0;
        const m = n[0];
        for (let S = 0; S < m.length; S++) {
          const D = m[S];
          ((!S || D.x < o) && (o = D.x),
            (!S || D.y < l) && (l = D.y),
            (!S || D.x > d) && (d = D.x),
            (!S || D.y > p) && (p = D.y));
        }
        const _ = Math.min(d - o, p - l);
        let x = _ / 2;
        const b = new mf([], _f);
        if (_ === 0) return new Ze(o, l);
        for (let S = o; S < d; S += _)
          for (let D = l; D < p; D += _) b.push(new ua(S + x, D + x, x, n));
        let w = (function (S) {
            let D = 0,
              I = 0,
              O = 0;
            const Z = S[0];
            for (let ne = 0, H = Z.length, P = H - 1; ne < H; P = ne++) {
              const R = Z[ne],
                W = Z[P],
                de = R.x * W.y - W.x * R.y;
              ((I += (R.x + W.x) * de), (O += (R.y + W.y) * de), (D += 3 * de));
            }
            return new ua(I / D, O / D, 0, S);
          })(n),
          F = b.length;
        for (; b.length; ) {
          const S = b.pop();
          ((S.d > w.d || !w.d) &&
            ((w = S),
            r &&
              console.log(
                "found best %d after %d probes",
                Math.round(1e4 * S.d) / 1e4,
                F,
              )),
            S.max - w.d <= t ||
              ((x = S.h / 2),
              b.push(new ua(S.p.x - x, S.p.y - x, x, n)),
              b.push(new ua(S.p.x + x, S.p.y - x, x, n)),
              b.push(new ua(S.p.x - x, S.p.y + x, x, n)),
              b.push(new ua(S.p.x + x, S.p.y + x, x, n)),
              (F += 4)));
        }
        return (
          r &&
            (console.log(`num probes: ${F}`),
            console.log(`best distance: ${w.d}`)),
          w.p
        );
      }
      function _f(n, t) {
        return t.max - n.max;
      }
      function ua(n, t, r, o) {
        ((this.p = new Ze(n, t)),
          (this.h = r),
          (this.d = (function (l, d) {
            let p = !1,
              m = 1 / 0;
            for (let _ = 0; _ < d.length; _++) {
              const x = d[_];
              for (let b = 0, w = x.length, F = w - 1; b < w; F = b++) {
                const S = x[b],
                  D = x[F];
                (S.y > l.y != D.y > l.y &&
                  l.x < ((D.x - S.x) * (l.y - S.y)) / (D.y - S.y) + S.x &&
                  (p = !p),
                  (m = Math.min(m, ch(l, S, D))));
              }
            }
            return (p ? 1 : -1) * Math.sqrt(m);
          })(this.p, o)),
          (this.max = this.d + this.h * Math.SQRT2));
      }
      var Pi;
      ((E.av = void 0),
        ((Pi = E.av || (E.av = {}))[(Pi.center = 1)] = "center"),
        (Pi[(Pi.left = 2)] = "left"),
        (Pi[(Pi.right = 3)] = "right"),
        (Pi[(Pi.top = 4)] = "top"),
        (Pi[(Pi.bottom = 5)] = "bottom"),
        (Pi[(Pi["top-left"] = 6)] = "top-left"),
        (Pi[(Pi["top-right"] = 7)] = "top-right"),
        (Pi[(Pi["bottom-left"] = 8)] = "bottom-left"),
        (Pi[(Pi["bottom-right"] = 9)] = "bottom-right"));
      const bo = 7,
        Wc = Number.POSITIVE_INFINITY;
      function Md(n, t) {
        return t[1] !== Wc
          ? (function (r, o, l) {
              let d = 0,
                p = 0;
              switch (((o = Math.abs(o)), (l = Math.abs(l)), r)) {
                case "top-right":
                case "top-left":
                case "top":
                  p = l - bo;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  p = -l + bo;
              }
              switch (r) {
                case "top-right":
                case "bottom-right":
                case "right":
                  d = -o;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  d = o;
              }
              return [d, p];
            })(n, t[0], t[1])
          : (function (r, o) {
              let l = 0,
                d = 0;
              o < 0 && (o = 0);
              const p = o / Math.SQRT2;
              switch (r) {
                case "top-right":
                case "top-left":
                  d = p - bo;
                  break;
                case "bottom-right":
                case "bottom-left":
                  d = -p + bo;
                  break;
                case "bottom":
                  d = -o + bo;
                  break;
                case "top":
                  d = o - bo;
              }
              switch (r) {
                case "top-right":
                case "bottom-right":
                  l = -p;
                  break;
                case "top-left":
                case "bottom-left":
                  l = p;
                  break;
                case "left":
                  l = o;
                  break;
                case "right":
                  l = -o;
              }
              return [l, d];
            })(n, t[0]);
      }
      function Id(n, t, r) {
        var o;
        const l = n.layout,
          d =
            (o = l.get("text-variable-anchor-offset")) === null || o === void 0
              ? void 0
              : o.evaluate(t, {}, r);
        if (d) {
          const m = d.values,
            _ = [];
          for (let x = 0; x < m.length; x += 2) {
            const b = (_[x] = m[x]),
              w = m[x + 1].map((F) => F * hi);
            (b.startsWith("top")
              ? (w[1] -= bo)
              : b.startsWith("bottom") && (w[1] += bo),
              (_[x + 1] = w));
          }
          return new Ti(_);
        }
        const p = l.get("text-variable-anchor");
        if (p) {
          let m;
          m =
            n._unevaluatedLayout.getValue("text-radial-offset") !== void 0
              ? [l.get("text-radial-offset").evaluate(t, {}, r) * hi, Wc]
              : l
                  .get("text-offset")
                  .evaluate(t, {}, r)
                  .map((x) => x * hi);
          const _ = [];
          for (const x of p) _.push(x, Md(x, m));
          return new Ti(_);
        }
        return null;
      }
      function Kc(n) {
        switch (n) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function yf(n, t, r, o, l, d, p, m, _, x, b, w) {
        let F = d.textMaxSize.evaluate(t, {});
        F === void 0 && (F = p);
        const S = n.layers[0].layout,
          D = S.get("icon-offset").evaluate(t, {}, b),
          I = kd(r.horizontal),
          O = p / 24,
          Z = n.tilePixelRatio * O,
          ne = (n.tilePixelRatio * F) / 24,
          H = n.tilePixelRatio * m,
          P = n.tilePixelRatio * S.get("symbol-spacing"),
          R = S.get("text-padding") * n.tilePixelRatio,
          W = (function (Ke, We, Ge, dt = 1) {
            const Xt = Ke.get("icon-padding").evaluate(We, {}, Ge),
              di = Xt && Xt.values;
            return [di[0] * dt, di[1] * dt, di[2] * dt, di[3] * dt];
          })(S, t, b, n.tilePixelRatio),
          de = (S.get("text-max-angle") / 180) * Math.PI,
          Te =
            S.get("text-rotation-alignment") !== "viewport" &&
            S.get("symbol-placement") !== "point",
          ge =
            S.get("icon-rotation-alignment") === "map" &&
            S.get("symbol-placement") !== "point",
          xe = S.get("symbol-placement"),
          Se = P / 2,
          Pe = S.get("icon-text-fit");
        let De;
        o &&
          Pe !== "none" &&
          (n.allowVerticalPlacement &&
            r.vertical &&
            (De = id(o, r.vertical, Pe, S.get("icon-text-fit-padding"), D, O)),
          I && (o = id(o, I, Pe, S.get("icon-text-fit-padding"), D, O)));
        const we = b ? w.line.getGranularityForZoomLevel(b.z) : 1,
          Ne = (Ke, We) => {
            We.x < 0 ||
              We.x >= qe ||
              We.y < 0 ||
              We.y >= qe ||
              (function (
                Ge,
                dt,
                Xt,
                di,
                bi,
                Br,
                Gi,
                wi,
                Si,
                Jt,
                pi,
                qi,
                Hi,
                Xi,
                fi,
                wr,
                nr,
                bt,
                Di,
                qt,
                Wt,
                gi,
                es,
                Cr,
                Xu,
              ) {
                const kr = Ge.addToLineVertexArray(dt, Xt);
                let pr,
                  Ci,
                  Er,
                  Un,
                  Od = 0,
                  jd = 0,
                  Nd = 0,
                  Vd = 0,
                  nh = -1,
                  oh = -1;
                const $n = {};
                let Ud = si("");
                if (Ge.allowVerticalPlacement && di.vertical) {
                  const Oi =
                    wi.layout.get("text-rotate").evaluate(Wt, {}, Cr) + 90;
                  ((Er = new qu(
                    Si,
                    dt,
                    Jt,
                    pi,
                    qi,
                    di.vertical,
                    Hi,
                    Xi,
                    fi,
                    Oi,
                  )),
                    Gi &&
                      (Un = new qu(Si, dt, Jt, pi, qi, Gi, nr, bt, fi, Oi)));
                }
                if (bi) {
                  const Oi = wi.layout.get("icon-rotate").evaluate(Wt, {}),
                    Ar = wi.layout.get("icon-text-fit") !== "none",
                    ts = Sd(bi, Oi, es, Ar),
                    Hr = Gi ? Sd(Gi, Oi, es, Ar) : void 0;
                  ((Ci = new qu(Si, dt, Jt, pi, qi, bi, nr, bt, !1, Oi)),
                    (Od = 4 * ts.length));
                  const is = Ge.iconSizeData;
                  let un = null;
                  (is.kind === "source"
                    ? ((un = [
                        ln * wi.layout.get("icon-size").evaluate(Wt, {}),
                      ]),
                      un[0] > yo &&
                        Ai(
                          `${Ge.layerIds[0]}: Value for "icon-size" is >= ${El}. Reduce your "icon-size".`,
                        ))
                    : is.kind === "composite" &&
                      ((un = [
                        ln * gi.compositeIconSizes[0].evaluate(Wt, {}, Cr),
                        ln * gi.compositeIconSizes[1].evaluate(Wt, {}, Cr),
                      ]),
                      (un[0] > yo || un[1] > yo) &&
                        Ai(
                          `${Ge.layerIds[0]}: Value for "icon-size" is >= ${El}. Reduce your "icon-size".`,
                        )),
                    Ge.addSymbols(
                      Ge.icon,
                      ts,
                      un,
                      qt,
                      Di,
                      Wt,
                      E.ai.none,
                      dt,
                      kr.lineStartIndex,
                      kr.lineLength,
                      -1,
                      Cr,
                    ),
                    (nh = Ge.icon.placedSymbolArray.length - 1),
                    Hr &&
                      ((jd = 4 * Hr.length),
                      Ge.addSymbols(
                        Ge.icon,
                        Hr,
                        un,
                        qt,
                        Di,
                        Wt,
                        E.ai.vertical,
                        dt,
                        kr.lineStartIndex,
                        kr.lineLength,
                        -1,
                        Cr,
                      ),
                      (oh = Ge.icon.placedSymbolArray.length - 1)));
                }
                const $d = Object.keys(di.horizontal);
                for (const Oi of $d) {
                  const Ar = di.horizontal[Oi];
                  if (!pr) {
                    Ud = si(Ar.text);
                    const Hr = wi.layout
                      .get("text-rotate")
                      .evaluate(Wt, {}, Cr);
                    pr = new qu(Si, dt, Jt, pi, qi, Ar, Hi, Xi, fi, Hr);
                  }
                  const ts = Ar.positionedLines.length === 1;
                  if (
                    ((Nd += Bd(
                      Ge,
                      dt,
                      Ar,
                      Br,
                      wi,
                      fi,
                      Wt,
                      wr,
                      kr,
                      di.vertical ? E.ai.horizontal : E.ai.horizontalOnly,
                      ts ? $d : [Oi],
                      $n,
                      nh,
                      gi,
                      Cr,
                    )),
                    ts)
                  )
                    break;
                }
                di.vertical &&
                  (Vd += Bd(
                    Ge,
                    dt,
                    di.vertical,
                    Br,
                    wi,
                    fi,
                    Wt,
                    wr,
                    kr,
                    E.ai.vertical,
                    ["vertical"],
                    $n,
                    oh,
                    gi,
                    Cr,
                  ));
                const bf = pr ? pr.boxStartIndex : Ge.collisionBoxArray.length,
                  wf = pr ? pr.boxEndIndex : Ge.collisionBoxArray.length,
                  Cf = Er ? Er.boxStartIndex : Ge.collisionBoxArray.length,
                  Ef = Er ? Er.boxEndIndex : Ge.collisionBoxArray.length,
                  Af = Ci ? Ci.boxStartIndex : Ge.collisionBoxArray.length,
                  Tf = Ci ? Ci.boxEndIndex : Ge.collisionBoxArray.length,
                  Ff = Un ? Un.boxStartIndex : Ge.collisionBoxArray.length,
                  Pf = Un ? Un.boxEndIndex : Ge.collisionBoxArray.length;
                let qr = -1;
                const Wu = (Oi, Ar) =>
                  Oi && Oi.circleDiameter
                    ? Math.max(Oi.circleDiameter, Ar)
                    : Ar;
                ((qr = Wu(pr, qr)),
                  (qr = Wu(Er, qr)),
                  (qr = Wu(Ci, qr)),
                  (qr = Wu(Un, qr)));
                const Zd = qr > -1 ? 1 : 0;
                (Zd && (qr *= Xu / hi),
                  Ge.glyphOffsetArray.length >= sa.MAX_GLYPHS &&
                    Ai(
                      "Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907",
                    ),
                  Wt.sortKey !== void 0 &&
                    Ge.addToSortKeyRanges(
                      Ge.symbolInstances.length,
                      Wt.sortKey,
                    ));
                const Sf = Id(wi, Wt, Cr),
                  [Df, Mf] = (function (Oi, Ar) {
                    const ts = Oi.length,
                      Hr = Ar == null ? void 0 : Ar.values;
                    if ((Hr == null ? void 0 : Hr.length) > 0)
                      for (let is = 0; is < Hr.length; is += 2) {
                        const un = Hr[is + 1];
                        Oi.emplaceBack(E.av[Hr[is]], un[0], un[1]);
                      }
                    return [ts, Oi.length];
                  })(Ge.textAnchorOffsets, Sf);
                Ge.symbolInstances.emplaceBack(
                  dt.x,
                  dt.y,
                  $n.right >= 0 ? $n.right : -1,
                  $n.center >= 0 ? $n.center : -1,
                  $n.left >= 0 ? $n.left : -1,
                  $n.vertical || -1,
                  nh,
                  oh,
                  Ud,
                  bf,
                  wf,
                  Cf,
                  Ef,
                  Af,
                  Tf,
                  Ff,
                  Pf,
                  Jt,
                  Nd,
                  Vd,
                  Od,
                  jd,
                  Zd,
                  0,
                  Hi,
                  qr,
                  Df,
                  Mf,
                );
              })(
                n,
                We,
                Ke,
                r,
                o,
                l,
                De,
                n.layers[0],
                n.collisionBoxArray,
                t.index,
                t.sourceLayerIndex,
                n.index,
                Z,
                [R, R, R, R],
                Te,
                _,
                H,
                W,
                ge,
                D,
                t,
                d,
                x,
                b,
                p,
              );
          };
        if (xe === "line")
          for (const Ke of Cd(t.geometry, 0, 0, qe, qe)) {
            const We = Qo(Ke, we),
              Ge = ff(We, P, de, r.vertical || I, o, 24, ne, n.overscaling, qe);
            for (const dt of Ge) (I && xf(n, I.text, Se, dt)) || Ne(We, dt);
          }
        else if (xe === "line-center") {
          for (const Ke of t.geometry)
            if (Ke.length > 1) {
              const We = Qo(Ke, we),
                Ge = pf(We, de, r.vertical || I, o, 24, ne);
              Ge && Ne(We, Ge);
            }
        } else if (t.type === "Polygon")
          for (const Ke of Kn(t.geometry, 0)) {
            const We = gf(Ke, 16);
            Ne(Qo(Ke[0], we, !0), new vo(We.x, We.y, 0));
          }
        else if (t.type === "LineString")
          for (const Ke of t.geometry) {
            const We = Qo(Ke, we);
            Ne(We, new vo(We[0].x, We[0].y, 0));
          }
        else if (t.type === "Point")
          for (const Ke of t.geometry)
            for (const We of Ke) Ne([We], new vo(We.x, We.y, 0));
      }
      function Bd(n, t, r, o, l, d, p, m, _, x, b, w, F, S, D) {
        const I = (function (ne, H, P, R, W, de, Te, ge) {
            const xe =
                (R.layout.get("text-rotate").evaluate(de, {}) * Math.PI) / 180,
              Se = [];
            for (const Pe of H.positionedLines)
              for (const De of Pe.positionedGlyphs) {
                if (!De.rect) continue;
                const we = De.rect || {};
                let Ne = Xh + 1,
                  Ke = !0,
                  We = 1,
                  Ge = 0;
                const dt = (W || ge) && De.vertical,
                  Xt = (De.metrics.advance * De.scale) / 2;
                if (
                  (ge &&
                    H.verticalizable &&
                    (Ge =
                      Pe.lineOffset / 2 -
                      (De.imageName
                        ? -(hi - De.metrics.width * De.scale) / 2
                        : (De.scale - 1) * hi)),
                  De.imageName)
                ) {
                  const bt = Te[De.imageName];
                  ((Ke = bt.sdf), (We = bt.pixelRatio), (Ne = rr / We));
                }
                const di = W ? [De.x + Xt, De.y] : [0, 0];
                let bi = W ? [0, 0] : [De.x + Xt + P[0], De.y + P[1] - Ge],
                  Br = [0, 0];
                dt && ((Br = bi), (bi = [0, 0]));
                const Gi = De.metrics.isDoubleResolution ? 2 : 1,
                  wi = (De.metrics.left - Ne) * De.scale - Xt + bi[0],
                  Si = (-De.metrics.top - Ne) * De.scale + bi[1],
                  Jt = wi + ((we.w / Gi) * De.scale) / We,
                  pi = Si + ((we.h / Gi) * De.scale) / We,
                  qi = new Ze(wi, Si),
                  Hi = new Ze(Jt, Si),
                  Xi = new Ze(wi, pi),
                  fi = new Ze(Jt, pi);
                if (dt) {
                  const bt = new Ze(-Xt, Xt - wl),
                    Di = -Math.PI / 2,
                    qt = hi / 2 - Xt,
                    Wt = new Ze(5 - wl - qt, -(De.imageName ? qt : 0)),
                    gi = new Ze(...Br);
                  (qi._rotateAround(Di, bt)._add(Wt)._add(gi),
                    Hi._rotateAround(Di, bt)._add(Wt)._add(gi),
                    Xi._rotateAround(Di, bt)._add(Wt)._add(gi),
                    fi._rotateAround(Di, bt)._add(Wt)._add(gi));
                }
                if (xe) {
                  const bt = Math.sin(xe),
                    Di = Math.cos(xe),
                    qt = [Di, -bt, bt, Di];
                  (qi._matMult(qt),
                    Hi._matMult(qt),
                    Xi._matMult(qt),
                    fi._matMult(qt));
                }
                const wr = new Ze(0, 0),
                  nr = new Ze(0, 0);
                Se.push({
                  tl: qi,
                  tr: Hi,
                  bl: Xi,
                  br: fi,
                  tex: we,
                  writingMode: H.writingMode,
                  glyphOffset: di,
                  sectionIndex: De.sectionIndex,
                  isSDF: Ke,
                  pixelOffsetTL: wr,
                  pixelOffsetBR: nr,
                  minFontScaleX: 0,
                  minFontScaleY: 0,
                });
              }
            return Se;
          })(0, r, m, l, d, p, o, n.allowVerticalPlacement),
          O = n.textSizeData;
        let Z = null;
        (O.kind === "source"
          ? ((Z = [ln * l.layout.get("text-size").evaluate(p, {})]),
            Z[0] > yo &&
              Ai(
                `${n.layerIds[0]}: Value for "text-size" is >= ${El}. Reduce your "text-size".`,
              ))
          : O.kind === "composite" &&
            ((Z = [
              ln * S.compositeTextSizes[0].evaluate(p, {}, D),
              ln * S.compositeTextSizes[1].evaluate(p, {}, D),
            ]),
            (Z[0] > yo || Z[1] > yo) &&
              Ai(
                `${n.layerIds[0]}: Value for "text-size" is >= ${El}. Reduce your "text-size".`,
              )),
          n.addSymbols(
            n.text,
            I,
            Z,
            m,
            d,
            p,
            x,
            t,
            _.lineStartIndex,
            _.lineLength,
            F,
            D,
          ));
        for (const ne of b) w[ne] = n.text.placedSymbolArray.length - 1;
        return 4 * I.length;
      }
      function kd(n) {
        for (const t in n) return n[t];
        return null;
      }
      function xf(n, t, r, o) {
        const l = n.compareText;
        if (t in l) {
          const d = l[t];
          for (let p = d.length - 1; p >= 0; p--)
            if (o.dist(d[p]) < r) return !0;
        } else l[t] = [];
        return (l[t].push(o), !1);
      }
      const zd = [
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      ];
      class Yc {
        static from(t) {
          if (!(t instanceof ArrayBuffer))
            throw new Error("Data must be an instance of ArrayBuffer.");
          const [r, o] = new Uint8Array(t, 0, 2);
          if (r !== 219)
            throw new Error("Data does not appear to be in a KDBush format.");
          const l = o >> 4;
          if (l !== 1) throw new Error(`Got v${l} data when expected v1.`);
          const d = zd[15 & o];
          if (!d) throw new Error("Unrecognized array type.");
          const [p] = new Uint16Array(t, 2, 1),
            [m] = new Uint32Array(t, 4, 1);
          return new Yc(m, p, d, t);
        }
        constructor(t, r = 64, o = Float64Array, l) {
          if (isNaN(t) || t < 0)
            throw new Error(`Unpexpected numItems value: ${t}.`);
          ((this.numItems = +t),
            (this.nodeSize = Math.min(Math.max(+r, 2), 65535)),
            (this.ArrayType = o),
            (this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array));
          const d = zd.indexOf(this.ArrayType),
            p = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
            m = t * this.IndexArrayType.BYTES_PER_ELEMENT,
            _ = (8 - (m % 8)) % 8;
          if (d < 0) throw new Error(`Unexpected typed array class: ${o}.`);
          l && l instanceof ArrayBuffer
            ? ((this.data = l),
              (this.ids = new this.IndexArrayType(this.data, 8, t)),
              (this.coords = new this.ArrayType(this.data, 8 + m + _, 2 * t)),
              (this._pos = 2 * t),
              (this._finished = !0))
            : ((this.data = new ArrayBuffer(8 + p + m + _)),
              (this.ids = new this.IndexArrayType(this.data, 8, t)),
              (this.coords = new this.ArrayType(this.data, 8 + m + _, 2 * t)),
              (this._pos = 0),
              (this._finished = !1),
              new Uint8Array(this.data, 0, 2).set([219, 16 + d]),
              (new Uint16Array(this.data, 2, 1)[0] = r),
              (new Uint32Array(this.data, 4, 1)[0] = t));
        }
        add(t, r) {
          const o = this._pos >> 1;
          return (
            (this.ids[o] = o),
            (this.coords[this._pos++] = t),
            (this.coords[this._pos++] = r),
            o
          );
        }
        finish() {
          const t = this._pos >> 1;
          if (t !== this.numItems)
            throw new Error(`Added ${t} items when expected ${this.numItems}.`);
          return (
            Jc(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0),
            (this._finished = !0),
            this
          );
        }
        range(t, r, o, l) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: d, coords: p, nodeSize: m } = this,
            _ = [0, d.length - 1, 0],
            x = [];
          for (; _.length; ) {
            const b = _.pop() || 0,
              w = _.pop() || 0,
              F = _.pop() || 0;
            if (w - F <= m) {
              for (let O = F; O <= w; O++) {
                const Z = p[2 * O],
                  ne = p[2 * O + 1];
                Z >= t && Z <= o && ne >= r && ne <= l && x.push(d[O]);
              }
              continue;
            }
            const S = (F + w) >> 1,
              D = p[2 * S],
              I = p[2 * S + 1];
            (D >= t && D <= o && I >= r && I <= l && x.push(d[S]),
              (b === 0 ? t <= D : r <= I) &&
                (_.push(F), _.push(S - 1), _.push(1 - b)),
              (b === 0 ? o >= D : l >= I) &&
                (_.push(S + 1), _.push(w), _.push(1 - b)));
          }
          return x;
        }
        within(t, r, o) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: l, coords: d, nodeSize: p } = this,
            m = [0, l.length - 1, 0],
            _ = [],
            x = o * o;
          for (; m.length; ) {
            const b = m.pop() || 0,
              w = m.pop() || 0,
              F = m.pop() || 0;
            if (w - F <= p) {
              for (let O = F; O <= w; O++)
                Rd(d[2 * O], d[2 * O + 1], t, r) <= x && _.push(l[O]);
              continue;
            }
            const S = (F + w) >> 1,
              D = d[2 * S],
              I = d[2 * S + 1];
            (Rd(D, I, t, r) <= x && _.push(l[S]),
              (b === 0 ? t - o <= D : r - o <= I) &&
                (m.push(F), m.push(S - 1), m.push(1 - b)),
              (b === 0 ? t + o >= D : r + o >= I) &&
                (m.push(S + 1), m.push(w), m.push(1 - b)));
          }
          return _;
        }
      }
      function Jc(n, t, r, o, l, d) {
        if (l - o <= r) return;
        const p = (o + l) >> 1;
        (Ld(n, t, p, o, l, d),
          Jc(n, t, r, o, p - 1, 1 - d),
          Jc(n, t, r, p + 1, l, 1 - d));
      }
      function Ld(n, t, r, o, l, d) {
        for (; l > o; ) {
          if (l - o > 600) {
            const x = l - o + 1,
              b = r - o + 1,
              w = Math.log(x),
              F = 0.5 * Math.exp((2 * w) / 3),
              S =
                0.5 *
                Math.sqrt((w * F * (x - F)) / x) *
                (b - x / 2 < 0 ? -1 : 1);
            Ld(
              n,
              t,
              r,
              Math.max(o, Math.floor(r - (b * F) / x + S)),
              Math.min(l, Math.floor(r + ((x - b) * F) / x + S)),
              d,
            );
          }
          const p = t[2 * r + d];
          let m = o,
            _ = l;
          for (Tl(n, t, o, r), t[2 * l + d] > p && Tl(n, t, o, l); m < _; ) {
            for (Tl(n, t, m, _), m++, _--; t[2 * m + d] < p; ) m++;
            for (; t[2 * _ + d] > p; ) _--;
          }
          (t[2 * o + d] === p ? Tl(n, t, o, _) : (_++, Tl(n, t, _, l)),
            _ <= r && (o = _ + 1),
            r <= _ && (l = _ - 1));
        }
      }
      function Tl(n, t, r, o) {
        (Qc(n, r, o), Qc(t, 2 * r, 2 * o), Qc(t, 2 * r + 1, 2 * o + 1));
      }
      function Qc(n, t, r) {
        const o = n[t];
        ((n[t] = n[r]), (n[r] = o));
      }
      function Rd(n, t, r, o) {
        const l = n - r,
          d = t - o;
        return l * l + d * d;
      }
      var eh;
      ((E.ce = void 0),
        ((eh = E.ce || (E.ce = {})).create = "create"),
        (eh.load = "load"),
        (eh.fullLoad = "fullLoad"));
      let Hu = null,
        Fl = [];
      const th = 1e3 / 60,
        ih = "loadTime",
        rh = "fullLoadTime",
        vf = {
          mark(n) {
            performance.mark(n);
          },
          frame(n) {
            const t = n;
            (Hu != null && Fl.push(t - Hu), (Hu = t));
          },
          clearMetrics() {
            ((Hu = null),
              (Fl = []),
              performance.clearMeasures(ih),
              performance.clearMeasures(rh));
            for (const n in E.ce) performance.clearMarks(E.ce[n]);
          },
          getPerformanceMetrics() {
            (performance.measure(ih, E.ce.create, E.ce.load),
              performance.measure(rh, E.ce.create, E.ce.fullLoad));
            const n = performance.getEntriesByName(ih)[0].duration,
              t = performance.getEntriesByName(rh)[0].duration,
              r = Fl.length,
              o = 1 / (Fl.reduce((d, p) => d + p, 0) / r / 1e3),
              l = Fl.filter((d) => d > th).reduce(
                (d, p) => d + (p - th) / th,
                0,
              );
            return {
              loadTime: n,
              fullLoadTime: t,
              fps: o,
              percentDroppedFrames: (l / (r + l)) * 100,
              totalFrames: r,
            };
          },
        };
      ((E.$ = oe),
        (E.A = Dt),
        (E.B = Vo),
        (E.C = function (n) {
          if (ti == null) {
            const t = n.navigator ? n.navigator.userAgent : null;
            ti =
              !!n.safari ||
              !(
                !t ||
                !(
                  /\b(iPad|iPhone|iPod)\b/.test(t) ||
                  (t.match("Safari") && !t.match("Chrome"))
                )
              );
          }
          return ti;
        }),
        (E.D = He),
        (E.E = Qr),
        (E.F = class {
          constructor(n, t) {
            ((this.target = n),
              (this.mapId = t),
              (this.resolveRejects = {}),
              (this.tasks = {}),
              (this.taskQueue = []),
              (this.abortControllers = {}),
              (this.messageHandlers = {}),
              (this.invoker = new hf(() => this.process())),
              (this.subscription = (function (r, o, l, d) {
                return (
                  r.addEventListener(o, l, !1),
                  {
                    unsubscribe: () => {
                      r.removeEventListener(o, l, !1);
                    },
                  }
                );
              })(this.target, "message", (r) => this.receive(r))),
              (this.globalScope = zr(self) ? n : window));
          }
          registerMessageHandler(n, t) {
            this.messageHandlers[n] = t;
          }
          sendAsync(n, t) {
            return new Promise((r, o) => {
              const l = Math.round(1e18 * Math.random())
                .toString(36)
                .substring(0, 10);
              ((this.resolveRejects[l] = { resolve: r, reject: o }),
                t &&
                  t.signal.addEventListener(
                    "abort",
                    () => {
                      delete this.resolveRejects[l];
                      const m = {
                        id: l,
                        type: "<cancel>",
                        origin: location.origin,
                        targetMapId: n.targetMapId,
                        sourceMapId: this.mapId,
                      };
                      this.target.postMessage(m);
                    },
                    { once: !0 },
                  ));
              const d = [],
                p = Object.assign(Object.assign({}, n), {
                  id: l,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: Uo(n.data, d),
                });
              this.target.postMessage(p, { transfer: d });
            });
          }
          receive(n) {
            const t = n.data,
              r = t.id;
            if (
              !(
                (t.origin !== "file://" &&
                  location.origin !== "file://" &&
                  t.origin !== "resource://android" &&
                  location.origin !== "resource://android" &&
                  t.origin !== location.origin) ||
                (t.targetMapId && this.mapId !== t.targetMapId)
              )
            ) {
              if (t.type === "<cancel>") {
                delete this.tasks[r];
                const o = this.abortControllers[r];
                return (delete this.abortControllers[r], void (o && o.abort()));
              }
              if (zr(self) || t.mustQueue)
                return (
                  (this.tasks[r] = t),
                  this.taskQueue.push(r),
                  void this.invoker.trigger()
                );
              this.processTask(r, t);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const n = this.taskQueue.shift(),
              t = this.tasks[n];
            (delete this.tasks[n],
              this.taskQueue.length > 0 && this.invoker.trigger(),
              t && this.processTask(n, t));
          }
          processTask(n, t) {
            return u(this, void 0, void 0, function* () {
              if (t.type === "<response>") {
                const l = this.resolveRejects[n];
                return (
                  delete this.resolveRejects[n],
                  l
                    ? void (t.error
                        ? l.reject(on(t.error))
                        : l.resolve(on(t.data)))
                    : void 0
                );
              }
              if (!this.messageHandlers[t.type])
                return void this.completeTask(
                  n,
                  new Error(
                    `Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`,
                  ),
                );
              const r = on(t.data),
                o = new AbortController();
              this.abortControllers[n] = o;
              try {
                const l = yield this.messageHandlers[t.type](
                  t.sourceMapId,
                  r,
                  o,
                );
                this.completeTask(n, null, l);
              } catch (l) {
                this.completeTask(n, l);
              }
            });
          }
          completeTask(n, t, r) {
            const o = [];
            delete this.abortControllers[n];
            const l = {
              id: n,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: t ? Uo(t) : null,
              data: Uo(r, o),
            };
            this.target.postMessage(l, { transfer: o });
          }
          remove() {
            (this.invoker.remove(), this.subscription.unsubscribe());
          }
        }),
        (E.G = vn),
        (E.H = function () {
          var n = new Dt(16);
          return (
            Dt != Float32Array &&
              ((n[1] = 0),
              (n[2] = 0),
              (n[3] = 0),
              (n[4] = 0),
              (n[6] = 0),
              (n[7] = 0),
              (n[8] = 0),
              (n[9] = 0),
              (n[11] = 0),
              (n[12] = 0),
              (n[13] = 0),
              (n[14] = 0)),
            (n[0] = 1),
            (n[5] = 1),
            (n[10] = 1),
            (n[15] = 1),
            n
          );
        }),
        (E.I = Oc),
        (E.J = function (n, t, r) {
          var o,
            l,
            d,
            p,
            m,
            _,
            x,
            b,
            w,
            F,
            S,
            D,
            I = r[0],
            O = r[1],
            Z = r[2];
          return (
            t === n
              ? ((n[12] = t[0] * I + t[4] * O + t[8] * Z + t[12]),
                (n[13] = t[1] * I + t[5] * O + t[9] * Z + t[13]),
                (n[14] = t[2] * I + t[6] * O + t[10] * Z + t[14]),
                (n[15] = t[3] * I + t[7] * O + t[11] * Z + t[15]))
              : ((l = t[1]),
                (d = t[2]),
                (p = t[3]),
                (m = t[4]),
                (_ = t[5]),
                (x = t[6]),
                (b = t[7]),
                (w = t[8]),
                (F = t[9]),
                (S = t[10]),
                (D = t[11]),
                (n[0] = o = t[0]),
                (n[1] = l),
                (n[2] = d),
                (n[3] = p),
                (n[4] = m),
                (n[5] = _),
                (n[6] = x),
                (n[7] = b),
                (n[8] = w),
                (n[9] = F),
                (n[10] = S),
                (n[11] = D),
                (n[12] = o * I + m * O + w * Z + t[12]),
                (n[13] = l * I + _ * O + F * Z + t[13]),
                (n[14] = d * I + x * O + S * Z + t[14]),
                (n[15] = p * I + b * O + D * Z + t[15])),
            n
          );
        }),
        (E.K = function (n, t, r) {
          var o = r[0],
            l = r[1],
            d = r[2];
          return (
            (n[0] = t[0] * o),
            (n[1] = t[1] * o),
            (n[2] = t[2] * o),
            (n[3] = t[3] * o),
            (n[4] = t[4] * l),
            (n[5] = t[5] * l),
            (n[6] = t[6] * l),
            (n[7] = t[7] * l),
            (n[8] = t[8] * d),
            (n[9] = t[9] * d),
            (n[10] = t[10] * d),
            (n[11] = t[11] * d),
            (n[12] = t[12]),
            (n[13] = t[13]),
            (n[14] = t[14]),
            (n[15] = t[15]),
            n
          );
        }),
        (E.L = function (n, t, r) {
          var o = t[0],
            l = t[1],
            d = t[2],
            p = t[3],
            m = t[4],
            _ = t[5],
            x = t[6],
            b = t[7],
            w = t[8],
            F = t[9],
            S = t[10],
            D = t[11],
            I = t[12],
            O = t[13],
            Z = t[14],
            ne = t[15],
            H = r[0],
            P = r[1],
            R = r[2],
            W = r[3];
          return (
            (n[0] = H * o + P * m + R * w + W * I),
            (n[1] = H * l + P * _ + R * F + W * O),
            (n[2] = H * d + P * x + R * S + W * Z),
            (n[3] = H * p + P * b + R * D + W * ne),
            (n[4] =
              (H = r[4]) * o +
              (P = r[5]) * m +
              (R = r[6]) * w +
              (W = r[7]) * I),
            (n[5] = H * l + P * _ + R * F + W * O),
            (n[6] = H * d + P * x + R * S + W * Z),
            (n[7] = H * p + P * b + R * D + W * ne),
            (n[8] =
              (H = r[8]) * o +
              (P = r[9]) * m +
              (R = r[10]) * w +
              (W = r[11]) * I),
            (n[9] = H * l + P * _ + R * F + W * O),
            (n[10] = H * d + P * x + R * S + W * Z),
            (n[11] = H * p + P * b + R * D + W * ne),
            (n[12] =
              (H = r[12]) * o +
              (P = r[13]) * m +
              (R = r[14]) * w +
              (W = r[15]) * I),
            (n[13] = H * l + P * _ + R * F + W * O),
            (n[14] = H * d + P * x + R * S + W * Z),
            (n[15] = H * p + P * b + R * D + W * ne),
            n
          );
        }),
        (E.M = function (n, t) {
          const r = {};
          for (let o = 0; o < t.length; o++) {
            const l = t[o];
            l in n && (r[l] = n[l]);
          }
          return r;
        }),
        (E.N = xo),
        (E.O = hd),
        (E.P = Ze),
        (E.Q = dd),
        (E.R = vr),
        (E.S = br),
        (E.T = Wa),
        (E.U = mr),
        (E.V = ei),
        (E.W = gr),
        (E.X = qe),
        (E.Y = Al),
        (E.Z = Xc),
        (E._ = u),
        (E.a = Yr),
        (E.a$ = function () {
          return new Float64Array(16);
        }),
        (E.a0 = (n) => {
          const t = window.document.createElement("video");
          return (
            (t.muted = !0),
            new Promise((r) => {
              t.onloadstart = () => {
                r(t);
              };
              for (const o of n) {
                const l = window.document.createElement("source");
                (wn(o) || (t.crossOrigin = "Anonymous"),
                  (l.src = o),
                  t.appendChild(l));
              }
            })
          );
        }),
        (E.a1 = function () {
          return pn++;
        }),
        (E.a2 = h),
        (E.a3 = sa),
        (E.a4 = js),
        (E.a5 = Vn),
        (E.a6 = xd),
        (E.a7 = function (n) {
          const t = {};
          if (
            (n.replace(
              /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
              (r, o, l, d) => {
                const p = l || d;
                return ((t[o] = !p || p.toLowerCase()), "");
              },
            ),
            t["max-age"])
          ) {
            const r = parseInt(t["max-age"], 10);
            isNaN(r) ? delete t["max-age"] : (t["max-age"] = r);
          }
          return t;
        }),
        (E.a8 = function (n) {
          return Math.log(n) / Math.LN2;
        }),
        (E.a9 = function (n) {
          var t = n[0],
            r = n[1];
          return t * t + r * r;
        }),
        (E.aA = ii),
        (E.aB = Lu),
        (E.aC = N),
        (E.aD = Le),
        (E.aE = ye),
        (E.aF = 85.051129),
        (E.aG = function (n) {
          return Math.pow(2, n);
        }),
        (E.aH = pd),
        (E.aI = ar),
        (E.aJ = Ji),
        (E.aK = fd),
        (E.aL = function (n, t, r) {
          return ((n[0] = t[0] * r), (n[1] = t[1] * r), (n[2] = t[2] * r), n);
        }),
        (E.aM = function (n, t, r) {
          return (
            (n[0] = t[0] + r[0]),
            (n[1] = t[1] + r[1]),
            (n[2] = t[2] + r[2]),
            n
          );
        }),
        (E.aN = function (n) {
          var t = new Dt(3);
          return ((t[0] = n[0]), (t[1] = n[1]), (t[2] = n[2]), t);
        }),
        (E.aO = function (n, t, r) {
          return (
            (n[0] = t[0] * r[0]),
            (n[1] = t[1] * r[1]),
            (n[2] = t[2] * r[2]),
            (n[3] = t[3] * r[3]),
            n
          );
        }),
        (E.aP = function (n, t, r) {
          return (
            (n[0] = t[0] - r[0]),
            (n[1] = t[1] - r[1]),
            (n[2] = t[2] - r[2]),
            n
          );
        }),
        (E.aQ = function (n, t) {
          var r = t[0],
            o = t[1],
            l = t[2],
            d = r * r + o * o + l * l;
          return (
            d > 0 && (d = 1 / Math.sqrt(d)),
            (n[0] = t[0] * d),
            (n[1] = t[1] * d),
            (n[2] = t[2] * d),
            n
          );
        }),
        (E.aR = function (n, t, r) {
          var o = t[0],
            l = t[1],
            d = t[2],
            p = r[0],
            m = r[1],
            _ = r[2];
          return (
            (n[0] = l * _ - d * m),
            (n[1] = d * p - o * _),
            (n[2] = o * m - l * p),
            n
          );
        }),
        (E.aS = function (n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
        }),
        (E.aT = gd),
        (E.aU = aa),
        (E.aV = function (n, t, r, o, l) {
          var d,
            p = 1 / Math.tan(t / 2);
          return (
            (n[0] = p / r),
            (n[1] = 0),
            (n[2] = 0),
            (n[3] = 0),
            (n[4] = 0),
            (n[5] = p),
            (n[6] = 0),
            (n[7] = 0),
            (n[8] = 0),
            (n[9] = 0),
            (n[11] = -1),
            (n[12] = 0),
            (n[13] = 0),
            (n[15] = 0),
            l != null && l !== 1 / 0
              ? ((n[10] = (l + o) * (d = 1 / (o - l))), (n[14] = 2 * l * o * d))
              : ((n[10] = -1), (n[14] = -2 * o)),
            n
          );
        }),
        (E.aW = function (n) {
          var t = new Dt(16);
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            t
          );
        }),
        (E.aX = function (n, t, r) {
          var o = Math.sin(r),
            l = Math.cos(r),
            d = t[0],
            p = t[1],
            m = t[2],
            _ = t[3],
            x = t[4],
            b = t[5],
            w = t[6],
            F = t[7];
          return (
            t !== n &&
              ((n[8] = t[8]),
              (n[9] = t[9]),
              (n[10] = t[10]),
              (n[11] = t[11]),
              (n[12] = t[12]),
              (n[13] = t[13]),
              (n[14] = t[14]),
              (n[15] = t[15])),
            (n[0] = d * l + x * o),
            (n[1] = p * l + b * o),
            (n[2] = m * l + w * o),
            (n[3] = _ * l + F * o),
            (n[4] = x * l - d * o),
            (n[5] = b * l - p * o),
            (n[6] = w * l - m * o),
            (n[7] = F * l - _ * o),
            n
          );
        }),
        (E.aY = function (n, t, r) {
          var o = Math.sin(r),
            l = Math.cos(r),
            d = t[4],
            p = t[5],
            m = t[6],
            _ = t[7],
            x = t[8],
            b = t[9],
            w = t[10],
            F = t[11];
          return (
            t !== n &&
              ((n[0] = t[0]),
              (n[1] = t[1]),
              (n[2] = t[2]),
              (n[3] = t[3]),
              (n[12] = t[12]),
              (n[13] = t[13]),
              (n[14] = t[14]),
              (n[15] = t[15])),
            (n[4] = d * l + x * o),
            (n[5] = p * l + b * o),
            (n[6] = m * l + w * o),
            (n[7] = _ * l + F * o),
            (n[8] = x * l - d * o),
            (n[9] = b * l - p * o),
            (n[10] = w * l - m * o),
            (n[11] = F * l - _ * o),
            n
          );
        }),
        (E.aZ = function () {
          const n = new Float32Array(16);
          return (Xr(n), n);
        }),
        (E.a_ = function () {
          const n = new Float64Array(16);
          return (Xr(n), n);
        }),
        (E.aa = function (n) {
          return (n * Math.PI) / 180;
        }),
        (E.ab = Bi),
        (E.ac = function (n, t) {
          const r = [];
          for (const o in n) o in t || r.push(o);
          return r;
        }),
        (E.ad = Oe),
        (E.ae = function (n) {
          return Math.hypot(n[0], n[1]);
        }),
        (E.af = function (n) {
          return ((n[0] = 0), (n[1] = 0), n);
        }),
        (E.ag = function (n, t, r) {
          return ((n[0] = t[0] * r), (n[1] = t[1] * r), n);
        }),
        (E.ah = function (n, t) {
          let r = 0,
            o = 0;
          if (n.kind === "constant") o = n.layoutSize;
          else if (n.kind !== "source") {
            const { interpolationType: l, minZoom: d, maxZoom: p } = n,
              m = l ? Bi(zi.interpolationFactor(l, t, d, p), 0, 1) : 0;
            n.kind === "camera"
              ? (o = Pr.number(n.minSize, n.maxSize, m))
              : (r = m);
          }
          return { uSizeT: r, uSize: o };
        }),
        (E.aj = function (
          n,
          { uSize: t, uSizeT: r },
          { lowerSize: o, upperSize: l },
        ) {
          return n.kind === "source"
            ? o / ln
            : n.kind === "composite"
              ? Pr.number(o / ln, l / ln, r)
              : t;
        }),
        (E.ak = Uc),
        (E.al = sr),
        (E.am = function (n, t, r, o) {
          const l = t.y - n.y,
            d = t.x - n.x,
            p = o.y - r.y,
            m = o.x - r.x,
            _ = p * d - m * l;
          if (_ === 0) return null;
          const x = (m * (n.y - r.y) - p * (n.x - r.x)) / _;
          return new Ze(n.x + x * d, n.y + x * l);
        }),
        (E.an = function (n, t) {
          var r = t[0],
            o = t[1],
            l = t[2],
            d = t[3],
            p = t[4],
            m = t[5],
            _ = t[6],
            x = t[7],
            b = t[8],
            w = t[9],
            F = t[10],
            S = t[11],
            D = t[12],
            I = t[13],
            O = t[14],
            Z = t[15],
            ne = r * m - o * p,
            H = r * _ - l * p,
            P = r * x - d * p,
            R = o * _ - l * m,
            W = o * x - d * m,
            de = l * x - d * _,
            Te = b * I - w * D,
            ge = b * O - F * D,
            xe = b * Z - S * D,
            Se = w * O - F * I,
            Pe = w * Z - S * I,
            De = F * Z - S * O,
            we = ne * De - H * Pe + P * Se + R * xe - W * ge + de * Te;
          return we
            ? ((n[0] = (m * De - _ * Pe + x * Se) * (we = 1 / we)),
              (n[1] = (l * Pe - o * De - d * Se) * we),
              (n[2] = (I * de - O * W + Z * R) * we),
              (n[3] = (F * W - w * de - S * R) * we),
              (n[4] = (_ * xe - p * De - x * ge) * we),
              (n[5] = (r * De - l * xe + d * ge) * we),
              (n[6] = (O * P - D * de - Z * H) * we),
              (n[7] = (b * de - F * P + S * H) * we),
              (n[8] = (p * Pe - m * xe + x * Te) * we),
              (n[9] = (o * xe - r * Pe - d * Te) * we),
              (n[10] = (D * W - I * P + Z * ne) * we),
              (n[11] = (w * P - b * W - S * ne) * we),
              (n[12] = (m * ge - p * Se - _ * Te) * we),
              (n[13] = (r * Se - o * ge + l * Te) * we),
              (n[14] = (I * H - D * R - O * ne) * we),
              (n[15] = (b * R - w * H + F * ne) * we),
              n)
            : null;
        }),
        (E.ao = Cd),
        (E.ap = sl),
        (E.aq = Xr),
        (E.ar = function (n) {
          let t = 1 / 0,
            r = 1 / 0,
            o = -1 / 0,
            l = -1 / 0;
          for (const d of n)
            ((t = Math.min(t, d.x)),
              (r = Math.min(r, d.y)),
              (o = Math.max(o, d.x)),
              (l = Math.max(l, d.y)));
          return [t, r, o, l];
        }),
        (E.as = hi),
        (E.at = pt),
        (E.au = function (n, t, r, o, l = !1) {
          if (!r[0] && !r[1]) return [0, 0];
          const d = l
            ? o === "map"
              ? -n.bearingInRadians
              : 0
            : o === "viewport"
              ? n.bearingInRadians
              : 0;
          if (d) {
            const p = Math.sin(d),
              m = Math.cos(d);
            r = [r[0] * m - r[1] * p, r[0] * p + r[1] * m];
          }
          return [
            l ? r[0] : pt(t, r[0], n.zoom),
            l ? r[1] : pt(t, r[1], n.zoom),
          ];
        }),
        (E.aw = Vc),
        (E.ax = Kc),
        (E.ay = Nc),
        (E.az = Yc),
        (E.b = gn),
        (E.b$ = (n) => n.type === "line"),
        (E.b0 = function (n, t, r) {
          const o = new Float64Array(4);
          return (
            (function (l, d, p, m) {
              var _ = (0.5 * Math.PI) / 180;
              ((d *= _), (p *= _), (m *= _));
              var x = Math.sin(d),
                b = Math.cos(d),
                w = Math.sin(p),
                F = Math.cos(p),
                S = Math.sin(m),
                D = Math.cos(m);
              ((l[0] = x * F * D - b * w * S),
                (l[1] = b * w * D + x * F * S),
                (l[2] = b * F * S - x * w * D),
                (l[3] = b * F * D + x * w * S));
            })(o, n, t - 90, r),
            o
          );
        }),
        (E.b1 = function (n, t, r, o) {
          var l,
            d,
            p,
            m,
            _,
            x = t[0],
            b = t[1],
            w = t[2],
            F = t[3],
            S = r[0],
            D = r[1],
            I = r[2],
            O = r[3];
          return (
            (d = x * S + b * D + w * I + F * O) < 0 &&
              ((d = -d), (S = -S), (D = -D), (I = -I), (O = -O)),
            1 - d > It
              ? ((l = Math.acos(d)),
                (p = Math.sin(l)),
                (m = Math.sin((1 - o) * l) / p),
                (_ = Math.sin(o * l) / p))
              : ((m = 1 - o), (_ = o)),
            (n[0] = m * x + _ * S),
            (n[1] = m * b + _ * D),
            (n[2] = m * w + _ * I),
            (n[3] = m * F + _ * O),
            n
          );
        }),
        (E.b2 = function (n) {
          const t = new Float64Array(9);
          var r, o, l, d, p, m, _, x, b, w, F, S, D, I, O, Z, ne, H;
          ((w = (l = (o = n)[0]) * (_ = l + l)),
            (F = (d = o[1]) * _),
            (D = (p = o[2]) * _),
            (I = p * (x = d + d)),
            (Z = (m = o[3]) * _),
            (ne = m * x),
            (H = m * (b = p + p)),
            ((r = t)[0] = 1 - (S = d * x) - (O = p * b)),
            (r[3] = F - H),
            (r[6] = D + ne),
            (r[1] = F + H),
            (r[4] = 1 - w - O),
            (r[7] = I - Z),
            (r[2] = D - ne),
            (r[5] = I + Z),
            (r[8] = 1 - w - S));
          const P = Ji(-Math.asin(Bi(t[2], -1, 1)));
          let R, W;
          return (
            Math.hypot(t[5], t[8]) < 0.001
              ? ((R = 0), (W = -Ji(Math.atan2(t[3], t[4]))))
              : ((R = Ji(
                  t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8]),
                )),
                (W = Ji(
                  t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]),
                ))),
            { roll: R, pitch: P + 90, bearing: W }
          );
        }),
        (E.b3 = function (n, t) {
          return (
            n.roll == t.roll && n.pitch == t.pitch && n.bearing == t.bearing
          );
        }),
        (E.b4 = ct),
        (E.b5 = Gr),
        (E.b6 = na),
        (E.b7 = gl),
        (E.b8 = ra),
        (E.b9 = Et),
        (E.bA = fn),
        (E.bB = mn),
        (E.bC = class extends er {
          constructor(n, t) {
            (super(n, t), (this.current = 0));
          }
          set(n) {
            this.current !== n &&
              ((this.current = n), this.gl.uniform1i(this.location, n));
          }
        }),
        (E.bD = class extends er {
          constructor(n, t) {
            (super(n, t), (this.current = go));
          }
          set(n) {
            if (n[12] !== this.current[12] || n[0] !== this.current[0])
              return (
                (this.current = n),
                void this.gl.uniformMatrix4fv(this.location, !1, n)
              );
            for (let t = 1; t < 16; t++)
              if (n[t] !== this.current[t]) {
                ((this.current = n),
                  this.gl.uniformMatrix4fv(this.location, !1, n));
                break;
              }
          }
        }),
        (E.bE = Ko),
        (E.bF = Yo),
        (E.bG = class extends er {
          constructor(n, t) {
            (super(n, t), (this.current = [0, 0, 0]));
          }
          set(n) {
            (n[0] === this.current[0] &&
              n[1] === this.current[1] &&
              n[2] === this.current[2]) ||
              ((this.current = n),
              this.gl.uniform3f(this.location, n[0], n[1], n[2]));
          }
        }),
        (E.bH = class extends er {
          constructor(n, t) {
            (super(n, t), (this.current = [0, 0]));
          }
          set(n) {
            (n[0] === this.current[0] && n[1] === this.current[1]) ||
              ((this.current = n),
              this.gl.uniform2f(this.location, n[0], n[1]));
          }
        }),
        (E.bI = Bt),
        (E.bJ = function (n, t) {
          var r = Math.sin(t),
            o = Math.cos(t);
          return (
            (n[0] = o),
            (n[1] = r),
            (n[2] = 0),
            (n[3] = -r),
            (n[4] = o),
            (n[5] = 0),
            (n[6] = 0),
            (n[7] = 0),
            (n[8] = 1),
            n
          );
        }),
        (E.bK = function (n, t, r) {
          var o = t[0],
            l = t[1],
            d = t[2];
          return (
            (n[0] = o * r[0] + l * r[3] + d * r[6]),
            (n[1] = o * r[1] + l * r[4] + d * r[7]),
            (n[2] = o * r[2] + l * r[5] + d * r[8]),
            n
          );
        }),
        (E.bL = function (n, t, r, o, l, d, p) {
          var m = 1 / (t - r),
            _ = 1 / (o - l),
            x = 1 / (d - p);
          return (
            (n[0] = -2 * m),
            (n[1] = 0),
            (n[2] = 0),
            (n[3] = 0),
            (n[4] = 0),
            (n[5] = -2 * _),
            (n[6] = 0),
            (n[7] = 0),
            (n[8] = 0),
            (n[9] = 0),
            (n[10] = 2 * x),
            (n[11] = 0),
            (n[12] = (t + r) * m),
            (n[13] = (l + o) * _),
            (n[14] = (p + d) * x),
            (n[15] = 1),
            n
          );
        }),
        (E.bM = class extends tl {}),
        (E.bN = Gp),
        (E.bO = class extends sn {}),
        (E.bP = wc),
        (E.bQ = function (n) {
          return n <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
        }),
        (E.bR = yh),
        (E.bS = function (n, t, r) {
          var o = t[0],
            l = t[1],
            d = t[2],
            p = r[3] * o + r[7] * l + r[11] * d + r[15];
          return (
            (n[0] = (r[0] * o + r[4] * l + r[8] * d + r[12]) / (p = p || 1)),
            (n[1] = (r[1] * o + r[5] * l + r[9] * d + r[13]) / p),
            (n[2] = (r[2] * o + r[6] * l + r[10] * d + r[14]) / p),
            n
          );
        }),
        (E.bT = class extends Ja {}),
        (E.bU = class extends i {}),
        (E.bV = function (n, t) {
          return (
            n[0] === t[0] &&
            n[1] === t[1] &&
            n[2] === t[2] &&
            n[3] === t[3] &&
            n[4] === t[4] &&
            n[5] === t[5] &&
            n[6] === t[6] &&
            n[7] === t[7] &&
            n[8] === t[8] &&
            n[9] === t[9] &&
            n[10] === t[10] &&
            n[11] === t[11] &&
            n[12] === t[12] &&
            n[13] === t[13] &&
            n[14] === t[14] &&
            n[15] === t[15]
          );
        }),
        (E.bW = function (n, t) {
          var r = n[0],
            o = n[1],
            l = n[2],
            d = n[3],
            p = n[4],
            m = n[5],
            _ = n[6],
            x = n[7],
            b = n[8],
            w = n[9],
            F = n[10],
            S = n[11],
            D = n[12],
            I = n[13],
            O = n[14],
            Z = n[15],
            ne = t[0],
            H = t[1],
            P = t[2],
            R = t[3],
            W = t[4],
            de = t[5],
            Te = t[6],
            ge = t[7],
            xe = t[8],
            Se = t[9],
            Pe = t[10],
            De = t[11],
            we = t[12],
            Ne = t[13],
            Ke = t[14],
            We = t[15];
          return (
            Math.abs(r - ne) <= It * Math.max(1, Math.abs(r), Math.abs(ne)) &&
            Math.abs(o - H) <= It * Math.max(1, Math.abs(o), Math.abs(H)) &&
            Math.abs(l - P) <= It * Math.max(1, Math.abs(l), Math.abs(P)) &&
            Math.abs(d - R) <= It * Math.max(1, Math.abs(d), Math.abs(R)) &&
            Math.abs(p - W) <= It * Math.max(1, Math.abs(p), Math.abs(W)) &&
            Math.abs(m - de) <= It * Math.max(1, Math.abs(m), Math.abs(de)) &&
            Math.abs(_ - Te) <= It * Math.max(1, Math.abs(_), Math.abs(Te)) &&
            Math.abs(x - ge) <= It * Math.max(1, Math.abs(x), Math.abs(ge)) &&
            Math.abs(b - xe) <= It * Math.max(1, Math.abs(b), Math.abs(xe)) &&
            Math.abs(w - Se) <= It * Math.max(1, Math.abs(w), Math.abs(Se)) &&
            Math.abs(F - Pe) <= It * Math.max(1, Math.abs(F), Math.abs(Pe)) &&
            Math.abs(S - De) <= It * Math.max(1, Math.abs(S), Math.abs(De)) &&
            Math.abs(D - we) <= It * Math.max(1, Math.abs(D), Math.abs(we)) &&
            Math.abs(I - Ne) <= It * Math.max(1, Math.abs(I), Math.abs(Ne)) &&
            Math.abs(O - Ke) <= It * Math.max(1, Math.abs(O), Math.abs(Ke)) &&
            Math.abs(Z - We) <= It * Math.max(1, Math.abs(Z), Math.abs(We))
          );
        }),
        (E.bX = function (n, t) {
          return (
            (n[0] = t[0]),
            (n[1] = t[1]),
            (n[2] = t[2]),
            (n[3] = t[3]),
            (n[4] = t[4]),
            (n[5] = t[5]),
            (n[6] = t[6]),
            (n[7] = t[7]),
            (n[8] = t[8]),
            (n[9] = t[9]),
            (n[10] = t[10]),
            (n[11] = t[11]),
            (n[12] = t[12]),
            (n[13] = t[13]),
            (n[14] = t[14]),
            (n[15] = t[15]),
            n
          );
        }),
        (E.bY = (n) => n.type === "symbol"),
        (E.bZ = (n) => n.type === "circle"),
        (E.b_ = (n) => n.type === "heatmap"),
        (E.ba = $t),
        (E.bb = xi),
        (E.bc = function (n, t, r, o, l) {
          return Et(o, l, Bi((n - t) / (r - t), 0, 1));
        }),
        (E.bd = tt),
        (E.be = function () {
          return new Float64Array(4);
        }),
        (E.bf = function () {
          return new Float64Array(3);
        }),
        (E.bg = function (n, t, r, o) {
          var l = [],
            d = [];
          return (
            (l[0] = t[0] - r[0]),
            (l[1] = t[1] - r[1]),
            (l[2] = t[2] - r[2]),
            (d[0] = l[0] * Math.cos(o) - l[1] * Math.sin(o)),
            (d[1] = l[0] * Math.sin(o) + l[1] * Math.cos(o)),
            (d[2] = l[2]),
            (n[0] = d[0] + r[0]),
            (n[1] = d[1] + r[1]),
            (n[2] = d[2] + r[2]),
            n
          );
        }),
        (E.bh = function (n, t, r, o) {
          var l = [],
            d = [];
          return (
            (l[0] = t[0] - r[0]),
            (l[1] = t[1] - r[1]),
            (l[2] = t[2] - r[2]),
            (d[0] = l[0]),
            (d[1] = l[1] * Math.cos(o) - l[2] * Math.sin(o)),
            (d[2] = l[1] * Math.sin(o) + l[2] * Math.cos(o)),
            (n[0] = d[0] + r[0]),
            (n[1] = d[1] + r[1]),
            (n[2] = d[2] + r[2]),
            n
          );
        }),
        (E.bi = function (n, t, r, o) {
          var l = [],
            d = [];
          return (
            (l[0] = t[0] - r[0]),
            (l[1] = t[1] - r[1]),
            (l[2] = t[2] - r[2]),
            (d[0] = l[2] * Math.sin(o) + l[0] * Math.cos(o)),
            (d[1] = l[1]),
            (d[2] = l[2] * Math.cos(o) - l[0] * Math.sin(o)),
            (n[0] = d[0] + r[0]),
            (n[1] = d[1] + r[1]),
            (n[2] = d[2] + r[2]),
            n
          );
        }),
        (E.bj = function (n, t, r) {
          var o = Math.sin(r),
            l = Math.cos(r),
            d = t[0],
            p = t[1],
            m = t[2],
            _ = t[3],
            x = t[8],
            b = t[9],
            w = t[10],
            F = t[11];
          return (
            t !== n &&
              ((n[4] = t[4]),
              (n[5] = t[5]),
              (n[6] = t[6]),
              (n[7] = t[7]),
              (n[12] = t[12]),
              (n[13] = t[13]),
              (n[14] = t[14]),
              (n[15] = t[15])),
            (n[0] = d * l - x * o),
            (n[1] = p * l - b * o),
            (n[2] = m * l - w * o),
            (n[3] = _ * l - F * o),
            (n[8] = d * o + x * l),
            (n[9] = p * o + b * l),
            (n[10] = m * o + w * l),
            (n[11] = _ * o + F * l),
            n
          );
        }),
        (E.bk = function (n, t) {
          const r = tt(n, 360),
            o = tt(t, 360),
            l = o - r,
            d = o > r ? l - 360 : l + 360;
          return Math.abs(l) < Math.abs(d) ? l : d;
        }),
        (E.bl = function (n) {
          return ((n[0] = 0), (n[1] = 0), (n[2] = 0), n);
        }),
        (E.bm = function (n, t, r, o) {
          const l = Math.sqrt(n * n + t * t),
            d = Math.sqrt(r * r + o * o);
          ((n /= l), (t /= l), (r /= d), (o /= d));
          const p = Math.acos(n * r + t * o);
          return -t * r + n * o > 0 ? p : -p;
        }),
        (E.bn = function (n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3];
        }),
        (E.bo = qc),
        (E.bp = function (n, t) {
          const r = tt(n, 2 * Math.PI),
            o = tt(t, 2 * Math.PI);
          return Math.min(
            Math.abs(r - o),
            Math.abs(r - o + 2 * Math.PI),
            Math.abs(r - o - 2 * Math.PI),
          );
        }),
        (E.bq = function (n) {
          return Math.hypot(n[0], n[1], n[2]);
        }),
        (E.br = function () {
          const n = {},
            t = j.$version;
          for (const r in j.$root) {
            const o = j.$root[r];
            if (o.required) {
              let l = null;
              ((l = r === "version" ? t : o.type === "array" ? [] : {}),
                l != null && (n[r] = l));
            }
          }
          return n;
        }),
        (E.bs = yu),
        (E.bt = bn),
        (E.bu = function (n) {
          n = n.slice();
          const t = Object.create(null);
          for (let r = 0; r < n.length; r++) t[n[r].id] = n[r];
          for (let r = 0; r < n.length; r++)
            "ref" in n[r] && (n[r] = z(n[r], t[n[r].ref]));
          return n;
        }),
        (E.bv = function (n) {
          if (n.type === "custom") return new cf(n);
          switch (n.type) {
            case "background":
              return new af(n);
            case "circle":
              return new sp(n);
            case "fill":
              return new Ap(n);
            case "fill-extrusion":
              return new Bp(n);
            case "heatmap":
              return new lp(n);
            case "hillshade":
              return new cp(n);
            case "line":
              return new Vp(n);
            case "raster":
              return new uf(n);
            case "symbol":
              return new Uu(n);
          }
        }),
        (E.bw = Yi),
        (E.bx = function (n, t) {
          if (!n) return [{ command: "setStyle", args: [t] }];
          let r = [];
          try {
            if (!L(n.version, t.version))
              return [{ command: "setStyle", args: [t] }];
            (L(n.center, t.center) ||
              r.push({ command: "setCenter", args: [t.center] }),
              L(n.centerAltitude, t.centerAltitude) ||
                r.push({
                  command: "setCenterAltitude",
                  args: [t.centerAltitude],
                }),
              L(n.zoom, t.zoom) ||
                r.push({ command: "setZoom", args: [t.zoom] }),
              L(n.bearing, t.bearing) ||
                r.push({ command: "setBearing", args: [t.bearing] }),
              L(n.pitch, t.pitch) ||
                r.push({ command: "setPitch", args: [t.pitch] }),
              L(n.roll, t.roll) ||
                r.push({ command: "setRoll", args: [t.roll] }),
              L(n.sprite, t.sprite) ||
                r.push({ command: "setSprite", args: [t.sprite] }),
              L(n.glyphs, t.glyphs) ||
                r.push({ command: "setGlyphs", args: [t.glyphs] }),
              L(n.transition, t.transition) ||
                r.push({ command: "setTransition", args: [t.transition] }),
              L(n.light, t.light) ||
                r.push({ command: "setLight", args: [t.light] }),
              L(n.terrain, t.terrain) ||
                r.push({ command: "setTerrain", args: [t.terrain] }),
              L(n.sky, t.sky) || r.push({ command: "setSky", args: [t.sky] }),
              L(n.projection, t.projection) ||
                r.push({ command: "setProjection", args: [t.projection] }));
            const o = {},
              l = [];
            (function (p, m, _, x) {
              let b;
              for (b in ((m = m || {}), (p = p || {})))
                Object.prototype.hasOwnProperty.call(p, b) &&
                  (Object.prototype.hasOwnProperty.call(m, b) || ue(b, _, x));
              for (b in m)
                Object.prototype.hasOwnProperty.call(m, b) &&
                  (Object.prototype.hasOwnProperty.call(p, b)
                    ? L(p[b], m[b]) ||
                      (p[b].type === "geojson" &&
                      m[b].type === "geojson" &&
                      ae(p, m, b)
                        ? q(_, {
                            command: "setGeoJSONSourceData",
                            args: [b, m[b].data],
                          })
                        : fe(b, m, _, x))
                    : te(b, m, _));
            })(n.sources, t.sources, l, o);
            const d = [];
            (n.layers &&
              n.layers.forEach((p) => {
                "source" in p && o[p.source]
                  ? r.push({ command: "removeLayer", args: [p.id] })
                  : d.push(p);
              }),
              (r = r.concat(l)),
              (function (p, m, _) {
                m = m || [];
                const x = (p = p || []).map(_e),
                  b = m.map(_e),
                  w = p.reduce(ce, {}),
                  F = m.reduce(ce, {}),
                  S = x.slice(),
                  D = Object.create(null);
                let I, O, Z, ne, H;
                for (let P = 0, R = 0; P < x.length; P++)
                  ((I = x[P]),
                    Object.prototype.hasOwnProperty.call(F, I)
                      ? R++
                      : (q(_, { command: "removeLayer", args: [I] }),
                        S.splice(S.indexOf(I, R), 1)));
                for (let P = 0, R = 0; P < b.length; P++)
                  ((I = b[b.length - 1 - P]),
                    S[S.length - 1 - P] !== I &&
                      (Object.prototype.hasOwnProperty.call(w, I)
                        ? (q(_, { command: "removeLayer", args: [I] }),
                          S.splice(S.lastIndexOf(I, S.length - R), 1))
                        : R++,
                      (ne = S[S.length - P]),
                      q(_, { command: "addLayer", args: [F[I], ne] }),
                      S.splice(S.length - P, 0, I),
                      (D[I] = !0)));
                for (let P = 0; P < b.length; P++)
                  if (((I = b[P]), (O = w[I]), (Z = F[I]), !D[I] && !L(O, Z)))
                    if (
                      L(O.source, Z.source) &&
                      L(O["source-layer"], Z["source-layer"]) &&
                      L(O.type, Z.type)
                    ) {
                      for (H in (ve(
                        O.layout,
                        Z.layout,
                        _,
                        I,
                        null,
                        "setLayoutProperty",
                      ),
                      ve(O.paint, Z.paint, _, I, null, "setPaintProperty"),
                      L(O.filter, Z.filter) ||
                        q(_, { command: "setFilter", args: [I, Z.filter] }),
                      (L(O.minzoom, Z.minzoom) && L(O.maxzoom, Z.maxzoom)) ||
                        q(_, {
                          command: "setLayerZoomRange",
                          args: [I, Z.minzoom, Z.maxzoom],
                        }),
                      O))
                        Object.prototype.hasOwnProperty.call(O, H) &&
                          H !== "layout" &&
                          H !== "paint" &&
                          H !== "filter" &&
                          H !== "metadata" &&
                          H !== "minzoom" &&
                          H !== "maxzoom" &&
                          (H.indexOf("paint.") === 0
                            ? ve(
                                O[H],
                                Z[H],
                                _,
                                I,
                                H.slice(6),
                                "setPaintProperty",
                              )
                            : L(O[H], Z[H]) ||
                              q(_, {
                                command: "setLayerProperty",
                                args: [I, H, Z[H]],
                              }));
                      for (H in Z)
                        Object.prototype.hasOwnProperty.call(Z, H) &&
                          !Object.prototype.hasOwnProperty.call(O, H) &&
                          H !== "layout" &&
                          H !== "paint" &&
                          H !== "filter" &&
                          H !== "metadata" &&
                          H !== "minzoom" &&
                          H !== "maxzoom" &&
                          (H.indexOf("paint.") === 0
                            ? ve(
                                O[H],
                                Z[H],
                                _,
                                I,
                                H.slice(6),
                                "setPaintProperty",
                              )
                            : L(O[H], Z[H]) ||
                              q(_, {
                                command: "setLayerProperty",
                                args: [I, H, Z[H]],
                              }));
                    } else
                      (q(_, { command: "removeLayer", args: [I] }),
                        (ne = S[S.lastIndexOf(I) + 1]),
                        q(_, { command: "addLayer", args: [Z, ne] }));
              })(d, t.layers, r));
          } catch (o) {
            (console.warn("Unable to compute style diff:", o),
              (r = [{ command: "setStyle", args: [t] }]));
          }
          return r;
        }),
        (E.by = function (n) {
          const t = [],
            r = n.id;
          return (
            r === void 0 &&
              t.push({
                message: `layers.${r}: missing required property "id"`,
              }),
            n.render === void 0 &&
              t.push({
                message: `layers.${r}: missing required method "render"`,
              }),
            n.renderingMode &&
              n.renderingMode !== "2d" &&
              n.renderingMode !== "3d" &&
              t.push({
                message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`,
              }),
            t
          );
        }),
        (E.bz = function n(t, r) {
          if (Array.isArray(t)) {
            if (!Array.isArray(r) || t.length !== r.length) return !1;
            for (let o = 0; o < t.length; o++) if (!n(t[o], r[o])) return !1;
            return !0;
          }
          if (typeof t == "object" && t !== null && r !== null) {
            if (
              typeof r != "object" ||
              Object.keys(t).length !== Object.keys(r).length
            )
              return !1;
            for (const o in t) if (!n(t[o], r[o])) return !1;
            return !0;
          }
          return t === r;
        }),
        (E.c = xn),
        (E.c0 = (n) => n.type === "fill"),
        (E.c1 = (n) => n.type === "fill-extrusion"),
        (E.c2 = (n) => n.type === "hillshade"),
        (E.c3 = (n) => n.type === "raster"),
        (E.c4 = (n) => n.type === "background"),
        (E.c5 = (n) => n.type === "custom"),
        (E.c6 = _i),
        (E.c7 = function (n, t, r) {
          const o = $e(t.x - r.x, t.y - r.y),
            l = $e(n.x - r.x, n.y - r.y);
          var d, p;
          return Ji(
            Math.atan2(
              o[0] * l[1] - o[1] * l[0],
              (d = o)[0] * (p = l)[0] + d[1] * p[1],
            ),
          );
        }),
        (E.c8 = Ii),
        (E.c9 = function (n, t, r) {
          var o = t[0],
            l = t[1];
          return (
            (n[0] = r[0] * o + r[4] * l + r[12]),
            (n[1] = r[1] * o + r[5] * l + r[13]),
            n
          );
        }),
        (E.cA = Hh),
        (E.cB = zs),
        (E.cC = Ur),
        (E.ca = function (n, t) {
          const { x: r, y: o } = Al.fromLngLat(t);
          return !(n < 0 || n > 25 || o < 0 || o >= 1 || r < 0 || r >= 1);
        }),
        (E.cb = function (n, t) {
          return (
            (n[0] = t[0]),
            (n[1] = 0),
            (n[2] = 0),
            (n[3] = 0),
            (n[4] = 0),
            (n[5] = t[1]),
            (n[6] = 0),
            (n[7] = 0),
            (n[8] = 0),
            (n[9] = 0),
            (n[10] = t[2]),
            (n[11] = 0),
            (n[12] = 0),
            (n[13] = 0),
            (n[14] = 0),
            (n[15] = 1),
            n
          );
        }),
        (E.cc = class extends qo {}),
        (E.cd = vf),
        (E.cf = function (n) {
          return n.message === yn;
        }),
        (E.cg = Lr),
        (E.ch = function (n, t) {
          Yr.REGISTERED_PROTOCOLS[n] = t;
        }),
        (E.ci = function (n) {
          delete Yr.REGISTERED_PROTOCOLS[n];
        }),
        (E.cj = function (n, t) {
          const r = {};
          for (let l = 0; l < n.length; l++) {
            const d = (t && t[n[l].id]) || Ua(n[l]);
            t && (t[n[l].id] = d);
            let p = r[d];
            (p || (p = r[d] = []), p.push(n[l]));
          }
          const o = [];
          for (const l in r) o.push(r[l]);
          return o;
        }),
        (E.ck = Re),
        (E.cl = yd),
        (E.cm = vd),
        (E.cn = Kh),
        (E.co = function (n) {
          (n.bucket.createArrays(),
            (n.bucket.tilePixelRatio = qe / (512 * n.bucket.overscaling)),
            (n.bucket.compareText = {}),
            (n.bucket.iconsNeedLinear = !1));
          const t = n.bucket.layers[0],
            r = t.layout,
            o = t._unevaluatedLayout._values,
            l = {
              layoutIconSize: o["icon-size"].possiblyEvaluate(
                new jt(n.bucket.zoom + 1),
                n.canonical,
              ),
              layoutTextSize: o["text-size"].possiblyEvaluate(
                new jt(n.bucket.zoom + 1),
                n.canonical,
              ),
              textMaxSize: o["text-size"].possiblyEvaluate(new jt(18)),
            };
          if (n.bucket.textSizeData.kind === "composite") {
            const { minZoom: x, maxZoom: b } = n.bucket.textSizeData;
            l.compositeTextSizes = [
              o["text-size"].possiblyEvaluate(new jt(x), n.canonical),
              o["text-size"].possiblyEvaluate(new jt(b), n.canonical),
            ];
          }
          if (n.bucket.iconSizeData.kind === "composite") {
            const { minZoom: x, maxZoom: b } = n.bucket.iconSizeData;
            l.compositeIconSizes = [
              o["icon-size"].possiblyEvaluate(new jt(x), n.canonical),
              o["icon-size"].possiblyEvaluate(new jt(b), n.canonical),
            ];
          }
          const d = r.get("text-line-height") * hi,
            p =
              r.get("text-rotation-alignment") !== "viewport" &&
              r.get("symbol-placement") !== "point",
            m = r.get("text-keep-upright"),
            _ = r.get("text-size");
          for (const x of n.bucket.features) {
            const b = r.get("text-font").evaluate(x, {}, n.canonical).join(","),
              w = _.evaluate(x, {}, n.canonical),
              F = l.layoutTextSize.evaluate(x, {}, n.canonical),
              S = l.layoutIconSize.evaluate(x, {}, n.canonical),
              D = { horizontal: {}, vertical: void 0 },
              I = x.text;
            let O,
              Z = [0, 0];
            if (I) {
              const P = I.toString(),
                R =
                  r.get("text-letter-spacing").evaluate(x, {}, n.canonical) *
                  hi,
                W = xu(P) ? R : 0,
                de = r.get("text-anchor").evaluate(x, {}, n.canonical),
                Te = Id(t, x, n.canonical);
              if (!Te) {
                const Pe = r
                  .get("text-radial-offset")
                  .evaluate(x, {}, n.canonical);
                Z = Pe
                  ? Md(de, [Pe * hi, Wc])
                  : r
                      .get("text-offset")
                      .evaluate(x, {}, n.canonical)
                      .map((De) => De * hi);
              }
              let ge = p
                ? "center"
                : r.get("text-justify").evaluate(x, {}, n.canonical);
              const xe =
                  r.get("symbol-placement") === "point"
                    ? r.get("text-max-width").evaluate(x, {}, n.canonical) * hi
                    : 1 / 0,
                Se = () => {
                  n.bucket.allowVerticalPlacement &&
                    ho(P) &&
                    (D.vertical = ju(
                      I,
                      n.glyphMap,
                      n.glyphPositions,
                      n.imagePositions,
                      b,
                      xe,
                      d,
                      de,
                      "left",
                      W,
                      Z,
                      E.ai.vertical,
                      !0,
                      F,
                      w,
                    ));
                };
              if (!p && Te) {
                const Pe = new Set();
                if (ge === "auto")
                  for (let we = 0; we < Te.values.length; we += 2)
                    Pe.add(Kc(Te.values[we]));
                else Pe.add(ge);
                let De = !1;
                for (const we of Pe)
                  if (!D.horizontal[we])
                    if (De) D.horizontal[we] = D.horizontal[0];
                    else {
                      const Ne = ju(
                        I,
                        n.glyphMap,
                        n.glyphPositions,
                        n.imagePositions,
                        b,
                        xe,
                        d,
                        "center",
                        we,
                        W,
                        Z,
                        E.ai.horizontal,
                        !1,
                        F,
                        w,
                      );
                      Ne &&
                        ((D.horizontal[we] = Ne),
                        (De = Ne.positionedLines.length === 1));
                    }
                Se();
              } else {
                ge === "auto" && (ge = Kc(de));
                const Pe = ju(
                  I,
                  n.glyphMap,
                  n.glyphPositions,
                  n.imagePositions,
                  b,
                  xe,
                  d,
                  de,
                  ge,
                  W,
                  Z,
                  E.ai.horizontal,
                  !1,
                  F,
                  w,
                );
                (Pe && (D.horizontal[ge] = Pe),
                  Se(),
                  ho(P) &&
                    p &&
                    m &&
                    (D.vertical = ju(
                      I,
                      n.glyphMap,
                      n.glyphPositions,
                      n.imagePositions,
                      b,
                      xe,
                      d,
                      de,
                      ge,
                      W,
                      Z,
                      E.ai.vertical,
                      !1,
                      F,
                      w,
                    )));
              }
            }
            let ne = !1;
            if (x.icon && x.icon.name) {
              const P = n.imageMap[x.icon.name];
              P &&
                ((O = tf(
                  n.imagePositions[x.icon.name],
                  r.get("icon-offset").evaluate(x, {}, n.canonical),
                  r.get("icon-anchor").evaluate(x, {}, n.canonical),
                )),
                (ne = !!P.sdf),
                n.bucket.sdfIcons === void 0
                  ? (n.bucket.sdfIcons = ne)
                  : n.bucket.sdfIcons !== ne &&
                    Ai(
                      "Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer",
                    ),
                (P.pixelRatio !== n.bucket.pixelRatio ||
                  r.get("icon-rotate").constantOr(1) !== 0) &&
                  (n.bucket.iconsNeedLinear = !0));
            }
            const H = kd(D.horizontal) || D.vertical;
            ((n.bucket.iconsInText = !!H && H.iconsInText),
              (H || O) &&
                yf(
                  n.bucket,
                  x,
                  D,
                  O,
                  n.imageMap,
                  l,
                  F,
                  S,
                  Z,
                  ne,
                  n.canonical,
                  n.subdivisionGranularity,
                ));
          }
          n.showCollisionBoxes && n.bucket.generateCollisionDebugBuffers();
        }),
        (E.cp = Bc),
        (E.cq = Fc),
        (E.cr = Ic),
        (E.cs = yl),
        (E.ct = Lc),
        (E.cu = class {
          constructor(n) {
            ((this._marks = {
              start: [n.url, "start"].join("#"),
              end: [n.url, "end"].join("#"),
              measure: n.url.toString(),
            }),
              performance.mark(this._marks.start));
          }
          finish() {
            performance.mark(this._marks.end);
            let n = performance.getEntriesByName(this._marks.measure);
            return (
              n.length === 0 &&
                (performance.measure(
                  this._marks.measure,
                  this._marks.start,
                  this._marks.end,
                ),
                (n = performance.getEntriesByName(this._marks.measure)),
                performance.clearMarks(this._marks.start),
                performance.clearMarks(this._marks.end),
                performance.clearMeasures(this._marks.measure)),
              n
            );
          }
        }),
        (E.cv = function (n, t, r, o, l) {
          return u(this, void 0, void 0, function* () {
            if (ei())
              try {
                return yield gr(n, t, r, o, l);
              } catch {}
            return (function (d, p, m, _, x) {
              const b = d.width,
                w = d.height;
              ((Wr && Kr) ||
                ((Wr = new OffscreenCanvas(b, w)),
                (Kr = Wr.getContext("2d", { willReadFrequently: !0 }))),
                (Wr.width = b),
                (Wr.height = w),
                Kr.drawImage(d, 0, 0, b, w));
              const F = Kr.getImageData(p, m, _, x);
              return (Kr.clearRect(0, 0, b, w), F.data);
            })(n, t, r, o, l);
          });
        }),
        (E.cw = _d),
        (E.cx = Ue),
        (E.cy = li),
        (E.cz = zh),
        (E.d = (n) =>
          u(void 0, void 0, void 0, function* () {
            if (n.byteLength === 0)
              return createImageBitmap(new ImageData(1, 1));
            const t = new Blob([new Uint8Array(n)], { type: "image/png" });
            try {
              return createImageBitmap(t);
            } catch (r) {
              throw new Error(
                `Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`,
              );
            }
          })),
        (E.e = yi),
        (E.f = (n) =>
          new Promise((t, r) => {
            const o = new Image();
            ((o.onload = () => {
              (t(o),
                URL.revokeObjectURL(o.src),
                (o.onload = null),
                window.requestAnimationFrame(() => {
                  o.src = _n;
                }));
            }),
              (o.onerror = () =>
                r(
                  new Error(
                    "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.",
                  ),
                )));
            const l = new Blob([new Uint8Array(n)], { type: "image/png" });
            o.src = n.byteLength ? URL.createObjectURL(l) : _n;
          })),
        (E.g = Ao),
        (E.h = (n, t) => Rr(yi(n, { type: "json" }), t)),
        (E.i = zr),
        (E.j = To),
        (E.k = qn),
        (E.l = (n, t) => Rr(yi(n, { type: "arrayBuffer" }), t)),
        (E.m = Rr),
        (E.n = function (n) {
          return new Lc(n).readFields(Xp, []);
        }),
        (E.o = hl),
        (E.p = Wh),
        (E.q = $i),
        (E.r = mc),
        (E.s = wn),
        (E.t = mu),
        (E.u = co),
        (E.v = j),
        (E.w = Ai),
        (E.x = function ([n, t, r]) {
          return (
            (t += 90),
            (t *= Math.PI / 180),
            (r *= Math.PI / 180),
            {
              x: n * Math.cos(t) * Math.sin(r),
              y: n * Math.sin(t) * Math.sin(r),
              z: n * Math.cos(r),
            }
          );
        }),
        (E.y = Pr),
        (E.z = jt));
    }),
      U("worker", ["./shared"], function (E) {
        class u {
          constructor(B) {
            ((this.keyCache = {}), B && this.replace(B));
          }
          replace(B) {
            ((this._layerConfigs = {}),
              (this._layers = {}),
              this.update(B, []));
          }
          update(B, z) {
            for (const q of B) {
              this._layerConfigs[q.id] = q;
              const te = (this._layers[q.id] = E.bv(q));
              ((te._featureFilter = E.a4(te.filter)),
                this.keyCache[q.id] && delete this.keyCache[q.id]);
            }
            for (const q of z)
              (delete this.keyCache[q],
                delete this._layerConfigs[q],
                delete this._layers[q]);
            this.familiesBySource = {};
            const L = E.cj(Object.values(this._layerConfigs), this.keyCache);
            for (const q of L) {
              const te = q.map((ce) => this._layers[ce.id]),
                ue = te[0];
              if (ue.visibility === "none") continue;
              const fe = ue.source || "";
              let ae = this.familiesBySource[fe];
              ae || (ae = this.familiesBySource[fe] = {});
              const ve = ue.sourceLayer || "_geojsonTileLayer";
              let _e = ae[ve];
              (_e || (_e = ae[ve] = []), _e.push(te));
            }
          }
        }
        class Ue {
          constructor(B) {
            const z = {},
              L = [];
            for (const fe in B) {
              const ae = B[fe],
                ve = (z[fe] = {});
              for (const _e in ae) {
                const ce = ae[+_e];
                if (!ce || ce.bitmap.width === 0 || ce.bitmap.height === 0)
                  continue;
                const oe = {
                  x: 0,
                  y: 0,
                  w: ce.bitmap.width + 2,
                  h: ce.bitmap.height + 2,
                };
                (L.push(oe), (ve[_e] = { rect: oe, metrics: ce.metrics }));
              }
            }
            const { w: q, h: te } = E.p(L),
              ue = new E.o({ width: q || 1, height: te || 1 });
            for (const fe in B) {
              const ae = B[fe];
              for (const ve in ae) {
                const _e = ae[+ve];
                if (!_e || _e.bitmap.width === 0 || _e.bitmap.height === 0)
                  continue;
                const ce = z[fe][ve].rect;
                E.o.copy(
                  _e.bitmap,
                  ue,
                  { x: 0, y: 0 },
                  { x: ce.x + 1, y: ce.y + 1 },
                  _e.bitmap,
                );
              }
            }
            ((this.image = ue), (this.positions = z));
          }
        }
        E.ck("GlyphAtlas", Ue);
        class rt {
          constructor(B) {
            ((this.tileID = new E.S(
              B.tileID.overscaledZ,
              B.tileID.wrap,
              B.tileID.canonical.z,
              B.tileID.canonical.x,
              B.tileID.canonical.y,
            )),
              (this.uid = B.uid),
              (this.zoom = B.zoom),
              (this.pixelRatio = B.pixelRatio),
              (this.tileSize = B.tileSize),
              (this.source = B.source),
              (this.overscaling = this.tileID.overscaleFactor()),
              (this.showCollisionBoxes = B.showCollisionBoxes),
              (this.collectResourceTiming = !!B.collectResourceTiming),
              (this.returnDependencies = !!B.returnDependencies),
              (this.promoteId = B.promoteId),
              (this.inFlightDependencies = []));
          }
          parse(B, z, L, q, te) {
            return E._(this, void 0, void 0, function* () {
              ((this.status = "parsing"),
                (this.data = B),
                (this.collisionBoxArray = new E.a2()));
              const ue = new E.cl(Object.keys(B.layers).sort()),
                fe = new E.cm(this.tileID, this.promoteId);
              fe.bucketLayerIDs = [];
              const ae = {},
                ve = {
                  featureIndex: fe,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  availableImages: L,
                  subdivisionGranularity: te,
                },
                _e = z.familiesBySource[this.source];
              for (const it in _e) {
                const je = B.layers[it];
                if (!je) continue;
                je.version === 1 &&
                  E.w(
                    `Vector tile source "${this.source}" layer "${it}" does not use vector tile spec v2 and therefore may have some rendering errors.`,
                  );
                const Ht = ue.encode(it),
                  en = [];
                for (let ci = 0; ci < je.length; ci++) {
                  const ni = je.feature(ci),
                    kt = fe.getId(ni, it);
                  en.push({
                    feature: ni,
                    id: kt,
                    index: ci,
                    sourceLayerIndex: Ht,
                  });
                }
                for (const ci of _e[it]) {
                  const ni = ci[0];
                  (ni.source !== this.source &&
                    E.w(
                      `layer.source = ${ni.source} does not equal this.source = ${this.source}`,
                    ),
                    (ni.minzoom && this.zoom < Math.floor(ni.minzoom)) ||
                      (ni.maxzoom && this.zoom >= ni.maxzoom) ||
                      (ni.visibility !== "none" &&
                        (_t(ci, this.zoom, L),
                        (ae[ni.id] = ni.createBucket({
                          index: fe.bucketLayerIDs.length,
                          layers: ci,
                          zoom: this.zoom,
                          pixelRatio: this.pixelRatio,
                          overscaling: this.overscaling,
                          collisionBoxArray: this.collisionBoxArray,
                          sourceLayerIndex: Ht,
                          sourceID: this.source,
                        })).populate(en, ve, this.tileID.canonical),
                        fe.bucketLayerIDs.push(ci.map((kt) => kt.id)))));
                }
              }
              const ce = E.bA(ve.glyphDependencies, (it) =>
                Object.keys(it).map(Number),
              );
              (this.inFlightDependencies.forEach((it) =>
                it == null ? void 0 : it.abort(),
              ),
                (this.inFlightDependencies = []));
              let oe = Promise.resolve({});
              if (Object.keys(ce).length) {
                const it = new AbortController();
                (this.inFlightDependencies.push(it),
                  (oe = q.sendAsync(
                    {
                      type: "GG",
                      data: {
                        stacks: ce,
                        source: this.source,
                        tileID: this.tileID,
                        type: "glyphs",
                      },
                    },
                    it,
                  )));
              }
              const ke = Object.keys(ve.iconDependencies);
              let Ie = Promise.resolve({});
              if (ke.length) {
                const it = new AbortController();
                (this.inFlightDependencies.push(it),
                  (Ie = q.sendAsync(
                    {
                      type: "GI",
                      data: {
                        icons: ke,
                        source: this.source,
                        tileID: this.tileID,
                        type: "icons",
                      },
                    },
                    it,
                  )));
              }
              const Je = Object.keys(ve.patternDependencies);
              let nt = Promise.resolve({});
              if (Je.length) {
                const it = new AbortController();
                (this.inFlightDependencies.push(it),
                  (nt = q.sendAsync(
                    {
                      type: "GI",
                      data: {
                        icons: Je,
                        source: this.source,
                        tileID: this.tileID,
                        type: "patterns",
                      },
                    },
                    it,
                  )));
              }
              const [Ce, ze, Ve] = yield Promise.all([oe, Ie, nt]),
                lt = new Ue(Ce),
                mt = new E.cn(ze, Ve);
              for (const it in ae) {
                const je = ae[it];
                je instanceof E.a3
                  ? (_t(je.layers, this.zoom, L),
                    E.co({
                      bucket: je,
                      glyphMap: Ce,
                      glyphPositions: lt.positions,
                      imageMap: ze,
                      imagePositions: mt.iconPositions,
                      showCollisionBoxes: this.showCollisionBoxes,
                      canonical: this.tileID.canonical,
                      subdivisionGranularity: ve.subdivisionGranularity,
                    }))
                  : je.hasPattern &&
                    (je instanceof E.cp ||
                      je instanceof E.cq ||
                      je instanceof E.cr) &&
                    (_t(je.layers, this.zoom, L),
                    je.addFeatures(
                      ve,
                      this.tileID.canonical,
                      mt.patternPositions,
                    ));
              }
              return (
                (this.status = "done"),
                {
                  buckets: Object.values(ae).filter((it) => !it.isEmpty()),
                  featureIndex: fe,
                  collisionBoxArray: this.collisionBoxArray,
                  glyphAtlasImage: lt.image,
                  imageAtlas: mt,
                  glyphMap: this.returnDependencies ? Ce : null,
                  iconMap: this.returnDependencies ? ze : null,
                  glyphPositions: this.returnDependencies ? lt.positions : null,
                }
              );
            });
          }
        }
        function _t(j, B, z) {
          const L = new E.z(B);
          for (const q of j) q.recalculate(L, z);
        }
        class li {
          constructor(B, z, L) {
            ((this.actor = B),
              (this.layerIndex = z),
              (this.availableImages = L),
              (this.fetching = {}),
              (this.loading = {}),
              (this.loaded = {}));
          }
          loadVectorTile(B, z) {
            return E._(this, void 0, void 0, function* () {
              const L = yield E.l(B.request, z);
              try {
                return {
                  vectorTile: new E.cs.VectorTile(new E.ct(L.data)),
                  rawData: L.data,
                  cacheControl: L.cacheControl,
                  expires: L.expires,
                };
              } catch (q) {
                const te = new Uint8Array(L.data);
                let ue = `Unable to parse the tile at ${B.request.url}, `;
                throw (
                  (ue +=
                    te[0] === 31 && te[1] === 139
                      ? "please make sure the data is not gzipped and that you have configured the relevant header in the server"
                      : `got error: ${q.message}`),
                  new Error(ue)
                );
              }
            });
          }
          loadTile(B) {
            return E._(this, void 0, void 0, function* () {
              const z = B.uid,
                L =
                  !!(B && B.request && B.request.collectResourceTiming) &&
                  new E.cu(B.request),
                q = new rt(B);
              this.loading[z] = q;
              const te = new AbortController();
              q.abort = te;
              try {
                const ue = yield this.loadVectorTile(B, te);
                if ((delete this.loading[z], !ue)) return null;
                const fe = ue.rawData,
                  ae = {};
                (ue.expires && (ae.expires = ue.expires),
                  ue.cacheControl && (ae.cacheControl = ue.cacheControl));
                const ve = {};
                if (L) {
                  const ce = L.finish();
                  ce && (ve.resourceTiming = JSON.parse(JSON.stringify(ce)));
                }
                q.vectorTile = ue.vectorTile;
                const _e = q.parse(
                  ue.vectorTile,
                  this.layerIndex,
                  this.availableImages,
                  this.actor,
                  B.subdivisionGranularity,
                );
                ((this.loaded[z] = q),
                  (this.fetching[z] = {
                    rawTileData: fe,
                    cacheControl: ae,
                    resourceTiming: ve,
                  }));
                try {
                  const ce = yield _e;
                  return E.e({ rawTileData: fe.slice(0) }, ce, ae, ve);
                } finally {
                  delete this.fetching[z];
                }
              } catch (ue) {
                throw (
                  delete this.loading[z],
                  (q.status = "done"),
                  (this.loaded[z] = q),
                  ue
                );
              }
            });
          }
          reloadTile(B) {
            return E._(this, void 0, void 0, function* () {
              const z = B.uid;
              if (!this.loaded || !this.loaded[z])
                throw new Error(
                  "Should not be trying to reload a tile that was never loaded or has been removed",
                );
              const L = this.loaded[z];
              if (
                ((L.showCollisionBoxes = B.showCollisionBoxes),
                L.status === "parsing")
              ) {
                const q = yield L.parse(
                  L.vectorTile,
                  this.layerIndex,
                  this.availableImages,
                  this.actor,
                  B.subdivisionGranularity,
                );
                let te;
                if (this.fetching[z]) {
                  const {
                    rawTileData: ue,
                    cacheControl: fe,
                    resourceTiming: ae,
                  } = this.fetching[z];
                  (delete this.fetching[z],
                    (te = E.e({ rawTileData: ue.slice(0) }, q, fe, ae)));
                } else te = q;
                return te;
              }
              if (L.status === "done" && L.vectorTile)
                return L.parse(
                  L.vectorTile,
                  this.layerIndex,
                  this.availableImages,
                  this.actor,
                  B.subdivisionGranularity,
                );
            });
          }
          abortTile(B) {
            return E._(this, void 0, void 0, function* () {
              const z = this.loading,
                L = B.uid;
              z && z[L] && z[L].abort && (z[L].abort.abort(), delete z[L]);
            });
          }
          removeTile(B) {
            return E._(this, void 0, void 0, function* () {
              this.loaded && this.loaded[B.uid] && delete this.loaded[B.uid];
            });
          }
        }
        class Qe {
          constructor() {
            this.loaded = {};
          }
          loadTile(B) {
            return E._(this, void 0, void 0, function* () {
              const {
                  uid: z,
                  encoding: L,
                  rawImageData: q,
                  redFactor: te,
                  greenFactor: ue,
                  blueFactor: fe,
                  baseShift: ae,
                } = B,
                ve = q.width + 2,
                _e = q.height + 2,
                ce = E.b(q)
                  ? new E.R(
                      { width: ve, height: _e },
                      yield E.cv(q, -1, -1, ve, _e),
                    )
                  : q,
                oe = new E.cw(z, ce, L, te, ue, fe, ae);
              return (
                (this.loaded = this.loaded || {}),
                (this.loaded[z] = oe),
                oe
              );
            });
          }
          removeTile(B) {
            const z = this.loaded,
              L = B.uid;
            z && z[L] && delete z[L];
          }
        }
        var me,
          Ze,
          Ni = (function () {
            if (Ze) return me;
            function j(z, L) {
              if (z.length !== 0) {
                B(z[0], L);
                for (var q = 1; q < z.length; q++) B(z[q], !L);
              }
            }
            function B(z, L) {
              for (
                var q = 0, te = 0, ue = 0, fe = z.length, ae = fe - 1;
                ue < fe;
                ae = ue++
              ) {
                var ve = (z[ue][0] - z[ae][0]) * (z[ae][1] + z[ue][1]),
                  _e = q + ve;
                ((te +=
                  Math.abs(q) >= Math.abs(ve) ? q - _e + ve : ve - _e + q),
                  (q = _e));
              }
              q + te >= 0 != !!L && z.reverse();
            }
            return (
              (Ze = 1),
              (me = function z(L, q) {
                var te,
                  ue = L && L.type;
                if (ue === "FeatureCollection")
                  for (te = 0; te < L.features.length; te++)
                    z(L.features[te], q);
                else if (ue === "GeometryCollection")
                  for (te = 0; te < L.geometries.length; te++)
                    z(L.geometries[te], q);
                else if (ue === "Feature") z(L.geometry, q);
                else if (ue === "Polygon") j(L.coordinates, q);
                else if (ue === "MultiPolygon")
                  for (te = 0; te < L.coordinates.length; te++)
                    j(L.coordinates[te], q);
                return L;
              })
            );
          })(),
          Ei = E.cx(Ni);
        const Mi = E.cs.VectorTileFeature.prototype.toGeoJSON;
        class Ki {
          constructor(B) {
            ((this._feature = B),
              (this.extent = E.X),
              (this.type = B.type),
              (this.properties = B.tags),
              "id" in B && !isNaN(B.id) && (this.id = parseInt(B.id, 10)));
          }
          loadGeometry() {
            if (this._feature.type === 1) {
              const B = [];
              for (const z of this._feature.geometry)
                B.push([new E.P(z[0], z[1])]);
              return B;
            }
            {
              const B = [];
              for (const z of this._feature.geometry) {
                const L = [];
                for (const q of z) L.push(new E.P(q[0], q[1]));
                B.push(L);
              }
              return B;
            }
          }
          toGeoJSON(B, z, L) {
            return Mi.call(this, B, z, L);
          }
        }
        class mr {
          constructor(B) {
            ((this.layers = { _geojsonTileLayer: this }),
              (this.name = "_geojsonTileLayer"),
              (this.extent = E.X),
              (this.length = B.length),
              (this._features = B));
          }
          feature(B) {
            return new Ki(this._features[B]);
          }
        }
        var ei,
          Vi,
          It,
          Dt = { exports: {} },
          Bt = (function () {
            if (It) return Dt.exports;
            It = 1;
            var j = E.cA(),
              B = (function () {
                if (Vi) return ei;
                Vi = 1;
                var _e = E.cy(),
                  ce = E.cz().VectorTileFeature;
                function oe(Ie, Je) {
                  ((this.options = Je || {}),
                    (this.features = Ie),
                    (this.length = Ie.length));
                }
                function ke(Ie, Je) {
                  ((this.id = typeof Ie.id == "number" ? Ie.id : void 0),
                    (this.type = Ie.type),
                    (this.rawGeometry =
                      Ie.type === 1 ? [Ie.geometry] : Ie.geometry),
                    (this.properties = Ie.tags),
                    (this.extent = Je || 4096));
                }
                return (
                  (ei = oe),
                  (oe.prototype.feature = function (Ie) {
                    return new ke(this.features[Ie], this.options.extent);
                  }),
                  (ke.prototype.loadGeometry = function () {
                    var Ie = this.rawGeometry;
                    this.geometry = [];
                    for (var Je = 0; Je < Ie.length; Je++) {
                      for (
                        var nt = Ie[Je], Ce = [], ze = 0;
                        ze < nt.length;
                        ze++
                      )
                        Ce.push(new _e(nt[ze][0], nt[ze][1]));
                      this.geometry.push(Ce);
                    }
                    return this.geometry;
                  }),
                  (ke.prototype.bbox = function () {
                    this.geometry || this.loadGeometry();
                    for (
                      var Ie = this.geometry,
                        Je = 1 / 0,
                        nt = -1 / 0,
                        Ce = 1 / 0,
                        ze = -1 / 0,
                        Ve = 0;
                      Ve < Ie.length;
                      Ve++
                    )
                      for (var lt = Ie[Ve], mt = 0; mt < lt.length; mt++) {
                        var it = lt[mt];
                        ((Je = Math.min(Je, it.x)),
                          (nt = Math.max(nt, it.x)),
                          (Ce = Math.min(Ce, it.y)),
                          (ze = Math.max(ze, it.y)));
                      }
                    return [Je, Ce, nt, ze];
                  }),
                  (ke.prototype.toGeoJSON = ce.prototype.toGeoJSON),
                  ei
                );
              })();
            function z(_e) {
              var ce = new j();
              return (
                (function (oe, ke) {
                  for (var Ie in oe.layers)
                    ke.writeMessage(3, L, oe.layers[Ie]);
                })(_e, ce),
                ce.finish()
              );
            }
            function L(_e, ce) {
              var oe;
              (ce.writeVarintField(15, _e.version || 1),
                ce.writeStringField(1, _e.name || ""),
                ce.writeVarintField(5, _e.extent || 4096));
              var ke = { keys: [], values: [], keycache: {}, valuecache: {} };
              for (oe = 0; oe < _e.length; oe++)
                ((ke.feature = _e.feature(oe)), ce.writeMessage(2, q, ke));
              var Ie = ke.keys;
              for (oe = 0; oe < Ie.length; oe++) ce.writeStringField(3, Ie[oe]);
              var Je = ke.values;
              for (oe = 0; oe < Je.length; oe++) ce.writeMessage(4, ve, Je[oe]);
            }
            function q(_e, ce) {
              var oe = _e.feature;
              (oe.id !== void 0 && ce.writeVarintField(1, oe.id),
                ce.writeMessage(2, te, _e),
                ce.writeVarintField(3, oe.type),
                ce.writeMessage(4, ae, oe));
            }
            function te(_e, ce) {
              var oe = _e.feature,
                ke = _e.keys,
                Ie = _e.values,
                Je = _e.keycache,
                nt = _e.valuecache;
              for (var Ce in oe.properties) {
                var ze = oe.properties[Ce],
                  Ve = Je[Ce];
                if (ze !== null) {
                  (Ve === void 0 &&
                    (ke.push(Ce), (Je[Ce] = Ve = ke.length - 1)),
                    ce.writeVarint(Ve));
                  var lt = typeof ze;
                  lt !== "string" &&
                    lt !== "boolean" &&
                    lt !== "number" &&
                    (ze = JSON.stringify(ze));
                  var mt = lt + ":" + ze,
                    it = nt[mt];
                  (it === void 0 &&
                    (Ie.push(ze), (nt[mt] = it = Ie.length - 1)),
                    ce.writeVarint(it));
                }
              }
            }
            function ue(_e, ce) {
              return (ce << 3) + (7 & _e);
            }
            function fe(_e) {
              return (_e << 1) ^ (_e >> 31);
            }
            function ae(_e, ce) {
              for (
                var oe = _e.loadGeometry(),
                  ke = _e.type,
                  Ie = 0,
                  Je = 0,
                  nt = oe.length,
                  Ce = 0;
                Ce < nt;
                Ce++
              ) {
                var ze = oe[Ce],
                  Ve = 1;
                (ke === 1 && (Ve = ze.length), ce.writeVarint(ue(1, Ve)));
                for (
                  var lt = ke === 3 ? ze.length - 1 : ze.length, mt = 0;
                  mt < lt;
                  mt++
                ) {
                  mt === 1 && ke !== 1 && ce.writeVarint(ue(2, lt - 1));
                  var it = ze[mt].x - Ie,
                    je = ze[mt].y - Je;
                  (ce.writeVarint(fe(it)),
                    ce.writeVarint(fe(je)),
                    (Ie += it),
                    (Je += je));
                }
                ke === 3 && ce.writeVarint(ue(7, 1));
              }
            }
            function ve(_e, ce) {
              var oe = typeof _e;
              oe === "string"
                ? ce.writeStringField(1, _e)
                : oe === "boolean"
                  ? ce.writeBooleanField(7, _e)
                  : oe === "number" &&
                    (_e % 1 != 0
                      ? ce.writeDoubleField(3, _e)
                      : _e < 0
                        ? ce.writeSVarintField(6, _e)
                        : ce.writeVarintField(5, _e));
            }
            return (
              (Dt.exports = z),
              (Dt.exports.fromVectorTileJs = z),
              (Dt.exports.fromGeojsonVt = function (_e, ce) {
                ce = ce || {};
                var oe = {};
                for (var ke in _e)
                  ((oe[ke] = new B(_e[ke].features, ce)),
                    (oe[ke].name = ke),
                    (oe[ke].version = ce.version),
                    (oe[ke].extent = ce.extent));
                return z({ layers: oe });
              }),
              (Dt.exports.GeoJSONWrapper = B),
              Dt.exports
            );
          })(),
          Xr = E.cx(Bt);
        const dn = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: (j) => j,
          },
          or =
            Math.fround ||
            ((sr = new Float32Array(1)), (j) => ((sr[0] = +j), sr[0]));
        var sr;
        const Ae = 3,
          Oe = 5,
          $e = 6;
        class qe {
          constructor(B) {
            ((this.options = Object.assign(Object.create(dn), B)),
              (this.trees = new Array(this.options.maxZoom + 1)),
              (this.stride = this.options.reduce ? 7 : 6),
              (this.clusterProps = []));
          }
          load(B) {
            const { log: z, minZoom: L, maxZoom: q } = this.options;
            z && console.time("total time");
            const te = `prepare ${B.length} points`;
            (z && console.time(te), (this.points = B));
            const ue = [];
            for (let ae = 0; ae < B.length; ae++) {
              const ve = B[ae];
              if (!ve.geometry) continue;
              const [_e, ce] = ve.geometry.coordinates,
                oe = or(Et(_e)),
                ke = or($t(ce));
              (ue.push(oe, ke, 1 / 0, ae, -1, 1),
                this.options.reduce && ue.push(0));
            }
            let fe = (this.trees[q + 1] = this._createTree(ue));
            z && console.timeEnd(te);
            for (let ae = q; ae >= L; ae--) {
              const ve = +Date.now();
              ((fe = this.trees[ae] = this._createTree(this._cluster(fe, ae))),
                z &&
                  console.log(
                    "z%d: %d clusters in %dms",
                    ae,
                    fe.numItems,
                    +Date.now() - ve,
                  ));
            }
            return (z && console.timeEnd("total time"), this);
          }
          getClusters(B, z) {
            let L = ((((B[0] + 180) % 360) + 360) % 360) - 180;
            const q = Math.max(-90, Math.min(90, B[1]));
            let te =
              B[2] === 180 ? 180 : ((((B[2] + 180) % 360) + 360) % 360) - 180;
            const ue = Math.max(-90, Math.min(90, B[3]));
            if (B[2] - B[0] >= 360) ((L = -180), (te = 180));
            else if (L > te) {
              const ce = this.getClusters([L, q, 180, ue], z),
                oe = this.getClusters([-180, q, te, ue], z);
              return ce.concat(oe);
            }
            const fe = this.trees[this._limitZoom(z)],
              ae = fe.range(Et(L), $t(ue), Et(te), $t(q)),
              ve = fe.data,
              _e = [];
            for (const ce of ae) {
              const oe = this.stride * ce;
              _e.push(
                ve[oe + Oe] > 1
                  ? pt(ve, oe, this.clusterProps)
                  : this.points[ve[oe + Ae]],
              );
            }
            return _e;
          }
          getChildren(B) {
            const z = this._getOriginId(B),
              L = this._getOriginZoom(B),
              q = "No cluster with the specified id.",
              te = this.trees[L];
            if (!te) throw new Error(q);
            const ue = te.data;
            if (z * this.stride >= ue.length) throw new Error(q);
            const fe =
                this.options.radius /
                (this.options.extent * Math.pow(2, L - 1)),
              ae = te.within(ue[z * this.stride], ue[z * this.stride + 1], fe),
              ve = [];
            for (const _e of ae) {
              const ce = _e * this.stride;
              ue[ce + 4] === B &&
                ve.push(
                  ue[ce + Oe] > 1
                    ? pt(ue, ce, this.clusterProps)
                    : this.points[ue[ce + Ae]],
                );
            }
            if (ve.length === 0) throw new Error(q);
            return ve;
          }
          getLeaves(B, z, L) {
            const q = [];
            return (
              this._appendLeaves(q, B, (z = z || 10), (L = L || 0), 0),
              q
            );
          }
          getTile(B, z, L) {
            const q = this.trees[this._limitZoom(B)],
              te = Math.pow(2, B),
              { extent: ue, radius: fe } = this.options,
              ae = fe / ue,
              ve = (L - ae) / te,
              _e = (L + 1 + ae) / te,
              ce = { features: [] };
            return (
              this._addTileFeatures(
                q.range((z - ae) / te, ve, (z + 1 + ae) / te, _e),
                q.data,
                z,
                L,
                te,
                ce,
              ),
              z === 0 &&
                this._addTileFeatures(
                  q.range(1 - ae / te, ve, 1, _e),
                  q.data,
                  te,
                  L,
                  te,
                  ce,
                ),
              z === te - 1 &&
                this._addTileFeatures(
                  q.range(0, ve, ae / te, _e),
                  q.data,
                  -1,
                  L,
                  te,
                  ce,
                ),
              ce.features.length ? ce : null
            );
          }
          getClusterExpansionZoom(B) {
            let z = this._getOriginZoom(B) - 1;
            for (; z <= this.options.maxZoom; ) {
              const L = this.getChildren(B);
              if ((z++, L.length !== 1)) break;
              B = L[0].properties.cluster_id;
            }
            return z;
          }
          _appendLeaves(B, z, L, q, te) {
            const ue = this.getChildren(z);
            for (const fe of ue) {
              const ae = fe.properties;
              if (
                (ae && ae.cluster
                  ? te + ae.point_count <= q
                    ? (te += ae.point_count)
                    : (te = this._appendLeaves(B, ae.cluster_id, L, q, te))
                  : te < q
                    ? te++
                    : B.push(fe),
                B.length === L)
              )
                break;
            }
            return te;
          }
          _createTree(B) {
            const z = new E.az(
              (B.length / this.stride) | 0,
              this.options.nodeSize,
              Float32Array,
            );
            for (let L = 0; L < B.length; L += this.stride)
              z.add(B[L], B[L + 1]);
            return (z.finish(), (z.data = B), z);
          }
          _addTileFeatures(B, z, L, q, te, ue) {
            for (const fe of B) {
              const ae = fe * this.stride,
                ve = z[ae + Oe] > 1;
              let _e, ce, oe;
              if (ve)
                ((_e = tt(z, ae, this.clusterProps)),
                  (ce = z[ae]),
                  (oe = z[ae + 1]));
              else {
                const Je = this.points[z[ae + Ae]];
                _e = Je.properties;
                const [nt, Ce] = Je.geometry.coordinates;
                ((ce = Et(nt)), (oe = $t(Ce)));
              }
              const ke = {
                type: 1,
                geometry: [
                  [
                    Math.round(this.options.extent * (ce * te - L)),
                    Math.round(this.options.extent * (oe * te - q)),
                  ],
                ],
                tags: _e,
              };
              let Ie;
              ((Ie =
                ve || this.options.generateId
                  ? z[ae + Ae]
                  : this.points[z[ae + Ae]].id),
                Ie !== void 0 && (ke.id = Ie),
                ue.features.push(ke));
            }
          }
          _limitZoom(B) {
            return Math.max(
              this.options.minZoom,
              Math.min(Math.floor(+B), this.options.maxZoom + 1),
            );
          }
          _cluster(B, z) {
            const {
                radius: L,
                extent: q,
                reduce: te,
                minPoints: ue,
              } = this.options,
              fe = L / (q * Math.pow(2, z)),
              ae = B.data,
              ve = [],
              _e = this.stride;
            for (let ce = 0; ce < ae.length; ce += _e) {
              if (ae[ce + 2] <= z) continue;
              ae[ce + 2] = z;
              const oe = ae[ce],
                ke = ae[ce + 1],
                Ie = B.within(ae[ce], ae[ce + 1], fe),
                Je = ae[ce + Oe];
              let nt = Je;
              for (const Ce of Ie) {
                const ze = Ce * _e;
                ae[ze + 2] > z && (nt += ae[ze + Oe]);
              }
              if (nt > Je && nt >= ue) {
                let Ce,
                  ze = oe * Je,
                  Ve = ke * Je,
                  lt = -1;
                const mt =
                  (((ce / _e) | 0) << 5) + (z + 1) + this.points.length;
                for (const it of Ie) {
                  const je = it * _e;
                  if (ae[je + 2] <= z) continue;
                  ae[je + 2] = z;
                  const Ht = ae[je + Oe];
                  ((ze += ae[je] * Ht),
                    (Ve += ae[je + 1] * Ht),
                    (ae[je + 4] = mt),
                    te &&
                      (Ce ||
                        ((Ce = this._map(ae, ce, !0)),
                        (lt = this.clusterProps.length),
                        this.clusterProps.push(Ce)),
                      te(Ce, this._map(ae, je))));
                }
                ((ae[ce + 4] = mt),
                  ve.push(ze / nt, Ve / nt, 1 / 0, mt, -1, nt),
                  te && ve.push(lt));
              } else {
                for (let Ce = 0; Ce < _e; Ce++) ve.push(ae[ce + Ce]);
                if (nt > 1)
                  for (const Ce of Ie) {
                    const ze = Ce * _e;
                    if (!(ae[ze + 2] <= z)) {
                      ae[ze + 2] = z;
                      for (let Ve = 0; Ve < _e; Ve++) ve.push(ae[ze + Ve]);
                    }
                  }
              }
            }
            return ve;
          }
          _getOriginId(B) {
            return (B - this.points.length) >> 5;
          }
          _getOriginZoom(B) {
            return (B - this.points.length) % 32;
          }
          _map(B, z, L) {
            if (B[z + Oe] > 1) {
              const ue = this.clusterProps[B[z + $e]];
              return L ? Object.assign({}, ue) : ue;
            }
            const q = this.points[B[z + Ae]].properties,
              te = this.options.map(q);
            return L && te === q ? Object.assign({}, te) : te;
          }
        }
        function pt(j, B, z) {
          return {
            type: "Feature",
            id: j[B + Ae],
            properties: tt(j, B, z),
            geometry: {
              type: "Point",
              coordinates: [((L = j[B]), 360 * (L - 0.5)), _i(j[B + 1])],
            },
          };
          var L;
        }
        function tt(j, B, z) {
          const L = j[B + Oe],
            q =
              L >= 1e4
                ? `${Math.round(L / 1e3)}k`
                : L >= 1e3
                  ? Math.round(L / 100) / 10 + "k"
                  : L,
            te = j[B + $e],
            ue = te === -1 ? {} : Object.assign({}, z[te]);
          return Object.assign(ue, {
            cluster: !0,
            cluster_id: j[B + Ae],
            point_count: L,
            point_count_abbreviated: q,
          });
        }
        function Et(j) {
          return j / 360 + 0.5;
        }
        function $t(j) {
          const B = Math.sin((j * Math.PI) / 180),
            z = 0.5 - (0.25 * Math.log((1 + B) / (1 - B))) / Math.PI;
          return z < 0 ? 0 : z > 1 ? 1 : z;
        }
        function _i(j) {
          const B = ((180 - 360 * j) * Math.PI) / 180;
          return (360 * Math.atan(Math.exp(B))) / Math.PI - 90;
        }
        function Ii(j, B, z, L) {
          let q = L;
          const te = B + ((z - B) >> 1);
          let ue,
            fe = z - B;
          const ae = j[B],
            ve = j[B + 1],
            _e = j[z],
            ce = j[z + 1];
          for (let oe = B + 3; oe < z; oe += 3) {
            const ke = Bi(j[oe], j[oe + 1], ae, ve, _e, ce);
            if (ke > q) ((ue = oe), (q = ke));
            else if (ke === q) {
              const Ie = Math.abs(oe - te);
              Ie < fe && ((ue = oe), (fe = Ie));
            }
          }
          q > L &&
            (ue - B > 3 && Ii(j, B, ue, L),
            (j[ue + 2] = q),
            z - ue > 3 && Ii(j, ue, z, L));
        }
        function Bi(j, B, z, L, q, te) {
          let ue = q - z,
            fe = te - L;
          if (ue !== 0 || fe !== 0) {
            const ae = ((j - z) * ue + (B - L) * fe) / (ue * ue + fe * fe);
            ae > 1
              ? ((z = q), (L = te))
              : ae > 0 && ((z += ue * ae), (L += fe * ae));
          }
          return ((ue = j - z), (fe = B - L), ue * ue + fe * fe);
        }
        function ar(j, B, z, L) {
          const q = {
            id: j == null ? null : j,
            type: B,
            geometry: z,
            tags: L,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0,
          };
          if (B === "Point" || B === "MultiPoint" || B === "LineString")
            yi(q, z);
          else if (B === "Polygon") yi(q, z[0]);
          else if (B === "MultiLineString") for (const te of z) yi(q, te);
          else if (B === "MultiPolygon") for (const te of z) yi(q, te[0]);
          return q;
        }
        function yi(j, B) {
          for (let z = 0; z < B.length; z += 3)
            ((j.minX = Math.min(j.minX, B[z])),
              (j.minY = Math.min(j.minY, B[z + 1])),
              (j.maxX = Math.max(j.maxX, B[z])),
              (j.maxY = Math.max(j.maxY, B[z + 1])));
        }
        function pn(j, B, z, L) {
          if (!B.geometry) return;
          const q = B.geometry.coordinates;
          if (q && q.length === 0) return;
          const te = B.geometry.type,
            ue = Math.pow(z.tolerance / ((1 << z.maxZoom) * z.extent), 2);
          let fe = [],
            ae = B.id;
          if (
            (z.promoteId
              ? (ae = B.properties[z.promoteId])
              : z.generateId && (ae = L || 0),
            te === "Point")
          )
            fn(q, fe);
          else if (te === "MultiPoint") for (const ve of q) fn(ve, fe);
          else if (te === "LineString") mn(q, fe, ue, !1);
          else if (te === "MultiLineString") {
            if (z.lineMetrics) {
              for (const ve of q)
                ((fe = []),
                  mn(ve, fe, ue, !1),
                  j.push(ar(ae, "LineString", fe, B.properties)));
              return;
            }
            Yi(q, fe, ue, !1);
          } else if (te === "Polygon") Yi(q, fe, ue, !0);
          else {
            if (te !== "MultiPolygon") {
              if (te === "GeometryCollection") {
                for (const ve of B.geometry.geometries)
                  pn(
                    j,
                    { id: ae, geometry: ve, properties: B.properties },
                    z,
                    L,
                  );
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const ve of q) {
              const _e = [];
              (Yi(ve, _e, ue, !0), fe.push(_e));
            }
          }
          j.push(ar(ae, te, fe, B.properties));
        }
        function fn(j, B) {
          B.push(Eo(j[0]), Ai(j[1]), 0);
        }
        function mn(j, B, z, L) {
          let q,
            te,
            ue = 0;
          for (let ae = 0; ae < j.length; ae++) {
            const ve = Eo(j[ae][0]),
              _e = Ai(j[ae][1]);
            (B.push(ve, _e, 0),
              ae > 0 &&
                (ue += L
                  ? (q * _e - ve * te) / 2
                  : Math.sqrt(Math.pow(ve - q, 2) + Math.pow(_e - te, 2))),
              (q = ve),
              (te = _e));
          }
          const fe = B.length - 3;
          ((B[2] = 1),
            Ii(B, 0, fe, z),
            (B[fe + 2] = 1),
            (B.size = Math.abs(ue)),
            (B.start = 0),
            (B.end = B.size));
        }
        function Yi(j, B, z, L) {
          for (let q = 0; q < j.length; q++) {
            const te = [];
            (mn(j[q], te, z, L), B.push(te));
          }
        }
        function Eo(j) {
          return j / 360 + 0.5;
        }
        function Ai(j) {
          const B = Math.sin((j * Math.PI) / 180),
            z = 0.5 - (0.25 * Math.log((1 + B) / (1 - B))) / Math.PI;
          return z < 0 ? 0 : z > 1 ? 1 : z;
        }
        function ui(j, B, z, L, q, te, ue, fe) {
          if (((L /= B), te >= (z /= B) && ue < L)) return j;
          if (ue < z || te >= L) return null;
          const ae = [];
          for (const ve of j) {
            const _e = ve.geometry;
            let ce = ve.type;
            const oe = q === 0 ? ve.minX : ve.minY,
              ke = q === 0 ? ve.maxX : ve.maxY;
            if (oe >= z && ke < L) {
              ae.push(ve);
              continue;
            }
            if (ke < z || oe >= L) continue;
            let Ie = [];
            if (ce === "Point" || ce === "MultiPoint") zr(_e, Ie, z, L, q);
            else if (ce === "LineString")
              ti(_e, Ie, z, L, q, !1, fe.lineMetrics);
            else if (ce === "MultiLineString") _n(_e, Ie, z, L, q, !1);
            else if (ce === "Polygon") _n(_e, Ie, z, L, q, !0);
            else if (ce === "MultiPolygon")
              for (const Je of _e) {
                const nt = [];
                (_n(Je, nt, z, L, q, !0), nt.length && Ie.push(nt));
              }
            if (Ie.length) {
              if (fe.lineMetrics && ce === "LineString") {
                for (const Je of Ie) ae.push(ar(ve.id, ce, Je, ve.tags));
                continue;
              }
              ((ce !== "LineString" && ce !== "MultiLineString") ||
                (Ie.length === 1
                  ? ((ce = "LineString"), (Ie = Ie[0]))
                  : (ce = "MultiLineString")),
                (ce !== "Point" && ce !== "MultiPoint") ||
                  (ce = Ie.length === 3 ? "Point" : "MultiPoint"),
                ae.push(ar(ve.id, ce, Ie, ve.tags)));
            }
          }
          return ae.length ? ae : null;
        }
        function zr(j, B, z, L, q) {
          for (let te = 0; te < j.length; te += 3) {
            const ue = j[te + q];
            ue >= z && ue <= L && gr(B, j[te], j[te + 1], j[te + 2]);
          }
        }
        function ti(j, B, z, L, q, te, ue) {
          let fe = gn(j);
          const ae = q === 0 ? Wr : Kr;
          let ve,
            _e,
            ce = j.start;
          for (let nt = 0; nt < j.length - 3; nt += 3) {
            const Ce = j[nt],
              ze = j[nt + 1],
              Ve = j[nt + 2],
              lt = j[nt + 3],
              mt = j[nt + 4],
              it = q === 0 ? Ce : ze,
              je = q === 0 ? lt : mt;
            let Ht = !1;
            (ue &&
              (ve = Math.sqrt(Math.pow(Ce - lt, 2) + Math.pow(ze - mt, 2))),
              it < z
                ? je > z &&
                  ((_e = ae(fe, Ce, ze, lt, mt, z)),
                  ue && (fe.start = ce + ve * _e))
                : it > L
                  ? je < L &&
                    ((_e = ae(fe, Ce, ze, lt, mt, L)),
                    ue && (fe.start = ce + ve * _e))
                  : gr(fe, Ce, ze, Ve),
              je < z &&
                it >= z &&
                ((_e = ae(fe, Ce, ze, lt, mt, z)), (Ht = !0)),
              je > L &&
                it <= L &&
                ((_e = ae(fe, Ce, ze, lt, mt, L)), (Ht = !0)),
              !te &&
                Ht &&
                (ue && (fe.end = ce + ve * _e), B.push(fe), (fe = gn(j))),
              ue && (ce += ve));
          }
          let oe = j.length - 3;
          const ke = j[oe],
            Ie = j[oe + 1],
            Je = q === 0 ? ke : Ie;
          (Je >= z && Je <= L && gr(fe, ke, Ie, j[oe + 2]),
            (oe = fe.length - 3),
            te &&
              oe >= 3 &&
              (fe[oe] !== fe[0] || fe[oe + 1] !== fe[1]) &&
              gr(fe, fe[0], fe[1], fe[2]),
            fe.length && B.push(fe));
        }
        function gn(j) {
          const B = [];
          return ((B.size = j.size), (B.start = j.start), (B.end = j.end), B);
        }
        function _n(j, B, z, L, q, te) {
          for (const ue of j) ti(ue, B, z, L, q, te, !1);
        }
        function gr(j, B, z, L) {
          j.push(B, z, L);
        }
        function Wr(j, B, z, L, q, te) {
          const ue = (te - B) / (L - B);
          return (gr(j, te, z + (q - z) * ue, 1), ue);
        }
        function Kr(j, B, z, L, q, te) {
          const ue = (te - z) / (q - z);
          return (gr(j, B + (L - B) * ue, te, 1), ue);
        }
        function Ji(j, B) {
          const z = [];
          for (let L = 0; L < j.length; L++) {
            const q = j[L],
              te = q.type;
            let ue;
            if (te === "Point" || te === "MultiPoint" || te === "LineString")
              ue = yn(q.geometry, B);
            else if (te === "MultiLineString" || te === "Polygon") {
              ue = [];
              for (const fe of q.geometry) ue.push(yn(fe, B));
            } else if (te === "MultiPolygon") {
              ue = [];
              for (const fe of q.geometry) {
                const ae = [];
                for (const ve of fe) ae.push(yn(ve, B));
                ue.push(ae);
              }
            }
            z.push(ar(q.id, te, ue, q.tags));
          }
          return z;
        }
        function yn(j, B) {
          const z = [];
          ((z.size = j.size),
            j.start !== void 0 && ((z.start = j.start), (z.end = j.end)));
          for (let L = 0; L < j.length; L += 3)
            z.push(j[L] + B, j[L + 1], j[L + 2]);
          return z;
        }
        function xn(j, B) {
          if (j.transformed) return j;
          const z = 1 << j.z,
            L = j.x,
            q = j.y;
          for (const te of j.features) {
            const ue = te.geometry,
              fe = te.type;
            if (((te.geometry = []), fe === 1))
              for (let ae = 0; ae < ue.length; ae += 2)
                te.geometry.push(Yr(ue[ae], ue[ae + 1], B, z, L, q));
            else
              for (let ae = 0; ae < ue.length; ae++) {
                const ve = [];
                for (let _e = 0; _e < ue[ae].length; _e += 2)
                  ve.push(Yr(ue[ae][_e], ue[ae][_e + 1], B, z, L, q));
                te.geometry.push(ve);
              }
          }
          return ((j.transformed = !0), j);
        }
        function Yr(j, B, z, L, q, te) {
          return [Math.round(z * (j * L - q)), Math.round(z * (B * L - te))];
        }
        function Ao(j, B, z, L, q) {
          const te = B === q.maxZoom ? 0 : q.tolerance / ((1 << B) * q.extent),
            ue = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: j.length,
              source: null,
              x: z,
              y: L,
              z: B,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0,
            };
          for (const fe of j) vn(ue, fe, te, q);
          return ue;
        }
        function vn(j, B, z, L) {
          const q = B.geometry,
            te = B.type,
            ue = [];
          if (
            ((j.minX = Math.min(j.minX, B.minX)),
            (j.minY = Math.min(j.minY, B.minY)),
            (j.maxX = Math.max(j.maxX, B.maxX)),
            (j.maxY = Math.max(j.maxY, B.maxY)),
            te === "Point" || te === "MultiPoint")
          )
            for (let fe = 0; fe < q.length; fe += 3)
              (ue.push(q[fe], q[fe + 1]), j.numPoints++, j.numSimplified++);
          else if (te === "LineString") Lr(ue, q, j, z, !1, !1);
          else if (te === "MultiLineString" || te === "Polygon")
            for (let fe = 0; fe < q.length; fe++)
              Lr(ue, q[fe], j, z, te === "Polygon", fe === 0);
          else if (te === "MultiPolygon")
            for (let fe = 0; fe < q.length; fe++) {
              const ae = q[fe];
              for (let ve = 0; ve < ae.length; ve++)
                Lr(ue, ae[ve], j, z, !0, ve === 0);
            }
          if (ue.length) {
            let fe = B.tags || null;
            if (te === "LineString" && L.lineMetrics) {
              fe = {};
              for (const ve in B.tags) fe[ve] = B.tags[ve];
              ((fe.mapbox_clip_start = q.start / q.size),
                (fe.mapbox_clip_end = q.end / q.size));
            }
            const ae = {
              geometry: ue,
              type:
                te === "Polygon" || te === "MultiPolygon"
                  ? 3
                  : te === "LineString" || te === "MultiLineString"
                    ? 2
                    : 1,
              tags: fe,
            };
            (B.id !== null && (ae.id = B.id), j.features.push(ae));
          }
        }
        function Lr(j, B, z, L, q, te) {
          const ue = L * L;
          if (L > 0 && B.size < (q ? ue : L))
            return void (z.numPoints += B.length / 3);
          const fe = [];
          for (let ae = 0; ae < B.length; ae += 3)
            ((L === 0 || B[ae + 2] > ue) &&
              (z.numSimplified++, fe.push(B[ae], B[ae + 1])),
              z.numPoints++);
          (q &&
            (function (ae, ve) {
              let _e = 0;
              for (
                let ce = 0, oe = ae.length, ke = oe - 2;
                ce < oe;
                ke = ce, ce += 2
              )
                _e += (ae[ce] - ae[ke]) * (ae[ce + 1] + ae[ke + 1]);
              if (_e > 0 === ve)
                for (let ce = 0, oe = ae.length; ce < oe / 2; ce += 2) {
                  const ke = ae[ce],
                    Ie = ae[ce + 1];
                  ((ae[ce] = ae[oe - 2 - ce]),
                    (ae[ce + 1] = ae[oe - 1 - ce]),
                    (ae[oe - 2 - ce] = ke),
                    (ae[oe - 1 - ce] = Ie));
                }
            })(fe, te),
            j.push(fe));
        }
        const bn = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0,
        };
        class Rr {
          constructor(B, z) {
            const L = (z = this.options =
              (function (te, ue) {
                for (const fe in ue) te[fe] = ue[fe];
                return te;
              })(Object.create(bn), z)).debug;
            if (
              (L && console.time("preprocess data"),
              z.maxZoom < 0 || z.maxZoom > 24)
            )
              throw new Error("maxZoom should be in the 0-24 range");
            if (z.promoteId && z.generateId)
              throw new Error(
                "promoteId and generateId cannot be used together.",
              );
            let q = (function (te, ue) {
              const fe = [];
              if (te.type === "FeatureCollection")
                for (let ae = 0; ae < te.features.length; ae++)
                  pn(fe, te.features[ae], ue, ae);
              else pn(fe, te.type === "Feature" ? te : { geometry: te }, ue);
              return fe;
            })(B, z);
            ((this.tiles = {}),
              (this.tileCoords = []),
              L &&
                (console.timeEnd("preprocess data"),
                console.log(
                  "index: maxZoom: %d, maxPoints: %d",
                  z.indexMaxZoom,
                  z.indexMaxPoints,
                ),
                console.time("generate tiles"),
                (this.stats = {}),
                (this.total = 0)),
              (q = (function (te, ue) {
                const fe = ue.buffer / ue.extent;
                let ae = te;
                const ve = ui(te, 1, -1 - fe, fe, 0, -1, 2, ue),
                  _e = ui(te, 1, 1 - fe, 2 + fe, 0, -1, 2, ue);
                return (
                  (ve || _e) &&
                    ((ae = ui(te, 1, -fe, 1 + fe, 0, -1, 2, ue) || []),
                    ve && (ae = Ji(ve, 1).concat(ae)),
                    _e && (ae = ae.concat(Ji(_e, -1)))),
                  ae
                );
              })(q, z)),
              q.length && this.splitTile(q, 0, 0, 0),
              L &&
                (q.length &&
                  console.log(
                    "features: %d, points: %d",
                    this.tiles[0].numFeatures,
                    this.tiles[0].numPoints,
                  ),
                console.timeEnd("generate tiles"),
                console.log(
                  "tiles generated:",
                  this.total,
                  JSON.stringify(this.stats),
                )));
          }
          splitTile(B, z, L, q, te, ue, fe) {
            const ae = [B, z, L, q],
              ve = this.options,
              _e = ve.debug;
            for (; ae.length; ) {
              ((q = ae.pop()), (L = ae.pop()), (z = ae.pop()), (B = ae.pop()));
              const ce = 1 << z,
                oe = wn(z, L, q);
              let ke = this.tiles[oe];
              if (
                !ke &&
                (_e > 1 && console.time("creation"),
                (ke = this.tiles[oe] = Ao(B, z, L, q, ve)),
                this.tileCoords.push({ z, x: L, y: q }),
                _e)
              ) {
                _e > 1 &&
                  (console.log(
                    "tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",
                    z,
                    L,
                    q,
                    ke.numFeatures,
                    ke.numPoints,
                    ke.numSimplified,
                  ),
                  console.timeEnd("creation"));
                const Ht = `z${z}`;
                ((this.stats[Ht] = (this.stats[Ht] || 0) + 1), this.total++);
              }
              if (((ke.source = B), te == null)) {
                if (z === ve.indexMaxZoom || ke.numPoints <= ve.indexMaxPoints)
                  continue;
              } else {
                if (z === ve.maxZoom || z === te) continue;
                if (te != null) {
                  const Ht = te - z;
                  if (L !== ue >> Ht || q !== fe >> Ht) continue;
                }
              }
              if (((ke.source = null), B.length === 0)) continue;
              _e > 1 && console.time("clipping");
              const Ie = (0.5 * ve.buffer) / ve.extent,
                Je = 0.5 - Ie,
                nt = 0.5 + Ie,
                Ce = 1 + Ie;
              let ze = null,
                Ve = null,
                lt = null,
                mt = null,
                it = ui(B, ce, L - Ie, L + nt, 0, ke.minX, ke.maxX, ve),
                je = ui(B, ce, L + Je, L + Ce, 0, ke.minX, ke.maxX, ve);
              ((B = null),
                it &&
                  ((ze = ui(it, ce, q - Ie, q + nt, 1, ke.minY, ke.maxY, ve)),
                  (Ve = ui(it, ce, q + Je, q + Ce, 1, ke.minY, ke.maxY, ve)),
                  (it = null)),
                je &&
                  ((lt = ui(je, ce, q - Ie, q + nt, 1, ke.minY, ke.maxY, ve)),
                  (mt = ui(je, ce, q + Je, q + Ce, 1, ke.minY, ke.maxY, ve)),
                  (je = null)),
                _e > 1 && console.timeEnd("clipping"),
                ae.push(ze || [], z + 1, 2 * L, 2 * q),
                ae.push(Ve || [], z + 1, 2 * L, 2 * q + 1),
                ae.push(lt || [], z + 1, 2 * L + 1, 2 * q),
                ae.push(mt || [], z + 1, 2 * L + 1, 2 * q + 1));
            }
          }
          getTile(B, z, L) {
            ((B = +B), (z = +z), (L = +L));
            const q = this.options,
              { extent: te, debug: ue } = q;
            if (B < 0 || B > 24) return null;
            const fe = 1 << B,
              ae = wn(B, (z = (z + fe) & (fe - 1)), L);
            if (this.tiles[ae]) return xn(this.tiles[ae], te);
            ue > 1 && console.log("drilling down to z%d-%d-%d", B, z, L);
            let ve,
              _e = B,
              ce = z,
              oe = L;
            for (; !ve && _e > 0; )
              (_e--, (ce >>= 1), (oe >>= 1), (ve = this.tiles[wn(_e, ce, oe)]));
            return ve && ve.source
              ? (ue > 1 &&
                  (console.log("found parent tile z%d-%d-%d", _e, ce, oe),
                  console.time("drilling down")),
                this.splitTile(ve.source, _e, ce, oe, B, z, L),
                ue > 1 && console.timeEnd("drilling down"),
                this.tiles[ae] ? xn(this.tiles[ae], te) : null)
              : null;
          }
        }
        function wn(j, B, z) {
          return 32 * ((1 << j) * z + B) + j;
        }
        function Jr(j, B) {
          return B ? j.properties[B] : j.id;
        }
        function Gn(j, B) {
          if (j == null) return !0;
          if (j.type === "Feature") return Jr(j, B) != null;
          if (j.type === "FeatureCollection") {
            const z = new Set();
            for (const L of j.features) {
              const q = Jr(L, B);
              if (q == null || z.has(q)) return !1;
              z.add(q);
            }
            return !0;
          }
          return !1;
        }
        function qn(j, B) {
          const z = new Map();
          if (j != null)
            if (j.type === "Feature") z.set(Jr(j, B), j);
            else for (const L of j.features) z.set(Jr(L, B), L);
          return z;
        }
        class To extends li {
          constructor() {
            (super(...arguments), (this._dataUpdateable = new Map()));
          }
          loadVectorTile(B, z) {
            return E._(this, void 0, void 0, function* () {
              const L = B.tileID.canonical;
              if (!this._geoJSONIndex)
                throw new Error(
                  "Unable to parse the data into a cluster or geojson",
                );
              const q = this._geoJSONIndex.getTile(L.z, L.x, L.y);
              if (!q) return null;
              const te = new mr(q.features);
              let ue = Xr(te);
              return (
                (ue.byteOffset === 0 &&
                  ue.byteLength === ue.buffer.byteLength) ||
                  (ue = new Uint8Array(ue)),
                { vectorTile: te, rawData: ue.buffer }
              );
            });
          }
          loadData(B) {
            return E._(this, void 0, void 0, function* () {
              var z;
              (z = this._pendingRequest) === null || z === void 0 || z.abort();
              const L =
                !!(B && B.request && B.request.collectResourceTiming) &&
                new E.cu(B.request);
              this._pendingRequest = new AbortController();
              try {
                ((this._pendingData = this.loadAndProcessGeoJSON(
                  B,
                  this._pendingRequest,
                )),
                  (this._geoJSONIndex = B.cluster
                    ? new qe(
                        (function ({
                          superclusterOptions: ue,
                          clusterProperties: fe,
                        }) {
                          if (!fe || !ue) return ue;
                          const ae = {},
                            ve = {},
                            _e = { accumulated: null, zoom: 0 },
                            ce = { properties: null },
                            oe = Object.keys(fe);
                          for (const ke of oe) {
                            const [Ie, Je] = fe[ke],
                              nt = E.cB(Je),
                              Ce = E.cB(
                                typeof Ie == "string"
                                  ? [Ie, ["accumulated"], ["get", ke]]
                                  : Ie,
                              );
                            ((ae[ke] = nt.value), (ve[ke] = Ce.value));
                          }
                          return (
                            (ue.map = (ke) => {
                              ce.properties = ke;
                              const Ie = {};
                              for (const Je of oe)
                                Ie[Je] = ae[Je].evaluate(_e, ce);
                              return Ie;
                            }),
                            (ue.reduce = (ke, Ie) => {
                              ce.properties = Ie;
                              for (const Je of oe)
                                ((_e.accumulated = ke[Je]),
                                  (ke[Je] = ve[Je].evaluate(_e, ce)));
                            }),
                            ue
                          );
                        })(B),
                      ).load((yield this._pendingData).features)
                    : ((q = yield this._pendingData),
                      new Rr(q, B.geojsonVtOptions))),
                  (this.loaded = {}));
                const te = {};
                if (L) {
                  const ue = L.finish();
                  ue &&
                    ((te.resourceTiming = {}),
                    (te.resourceTiming[B.source] = JSON.parse(
                      JSON.stringify(ue),
                    )));
                }
                return te;
              } catch (te) {
                if ((delete this._pendingRequest, E.cf(te)))
                  return { abandoned: !0 };
                throw te;
              }
              var q;
            });
          }
          getData() {
            return E._(this, void 0, void 0, function* () {
              return this._pendingData;
            });
          }
          reloadTile(B) {
            const z = this.loaded;
            return z && z[B.uid] ? super.reloadTile(B) : this.loadTile(B);
          }
          loadAndProcessGeoJSON(B, z) {
            return E._(this, void 0, void 0, function* () {
              let L = yield this.loadGeoJSON(B, z);
              if ((delete this._pendingRequest, typeof L != "object"))
                throw new Error(
                  `Input data given to '${B.source}' is not a valid GeoJSON object.`,
                );
              if ((Ei(L, !0), B.filter)) {
                const q = E.cB(B.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1,
                });
                if (q.result === "error")
                  throw new Error(
                    q.value.map((ue) => `${ue.key}: ${ue.message}`).join(", "),
                  );
                L = {
                  type: "FeatureCollection",
                  features: L.features.filter((ue) =>
                    q.value.evaluate({ zoom: 0 }, ue),
                  ),
                };
              }
              return L;
            });
          }
          loadGeoJSON(B, z) {
            return E._(this, void 0, void 0, function* () {
              const { promoteId: L } = B;
              if (B.request) {
                const q = yield E.h(B.request, z);
                return (
                  (this._dataUpdateable = Gn(q.data, L)
                    ? qn(q.data, L)
                    : void 0),
                  q.data
                );
              }
              if (typeof B.data == "string")
                try {
                  const q = JSON.parse(B.data);
                  return (
                    (this._dataUpdateable = Gn(q, L) ? qn(q, L) : void 0),
                    q
                  );
                } catch {
                  throw new Error(
                    `Input data given to '${B.source}' is not a valid GeoJSON object.`,
                  );
                }
              if (!B.dataDiff)
                throw new Error(
                  `Input data given to '${B.source}' is not a valid GeoJSON object.`,
                );
              if (!this._dataUpdateable)
                throw new Error(
                  `Cannot update existing geojson data in ${B.source}`,
                );
              return (
                (function (q, te, ue) {
                  var fe, ae, ve, _e;
                  if ((te.removeAll && q.clear(), te.remove))
                    for (const ce of te.remove) q.delete(ce);
                  if (te.add)
                    for (const ce of te.add) {
                      const oe = Jr(ce, ue);
                      oe != null && q.set(oe, ce);
                    }
                  if (te.update)
                    for (const ce of te.update) {
                      let oe = q.get(ce.id);
                      if (oe == null) continue;
                      const ke =
                        !ce.removeAllProperties &&
                        (((fe = ce.removeProperties) === null || fe === void 0
                          ? void 0
                          : fe.length) > 0 ||
                          ((ae = ce.addOrUpdateProperties) === null ||
                          ae === void 0
                            ? void 0
                            : ae.length) > 0);
                      if (
                        ((ce.newGeometry || ce.removeAllProperties || ke) &&
                          ((oe = Object.assign({}, oe)),
                          q.set(ce.id, oe),
                          ke &&
                            (oe.properties = Object.assign({}, oe.properties))),
                        ce.newGeometry && (oe.geometry = ce.newGeometry),
                        ce.removeAllProperties)
                      )
                        oe.properties = {};
                      else if (
                        ((ve = ce.removeProperties) === null || ve === void 0
                          ? void 0
                          : ve.length) > 0
                      )
                        for (const Ie of ce.removeProperties)
                          Object.prototype.hasOwnProperty.call(
                            oe.properties,
                            Ie,
                          ) && delete oe.properties[Ie];
                      if (
                        ((_e = ce.addOrUpdateProperties) === null ||
                        _e === void 0
                          ? void 0
                          : _e.length) > 0
                      )
                        for (const {
                          key: Ie,
                          value: Je,
                        } of ce.addOrUpdateProperties)
                          oe.properties[Ie] = Je;
                    }
                })(this._dataUpdateable, B.dataDiff, L),
                {
                  type: "FeatureCollection",
                  features: Array.from(this._dataUpdateable.values()),
                }
              );
            });
          }
          removeSource(B) {
            return E._(this, void 0, void 0, function* () {
              this._pendingRequest && this._pendingRequest.abort();
            });
          }
          getClusterExpansionZoom(B) {
            return this._geoJSONIndex.getClusterExpansionZoom(B.clusterId);
          }
          getClusterChildren(B) {
            return this._geoJSONIndex.getChildren(B.clusterId);
          }
          getClusterLeaves(B) {
            return this._geoJSONIndex.getLeaves(B.clusterId, B.limit, B.offset);
          }
        }
        class Qr {
          constructor(B) {
            ((this.self = B),
              (this.actor = new E.F(B)),
              (this.layerIndexes = {}),
              (this.availableImages = {}),
              (this.workerSources = {}),
              (this.demWorkerSources = {}),
              (this.externalWorkerSourceTypes = {}),
              (this.self.registerWorkerSource = (z, L) => {
                if (this.externalWorkerSourceTypes[z])
                  throw new Error(
                    `Worker source with name "${z}" already registered.`,
                  );
                this.externalWorkerSourceTypes[z] = L;
              }),
              (this.self.addProtocol = E.ch),
              (this.self.removeProtocol = E.ci),
              (this.self.registerRTLTextPlugin = (z) => {
                E.cC.setMethods(z);
              }),
              this.actor.registerMessageHandler("LDT", (z, L) =>
                this._getDEMWorkerSource(z, L.source).loadTile(L),
              ),
              this.actor.registerMessageHandler("RDT", (z, L) =>
                E._(this, void 0, void 0, function* () {
                  this._getDEMWorkerSource(z, L.source).removeTile(L);
                }),
              ),
              this.actor.registerMessageHandler("GCEZ", (z, L) =>
                E._(this, void 0, void 0, function* () {
                  return this._getWorkerSource(
                    z,
                    L.type,
                    L.source,
                  ).getClusterExpansionZoom(L);
                }),
              ),
              this.actor.registerMessageHandler("GCC", (z, L) =>
                E._(this, void 0, void 0, function* () {
                  return this._getWorkerSource(
                    z,
                    L.type,
                    L.source,
                  ).getClusterChildren(L);
                }),
              ),
              this.actor.registerMessageHandler("GCL", (z, L) =>
                E._(this, void 0, void 0, function* () {
                  return this._getWorkerSource(
                    z,
                    L.type,
                    L.source,
                  ).getClusterLeaves(L);
                }),
              ),
              this.actor.registerMessageHandler("LD", (z, L) =>
                this._getWorkerSource(z, L.type, L.source).loadData(L),
              ),
              this.actor.registerMessageHandler("GD", (z, L) =>
                this._getWorkerSource(z, L.type, L.source).getData(),
              ),
              this.actor.registerMessageHandler("LT", (z, L) =>
                this._getWorkerSource(z, L.type, L.source).loadTile(L),
              ),
              this.actor.registerMessageHandler("RT", (z, L) =>
                this._getWorkerSource(z, L.type, L.source).reloadTile(L),
              ),
              this.actor.registerMessageHandler("AT", (z, L) =>
                this._getWorkerSource(z, L.type, L.source).abortTile(L),
              ),
              this.actor.registerMessageHandler("RMT", (z, L) =>
                this._getWorkerSource(z, L.type, L.source).removeTile(L),
              ),
              this.actor.registerMessageHandler("RS", (z, L) =>
                E._(this, void 0, void 0, function* () {
                  if (
                    !this.workerSources[z] ||
                    !this.workerSources[z][L.type] ||
                    !this.workerSources[z][L.type][L.source]
                  )
                    return;
                  const q = this.workerSources[z][L.type][L.source];
                  (delete this.workerSources[z][L.type][L.source],
                    q.removeSource !== void 0 && q.removeSource(L));
                }),
              ),
              this.actor.registerMessageHandler("RM", (z) =>
                E._(this, void 0, void 0, function* () {
                  (delete this.layerIndexes[z],
                    delete this.availableImages[z],
                    delete this.workerSources[z],
                    delete this.demWorkerSources[z]);
                }),
              ),
              this.actor.registerMessageHandler("SR", (z, L) =>
                E._(this, void 0, void 0, function* () {
                  this.referrer = L;
                }),
              ),
              this.actor.registerMessageHandler("SRPS", (z, L) =>
                this._syncRTLPluginState(z, L),
              ),
              this.actor.registerMessageHandler("IS", (z, L) =>
                E._(this, void 0, void 0, function* () {
                  this.self.importScripts(L);
                }),
              ),
              this.actor.registerMessageHandler("SI", (z, L) =>
                this._setImages(z, L),
              ),
              this.actor.registerMessageHandler("UL", (z, L) =>
                E._(this, void 0, void 0, function* () {
                  this._getLayerIndex(z).update(L.layers, L.removedIds);
                }),
              ),
              this.actor.registerMessageHandler("SL", (z, L) =>
                E._(this, void 0, void 0, function* () {
                  this._getLayerIndex(z).replace(L);
                }),
              ));
          }
          _setImages(B, z) {
            return E._(this, void 0, void 0, function* () {
              this.availableImages[B] = z;
              for (const L in this.workerSources[B]) {
                const q = this.workerSources[B][L];
                for (const te in q) q[te].availableImages = z;
              }
            });
          }
          _syncRTLPluginState(B, z) {
            return E._(this, void 0, void 0, function* () {
              return yield E.cC.syncState(z, this.self.importScripts);
            });
          }
          _getAvailableImages(B) {
            let z = this.availableImages[B];
            return (z || (z = []), z);
          }
          _getLayerIndex(B) {
            let z = this.layerIndexes[B];
            return (z || (z = this.layerIndexes[B] = new u()), z);
          }
          _getWorkerSource(B, z, L) {
            if (
              (this.workerSources[B] || (this.workerSources[B] = {}),
              this.workerSources[B][z] || (this.workerSources[B][z] = {}),
              !this.workerSources[B][z][L])
            ) {
              const q = {
                sendAsync: (te, ue) => (
                  (te.targetMapId = B),
                  this.actor.sendAsync(te, ue)
                ),
              };
              switch (z) {
                case "vector":
                  this.workerSources[B][z][L] = new li(
                    q,
                    this._getLayerIndex(B),
                    this._getAvailableImages(B),
                  );
                  break;
                case "geojson":
                  this.workerSources[B][z][L] = new To(
                    q,
                    this._getLayerIndex(B),
                    this._getAvailableImages(B),
                  );
                  break;
                default:
                  this.workerSources[B][z][L] =
                    new this.externalWorkerSourceTypes[z](
                      q,
                      this._getLayerIndex(B),
                      this._getAvailableImages(B),
                    );
              }
            }
            return this.workerSources[B][z][L];
          }
          _getDEMWorkerSource(B, z) {
            return (
              this.demWorkerSources[B] || (this.demWorkerSources[B] = {}),
              this.demWorkerSources[B][z] ||
                (this.demWorkerSources[B][z] = new Qe()),
              this.demWorkerSources[B][z]
            );
          }
        }
        return (E.i(self) && (self.worker = new Qr(self)), Qr);
      }),
      U("index", ["exports", "./shared"], function (E, u) {
        var Ue = "5.0.0";
        function rt() {
          var c = new u.A(4);
          return (
            u.A != Float32Array && ((c[1] = 0), (c[2] = 0)),
            (c[0] = 1),
            (c[3] = 1),
            c
          );
        }
        let _t, li;
        const Qe = {
          now:
            typeof performance < "u" && performance && performance.now
              ? performance.now.bind(performance)
              : Date.now.bind(Date),
          frameAsync: (c) =>
            new Promise((e, i) => {
              const s = requestAnimationFrame(e);
              c.signal.addEventListener("abort", () => {
                (cancelAnimationFrame(s), i(u.c()));
              });
            }),
          getImageData(c, e = 0) {
            return this.getImageCanvasContext(c).getImageData(
              -e,
              -e,
              c.width + 2 * e,
              c.height + 2 * e,
            );
          },
          getImageCanvasContext(c) {
            const e = window.document.createElement("canvas"),
              i = e.getContext("2d", { willReadFrequently: !0 });
            if (!i) throw new Error("failed to create canvas 2d context");
            return (
              (e.width = c.width),
              (e.height = c.height),
              i.drawImage(c, 0, 0, c.width, c.height),
              i
            );
          },
          resolveURL: (c) => (
            _t || (_t = document.createElement("a")),
            (_t.href = c),
            _t.href
          ),
          hardwareConcurrency:
            (typeof navigator < "u" && navigator.hardwareConcurrency) || 4,
          get prefersReducedMotion() {
            return (
              !!matchMedia &&
              (li == null &&
                (li = matchMedia("(prefers-reduced-motion: reduce)")),
              li.matches)
            );
          },
        };
        class me {
          static testProp(e) {
            if (!me.docStyle) return e[0];
            for (let i = 0; i < e.length; i++)
              if (e[i] in me.docStyle) return e[i];
            return e[0];
          }
          static create(e, i, s) {
            const a = window.document.createElement(e);
            return (
              i !== void 0 && (a.className = i),
              s && s.appendChild(a),
              a
            );
          }
          static createNS(e, i) {
            return window.document.createElementNS(e, i);
          }
          static disableDrag() {
            me.docStyle &&
              me.selectProp &&
              ((me.userSelect = me.docStyle[me.selectProp]),
              (me.docStyle[me.selectProp] = "none"));
          }
          static enableDrag() {
            me.docStyle &&
              me.selectProp &&
              (me.docStyle[me.selectProp] = me.userSelect);
          }
          static setTransform(e, i) {
            e.style[me.transformProp] = i;
          }
          static addEventListener(e, i, s, a = {}) {
            e.addEventListener(i, s, "passive" in a ? a : a.capture);
          }
          static removeEventListener(e, i, s, a = {}) {
            e.removeEventListener(i, s, "passive" in a ? a : a.capture);
          }
          static suppressClickInternal(e) {
            (e.preventDefault(),
              e.stopPropagation(),
              window.removeEventListener(
                "click",
                me.suppressClickInternal,
                !0,
              ));
          }
          static suppressClick() {
            (window.addEventListener("click", me.suppressClickInternal, !0),
              window.setTimeout(() => {
                window.removeEventListener(
                  "click",
                  me.suppressClickInternal,
                  !0,
                );
              }, 0));
          }
          static getScale(e) {
            const i = e.getBoundingClientRect();
            return {
              x: i.width / e.offsetWidth || 1,
              y: i.height / e.offsetHeight || 1,
              boundingClientRect: i,
            };
          }
          static getPoint(e, i, s) {
            const a = i.boundingClientRect;
            return new u.P(
              (s.clientX - a.left) / i.x - e.clientLeft,
              (s.clientY - a.top) / i.y - e.clientTop,
            );
          }
          static mousePos(e, i) {
            const s = me.getScale(e);
            return me.getPoint(e, s, i);
          }
          static touchPos(e, i) {
            const s = [],
              a = me.getScale(e);
            for (let h = 0; h < i.length; h++) s.push(me.getPoint(e, a, i[h]));
            return s;
          }
          static mouseButton(e) {
            return e.button;
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e);
          }
          static sanitize(e) {
            const i =
                new DOMParser().parseFromString(e, "text/html").body ||
                document.createElement("body"),
              s = i.querySelectorAll("script");
            for (const a of s) a.remove();
            return (me.clean(i), i.innerHTML);
          }
          static isPossiblyDangerous(e, i) {
            const s = i.replace(/\s+/g, "").toLowerCase();
            return (
              !(
                !["src", "href", "xlink:href"].includes(e) ||
                (!s.includes("javascript:") && !s.includes("data:"))
              ) ||
              !!e.startsWith("on") ||
              void 0
            );
          }
          static clean(e) {
            const i = e.children;
            for (const s of i) (me.removeAttributes(s), me.clean(s));
          }
          static removeAttributes(e) {
            for (const { name: i, value: s } of e.attributes)
              me.isPossiblyDangerous(i, s) && e.removeAttribute(i);
          }
        }
        ((me.docStyle =
          typeof window < "u" &&
          window.document &&
          window.document.documentElement.style),
          (me.selectProp = me.testProp([
            "userSelect",
            "MozUserSelect",
            "WebkitUserSelect",
            "msUserSelect",
          ])),
          (me.transformProp = me.testProp(["transform", "WebkitTransform"])));
        const Ze = {
          supported: !1,
          testSupport: function (c) {
            !Mi && Ei && (Ki ? mr(c) : (Ni = c));
          },
        };
        let Ni,
          Ei,
          Mi = !1,
          Ki = !1;
        function mr(c) {
          const e = c.createTexture();
          c.bindTexture(c.TEXTURE_2D, e);
          try {
            if (
              (c.texImage2D(
                c.TEXTURE_2D,
                0,
                c.RGBA,
                c.RGBA,
                c.UNSIGNED_BYTE,
                Ei,
              ),
              c.isContextLost())
            )
              return;
            Ze.supported = !0;
          } catch {}
          (c.deleteTexture(e), (Mi = !0));
        }
        var ei;
        (typeof document < "u" &&
          ((Ei = document.createElement("img")),
          (Ei.onload = () => {
            (Ni && mr(Ni), (Ni = null), (Ki = !0));
          }),
          (Ei.onerror = () => {
            ((Mi = !0), (Ni = null));
          }),
          (Ei.src =
            "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=")),
          (function (c) {
            let e, i, s, a;
            ((c.resetRequestQueue = () => {
              ((e = []), (i = 0), (s = 0), (a = {}));
            }),
              (c.addThrottleControl = (y) => {
                const v = s++;
                return ((a[v] = y), v);
              }),
              (c.removeThrottleControl = (y) => {
                (delete a[y], f());
              }),
              (c.getImage = (y, v, C = !0) =>
                new Promise((A, T) => {
                  (Ze.supported &&
                    (y.headers || (y.headers = {}),
                    (y.headers.accept = "image/webp,*/*")),
                    u.e(y, { type: "image" }),
                    e.push({
                      abortController: v,
                      requestParameters: y,
                      supportImageRefresh: C,
                      state: "queued",
                      onError: (M) => {
                        T(M);
                      },
                      onSuccess: (M) => {
                        A(M);
                      },
                    }),
                    f());
                })));
            const h = (y) =>
                u._(this, void 0, void 0, function* () {
                  y.state = "running";
                  const {
                      requestParameters: v,
                      supportImageRefresh: C,
                      onError: A,
                      onSuccess: T,
                      abortController: M,
                    } = y,
                    k =
                      C === !1 &&
                      !u.i(self) &&
                      !u.g(v.url) &&
                      (!v.headers ||
                        Object.keys(v.headers).reduce(
                          ($, G) => $ && G === "accept",
                          !0,
                        ));
                  i++;
                  const V = k ? g(v, M) : u.m(v, M);
                  try {
                    const $ = yield V;
                    (delete y.abortController,
                      (y.state = "completed"),
                      $.data instanceof HTMLImageElement || u.b($.data)
                        ? T($)
                        : $.data &&
                          T({
                            data: yield ((N = $.data),
                            typeof createImageBitmap == "function"
                              ? u.d(N)
                              : u.f(N)),
                            cacheControl: $.cacheControl,
                            expires: $.expires,
                          }));
                  } catch ($) {
                    (delete y.abortController, A($));
                  } finally {
                    (i--, f());
                  }
                  var N;
                }),
              f = () => {
                const y = (() => {
                  for (const v of Object.keys(a)) if (a[v]()) return !0;
                  return !1;
                })()
                  ? u.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME
                  : u.a.MAX_PARALLEL_IMAGE_REQUESTS;
                for (let v = i; v < y && e.length > 0; v++) {
                  const C = e.shift();
                  C.abortController.signal.aborted ? v-- : h(C);
                }
              },
              g = (y, v) =>
                new Promise((C, A) => {
                  const T = new Image(),
                    M = y.url,
                    k = y.credentials;
                  (k && k === "include"
                    ? (T.crossOrigin = "use-credentials")
                    : ((k && k === "same-origin") || !u.s(M)) &&
                      (T.crossOrigin = "anonymous"),
                    v.signal.addEventListener("abort", () => {
                      ((T.src = ""), A(u.c()));
                    }),
                    (T.fetchPriority = "high"),
                    (T.onload = () => {
                      ((T.onerror = T.onload = null), C({ data: T }));
                    }),
                    (T.onerror = () => {
                      ((T.onerror = T.onload = null),
                        v.signal.aborted ||
                          A(
                            new Error(
                              "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.",
                            ),
                          ));
                    }),
                    (T.src = M));
                });
          })(ei || (ei = {})),
          ei.resetRequestQueue());
        class Vi {
          constructor(e) {
            this._transformRequestFn = e;
          }
          transformRequest(e, i) {
            return (
              (this._transformRequestFn && this._transformRequestFn(e, i)) || {
                url: e,
              }
            );
          }
          setTransformRequest(e) {
            this._transformRequestFn = e;
          }
        }
        function It(c) {
          const e = [];
          if (typeof c == "string") e.push({ id: "default", url: c });
          else if (c && c.length > 0) {
            const i = [];
            for (const { id: s, url: a } of c) {
              const h = `${s}${a}`;
              i.indexOf(h) === -1 && (i.push(h), e.push({ id: s, url: a }));
            }
          }
          return e;
        }
        function Dt(c, e, i) {
          try {
            const s = new URL(c);
            return ((s.pathname += `${e}${i}`), s.toString());
          } catch {
            throw new Error(
              `Invalid sprite URL "${c}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`,
            );
          }
        }
        class Bt {
          constructor(e, i, s, a) {
            ((this.context = e),
              (this.format = s),
              (this.texture = e.gl.createTexture()),
              this.update(i, a));
          }
          update(e, i, s) {
            const { width: a, height: h } = e,
              f = !(
                (this.size && this.size[0] === a && this.size[1] === h) ||
                s
              ),
              { context: g } = this,
              { gl: y } = g;
            if (
              ((this.useMipmap = Boolean(i && i.useMipmap)),
              y.bindTexture(y.TEXTURE_2D, this.texture),
              g.pixelStoreUnpackFlipY.set(!1),
              g.pixelStoreUnpack.set(1),
              g.pixelStoreUnpackPremultiplyAlpha.set(
                this.format === y.RGBA && (!i || i.premultiply !== !1),
              ),
              f)
            )
              ((this.size = [a, h]),
                e instanceof HTMLImageElement ||
                e instanceof HTMLCanvasElement ||
                e instanceof HTMLVideoElement ||
                e instanceof ImageData ||
                u.b(e)
                  ? y.texImage2D(
                      y.TEXTURE_2D,
                      0,
                      this.format,
                      this.format,
                      y.UNSIGNED_BYTE,
                      e,
                    )
                  : y.texImage2D(
                      y.TEXTURE_2D,
                      0,
                      this.format,
                      a,
                      h,
                      0,
                      this.format,
                      y.UNSIGNED_BYTE,
                      e.data,
                    ));
            else {
              const { x: v, y: C } = s || { x: 0, y: 0 };
              e instanceof HTMLImageElement ||
              e instanceof HTMLCanvasElement ||
              e instanceof HTMLVideoElement ||
              e instanceof ImageData ||
              u.b(e)
                ? y.texSubImage2D(
                    y.TEXTURE_2D,
                    0,
                    v,
                    C,
                    y.RGBA,
                    y.UNSIGNED_BYTE,
                    e,
                  )
                : y.texSubImage2D(
                    y.TEXTURE_2D,
                    0,
                    v,
                    C,
                    a,
                    h,
                    y.RGBA,
                    y.UNSIGNED_BYTE,
                    e.data,
                  );
            }
            this.useMipmap &&
              this.isSizePowerOfTwo() &&
              y.generateMipmap(y.TEXTURE_2D);
          }
          bind(e, i, s) {
            const { context: a } = this,
              { gl: h } = a;
            (h.bindTexture(h.TEXTURE_2D, this.texture),
              s !== h.LINEAR_MIPMAP_NEAREST ||
                this.isSizePowerOfTwo() ||
                (s = h.LINEAR),
              e !== this.filter &&
                (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, e),
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, s || e),
                (this.filter = e)),
              i !== this.wrap &&
                (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, i),
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, i),
                (this.wrap = i)));
          }
          isSizePowerOfTwo() {
            return (
              this.size[0] === this.size[1] &&
              (Math.log(this.size[0]) / Math.LN2) % 1 == 0
            );
          }
          destroy() {
            const { gl: e } = this.context;
            (e.deleteTexture(this.texture), (this.texture = null));
          }
        }
        function Xr(c) {
          const { userImage: e } = c;
          return (
            !!(e && e.render && e.render()) &&
            (c.data.replace(new Uint8Array(e.data.buffer)), !0)
          );
        }
        class dn extends u.E {
          constructor() {
            (super(),
              (this.images = {}),
              (this.updatedImages = {}),
              (this.callbackDispatchedThisFrame = {}),
              (this.loaded = !1),
              (this.requestors = []),
              (this.patterns = {}),
              (this.atlasImage = new u.R({ width: 1, height: 1 })),
              (this.dirty = !0));
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e) {
            if (this.loaded !== e && ((this.loaded = e), e)) {
              for (const { ids: i, promiseResolve: s } of this.requestors)
                s(this._getImagesForIds(i));
              this.requestors = [];
            }
          }
          getImage(e) {
            const i = this.images[e];
            if (i && !i.data && i.spriteData) {
              const s = i.spriteData;
              ((i.data = new u.R(
                { width: s.width, height: s.height },
                s.context.getImageData(s.x, s.y, s.width, s.height).data,
              )),
                (i.spriteData = null));
            }
            return i;
          }
          addImage(e, i) {
            if (this.images[e])
              throw new Error(
                `Image id ${e} already exist, use updateImage instead`,
              );
            this._validate(e, i) && (this.images[e] = i);
          }
          _validate(e, i) {
            let s = !0;
            const a = i.data || i.spriteData;
            return (
              this._validateStretch(i.stretchX, a && a.width) ||
                (this.fire(
                  new u.j(
                    new Error(`Image "${e}" has invalid "stretchX" value`),
                  ),
                ),
                (s = !1)),
              this._validateStretch(i.stretchY, a && a.height) ||
                (this.fire(
                  new u.j(
                    new Error(`Image "${e}" has invalid "stretchY" value`),
                  ),
                ),
                (s = !1)),
              this._validateContent(i.content, i) ||
                (this.fire(
                  new u.j(
                    new Error(`Image "${e}" has invalid "content" value`),
                  ),
                ),
                (s = !1)),
              s
            );
          }
          _validateStretch(e, i) {
            if (!e) return !0;
            let s = 0;
            for (const a of e) {
              if (a[0] < s || a[1] < a[0] || i < a[1]) return !1;
              s = a[1];
            }
            return !0;
          }
          _validateContent(e, i) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const s = i.spriteData,
              a = (s && s.width) || i.data.width,
              h = (s && s.height) || i.data.height;
            return !(
              e[0] < 0 ||
              a < e[0] ||
              e[1] < 0 ||
              h < e[1] ||
              e[2] < 0 ||
              a < e[2] ||
              e[3] < 0 ||
              h < e[3] ||
              e[2] < e[0] ||
              e[3] < e[1]
            );
          }
          updateImage(e, i, s = !0) {
            const a = this.getImage(e);
            if (
              s &&
              (a.data.width !== i.data.width || a.data.height !== i.data.height)
            )
              throw new Error(
                `size mismatch between old image (${a.data.width}x${a.data.height}) and new image (${i.data.width}x${i.data.height}).`,
              );
            ((i.version = a.version + 1),
              (this.images[e] = i),
              (this.updatedImages[e] = !0));
          }
          removeImage(e) {
            const i = this.images[e];
            (delete this.images[e],
              delete this.patterns[e],
              i.userImage && i.userImage.onRemove && i.userImage.onRemove());
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e) {
            return new Promise((i, s) => {
              let a = !0;
              if (!this.isLoaded())
                for (const h of e) this.images[h] || (a = !1);
              this.isLoaded() || a
                ? i(this._getImagesForIds(e))
                : this.requestors.push({ ids: e, promiseResolve: i });
            });
          }
          _getImagesForIds(e) {
            const i = {};
            for (const s of e) {
              let a = this.getImage(s);
              (a ||
                (this.fire(new u.k("styleimagemissing", { id: s })),
                (a = this.getImage(s))),
                a
                  ? (i[s] = {
                      data: a.data.clone(),
                      pixelRatio: a.pixelRatio,
                      sdf: a.sdf,
                      version: a.version,
                      stretchX: a.stretchX,
                      stretchY: a.stretchY,
                      content: a.content,
                      textFitWidth: a.textFitWidth,
                      textFitHeight: a.textFitHeight,
                      hasRenderCallback: Boolean(
                        a.userImage && a.userImage.render,
                      ),
                    })
                  : u.w(
                      `Image "${s}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`,
                    ));
            }
            return i;
          }
          getPixelSize() {
            const { width: e, height: i } = this.atlasImage;
            return { width: e, height: i };
          }
          getPattern(e) {
            const i = this.patterns[e],
              s = this.getImage(e);
            if (!s) return null;
            if (i && i.position.version === s.version) return i.position;
            if (i) i.position.version = s.version;
            else {
              const a = {
                  w: s.data.width + 2,
                  h: s.data.height + 2,
                  x: 0,
                  y: 0,
                },
                h = new u.I(a, s);
              this.patterns[e] = { bin: a, position: h };
            }
            return (this._updatePatternAtlas(), this.patterns[e].position);
          }
          bind(e) {
            const i = e.gl;
            (this.atlasTexture
              ? this.dirty &&
                (this.atlasTexture.update(this.atlasImage), (this.dirty = !1))
              : (this.atlasTexture = new Bt(e, this.atlasImage, i.RGBA)),
              this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
          }
          _updatePatternAtlas() {
            const e = [];
            for (const h in this.patterns) e.push(this.patterns[h].bin);
            const { w: i, h: s } = u.p(e),
              a = this.atlasImage;
            a.resize({ width: i || 1, height: s || 1 });
            for (const h in this.patterns) {
              const { bin: f } = this.patterns[h],
                g = f.x + 1,
                y = f.y + 1,
                v = this.getImage(h).data,
                C = v.width,
                A = v.height;
              (u.R.copy(
                v,
                a,
                { x: 0, y: 0 },
                { x: g, y },
                { width: C, height: A },
              ),
                u.R.copy(
                  v,
                  a,
                  { x: 0, y: A - 1 },
                  { x: g, y: y - 1 },
                  { width: C, height: 1 },
                ),
                u.R.copy(
                  v,
                  a,
                  { x: 0, y: 0 },
                  { x: g, y: y + A },
                  { width: C, height: 1 },
                ),
                u.R.copy(
                  v,
                  a,
                  { x: C - 1, y: 0 },
                  { x: g - 1, y },
                  { width: 1, height: A },
                ),
                u.R.copy(
                  v,
                  a,
                  { x: 0, y: 0 },
                  { x: g + C, y },
                  { width: 1, height: A },
                ));
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e) {
            for (const i of e) {
              if (this.callbackDispatchedThisFrame[i]) continue;
              this.callbackDispatchedThisFrame[i] = !0;
              const s = this.getImage(i);
              (s || u.w(`Image with ID: "${i}" was not found`),
                Xr(s) && this.updateImage(i, s));
            }
          }
        }
        const or = 1e20;
        function sr(c, e, i, s, a, h, f, g, y) {
          for (let v = e; v < e + s; v++) Ae(c, i * h + v, h, a, f, g, y);
          for (let v = i; v < i + a; v++) Ae(c, v * h + e, 1, s, f, g, y);
        }
        function Ae(c, e, i, s, a, h, f) {
          ((h[0] = 0), (f[0] = -or), (f[1] = or), (a[0] = c[e]));
          for (let g = 1, y = 0, v = 0; g < s; g++) {
            a[g] = c[e + g * i];
            const C = g * g;
            do {
              const A = h[y];
              v = (a[g] - a[A] + C - A * A) / (g - A) / 2;
            } while (v <= f[y] && --y > -1);
            (y++, (h[y] = g), (f[y] = v), (f[y + 1] = or));
          }
          for (let g = 0, y = 0; g < s; g++) {
            for (; f[y + 1] < g; ) y++;
            const v = h[y],
              C = g - v;
            c[e + g * i] = a[v] + C * C;
          }
        }
        class Oe {
          constructor(e, i) {
            ((this.requestManager = e),
              (this.localIdeographFontFamily = i),
              (this.entries = {}));
          }
          setURL(e) {
            this.url = e;
          }
          getGlyphs(e) {
            return u._(this, void 0, void 0, function* () {
              const i = [];
              for (const h in e)
                for (const f of e[h])
                  i.push(this._getAndCacheGlyphsPromise(h, f));
              const s = yield Promise.all(i),
                a = {};
              for (const { stack: h, id: f, glyph: g } of s)
                (a[h] || (a[h] = {}),
                  (a[h][f] = g && {
                    id: g.id,
                    bitmap: g.bitmap.clone(),
                    metrics: g.metrics,
                  }));
              return a;
            });
          }
          _getAndCacheGlyphsPromise(e, i) {
            return u._(this, void 0, void 0, function* () {
              let s = this.entries[e];
              s ||
                (s = this.entries[e] =
                  { glyphs: {}, requests: {}, ranges: {} });
              let a = s.glyphs[i];
              if (a !== void 0) return { stack: e, id: i, glyph: a };
              if (((a = this._tinySDF(s, e, i)), a))
                return ((s.glyphs[i] = a), { stack: e, id: i, glyph: a });
              const h = Math.floor(i / 256);
              if (256 * h > 65535)
                throw new Error("glyphs > 65535 not supported");
              if (s.ranges[h]) return { stack: e, id: i, glyph: a };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!s.requests[h]) {
                const g = Oe.loadGlyphRange(
                  e,
                  h,
                  this.url,
                  this.requestManager,
                );
                s.requests[h] = g;
              }
              const f = yield s.requests[h];
              for (const g in f)
                this._doesCharSupportLocalGlyph(+g) || (s.glyphs[+g] = f[+g]);
              return (
                (s.ranges[h] = !0),
                { stack: e, id: i, glyph: f[i] || null }
              );
            });
          }
          _doesCharSupportLocalGlyph(e) {
            return (
              !!this.localIdeographFontFamily &&
              /\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(
                String.fromCodePoint(e),
              )
            );
          }
          _tinySDF(e, i, s) {
            const a = this.localIdeographFontFamily;
            if (!a || !this._doesCharSupportLocalGlyph(s)) return;
            let h = e.tinySDF;
            if (!h) {
              let g = "400";
              (/bold/i.test(i)
                ? (g = "900")
                : /medium/i.test(i)
                  ? (g = "500")
                  : /light/i.test(i) && (g = "200"),
                (h = e.tinySDF =
                  new Oe.TinySDF({
                    fontSize: 48,
                    buffer: 6,
                    radius: 16,
                    cutoff: 0.25,
                    fontFamily: a,
                    fontWeight: g,
                  })));
            }
            const f = h.draw(String.fromCharCode(s));
            return {
              id: s,
              bitmap: new u.o(
                { width: f.width || 60, height: f.height || 60 },
                f.data,
              ),
              metrics: {
                width: f.glyphWidth / 2 || 24,
                height: f.glyphHeight / 2 || 24,
                left: f.glyphLeft / 2 + 0.5 || 0,
                top: f.glyphTop / 2 - 27.5 || -8,
                advance: f.glyphAdvance / 2 || 24,
                isDoubleResolution: !0,
              },
            };
          }
        }
        ((Oe.loadGlyphRange = function (c, e, i, s) {
          return u._(this, void 0, void 0, function* () {
            const a = 256 * e,
              h = a + 255,
              f = s.transformRequest(
                i.replace("{fontstack}", c).replace("{range}", `${a}-${h}`),
                "Glyphs",
              ),
              g = yield u.l(f, new AbortController());
            if (!g || !g.data)
              throw new Error(
                `Could not load glyph range. range: ${e}, ${a}-${h}`,
              );
            const y = {};
            for (const v of u.n(g.data)) y[v.id] = v;
            return y;
          });
        }),
          (Oe.TinySDF = class {
            constructor({
              fontSize: c = 24,
              buffer: e = 3,
              radius: i = 8,
              cutoff: s = 0.25,
              fontFamily: a = "sans-serif",
              fontWeight: h = "normal",
              fontStyle: f = "normal",
            } = {}) {
              ((this.buffer = e), (this.cutoff = s), (this.radius = i));
              const g = (this.size = c + 4 * e),
                y = this._createCanvas(g),
                v = (this.ctx = y.getContext("2d", { willReadFrequently: !0 }));
              ((v.font = `${f} ${h} ${c}px ${a}`),
                (v.textBaseline = "alphabetic"),
                (v.textAlign = "left"),
                (v.fillStyle = "black"),
                (this.gridOuter = new Float64Array(g * g)),
                (this.gridInner = new Float64Array(g * g)),
                (this.f = new Float64Array(g)),
                (this.z = new Float64Array(g + 1)),
                (this.v = new Uint16Array(g)));
            }
            _createCanvas(c) {
              const e = document.createElement("canvas");
              return ((e.width = e.height = c), e);
            }
            draw(c) {
              const {
                  width: e,
                  actualBoundingBoxAscent: i,
                  actualBoundingBoxDescent: s,
                  actualBoundingBoxLeft: a,
                  actualBoundingBoxRight: h,
                } = this.ctx.measureText(c),
                f = Math.ceil(i),
                g = Math.max(
                  0,
                  Math.min(this.size - this.buffer, Math.ceil(h - a)),
                ),
                y = Math.min(this.size - this.buffer, f + Math.ceil(s)),
                v = g + 2 * this.buffer,
                C = y + 2 * this.buffer,
                A = Math.max(v * C, 0),
                T = new Uint8ClampedArray(A),
                M = {
                  data: T,
                  width: v,
                  height: C,
                  glyphWidth: g,
                  glyphHeight: y,
                  glyphTop: f,
                  glyphLeft: 0,
                  glyphAdvance: e,
                };
              if (g === 0 || y === 0) return M;
              const { ctx: k, buffer: V, gridInner: N, gridOuter: $ } = this;
              (k.clearRect(V, V, g, y), k.fillText(c, V, V + f));
              const G = k.getImageData(V, V, g, y);
              ($.fill(or, 0, A), N.fill(0, 0, A));
              for (let Y = 0; Y < y; Y++)
                for (let Q = 0; Q < g; Q++) {
                  const ee = G.data[4 * (Y * g + Q) + 3] / 255;
                  if (ee === 0) continue;
                  const re = (Y + V) * v + Q + V;
                  if (ee === 1) (($[re] = 0), (N[re] = or));
                  else {
                    const ie = 0.5 - ee;
                    (($[re] = ie > 0 ? ie * ie : 0),
                      (N[re] = ie < 0 ? ie * ie : 0));
                  }
                }
              (sr($, 0, 0, v, C, v, this.f, this.v, this.z),
                sr(N, V, V, g, y, v, this.f, this.v, this.z));
              for (let Y = 0; Y < A; Y++) {
                const Q = Math.sqrt($[Y]) - Math.sqrt(N[Y]);
                T[Y] = Math.round(255 - 255 * (Q / this.radius + this.cutoff));
              }
              return M;
            }
          }));
        class $e {
          constructor() {
            this.specification = u.v.light.position;
          }
          possiblyEvaluate(e, i) {
            return u.x(e.expression.evaluate(i));
          }
          interpolate(e, i, s) {
            return {
              x: u.y.number(e.x, i.x, s),
              y: u.y.number(e.y, i.y, s),
              z: u.y.number(e.z, i.z, s),
            };
          }
        }
        let qe;
        class pt extends u.E {
          constructor(e) {
            (super(),
              (qe =
                qe ||
                new u.q({
                  anchor: new u.D(u.v.light.anchor),
                  position: new $e(),
                  color: new u.D(u.v.light.color),
                  intensity: new u.D(u.v.light.intensity),
                })),
              (this._transitionable = new u.T(qe)),
              this.setLight(e),
              (this._transitioning = this._transitionable.untransitioned()));
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e, i = {}) {
            if (!this._validate(u.r, e, i))
              for (const s in e) {
                const a = e[s];
                s.endsWith("-transition")
                  ? this._transitionable.setTransition(s.slice(0, -11), a)
                  : this._transitionable.setValue(s, a);
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(
              e,
              this._transitioning,
            );
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, i, s) {
            return (
              (!s || s.validate !== !1) &&
              u.t(
                this,
                e.call(u.u, {
                  value: i,
                  style: { glyphs: !0, sprite: !0 },
                  styleSpec: u.v,
                }),
              )
            );
          }
        }
        const tt = new u.q({
          "sky-color": new u.D(u.v.sky["sky-color"]),
          "horizon-color": new u.D(u.v.sky["horizon-color"]),
          "fog-color": new u.D(u.v.sky["fog-color"]),
          "fog-ground-blend": new u.D(u.v.sky["fog-ground-blend"]),
          "horizon-fog-blend": new u.D(u.v.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new u.D(u.v.sky["sky-horizon-blend"]),
          "atmosphere-blend": new u.D(u.v.sky["atmosphere-blend"]),
        });
        class Et extends u.E {
          constructor(e) {
            (super(),
              (this._transitionable = new u.T(tt)),
              this.setSky(e),
              (this._transitioning = this._transitionable.untransitioned()),
              this.recalculate(new u.z(0)));
          }
          setSky(e, i = {}) {
            if (!this._validate(u.B, e, i)) {
              e ||
                (e = {
                  "sky-color": "transparent",
                  "horizon-color": "transparent",
                  "fog-color": "transparent",
                  "fog-ground-blend": 1,
                  "atmosphere-blend": 0,
                });
              for (const s in e) {
                const a = e[s];
                s.endsWith("-transition")
                  ? this._transitionable.setTransition(s.slice(0, -11), a)
                  : this._transitionable.setValue(s, a);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(
              e,
              this._transitioning,
            );
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, i, s = {}) {
            return (
              (s == null ? void 0 : s.validate) !== !1 &&
              u.t(
                this,
                e.call(
                  u.u,
                  u.e({
                    value: i,
                    style: { glyphs: !0, sprite: !0 },
                    styleSpec: u.v,
                  }),
                ),
              )
            );
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
          }
        }
        class $t {
          constructor(e, i) {
            ((this.width = e),
              (this.height = i),
              (this.nextRow = 0),
              (this.data = new Uint8Array(this.width * this.height)),
              (this.dashEntry = {}));
          }
          getDash(e, i) {
            const s = e.join(",") + String(i);
            return (
              this.dashEntry[s] || (this.dashEntry[s] = this.addDash(e, i)),
              this.dashEntry[s]
            );
          }
          getDashRanges(e, i, s) {
            const a = [];
            let h = e.length % 2 == 1 ? -e[e.length - 1] * s : 0,
              f = e[0] * s,
              g = !0;
            a.push({ left: h, right: f, isDash: g, zeroLength: e[0] === 0 });
            let y = e[0];
            for (let v = 1; v < e.length; v++) {
              g = !g;
              const C = e[v];
              ((h = y * s),
                (y += C),
                (f = y * s),
                a.push({ left: h, right: f, isDash: g, zeroLength: C === 0 }));
            }
            return a;
          }
          addRoundDash(e, i, s) {
            const a = i / 2;
            for (let h = -s; h <= s; h++) {
              const f = this.width * (this.nextRow + s + h);
              let g = 0,
                y = e[g];
              for (let v = 0; v < this.width; v++) {
                v / y.right > 1 && (y = e[++g]);
                const C = Math.abs(v - y.left),
                  A = Math.abs(v - y.right),
                  T = Math.min(C, A);
                let M;
                const k = (h / s) * (a + 1);
                if (y.isDash) {
                  const V = a - Math.abs(k);
                  M = Math.sqrt(T * T + V * V);
                } else M = a - Math.sqrt(T * T + k * k);
                this.data[f + v] = Math.max(0, Math.min(255, M + 128));
              }
            }
          }
          addRegularDash(e) {
            for (let g = e.length - 1; g >= 0; --g) {
              const y = e[g],
                v = e[g + 1];
              y.zeroLength
                ? e.splice(g, 1)
                : v &&
                  v.isDash === y.isDash &&
                  ((v.left = y.left), e.splice(g, 1));
            }
            const i = e[0],
              s = e[e.length - 1];
            i.isDash === s.isDash &&
              ((i.left = s.left - this.width),
              (s.right = i.right + this.width));
            const a = this.width * this.nextRow;
            let h = 0,
              f = e[h];
            for (let g = 0; g < this.width; g++) {
              g / f.right > 1 && (f = e[++h]);
              const y = Math.abs(g - f.left),
                v = Math.abs(g - f.right),
                C = Math.min(y, v);
              this.data[a + g] = Math.max(
                0,
                Math.min(255, (f.isDash ? C : -C) + 128),
              );
            }
          }
          addDash(e, i) {
            const s = i ? 7 : 0,
              a = 2 * s + 1;
            if (this.nextRow + a > this.height)
              return (u.w("LineAtlas out of space"), null);
            let h = 0;
            for (let g = 0; g < e.length; g++) h += e[g];
            if (h !== 0) {
              const g = this.width / h,
                y = this.getDashRanges(e, this.width, g);
              i ? this.addRoundDash(y, g, s) : this.addRegularDash(y);
            }
            const f = {
              y: (this.nextRow + s + 0.5) / this.height,
              height: (2 * s) / this.height,
              width: h,
            };
            return ((this.nextRow += a), (this.dirty = !0), f);
          }
          bind(e) {
            const i = e.gl;
            this.texture
              ? (i.bindTexture(i.TEXTURE_2D, this.texture),
                this.dirty &&
                  ((this.dirty = !1),
                  i.texSubImage2D(
                    i.TEXTURE_2D,
                    0,
                    0,
                    0,
                    this.width,
                    this.height,
                    i.ALPHA,
                    i.UNSIGNED_BYTE,
                    this.data,
                  )))
              : ((this.texture = i.createTexture()),
                i.bindTexture(i.TEXTURE_2D, this.texture),
                i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT),
                i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT),
                i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR),
                i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR),
                i.texImage2D(
                  i.TEXTURE_2D,
                  0,
                  i.ALPHA,
                  this.width,
                  this.height,
                  0,
                  i.ALPHA,
                  i.UNSIGNED_BYTE,
                  this.data,
                ));
          }
        }
        const _i = "maplibre_preloaded_worker_pool";
        class Ii {
          constructor() {
            this.active = {};
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < Ii.workerCount; )
                this.workers.push(new Worker(u.a.WORKER_URL));
            return ((this.active[e] = !0), this.workers.slice());
          }
          release(e) {
            (delete this.active[e],
              this.numActive() === 0 &&
                (this.workers.forEach((i) => {
                  i.terminate();
                }),
                (this.workers = null)));
          }
          isPreloaded() {
            return !!this.active[_i];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const Bi = Math.floor(Qe.hardwareConcurrency / 2);
        let ar, yi;
        function pn() {
          return (ar || (ar = new Ii()), ar);
        }
        Ii.workerCount = u.C(globalThis) ? Math.max(Math.min(Bi, 3), 1) : 1;
        class fn {
          constructor(e, i) {
            ((this.workerPool = e),
              (this.actors = []),
              (this.currentActor = 0),
              (this.id = i));
            const s = this.workerPool.acquire(i);
            for (let a = 0; a < s.length; a++) {
              const h = new u.F(s[a], i);
              ((h.name = `Worker ${a}`), this.actors.push(h));
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e, i) {
            const s = [];
            for (const a of this.actors)
              s.push(a.sendAsync({ type: e, data: i }));
            return Promise.all(s);
          }
          getActor() {
            return (
              (this.currentActor =
                (this.currentActor + 1) % this.actors.length),
              this.actors[this.currentActor]
            );
          }
          remove(e = !0) {
            (this.actors.forEach((i) => {
              i.remove();
            }),
              (this.actors = []),
              e && this.workerPool.release(this.id));
          }
          registerMessageHandler(e, i) {
            for (const s of this.actors) s.registerMessageHandler(e, i);
          }
        }
        function mn() {
          return (
            yi ||
              ((yi = new fn(pn(), u.G)),
              yi.registerMessageHandler("GR", (c, e, i) => u.m(e, i))),
            yi
          );
        }
        function Yi(c, e) {
          const i = u.H();
          return (
            u.J(i, i, [1, 1, 0]),
            u.K(i, i, [0.5 * c.width, 0.5 * c.height, 1]),
            c.calculatePosMatrix
              ? u.L(i, i, c.calculatePosMatrix(e.toUnwrapped()))
              : i
          );
        }
        function Eo(c, e, i, s, a, h) {
          var f;
          const g = (function (A, T, M) {
              if (A)
                for (const k of A) {
                  const V = T[k];
                  if (V && V.source === M && V.type === "fill-extrusion")
                    return !0;
                }
              else
                for (const k in T) {
                  const V = T[k];
                  if (V.source === M && V.type === "fill-extrusion") return !0;
                }
              return !1;
            })(
              (f = a == null ? void 0 : a.layers) !== null && f !== void 0
                ? f
                : null,
              e,
              c.id,
            ),
            y = h.maxPitchScaleFactor(),
            v = c.tilesIn(s, y, g);
          v.sort(Ai);
          const C = [];
          for (const A of v)
            C.push({
              wrappedTileID: A.tileID.wrapped().key,
              queryResults: A.tile.queryRenderedFeatures(
                e,
                i,
                c._state,
                A.queryGeometry,
                A.cameraQueryGeometry,
                A.scale,
                a,
                h,
                y,
                Yi(c.transform, A.tileID),
              ),
            });
          return (function (A, T) {
            for (const M in A) for (const k of A[M]) ui(k, T);
            return A;
          })(
            (function (A) {
              const T = {},
                M = {};
              for (const k of A) {
                const V = k.queryResults,
                  N = k.wrappedTileID,
                  $ = (M[N] = M[N] || {});
                for (const G in V) {
                  const Y = V[G],
                    Q = ($[G] = $[G] || {}),
                    ee = (T[G] = T[G] || []);
                  for (const re of Y)
                    Q[re.featureIndex] ||
                      ((Q[re.featureIndex] = !0), ee.push(re));
                }
              }
              return T;
            })(C),
            c,
          );
        }
        function Ai(c, e) {
          const i = c.tileID,
            s = e.tileID;
          return (
            i.overscaledZ - s.overscaledZ ||
            i.canonical.y - s.canonical.y ||
            i.wrap - s.wrap ||
            i.canonical.x - s.canonical.x
          );
        }
        function ui(c, e) {
          const i = c.feature,
            s = e.getFeatureState(i.layer["source-layer"], i.id);
          ((i.source = i.layer.source),
            i.layer["source-layer"] &&
              (i.sourceLayer = i.layer["source-layer"]),
            (i.state = s));
        }
        function zr(c, e, i) {
          return u._(this, void 0, void 0, function* () {
            let s = c;
            if (
              (c.url
                ? (s = (yield u.h(e.transformRequest(c.url, "Source"), i)).data)
                : yield Qe.frameAsync(i),
              !s)
            )
              return null;
            const a = u.M(u.e(s, c), [
              "tiles",
              "minzoom",
              "maxzoom",
              "attribution",
              "bounds",
              "scheme",
              "tileSize",
              "encoding",
            ]);
            return (
              "vector_layers" in s &&
                s.vector_layers &&
                (a.vectorLayerIds = s.vector_layers.map((h) => h.id)),
              a
            );
          });
        }
        class ti {
          constructor(e, i) {
            e &&
              (i
                ? this.setSouthWest(e).setNorthEast(i)
                : Array.isArray(e) &&
                  (e.length === 4
                    ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]])
                    : this.setSouthWest(e[0]).setNorthEast(e[1])));
          }
          setNorthEast(e) {
            return (
              (this._ne =
                e instanceof u.N ? new u.N(e.lng, e.lat) : u.N.convert(e)),
              this
            );
          }
          setSouthWest(e) {
            return (
              (this._sw =
                e instanceof u.N ? new u.N(e.lng, e.lat) : u.N.convert(e)),
              this
            );
          }
          extend(e) {
            const i = this._sw,
              s = this._ne;
            let a, h;
            if (e instanceof u.N) ((a = e), (h = e));
            else {
              if (!(e instanceof ti))
                return Array.isArray(e)
                  ? e.length === 4 || e.every(Array.isArray)
                    ? this.extend(ti.convert(e))
                    : this.extend(u.N.convert(e))
                  : e && ("lng" in e || "lon" in e) && "lat" in e
                    ? this.extend(u.N.convert(e))
                    : this;
              if (((a = e._sw), (h = e._ne), !a || !h)) return this;
            }
            return (
              i || s
                ? ((i.lng = Math.min(a.lng, i.lng)),
                  (i.lat = Math.min(a.lat, i.lat)),
                  (s.lng = Math.max(h.lng, s.lng)),
                  (s.lat = Math.max(h.lat, s.lat)))
                : ((this._sw = new u.N(a.lng, a.lat)),
                  (this._ne = new u.N(h.lng, h.lat))),
              this
            );
          }
          getCenter() {
            return new u.N(
              (this._sw.lng + this._ne.lng) / 2,
              (this._sw.lat + this._ne.lat) / 2,
            );
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new u.N(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new u.N(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: i, lat: s } = u.N.convert(e);
            let a = this._sw.lng <= i && i <= this._ne.lng;
            return (
              this._sw.lng > this._ne.lng &&
                (a = this._sw.lng >= i && i >= this._ne.lng),
              this._sw.lat <= s && s <= this._ne.lat && a
            );
          }
          static convert(e) {
            return e instanceof ti ? e : e && new ti(e);
          }
          static fromLngLat(e, i = 0) {
            const s = (360 * i) / 40075017,
              a = s / Math.cos((Math.PI / 180) * e.lat);
            return new ti(
              new u.N(e.lng - a, e.lat - s),
              new u.N(e.lng + a, e.lat + s),
            );
          }
          adjustAntiMeridian() {
            const e = new u.N(this._sw.lng, this._sw.lat),
              i = new u.N(this._ne.lng, this._ne.lat);
            return new ti(e, e.lng > i.lng ? new u.N(i.lng + 360, i.lat) : i);
          }
        }
        class gn {
          constructor(e, i, s) {
            ((this.bounds = ti.convert(this.validateBounds(e))),
              (this.minzoom = i || 0),
              (this.maxzoom = s || 24));
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4
              ? [
                  Math.max(-180, e[0]),
                  Math.max(-90, e[1]),
                  Math.min(180, e[2]),
                  Math.min(90, e[3]),
                ]
              : [-180, -90, 180, 90];
          }
          contains(e) {
            const i = Math.pow(2, e.z),
              s = Math.floor(u.O(this.bounds.getWest()) * i),
              a = Math.floor(u.Q(this.bounds.getNorth()) * i),
              h = Math.ceil(u.O(this.bounds.getEast()) * i),
              f = Math.ceil(u.Q(this.bounds.getSouth()) * i);
            return e.x >= s && e.x < h && e.y >= a && e.y < f;
          }
        }
        class _n extends u.E {
          constructor(e, i, s, a) {
            if (
              (super(),
              (this.id = e),
              (this.dispatcher = s),
              (this.type = "vector"),
              (this.minzoom = 0),
              (this.maxzoom = 22),
              (this.scheme = "xyz"),
              (this.tileSize = 512),
              (this.reparseOverscaled = !0),
              (this.isTileClipped = !0),
              (this._loaded = !1),
              u.e(this, u.M(i, ["url", "scheme", "tileSize", "promoteId"])),
              (this._options = u.e({ type: "vector" }, i)),
              (this._collectResourceTiming = i.collectResourceTiming),
              this.tileSize !== 512)
            )
              throw new Error(
                "vector tile sources must have a tileSize of 512",
              );
            this.setEventedParent(a);
          }
          load() {
            return u._(this, void 0, void 0, function* () {
              ((this._loaded = !1),
                this.fire(new u.k("dataloading", { dataType: "source" })),
                (this._tileJSONRequest = new AbortController()));
              try {
                const e = yield zr(
                  this._options,
                  this.map._requestManager,
                  this._tileJSONRequest,
                );
                ((this._tileJSONRequest = null),
                  (this._loaded = !0),
                  this.map.style.sourceCaches[this.id].clearTiles(),
                  e &&
                    (u.e(this, e),
                    e.bounds &&
                      (this.tileBounds = new gn(
                        e.bounds,
                        this.minzoom,
                        this.maxzoom,
                      )),
                    this.fire(
                      new u.k("data", {
                        dataType: "source",
                        sourceDataType: "metadata",
                      }),
                    ),
                    this.fire(
                      new u.k("data", {
                        dataType: "source",
                        sourceDataType: "content",
                      }),
                    )));
              } catch (e) {
                ((this._tileJSONRequest = null), this.fire(new u.j(e)));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            ((this.map = e), this.load());
          }
          setSourceProperty(e) {
            (this._tileJSONRequest && this._tileJSONRequest.abort(),
              e(),
              this.load());
          }
          setTiles(e) {
            return (
              this.setSourceProperty(() => {
                this._options.tiles = e;
              }),
              this
            );
          }
          setUrl(e) {
            return (
              this.setSourceProperty(() => {
                ((this.url = e), (this._options.url = e));
              }),
              this
            );
          }
          onRemove() {
            this._tileJSONRequest &&
              (this._tileJSONRequest.abort(), (this._tileJSONRequest = null));
          }
          serialize() {
            return u.e({}, this._options);
          }
          loadTile(e) {
            return u._(this, void 0, void 0, function* () {
              const i = e.tileID.canonical.url(
                  this.tiles,
                  this.map.getPixelRatio(),
                  this.scheme,
                ),
                s = {
                  request: this.map._requestManager.transformRequest(i, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity:
                    this.map.style.projection.subdivisionGranularity,
                };
              s.request.collectResourceTiming = this._collectResourceTiming;
              let a = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading")
                  return new Promise((h, f) => {
                    e.reloadPromise = { resolve: h, reject: f };
                  });
              } else ((e.actor = this.dispatcher.getActor()), (a = "LT"));
              e.abortController = new AbortController();
              try {
                const h = yield e.actor.sendAsync(
                  { type: a, data: s },
                  e.abortController,
                );
                if ((delete e.abortController, e.aborted)) return;
                this._afterTileLoadWorkerResponse(e, h);
              } catch (h) {
                if ((delete e.abortController, e.aborted)) return;
                if (h && h.status !== 404) throw h;
                this._afterTileLoadWorkerResponse(e, null);
              }
            });
          }
          _afterTileLoadWorkerResponse(e, i) {
            if (
              (i && i.resourceTiming && (e.resourceTiming = i.resourceTiming),
              i && this.map._refreshExpiredTiles && e.setExpiryData(i),
              e.loadVectorData(i, this.map.painter),
              e.reloadPromise)
            ) {
              const s = e.reloadPromise;
              ((e.reloadPromise = null),
                this.loadTile(e).then(s.resolve).catch(s.reject));
            }
          }
          abortTile(e) {
            return u._(this, void 0, void 0, function* () {
              (e.abortController &&
                (e.abortController.abort(), delete e.abortController),
                e.actor &&
                  (yield e.actor.sendAsync({
                    type: "AT",
                    data: { uid: e.uid, type: this.type, source: this.id },
                  })));
            });
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, function* () {
              (e.unloadVectorData(),
                e.actor &&
                  (yield e.actor.sendAsync({
                    type: "RMT",
                    data: { uid: e.uid, type: this.type, source: this.id },
                  })));
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class gr extends u.E {
          constructor(e, i, s, a) {
            (super(),
              (this.id = e),
              (this.dispatcher = s),
              this.setEventedParent(a),
              (this.type = "raster"),
              (this.minzoom = 0),
              (this.maxzoom = 22),
              (this.roundZoom = !0),
              (this.scheme = "xyz"),
              (this.tileSize = 512),
              (this._loaded = !1),
              (this._options = u.e({ type: "raster" }, i)),
              u.e(this, u.M(i, ["url", "scheme", "tileSize"])));
          }
          load() {
            return u._(this, arguments, void 0, function* (e = !1) {
              ((this._loaded = !1),
                this.fire(new u.k("dataloading", { dataType: "source" })),
                (this._tileJSONRequest = new AbortController()));
              try {
                const i = yield zr(
                  this._options,
                  this.map._requestManager,
                  this._tileJSONRequest,
                );
                ((this._tileJSONRequest = null),
                  (this._loaded = !0),
                  i &&
                    (u.e(this, i),
                    i.bounds &&
                      (this.tileBounds = new gn(
                        i.bounds,
                        this.minzoom,
                        this.maxzoom,
                      )),
                    this.fire(
                      new u.k("data", {
                        dataType: "source",
                        sourceDataType: "metadata",
                      }),
                    ),
                    this.fire(
                      new u.k("data", {
                        dataType: "source",
                        sourceDataType: "content",
                        sourceDataChanged: e,
                      }),
                    )));
              } catch (i) {
                ((this._tileJSONRequest = null), this.fire(new u.j(i)));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e) {
            ((this.map = e), this.load());
          }
          onRemove() {
            this._tileJSONRequest &&
              (this._tileJSONRequest.abort(), (this._tileJSONRequest = null));
          }
          setSourceProperty(e) {
            (this._tileJSONRequest &&
              (this._tileJSONRequest.abort(), (this._tileJSONRequest = null)),
              e(),
              this.load(!0));
          }
          setTiles(e) {
            return (
              this.setSourceProperty(() => {
                this._options.tiles = e;
              }),
              this
            );
          }
          setUrl(e) {
            return (
              this.setSourceProperty(() => {
                ((this.url = e), (this._options.url = e));
              }),
              this
            );
          }
          serialize() {
            return u.e({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(e) {
            return u._(this, void 0, void 0, function* () {
              const i = e.tileID.canonical.url(
                this.tiles,
                this.map.getPixelRatio(),
                this.scheme,
              );
              e.abortController = new AbortController();
              try {
                const s = yield ei.getImage(
                  this.map._requestManager.transformRequest(i, "Tile"),
                  e.abortController,
                  this.map._refreshExpiredTiles,
                );
                if ((delete e.abortController, e.aborted))
                  return void (e.state = "unloaded");
                if (s && s.data) {
                  this.map._refreshExpiredTiles &&
                    s.cacheControl &&
                    s.expires &&
                    e.setExpiryData({
                      cacheControl: s.cacheControl,
                      expires: s.expires,
                    });
                  const a = this.map.painter.context,
                    h = a.gl,
                    f = s.data;
                  ((e.texture = this.map.painter.getTileTexture(f.width)),
                    e.texture
                      ? e.texture.update(f, { useMipmap: !0 })
                      : ((e.texture = new Bt(a, f, h.RGBA, { useMipmap: !0 })),
                        e.texture.bind(
                          h.LINEAR,
                          h.CLAMP_TO_EDGE,
                          h.LINEAR_MIPMAP_NEAREST,
                        )),
                    (e.state = "loaded"));
                }
              } catch (s) {
                if ((delete e.abortController, e.aborted)) e.state = "unloaded";
                else if (s) throw ((e.state = "errored"), s);
              }
            });
          }
          abortTile(e) {
            return u._(this, void 0, void 0, function* () {
              e.abortController &&
                (e.abortController.abort(), delete e.abortController);
            });
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, function* () {
              e.texture && this.map.painter.saveTileTexture(e.texture);
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class Wr extends gr {
          constructor(e, i, s, a) {
            (super(e, i, s, a),
              (this.type = "raster-dem"),
              (this.maxzoom = 22),
              (this._options = u.e({ type: "raster-dem" }, i)),
              (this.encoding = i.encoding || "mapbox"),
              (this.redFactor = i.redFactor),
              (this.greenFactor = i.greenFactor),
              (this.blueFactor = i.blueFactor),
              (this.baseShift = i.baseShift));
          }
          loadTile(e) {
            return u._(this, void 0, void 0, function* () {
              const i = e.tileID.canonical.url(
                  this.tiles,
                  this.map.getPixelRatio(),
                  this.scheme,
                ),
                s = this.map._requestManager.transformRequest(i, "Tile");
              ((e.neighboringTiles = this._getNeighboringTiles(e.tileID)),
                (e.abortController = new AbortController()));
              try {
                const a = yield ei.getImage(
                  s,
                  e.abortController,
                  this.map._refreshExpiredTiles,
                );
                if ((delete e.abortController, e.aborted))
                  return void (e.state = "unloaded");
                if (a && a.data) {
                  const h = a.data;
                  this.map._refreshExpiredTiles &&
                    a.cacheControl &&
                    a.expires &&
                    e.setExpiryData({
                      cacheControl: a.cacheControl,
                      expires: a.expires,
                    });
                  const f = u.b(h) && u.U() ? h : yield this.readImageNow(h),
                    g = {
                      type: this.type,
                      uid: e.uid,
                      source: this.id,
                      rawImageData: f,
                      encoding: this.encoding,
                      redFactor: this.redFactor,
                      greenFactor: this.greenFactor,
                      blueFactor: this.blueFactor,
                      baseShift: this.baseShift,
                    };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const y = yield e.actor.sendAsync({ type: "LDT", data: g });
                    ((e.dem = y),
                      (e.needsHillshadePrepare = !0),
                      (e.needsTerrainPrepare = !0),
                      (e.state = "loaded"));
                  }
                }
              } catch (a) {
                if ((delete e.abortController, e.aborted)) e.state = "unloaded";
                else if (a) throw ((e.state = "errored"), a);
              }
            });
          }
          readImageNow(e) {
            return u._(this, void 0, void 0, function* () {
              if (typeof VideoFrame < "u" && u.V()) {
                const i = e.width + 2,
                  s = e.height + 2;
                try {
                  return new u.R(
                    { width: i, height: s },
                    yield u.W(e, -1, -1, i, s),
                  );
                } catch {}
              }
              return Qe.getImageData(e, 1);
            });
          }
          _getNeighboringTiles(e) {
            const i = e.canonical,
              s = Math.pow(2, i.z),
              a = (i.x - 1 + s) % s,
              h = i.x === 0 ? e.wrap - 1 : e.wrap,
              f = (i.x + 1 + s) % s,
              g = i.x + 1 === s ? e.wrap + 1 : e.wrap,
              y = {};
            return (
              (y[new u.S(e.overscaledZ, h, i.z, a, i.y).key] = {
                backfilled: !1,
              }),
              (y[new u.S(e.overscaledZ, g, i.z, f, i.y).key] = {
                backfilled: !1,
              }),
              i.y > 0 &&
                ((y[new u.S(e.overscaledZ, h, i.z, a, i.y - 1).key] = {
                  backfilled: !1,
                }),
                (y[new u.S(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = {
                  backfilled: !1,
                }),
                (y[new u.S(e.overscaledZ, g, i.z, f, i.y - 1).key] = {
                  backfilled: !1,
                })),
              i.y + 1 < s &&
                ((y[new u.S(e.overscaledZ, h, i.z, a, i.y + 1).key] = {
                  backfilled: !1,
                }),
                (y[new u.S(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = {
                  backfilled: !1,
                }),
                (y[new u.S(e.overscaledZ, g, i.z, f, i.y + 1).key] = {
                  backfilled: !1,
                })),
              y
            );
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, function* () {
              (e.demTexture && this.map.painter.saveTileTexture(e.demTexture),
                e.fbo && (e.fbo.destroy(), delete e.fbo),
                e.dem && delete e.dem,
                delete e.neighboringTiles,
                (e.state = "unloaded"),
                e.actor &&
                  (yield e.actor.sendAsync({
                    type: "RDT",
                    data: { type: this.type, uid: e.uid, source: this.id },
                  })));
            });
          }
        }
        class Kr extends u.E {
          constructor(e, i, s, a) {
            (super(),
              (this.id = e),
              (this.type = "geojson"),
              (this.minzoom = 0),
              (this.maxzoom = 18),
              (this.tileSize = 512),
              (this.isTileClipped = !0),
              (this.reparseOverscaled = !0),
              (this._removed = !1),
              (this._pendingLoads = 0),
              (this.actor = s.getActor()),
              this.setEventedParent(a),
              (this._data = i.data),
              (this._options = u.e({}, i)),
              (this._collectResourceTiming = i.collectResourceTiming),
              i.maxzoom !== void 0 && (this.maxzoom = i.maxzoom),
              i.type && (this.type = i.type),
              i.attribution && (this.attribution = i.attribution),
              (this.promoteId = i.promoteId),
              i.clusterMaxZoom !== void 0 &&
                this.maxzoom <= i.clusterMaxZoom &&
                u.w(
                  `The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`,
                ),
              (this.workerOptions = u.e(
                {
                  source: this.id,
                  cluster: i.cluster || !1,
                  geojsonVtOptions: {
                    buffer: this._pixelsToTileUnits(
                      i.buffer !== void 0 ? i.buffer : 128,
                    ),
                    tolerance: this._pixelsToTileUnits(
                      i.tolerance !== void 0 ? i.tolerance : 0.375,
                    ),
                    extent: u.X,
                    maxZoom: this.maxzoom,
                    lineMetrics: i.lineMetrics || !1,
                    generateId: i.generateId || !1,
                  },
                  superclusterOptions: {
                    maxZoom:
                      i.clusterMaxZoom !== void 0
                        ? i.clusterMaxZoom
                        : this.maxzoom - 1,
                    minPoints: Math.max(2, i.clusterMinPoints || 2),
                    extent: u.X,
                    radius: this._pixelsToTileUnits(i.clusterRadius || 50),
                    log: !1,
                    generateId: i.generateId || !1,
                  },
                  clusterProperties: i.clusterProperties,
                  filter: i.filter,
                },
                i.workerOptions,
              )),
              typeof this.promoteId == "string" &&
                (this.workerOptions.promoteId = this.promoteId));
          }
          _pixelsToTileUnits(e) {
            return e * (u.X / this.tileSize);
          }
          load() {
            return u._(this, void 0, void 0, function* () {
              yield this._updateWorkerData();
            });
          }
          onAdd(e) {
            ((this.map = e), this.load());
          }
          setData(e) {
            return ((this._data = e), this._updateWorkerData(), this);
          }
          updateData(e) {
            return (this._updateWorkerData(e), this);
          }
          getData() {
            return u._(this, void 0, void 0, function* () {
              const e = u.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e });
            });
          }
          setClusterOptions(e) {
            return (
              (this.workerOptions.cluster = e.cluster),
              e &&
                (e.clusterRadius !== void 0 &&
                  (this.workerOptions.superclusterOptions.radius =
                    this._pixelsToTileUnits(e.clusterRadius)),
                e.clusterMaxZoom !== void 0 &&
                  (this.workerOptions.superclusterOptions.maxZoom =
                    e.clusterMaxZoom)),
              this._updateWorkerData(),
              this
            );
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: { type: this.type, clusterId: e, source: this.id },
            });
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: { type: this.type, clusterId: e, source: this.id },
            });
          }
          getClusterLeaves(e, i, s) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: i,
                offset: s,
              },
            });
          }
          _updateWorkerData(e) {
            return u._(this, void 0, void 0, function* () {
              const i = u.e({ type: this.type }, this.workerOptions);
              (e
                ? (i.dataDiff = e)
                : typeof this._data == "string"
                  ? ((i.request = this.map._requestManager.transformRequest(
                      Qe.resolveURL(this._data),
                      "Source",
                    )),
                    (i.request.collectResourceTiming =
                      this._collectResourceTiming))
                  : (i.data = JSON.stringify(this._data)),
                this._pendingLoads++,
                this.fire(new u.k("dataloading", { dataType: "source" })));
              try {
                const s = yield this.actor.sendAsync({ type: "LD", data: i });
                if ((this._pendingLoads--, this._removed || s.abandoned))
                  return void this.fire(
                    new u.k("dataabort", { dataType: "source" }),
                  );
                let a = null;
                s.resourceTiming &&
                  s.resourceTiming[this.id] &&
                  (a = s.resourceTiming[this.id].slice(0));
                const h = { dataType: "source" };
                (this._collectResourceTiming &&
                  a &&
                  a.length > 0 &&
                  u.e(h, { resourceTiming: a }),
                  this.fire(
                    new u.k(
                      "data",
                      Object.assign(Object.assign({}, h), {
                        sourceDataType: "metadata",
                      }),
                    ),
                  ),
                  this.fire(
                    new u.k(
                      "data",
                      Object.assign(Object.assign({}, h), {
                        sourceDataType: "content",
                      }),
                    ),
                  ));
              } catch (s) {
                if ((this._pendingLoads--, this._removed))
                  return void this.fire(
                    new u.k("dataabort", { dataType: "source" }),
                  );
                this.fire(new u.j(s));
              }
            });
          }
          loaded() {
            return this._pendingLoads === 0;
          }
          loadTile(e) {
            return u._(this, void 0, void 0, function* () {
              const i = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const s = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity:
                  this.map.style.projection.subdivisionGranularity,
              };
              e.abortController = new AbortController();
              const a = yield this.actor.sendAsync(
                { type: i, data: s },
                e.abortController,
              );
              (delete e.abortController,
                e.unloadVectorData(),
                e.aborted || e.loadVectorData(a, this.map.painter, i === "RT"));
            });
          }
          abortTile(e) {
            return u._(this, void 0, void 0, function* () {
              (e.abortController &&
                (e.abortController.abort(), delete e.abortController),
                (e.aborted = !0));
            });
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, function* () {
              (e.unloadVectorData(),
                yield this.actor.sendAsync({
                  type: "RMT",
                  data: { uid: e.uid, type: this.type, source: this.id },
                }));
            });
          }
          onRemove() {
            ((this._removed = !0),
              this.actor.sendAsync({
                type: "RS",
                data: { type: this.type, source: this.id },
              }));
          }
          serialize() {
            return u.e({}, this._options, {
              type: this.type,
              data: this._data,
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class Ji extends u.E {
          constructor(e, i, s, a) {
            (super(),
              (this.flippedWindingOrder = !1),
              (this.id = e),
              (this.dispatcher = s),
              (this.coordinates = i.coordinates),
              (this.type = "image"),
              (this.minzoom = 0),
              (this.maxzoom = 22),
              (this.tileSize = 512),
              (this.tiles = {}),
              (this._loaded = !1),
              this.setEventedParent(a),
              (this.options = i));
          }
          load(e) {
            return u._(this, void 0, void 0, function* () {
              ((this._loaded = !1),
                this.fire(new u.k("dataloading", { dataType: "source" })),
                (this.url = this.options.url),
                (this._request = new AbortController()));
              try {
                const i = yield ei.getImage(
                  this.map._requestManager.transformRequest(this.url, "Image"),
                  this._request,
                );
                ((this._request = null),
                  (this._loaded = !0),
                  i &&
                    i.data &&
                    ((this.image = i.data),
                    e && (this.coordinates = e),
                    this._finishLoading()));
              } catch (i) {
                ((this._request = null),
                  (this._loaded = !0),
                  this.fire(new u.j(i)));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url
              ? (this._request &&
                  (this._request.abort(), (this._request = null)),
                (this.options.url = e.url),
                this.load(e.coordinates).finally(() => {
                  this.texture = null;
                }),
                this)
              : this;
          }
          _finishLoading() {
            this.map &&
              (this.setCoordinates(this.coordinates),
              this.fire(
                new u.k("data", {
                  dataType: "source",
                  sourceDataType: "metadata",
                }),
              ));
          }
          onAdd(e) {
            ((this.map = e), this.load());
          }
          onRemove() {
            this._request && (this._request.abort(), (this._request = null));
          }
          setCoordinates(e) {
            this.coordinates = e;
            const i = e.map(u.Y.fromLngLat);
            var s;
            return (
              (this.tileID = (function (a) {
                let h = 1 / 0,
                  f = 1 / 0,
                  g = -1 / 0,
                  y = -1 / 0;
                for (const T of a)
                  ((h = Math.min(h, T.x)),
                    (f = Math.min(f, T.y)),
                    (g = Math.max(g, T.x)),
                    (y = Math.max(y, T.y)));
                const v = Math.max(g - h, y - f),
                  C = Math.max(0, Math.floor(-Math.log(v) / Math.LN2)),
                  A = Math.pow(2, C);
                return new u.Z(
                  C,
                  Math.floor(((h + g) / 2) * A),
                  Math.floor(((f + y) / 2) * A),
                );
              })(i)),
              (this.minzoom = this.maxzoom = this.tileID.z),
              (this.tileCoords = i.map((a) =>
                this.tileID.getTilePoint(a)._round(),
              )),
              (this.flippedWindingOrder =
                ((s = this.tileCoords)[1].x - s[0].x) * (s[2].y - s[0].y) -
                  (s[1].y - s[0].y) * (s[2].x - s[0].x) <
                0),
              this.fire(
                new u.k("data", {
                  dataType: "source",
                  sourceDataType: "content",
                }),
              ),
              this
            );
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              i = e.gl;
            this.texture ||
              ((this.texture = new Bt(e, this.image, i.RGBA)),
              this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let s = !1;
            for (const a in this.tiles) {
              const h = this.tiles[a];
              h.state !== "loaded" &&
                ((h.state = "loaded"), (h.texture = this.texture), (s = !0));
            }
            s &&
              this.fire(
                new u.k("data", {
                  dataType: "source",
                  sourceDataType: "idle",
                  sourceId: this.id,
                }),
              );
          }
          loadTile(e) {
            return u._(this, void 0, void 0, function* () {
              this.tileID && this.tileID.equals(e.tileID.canonical)
                ? ((this.tiles[String(e.tileID.wrap)] = e), (e.buckets = {}))
                : (e.state = "errored");
            });
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates,
            };
          }
          hasTransition() {
            return !1;
          }
        }
        class yn extends Ji {
          constructor(e, i, s, a) {
            (super(e, i, s, a),
              (this.roundZoom = !0),
              (this.type = "video"),
              (this.options = i));
          }
          load() {
            return u._(this, void 0, void 0, function* () {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const i of e.urls)
                this.urls.push(
                  this.map._requestManager.transformRequest(i, "Source").url,
                );
              try {
                const i = yield u.a0(this.urls);
                if (((this._loaded = !0), !i)) return;
                ((this.video = i),
                  (this.video.loop = !0),
                  this.video.addEventListener("playing", () => {
                    this.map.triggerRepaint();
                  }),
                  this.map && this.video.play(),
                  this._finishLoading());
              } catch (i) {
                this.fire(new u.j(i));
              }
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e) {
            if (this.video) {
              const i = this.video.seekable;
              e < i.start(0) || e > i.end(0)
                ? this.fire(
                    new u.j(
                      new u.$(
                        `sources.${this.id}`,
                        null,
                        `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`,
                      ),
                    ),
                  )
                : (this.video.currentTime = e);
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map ||
              ((this.map = e),
              this.load(),
              this.video &&
                (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (
              Object.keys(this.tiles).length === 0 ||
              this.video.readyState < 2
            )
              return;
            const e = this.map.painter.context,
              i = e.gl;
            this.texture
              ? this.video.paused ||
                (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
                i.texSubImage2D(
                  i.TEXTURE_2D,
                  0,
                  0,
                  0,
                  i.RGBA,
                  i.UNSIGNED_BYTE,
                  this.video,
                ))
              : ((this.texture = new Bt(e, this.video, i.RGBA)),
                this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let s = !1;
            for (const a in this.tiles) {
              const h = this.tiles[a];
              h.state !== "loaded" &&
                ((h.state = "loaded"), (h.texture = this.texture), (s = !0));
            }
            s &&
              this.fire(
                new u.k("data", {
                  dataType: "source",
                  sourceDataType: "idle",
                  sourceId: this.id,
                }),
              );
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates,
            };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class xn extends Ji {
          constructor(e, i, s, a) {
            (super(e, i, s, a),
              i.coordinates
                ? (Array.isArray(i.coordinates) &&
                    i.coordinates.length === 4 &&
                    !i.coordinates.some(
                      (h) =>
                        !Array.isArray(h) ||
                        h.length !== 2 ||
                        h.some((f) => typeof f != "number"),
                    )) ||
                  this.fire(
                    new u.j(
                      new u.$(
                        `sources.${e}`,
                        null,
                        "\"coordinates\" property must be an array of 4 longitude/latitude array pairs",
                      ),
                    ),
                  )
                : this.fire(
                    new u.j(
                      new u.$(
                        `sources.${e}`,
                        null,
                        "missing required property \"coordinates\"",
                      ),
                    ),
                  ),
              i.animate &&
                typeof i.animate != "boolean" &&
                this.fire(
                  new u.j(
                    new u.$(
                      `sources.${e}`,
                      null,
                      "optional \"animate\" property must be a boolean value",
                    ),
                  ),
                ),
              i.canvas
                ? typeof i.canvas == "string" ||
                  i.canvas instanceof HTMLCanvasElement ||
                  this.fire(
                    new u.j(
                      new u.$(
                        `sources.${e}`,
                        null,
                        "\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance",
                      ),
                    ),
                  )
                : this.fire(
                    new u.j(
                      new u.$(
                        `sources.${e}`,
                        null,
                        "missing required property \"canvas\"",
                      ),
                    ),
                  ),
              (this.options = i),
              (this.animate = i.animate === void 0 || i.animate));
          }
          load() {
            return u._(this, void 0, void 0, function* () {
              ((this._loaded = !0),
                this.canvas ||
                  (this.canvas =
                    this.options.canvas instanceof HTMLCanvasElement
                      ? this.options.canvas
                      : document.getElementById(this.options.canvas)),
                (this.width = this.canvas.width),
                (this.height = this.canvas.height),
                this._hasInvalidDimensions()
                  ? this.fire(
                      new u.j(
                        new Error(
                          "Canvas dimensions cannot be less than or equal to zero.",
                        ),
                      ),
                    )
                  : ((this.play = function () {
                      ((this._playing = !0), this.map.triggerRepaint());
                    }),
                    (this.pause = function () {
                      this._playing && (this.prepare(), (this._playing = !1));
                    }),
                    this._finishLoading()));
            });
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            ((this.map = e),
              this.load(),
              this.canvas && this.animate && this.play());
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e = !1;
            if (
              (this.canvas.width !== this.width &&
                ((this.width = this.canvas.width), (e = !0)),
              this.canvas.height !== this.height &&
                ((this.height = this.canvas.height), (e = !0)),
              this._hasInvalidDimensions() ||
                Object.keys(this.tiles).length === 0)
            )
              return;
            const i = this.map.painter.context,
              s = i.gl;
            this.texture
              ? (e || this._playing) &&
                this.texture.update(this.canvas, { premultiply: !0 })
              : (this.texture = new Bt(i, this.canvas, s.RGBA, {
                  premultiply: !0,
                }));
            let a = !1;
            for (const h in this.tiles) {
              const f = this.tiles[h];
              f.state !== "loaded" &&
                ((f.state = "loaded"), (f.texture = this.texture), (a = !0));
            }
            a &&
              this.fire(
                new u.k("data", {
                  dataType: "source",
                  sourceDataType: "idle",
                  sourceId: this.id,
                }),
              );
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1;
          }
        }
        const Yr = {},
          Ao = (c) => {
            switch (c) {
              case "geojson":
                return Kr;
              case "image":
                return Ji;
              case "raster":
                return gr;
              case "raster-dem":
                return Wr;
              case "vector":
                return _n;
              case "video":
                return yn;
              case "canvas":
                return xn;
            }
            return Yr[c];
          },
          vn = "RTLPluginLoaded";
        class Lr extends u.E {
          constructor() {
            (super(...arguments),
              (this.status = "unavailable"),
              (this.url = null),
              (this.dispatcher = mn()));
          }
          _syncState(e) {
            return (
              (this.status = e),
              this.dispatcher
                .broadcast("SRPS", { pluginStatus: e, pluginURL: this.url })
                .catch((i) => {
                  throw ((this.status = "error"), i);
                })
            );
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            ((this.status = "unavailable"), (this.url = null));
          }
          setRTLTextPlugin(e) {
            return u._(this, arguments, void 0, function* (i, s = !1) {
              if (this.url)
                throw new Error(
                  "setRTLTextPlugin cannot be called multiple times.",
                );
              if (((this.url = Qe.resolveURL(i)), !this.url))
                throw new Error(`requested url ${i} is invalid`);
              if (this.status === "unavailable") {
                if (!s) return this._requestImport();
                ((this.status = "deferred"), this._syncState(this.status));
              } else if (this.status === "requested")
                return this._requestImport();
            });
          }
          _requestImport() {
            return u._(this, void 0, void 0, function* () {
              (yield this._syncState("loading"),
                (this.status = "loaded"),
                this.fire(new u.k(vn)));
            });
          }
          lazyLoad() {
            this.status === "unavailable"
              ? (this.status = "requested")
              : this.status === "deferred" && this._requestImport();
          }
        }
        let bn = null;
        function Rr() {
          return (bn || (bn = new Lr()), bn);
        }
        class wn {
          constructor(e, i) {
            ((this.timeAdded = 0),
              (this.fadeEndTime = 0),
              (this.tileID = e),
              (this.uid = u.a1()),
              (this.uses = 0),
              (this.tileSize = i),
              (this.buckets = {}),
              (this.expirationTime = null),
              (this.queryPadding = 0),
              (this.hasSymbolBuckets = !1),
              (this.hasRTLText = !1),
              (this.dependencies = {}),
              (this.rtt = []),
              (this.rttCoords = {}),
              (this.expiredRequestCount = 0),
              (this.state = "loading"));
          }
          registerFadeDuration(e) {
            const i = e + this.timeAdded;
            i < this.fadeEndTime || (this.fadeEndTime = i);
          }
          wasRequested() {
            return (
              this.state === "errored" ||
              this.state === "loaded" ||
              this.state === "reloading"
            );
          }
          clearTextures(e) {
            (this.demTexture && e.saveTileTexture(this.demTexture),
              (this.demTexture = null));
          }
          loadVectorData(e, i, s) {
            if (
              (this.hasData() && this.unloadVectorData(),
              (this.state = "loaded"),
              e)
            ) {
              (e.featureIndex &&
                ((this.latestFeatureIndex = e.featureIndex),
                e.rawTileData
                  ? ((this.latestRawTileData = e.rawTileData),
                    (this.latestFeatureIndex.rawTileData = e.rawTileData))
                  : this.latestRawTileData &&
                    (this.latestFeatureIndex.rawTileData =
                      this.latestRawTileData)),
                (this.collisionBoxArray = e.collisionBoxArray),
                (this.buckets = (function (a, h) {
                  const f = {};
                  if (!h) return f;
                  for (const g of a) {
                    const y = g.layerIds
                      .map((v) => h.getLayer(v))
                      .filter(Boolean);
                    if (y.length !== 0) {
                      ((g.layers = y),
                        g.stateDependentLayerIds &&
                          (g.stateDependentLayers =
                            g.stateDependentLayerIds.map(
                              (v) => y.filter((C) => C.id === v)[0],
                            )));
                      for (const v of y) f[v.id] = g;
                    }
                  }
                  return f;
                })(e.buckets, i == null ? void 0 : i.style)),
                (this.hasSymbolBuckets = !1));
              for (const a in this.buckets) {
                const h = this.buckets[a];
                if (h instanceof u.a3) {
                  if (((this.hasSymbolBuckets = !0), !s)) break;
                  h.justReloaded = !0;
                }
              }
              if (((this.hasRTLText = !1), this.hasSymbolBuckets))
                for (const a in this.buckets) {
                  const h = this.buckets[a];
                  if (h instanceof u.a3 && h.hasRTLText) {
                    ((this.hasRTLText = !0), Rr().lazyLoad());
                    break;
                  }
                }
              this.queryPadding = 0;
              for (const a in this.buckets) {
                const h = this.buckets[a];
                this.queryPadding = Math.max(
                  this.queryPadding,
                  i.style.getLayer(a).queryRadius(h),
                );
              }
              (e.imageAtlas && (this.imageAtlas = e.imageAtlas),
                e.glyphAtlasImage &&
                  (this.glyphAtlasImage = e.glyphAtlasImage));
            } else this.collisionBoxArray = new u.a2();
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            ((this.buckets = {}),
              this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
              this.imageAtlas && (this.imageAtlas = null),
              this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
              (this.latestFeatureIndex = null),
              (this.state = "unloaded"));
          }
          getBucket(e) {
            return this.buckets[e.id];
          }
          upload(e) {
            for (const s in this.buckets) {
              const a = this.buckets[s];
              a.uploadPending() && a.upload(e);
            }
            const i = e.gl;
            (this.imageAtlas &&
              !this.imageAtlas.uploaded &&
              ((this.imageAtlasTexture = new Bt(
                e,
                this.imageAtlas.image,
                i.RGBA,
              )),
              (this.imageAtlas.uploaded = !0)),
              this.glyphAtlasImage &&
                ((this.glyphAtlasTexture = new Bt(
                  e,
                  this.glyphAtlasImage,
                  i.ALPHA,
                )),
                (this.glyphAtlasImage = null)));
          }
          prepare(e) {
            this.imageAtlas &&
              this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e, i, s, a, h, f, g, y, v, C) {
            return this.latestFeatureIndex &&
              this.latestFeatureIndex.rawTileData
              ? this.latestFeatureIndex.query(
                  {
                    queryGeometry: a,
                    cameraQueryGeometry: h,
                    scale: f,
                    tileSize: this.tileSize,
                    pixelPosMatrix: C,
                    transform: y,
                    params: g,
                    queryPadding: this.queryPadding * v,
                  },
                  e,
                  i,
                  s,
                )
              : {};
          }
          querySourceFeatures(e, i) {
            const s = this.latestFeatureIndex;
            if (!s || !s.rawTileData) return;
            const a = s.loadVTLayers(),
              h = i && i.sourceLayer ? i.sourceLayer : "",
              f = a._geojsonTileLayer || a[h];
            if (!f) return;
            const g = u.a4(i && i.filter),
              { z: y, x: v, y: C } = this.tileID.canonical,
              A = { z: y, x: v, y: C };
            for (let T = 0; T < f.length; T++) {
              const M = f.feature(T);
              if (g.needGeometry) {
                const N = u.a5(M, !0);
                if (
                  !g.filter(
                    new u.z(this.tileID.overscaledZ),
                    N,
                    this.tileID.canonical,
                  )
                )
                  continue;
              } else if (!g.filter(new u.z(this.tileID.overscaledZ), M))
                continue;
              const k = s.getId(M, h),
                V = new u.a6(M, y, v, C, k);
              ((V.tile = A), e.push(V));
            }
          }
          hasData() {
            return (
              this.state === "loaded" ||
              this.state === "reloading" ||
              this.state === "expired"
            );
          }
          patternsLoaded() {
            return (
              this.imageAtlas &&
              !!Object.keys(this.imageAtlas.patternPositions).length
            );
          }
          setExpiryData(e) {
            const i = this.expirationTime;
            if (e.cacheControl) {
              const s = u.a7(e.cacheControl);
              s["max-age"] &&
                (this.expirationTime = Date.now() + 1e3 * s["max-age"]);
            } else
              e.expires &&
                (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const s = Date.now();
              let a = !1;
              if (this.expirationTime > s) a = !1;
              else if (i)
                if (this.expirationTime < i) a = !0;
                else {
                  const h = this.expirationTime - i;
                  h ? (this.expirationTime = s + Math.max(h, 3e4)) : (a = !0);
                }
              else a = !0;
              a
                ? (this.expiredRequestCount++, (this.state = "expired"))
                : (this.expiredRequestCount = 0);
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime)
              return this.expiredRequestCount
                ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31))
                : Math.min(
                    this.expirationTime - new Date().getTime(),
                    Math.pow(2, 31) - 1,
                  );
          }
          setFeatureState(e, i) {
            if (
              !this.latestFeatureIndex ||
              !this.latestFeatureIndex.rawTileData ||
              Object.keys(e).length === 0
            )
              return;
            const s = this.latestFeatureIndex.loadVTLayers();
            for (const a in this.buckets) {
              if (!i.style.hasLayer(a)) continue;
              const h = this.buckets[a],
                f = h.layers[0].sourceLayer || "_geojsonTileLayer",
                g = s[f],
                y = e[f];
              if (!g || !y || Object.keys(y).length === 0) continue;
              h.update(
                y,
                g,
                (this.imageAtlas && this.imageAtlas.patternPositions) || {},
              );
              const v = i && i.style && i.style.getLayer(a);
              v &&
                (this.queryPadding = Math.max(
                  this.queryPadding,
                  v.queryRadius(h),
                ));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return (
              !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Qe.now()
            );
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = Qe.now() + e;
          }
          setDependencies(e, i) {
            const s = {};
            for (const a of i) s[a] = !0;
            this.dependencies[e] = s;
          }
          hasDependency(e, i) {
            for (const s of e) {
              const a = this.dependencies[s];
              if (a) {
                for (const h of i) if (a[h]) return !0;
              }
            }
            return !1;
          }
        }
        class Jr {
          constructor(e, i) {
            ((this.max = e), (this.onRemove = i), this.reset());
          }
          reset() {
            for (const e in this.data)
              for (const i of this.data[e])
                (i.timeout && clearTimeout(i.timeout), this.onRemove(i.value));
            return ((this.data = {}), (this.order = []), this);
          }
          add(e, i, s) {
            const a = e.wrapped().key;
            this.data[a] === void 0 && (this.data[a] = []);
            const h = { value: i, timeout: void 0 };
            if (
              (s !== void 0 &&
                (h.timeout = setTimeout(() => {
                  this.remove(e, h);
                }, s)),
              this.data[a].push(h),
              this.order.push(a),
              this.order.length > this.max)
            ) {
              const f = this._getAndRemoveByKey(this.order[0]);
              f && this.onRemove(f);
            }
            return this;
          }
          has(e) {
            return e.wrapped().key in this.data;
          }
          getAndRemove(e) {
            return this.has(e)
              ? this._getAndRemoveByKey(e.wrapped().key)
              : null;
          }
          _getAndRemoveByKey(e) {
            const i = this.data[e].shift();
            return (
              i.timeout && clearTimeout(i.timeout),
              this.data[e].length === 0 && delete this.data[e],
              this.order.splice(this.order.indexOf(e), 1),
              i.value
            );
          }
          getByKey(e) {
            const i = this.data[e];
            return i ? i[0].value : null;
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null;
          }
          remove(e, i) {
            if (!this.has(e)) return this;
            const s = e.wrapped().key,
              a = i === void 0 ? 0 : this.data[s].indexOf(i),
              h = this.data[s][a];
            return (
              this.data[s].splice(a, 1),
              h.timeout && clearTimeout(h.timeout),
              this.data[s].length === 0 && delete this.data[s],
              this.onRemove(h.value),
              this.order.splice(this.order.indexOf(s), 1),
              this
            );
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max; ) {
              const i = this._getAndRemoveByKey(this.order[0]);
              i && this.onRemove(i);
            }
            return this;
          }
          filter(e) {
            const i = [];
            for (const s in this.data)
              for (const a of this.data[s]) e(a.value) || i.push(a);
            for (const s of i) this.remove(s.value.tileID, s);
          }
        }
        class Gn {
          constructor() {
            ((this.state = {}),
              (this.stateChanges = {}),
              (this.deletedStates = {}));
          }
          updateState(e, i, s) {
            const a = String(i);
            if (
              ((this.stateChanges[e] = this.stateChanges[e] || {}),
              (this.stateChanges[e][a] = this.stateChanges[e][a] || {}),
              u.e(this.stateChanges[e][a], s),
              this.deletedStates[e] === null)
            ) {
              this.deletedStates[e] = {};
              for (const h in this.state[e])
                h !== a && (this.deletedStates[e][h] = null);
            } else if (
              this.deletedStates[e] &&
              this.deletedStates[e][a] === null
            ) {
              this.deletedStates[e][a] = {};
              for (const h in this.state[e][a])
                s[h] || (this.deletedStates[e][a][h] = null);
            } else
              for (const h in s)
                this.deletedStates[e] &&
                  this.deletedStates[e][a] &&
                  this.deletedStates[e][a][h] === null &&
                  delete this.deletedStates[e][a][h];
          }
          removeFeatureState(e, i, s) {
            if (this.deletedStates[e] === null) return;
            const a = String(i);
            if (
              ((this.deletedStates[e] = this.deletedStates[e] || {}),
              s && i !== void 0)
            )
              this.deletedStates[e][a] !== null &&
                ((this.deletedStates[e][a] = this.deletedStates[e][a] || {}),
                (this.deletedStates[e][a][s] = null));
            else if (i !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][a])
                for (s in ((this.deletedStates[e][a] = {}),
                this.stateChanges[e][a]))
                  this.deletedStates[e][a][s] = null;
              else this.deletedStates[e][a] = null;
            else this.deletedStates[e] = null;
          }
          getState(e, i) {
            const s = String(i),
              a = u.e(
                {},
                (this.state[e] || {})[s],
                (this.stateChanges[e] || {})[s],
              );
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const h = this.deletedStates[e][i];
              if (h === null) return {};
              for (const f in h) delete a[f];
            }
            return a;
          }
          initializeTileState(e, i) {
            e.setFeatureState(this.state, i);
          }
          coalesceChanges(e, i) {
            const s = {};
            for (const a in this.stateChanges) {
              this.state[a] = this.state[a] || {};
              const h = {};
              for (const f in this.stateChanges[a])
                (this.state[a][f] || (this.state[a][f] = {}),
                  u.e(this.state[a][f], this.stateChanges[a][f]),
                  (h[f] = this.state[a][f]));
              s[a] = h;
            }
            for (const a in this.deletedStates) {
              this.state[a] = this.state[a] || {};
              const h = {};
              if (this.deletedStates[a] === null)
                for (const f in this.state[a])
                  ((h[f] = {}), (this.state[a][f] = {}));
              else
                for (const f in this.deletedStates[a]) {
                  if (this.deletedStates[a][f] === null) this.state[a][f] = {};
                  else
                    for (const g of Object.keys(this.deletedStates[a][f]))
                      delete this.state[a][f][g];
                  h[f] = this.state[a][f];
                }
              ((s[a] = s[a] || {}), u.e(s[a], h));
            }
            if (
              ((this.stateChanges = {}),
              (this.deletedStates = {}),
              Object.keys(s).length !== 0)
            )
              for (const a in e) e[a].setFeatureState(s, i);
          }
        }
        function qn(c, e, i) {
          const s = e.intersectsFrustum(c);
          if (!i) return s;
          const a = e.intersectsPlane(i);
          return s === 0 || a === 0 ? 0 : s === 2 && a === 2 ? 2 : 1;
        }
        function To(c, e, i, s, a) {
          let h = c;
          const f = Math.atan(e / i),
            g = Math.hypot(e, i);
          return (
            (h = c + u.a8(s / g / Math.max(0.5, Math.cos(u.aa(a / 2))))),
            (h += (1 * u.a8(Math.cos(f))) / 2),
            (h += u.ab(c - h, -0, 0)),
            h
          );
        }
        function Qr(c, e) {
          const i = (e.roundZoom ? Math.round : Math.floor)(
            c.zoom + u.a8(c.tileSize / e.tileSize),
          );
          return Math.max(0, i);
        }
        function j(c, e) {
          const i = c.getCameraFrustum(),
            s = c.getClippingPlane(),
            a = c.screenPointToMercatorCoordinate(c.getCameraPoint()),
            h = u.Y.fromLngLat(c.center, c.elevation);
          a.z =
            h.z +
            (Math.cos(c.pitchInRadians) * c.cameraToCenterDistance) /
              c.worldSize;
          const f = c.getCoveringTilesDetailsProvider(),
            g = f.allowVariableZoom(c, e),
            y = Qr(c, e),
            v = e.minzoom || 0,
            C = e.maxzoom !== void 0 ? e.maxzoom : c.maxZoom,
            A = Math.min(Math.max(0, y), C),
            T = Math.pow(2, A),
            M = [T * a.x, T * a.y, 0],
            k = [T * h.x, T * h.y, 0],
            V = Math.hypot(h.x - a.x, h.y - a.y),
            N = Math.abs(h.z - a.z),
            $ = Math.hypot(V, N),
            G = (ee) => ({ zoom: 0, x: 0, y: 0, wrap: ee, fullyVisible: !1 }),
            Y = [],
            Q = [];
          if (c.renderWorldCopies && f.allowWorldCopies())
            for (let ee = 1; ee <= 3; ee++) (Y.push(G(-ee)), Y.push(G(ee)));
          for (Y.push(G(0)); Y.length > 0; ) {
            const ee = Y.pop(),
              re = ee.x,
              ie = ee.y;
            let he = ee.fullyVisible;
            const pe = { x: re, y: ie, z: ee.zoom },
              be = f.getTileAABB(pe, ee.wrap, c.elevation, e);
            if (!he) {
              const Me = qn(i, be, s);
              if (Me === 0) continue;
              he = Me === 2;
            }
            const Ee = f.distanceToTile2d(a.x, a.y, pe, be);
            let ye = y;
            (g &&
              (ye = (e.calculateTileZoom || To)(
                c.zoom + u.a8(c.tileSize / e.tileSize),
                Ee,
                N,
                $,
                c.fov,
              )),
              (ye = (e.roundZoom ? Math.round : Math.floor)(ye)),
              (ye = Math.max(0, ye)));
            const Be = Math.min(ye, C);
            if (((ee.wrap = f.getWrap(h, pe, ee.wrap)), ee.zoom >= Be)) {
              if (ee.zoom < v) continue;
              const Me = A - ee.zoom,
                Fe = M[0] - 0.5 - (re << Me),
                Le = M[1] - 0.5 - (ie << Me),
                st = e.reparseOverscaled ? Math.max(ee.zoom, ye) : ee.zoom;
              Q.push({
                tileID: new u.S(
                  ee.zoom === C ? st : ee.zoom,
                  ee.wrap,
                  ee.zoom,
                  re,
                  ie,
                ),
                distanceSq: u.a9([k[0] - 0.5 - re, k[1] - 0.5 - ie]),
                tileDistanceToCamera: Math.sqrt(Fe * Fe + Le * Le),
              });
            } else
              for (let Me = 0; Me < 4; Me++)
                Y.push({
                  zoom: ee.zoom + 1,
                  x: (re << 1) + (Me % 2),
                  y: (ie << 1) + (Me >> 1),
                  wrap: ee.wrap,
                  fullyVisible: he,
                });
          }
          return Q.sort((ee, re) => ee.distanceSq - re.distanceSq).map(
            (ee) => ee.tileID,
          );
        }
        class B extends u.E {
          constructor(e, i, s) {
            (super(),
              (this.id = e),
              (this.dispatcher = s),
              this.on("data", (a) => this._dataHandler(a)),
              this.on("dataloading", () => {
                this._sourceErrored = !1;
              }),
              this.on("error", () => {
                this._sourceErrored = this._source.loaded();
              }),
              (this._source = ((a, h, f, g) => {
                const y = new (Ao(h.type))(a, h, f, g);
                if (y.id !== a)
                  throw new Error(
                    `Expected Source id to be ${a} instead of ${y.id}`,
                  );
                return y;
              })(e, i, s, this)),
              (this._tiles = {}),
              (this._cache = new Jr(0, (a) => this._unloadTile(a))),
              (this._timers = {}),
              (this._cacheTimers = {}),
              (this._maxTileCacheSize = null),
              (this._maxTileCacheZoomLevels = null),
              (this._loadedParentTiles = {}),
              (this._coveredTiles = {}),
              (this._state = new Gn()),
              (this._didEmitContent = !1),
              (this._updated = !1));
          }
          onAdd(e) {
            ((this.map = e),
              (this._maxTileCacheSize = e ? e._maxTileCacheSize : null),
              (this._maxTileCacheZoomLevels = e
                ? e._maxTileCacheZoomLevels
                : null),
              this._source && this._source.onAdd && this._source.onAdd(e));
          }
          onRemove(e) {
            (this.clearTiles(),
              this._source &&
                this._source.onRemove &&
                this._source.onRemove(e));
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (
              !(
                (this.used === void 0 && this.usedForTerrain === void 0) ||
                this.used ||
                this.usedForTerrain
              )
            )
              return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const i = this._tiles[e];
              if (i.state !== "loaded" && i.state !== "errored") return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            ((this._paused = !1),
              (this._shouldReloadOnResume = !1),
              e && this.reload(),
              this.transform && this.update(this.transform, this.terrain));
          }
          _loadTile(e, i, s) {
            return u._(this, void 0, void 0, function* () {
              try {
                (yield this._source.loadTile(e), this._tileLoaded(e, i, s));
              } catch (a) {
                ((e.state = "errored"),
                  a.status !== 404
                    ? this._source.fire(new u.j(a, { tile: e }))
                    : this.update(this.transform, this.terrain));
              }
            });
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e);
          }
          _abortTile(e) {
            (this._source.abortTile && this._source.abortTile(e),
              this._source.fire(
                new u.k("dataabort", {
                  tile: e,
                  coord: e.tileID,
                  dataType: "source",
                }),
              ));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e) {
            (this._source.prepare && this._source.prepare(),
              this._state.coalesceChanges(
                this._tiles,
                this.map ? this.map.painter : null,
              ));
            for (const i in this._tiles) {
              const s = this._tiles[i];
              (s.upload(e), s.prepare(this.map.style.imageManager));
            }
          }
          getIds() {
            return Object.values(this._tiles)
              .map((e) => e.tileID)
              .sort(z)
              .map((e) => e.key);
          }
          getRenderableIds(e) {
            const i = [];
            for (const s in this._tiles)
              this._isIdRenderable(s, e) && i.push(this._tiles[s]);
            return e
              ? i
                  .sort((s, a) => {
                    const h = s.tileID,
                      f = a.tileID,
                      g = new u.P(h.canonical.x, h.canonical.y)._rotate(
                        -this.transform.bearingInRadians,
                      ),
                      y = new u.P(f.canonical.x, f.canonical.y)._rotate(
                        -this.transform.bearingInRadians,
                      );
                    return (
                      h.overscaledZ - f.overscaledZ || y.y - g.y || y.x - g.x
                    );
                  })
                  .map((s) => s.tileID.key)
              : i
                  .map((s) => s.tileID)
                  .sort(z)
                  .map((s) => s.key);
          }
          hasRenderableParent(e) {
            const i = this.findLoadedParent(e, 0);
            return !!i && this._isIdRenderable(i.tileID.key);
          }
          _isIdRenderable(e, i) {
            return (
              this._tiles[e] &&
              this._tiles[e].hasData() &&
              !this._coveredTiles[e] &&
              (i || !this._tiles[e].holdingForFade())
            );
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const i in this._tiles)
                (e || this._tiles[i].state !== "errored") &&
                  this._reloadTile(i, "reloading");
            }
          }
          _reloadTile(e, i) {
            return u._(this, void 0, void 0, function* () {
              const s = this._tiles[e];
              s &&
                (s.state !== "loading" && (s.state = i),
                yield this._loadTile(s, e, i));
            });
          }
          _tileLoaded(e, i, s) {
            ((e.timeAdded = Qe.now()),
              s === "expired" && (e.refreshedUponExpiration = !0),
              this._setTileReloadTimer(i, e),
              this.getSource().type === "raster-dem" &&
                e.dem &&
                this._backfillDEM(e),
              this._state.initializeTileState(
                e,
                this.map ? this.map.painter : null,
              ),
              e.aborted ||
                this._source.fire(
                  new u.k("data", {
                    dataType: "source",
                    tile: e,
                    coord: e.tileID,
                  }),
                ));
          }
          _backfillDEM(e) {
            const i = this.getRenderableIds();
            for (let a = 0; a < i.length; a++) {
              const h = i[a];
              if (e.neighboringTiles && e.neighboringTiles[h]) {
                const f = this.getTileByID(h);
                (s(e, f), s(f, e));
              }
            }
            function s(a, h) {
              ((a.needsHillshadePrepare = !0), (a.needsTerrainPrepare = !0));
              let f = h.tileID.canonical.x - a.tileID.canonical.x;
              const g = h.tileID.canonical.y - a.tileID.canonical.y,
                y = Math.pow(2, a.tileID.canonical.z),
                v = h.tileID.key;
              (f === 0 && g === 0) ||
                Math.abs(g) > 1 ||
                (Math.abs(f) > 1 &&
                  (Math.abs(f + y) === 1
                    ? (f += y)
                    : Math.abs(f - y) === 1 && (f -= y)),
                h.dem &&
                  a.dem &&
                  (a.dem.backfillBorder(h.dem, f, g),
                  a.neighboringTiles &&
                    a.neighboringTiles[v] &&
                    (a.neighboringTiles[v].backfilled = !0)));
            }
          }
          getTile(e) {
            return this.getTileByID(e.key);
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          _retainLoadedChildren(e, i, s, a) {
            for (const h in this._tiles) {
              let f = this._tiles[h];
              if (
                a[h] ||
                !f.hasData() ||
                f.tileID.overscaledZ <= i ||
                f.tileID.overscaledZ > s
              )
                continue;
              let g = f.tileID;
              for (; f && f.tileID.overscaledZ > i + 1; ) {
                const v = f.tileID.scaledTo(f.tileID.overscaledZ - 1);
                ((f = this._tiles[v.key]), f && f.hasData() && (g = v));
              }
              let y = g;
              for (; y.overscaledZ > i; )
                if (
                  ((y = y.scaledTo(y.overscaledZ - 1)),
                  e[y.key] || e[y.canonical.key])
                ) {
                  a[g.key] = g;
                  break;
                }
            }
          }
          findLoadedParent(e, i) {
            if (e.key in this._loadedParentTiles) {
              const s = this._loadedParentTiles[e.key];
              return s && s.tileID.overscaledZ >= i ? s : null;
            }
            for (let s = e.overscaledZ - 1; s >= i; s--) {
              const a = e.scaledTo(s),
                h = this._getLoadedTile(a);
              if (h) return h;
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e);
          }
          _getLoadedTile(e) {
            const i = this._tiles[e.key];
            return i && i.hasData() ? i : this._cache.getByKey(e.wrapped().key);
          }
          updateCacheSize(e) {
            const i = Math.ceil(e.width / this._source.tileSize) + 1,
              s = Math.ceil(e.height / this._source.tileSize) + 1,
              a = Math.floor(
                i *
                  s *
                  (this._maxTileCacheZoomLevels === null
                    ? u.a.MAX_TILE_CACHE_ZOOM_LEVELS
                    : this._maxTileCacheZoomLevels),
              ),
              h =
                typeof this._maxTileCacheSize == "number"
                  ? Math.min(this._maxTileCacheSize, a)
                  : a;
            this._cache.setMaxSize(h);
          }
          handleWrapJump(e) {
            const i = Math.round(
              (e - (this._prevLng === void 0 ? e : this._prevLng)) / 360,
            );
            if (((this._prevLng = e), i)) {
              const s = {};
              for (const a in this._tiles) {
                const h = this._tiles[a];
                ((h.tileID = h.tileID.unwrapTo(h.tileID.wrap + i)),
                  (s[h.tileID.key] = h));
              }
              this._tiles = s;
              for (const a in this._timers)
                (clearTimeout(this._timers[a]), delete this._timers[a]);
              for (const a in this._tiles)
                this._setTileReloadTimer(a, this._tiles[a]);
            }
          }
          _updateCoveredAndRetainedTiles(e, i, s, a, h, f) {
            const g = {},
              y = {},
              v = Object.keys(e),
              C = Qe.now();
            for (const A of v) {
              const T = e[A],
                M = this._tiles[A];
              if (!M || (M.fadeEndTime !== 0 && M.fadeEndTime <= C)) continue;
              const k = this.findLoadedParent(T, i),
                V = this.findLoadedSibling(T),
                N = k || V || null;
              (N && (this._addTile(N.tileID), (g[N.tileID.key] = N.tileID)),
                (y[A] = T));
            }
            this._retainLoadedChildren(y, a, s, e);
            for (const A in g)
              e[A] || ((this._coveredTiles[A] = !0), (e[A] = g[A]));
            if (f) {
              const A = {},
                T = {};
              for (const M of h)
                this._tiles[M.key].hasData() ? (A[M.key] = M) : (T[M.key] = M);
              for (const M in T) {
                const k = T[M].children(this._source.maxzoom);
                this._tiles[k[0].key] &&
                  this._tiles[k[1].key] &&
                  this._tiles[k[2].key] &&
                  this._tiles[k[3].key] &&
                  ((A[k[0].key] = e[k[0].key] = k[0]),
                  (A[k[1].key] = e[k[1].key] = k[1]),
                  (A[k[2].key] = e[k[2].key] = k[2]),
                  (A[k[3].key] = e[k[3].key] = k[3]),
                  delete T[M]);
              }
              for (const M in T) {
                const k = T[M],
                  V = this.findLoadedParent(k, this._source.minzoom),
                  N = this.findLoadedSibling(k),
                  $ = V || N || null;
                if ($) {
                  A[$.tileID.key] = e[$.tileID.key] = $.tileID;
                  for (const G in A) A[G].isChildOf($.tileID) && delete A[G];
                }
              }
              for (const M in this._tiles) A[M] || (this._coveredTiles[M] = !0);
            }
          }
          update(e, i) {
            if (!this._sourceLoaded || this._paused) return;
            let s;
            ((this.transform = e),
              (this.terrain = i),
              this.updateCacheSize(e),
              this.handleWrapJump(this.transform.center.lng),
              (this._coveredTiles = {}),
              this.used || this.usedForTerrain
                ? this._source.tileID
                  ? (s = e
                      .getVisibleUnwrappedCoordinates(this._source.tileID)
                      .map(
                        (C) =>
                          new u.S(
                            C.canonical.z,
                            C.wrap,
                            C.canonical.z,
                            C.canonical.x,
                            C.canonical.y,
                          ),
                      ))
                  : ((s = j(e, {
                      tileSize: this.usedForTerrain
                        ? this.tileSize
                        : this._source.tileSize,
                      minzoom: this._source.minzoom,
                      maxzoom: this._source.maxzoom,
                      roundZoom: !this.usedForTerrain && this._source.roundZoom,
                      reparseOverscaled: this._source.reparseOverscaled,
                      terrain: i,
                      calculateTileZoom: this._source.calculateTileZoom,
                    })),
                    this._source.hasTile &&
                      (s = s.filter((C) => this._source.hasTile(C))))
                : (s = []));
            const a = Qr(e, this._source),
              h = Math.max(a - B.maxOverzooming, this._source.minzoom),
              f = Math.max(a + B.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const C = {};
              for (const A of s)
                if (A.canonical.z > this._source.minzoom) {
                  const T = A.scaledTo(A.canonical.z - 1);
                  C[T.key] = T;
                  const M = A.scaledTo(
                    Math.max(this._source.minzoom, Math.min(A.canonical.z, 5)),
                  );
                  C[M.key] = M;
                }
              s = s.concat(Object.values(C));
            }
            const g = s.length === 0 && !this._updated && this._didEmitContent;
            ((this._updated = !0),
              g &&
                this.fire(
                  new u.k("data", {
                    sourceDataType: "idle",
                    dataType: "source",
                    sourceId: this.id,
                  }),
                ));
            const y = this._updateRetainedTiles(s, a);
            L(this._source.type) &&
              this._updateCoveredAndRetainedTiles(y, h, f, a, s, i);
            for (const C in y) this._tiles[C].clearFadeHold();
            const v = u.ac(this._tiles, y);
            for (const C of v) {
              const A = this._tiles[C];
              A.hasSymbolBuckets && !A.holdingForFade()
                ? A.setHoldDuration(this.map._fadeDuration)
                : (A.hasSymbolBuckets && !A.symbolFadeFinished()) ||
                  this._removeTile(C);
            }
            (this._updateLoadedParentTileCache(),
              this._updateLoadedSiblingTileCache());
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles)
              this._tiles[e].holdingForFade() && this._removeTile(e);
          }
          _updateRetainedTiles(e, i) {
            var s;
            const a = {},
              h = {},
              f = Math.max(i - B.maxOverzooming, this._source.minzoom),
              g = Math.max(i + B.maxUnderzooming, this._source.minzoom),
              y = {};
            for (const v of e) {
              const C = this._addTile(v);
              ((a[v.key] = v),
                C.hasData() || (i < this._source.maxzoom && (y[v.key] = v)));
            }
            this._retainLoadedChildren(y, i, g, a);
            for (const v of e) {
              let C = this._tiles[v.key];
              if (C.hasData()) continue;
              if (i + 1 > this._source.maxzoom) {
                const T = v.children(this._source.maxzoom)[0],
                  M = this.getTile(T);
                if (M && M.hasData()) {
                  a[T.key] = T;
                  continue;
                }
              } else {
                const T = v.children(this._source.maxzoom);
                if (a[T[0].key] && a[T[1].key] && a[T[2].key] && a[T[3].key])
                  continue;
              }
              let A = C.wasRequested();
              for (let T = v.overscaledZ - 1; T >= f; --T) {
                const M = v.scaledTo(T);
                if (h[M.key]) break;
                if (
                  ((h[M.key] = !0),
                  (C = this.getTile(M)),
                  !C && A && (C = this._addTile(M)),
                  C)
                ) {
                  const k = C.hasData();
                  if (
                    ((k ||
                      !(
                        !((s = this.map) === null || s === void 0) &&
                        s.cancelPendingTileRequestsWhileZooming
                      ) ||
                      A) &&
                      (a[M.key] = M),
                    (A = C.wasRequested()),
                    k)
                  )
                    break;
                }
              }
            }
            return a;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const i = [];
              let s,
                a = this._tiles[e].tileID;
              for (; a.overscaledZ > 0; ) {
                if (a.key in this._loadedParentTiles) {
                  s = this._loadedParentTiles[a.key];
                  break;
                }
                i.push(a.key);
                const h = a.scaledTo(a.overscaledZ - 1);
                if (((s = this._getLoadedTile(h)), s)) break;
                a = h;
              }
              for (const h of i) this._loadedParentTiles[h] = s;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const i = this._tiles[e].tileID,
                s = this._getLoadedTile(i);
              this._loadedSiblingTiles[i.key] = s;
            }
          }
          _addTile(e) {
            let i = this._tiles[e.key];
            if (i) return i;
            ((i = this._cache.getAndRemove(e)),
              i &&
                (this._setTileReloadTimer(e.key, i),
                (i.tileID = e),
                this._state.initializeTileState(
                  i,
                  this.map ? this.map.painter : null,
                ),
                this._cacheTimers[e.key] &&
                  (clearTimeout(this._cacheTimers[e.key]),
                  delete this._cacheTimers[e.key],
                  this._setTileReloadTimer(e.key, i))));
            const s = i;
            return (
              i ||
                ((i = new wn(e, this._source.tileSize * e.overscaleFactor())),
                this._loadTile(i, e.key, i.state)),
              i.uses++,
              (this._tiles[e.key] = i),
              s ||
                this._source.fire(
                  new u.k("dataloading", {
                    tile: i,
                    coord: i.tileID,
                    dataType: "source",
                  }),
                ),
              i
            );
          }
          _setTileReloadTimer(e, i) {
            e in this._timers &&
              (clearTimeout(this._timers[e]), delete this._timers[e]);
            const s = i.getExpiryTimeout();
            s &&
              (this._timers[e] = setTimeout(() => {
                (this._reloadTile(e, "expired"), delete this._timers[e]);
              }, s));
          }
          _removeTile(e) {
            const i = this._tiles[e];
            i &&
              (i.uses--,
              delete this._tiles[e],
              this._timers[e] &&
                (clearTimeout(this._timers[e]), delete this._timers[e]),
              i.uses > 0 ||
                (i.hasData() && i.state !== "reloading"
                  ? this._cache.add(i.tileID, i, i.getExpiryTimeout())
                  : ((i.aborted = !0),
                    this._abortTile(i),
                    this._unloadTile(i))));
          }
          _dataHandler(e) {
            const i = e.sourceDataType;
            (e.dataType === "source" &&
              i === "metadata" &&
              (this._sourceLoaded = !0),
              this._sourceLoaded &&
                !this._paused &&
                e.dataType === "source" &&
                i === "content" &&
                (this.reload(e.sourceDataChanged),
                this.transform && this.update(this.transform, this.terrain),
                (this._didEmitContent = !0)));
          }
          clearTiles() {
            ((this._shouldReloadOnResume = !1), (this._paused = !1));
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset();
          }
          tilesIn(e, i, s) {
            const a = [],
              h = this.transform;
            if (!h) return a;
            const f = s ? h.getCameraQueryGeometry(e) : e,
              g = e.map((k) =>
                h.screenPointToMercatorCoordinate(k, this.terrain),
              ),
              y = f.map((k) =>
                h.screenPointToMercatorCoordinate(k, this.terrain),
              ),
              v = this.getIds();
            let C = 1 / 0,
              A = 1 / 0,
              T = -1 / 0,
              M = -1 / 0;
            for (const k of y)
              ((C = Math.min(C, k.x)),
                (A = Math.min(A, k.y)),
                (T = Math.max(T, k.x)),
                (M = Math.max(M, k.y)));
            for (let k = 0; k < v.length; k++) {
              const V = this._tiles[v[k]];
              if (V.holdingForFade()) continue;
              const N = V.tileID,
                $ = Math.pow(2, h.zoom - V.tileID.overscaledZ),
                G = (i * V.queryPadding * u.X) / V.tileSize / $,
                Y = [
                  N.getTilePoint(new u.Y(C, A)),
                  N.getTilePoint(new u.Y(T, M)),
                ];
              if (
                Y[0].x - G < u.X &&
                Y[0].y - G < u.X &&
                Y[1].x + G >= 0 &&
                Y[1].y + G >= 0
              ) {
                const Q = g.map((re) => N.getTilePoint(re)),
                  ee = y.map((re) => N.getTilePoint(re));
                a.push({
                  tile: V,
                  tileID: N,
                  queryGeometry: Q,
                  cameraQueryGeometry: ee,
                  scale: $,
                });
              }
            }
            return a;
          }
          getVisibleCoordinates(e) {
            const i = this.getRenderableIds(e).map(
              (s) => this._tiles[s].tileID,
            );
            return (this.transform && this.transform.populateCache(i), i);
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (L(this._source.type)) {
              const e = Qe.now();
              for (const i in this._tiles)
                if (this._tiles[i].fadeEndTime >= e) return !0;
            }
            return !1;
          }
          setFeatureState(e, i, s) {
            this._state.updateState((e = e || "_geojsonTileLayer"), i, s);
          }
          removeFeatureState(e, i, s) {
            this._state.removeFeatureState(
              (e = e || "_geojsonTileLayer"),
              i,
              s,
            );
          }
          getFeatureState(e, i) {
            return this._state.getState((e = e || "_geojsonTileLayer"), i);
          }
          setDependencies(e, i, s) {
            const a = this._tiles[e];
            a && a.setDependencies(i, s);
          }
          reloadTilesForDependencies(e, i) {
            for (const s in this._tiles)
              this._tiles[s].hasDependency(e, i) &&
                this._reloadTile(s, "reloading");
            this._cache.filter((s) => !s.hasDependency(e, i));
          }
        }
        function z(c, e) {
          const i = Math.abs(2 * c.wrap) - +(c.wrap < 0),
            s = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return (
            c.overscaledZ - e.overscaledZ ||
            s - i ||
            e.canonical.y - c.canonical.y ||
            e.canonical.x - c.canonical.x
          );
        }
        function L(c) {
          return c === "raster" || c === "image" || c === "video";
        }
        ((B.maxOverzooming = 10), (B.maxUnderzooming = 3));
        class q {
          constructor(e, i) {
            this.reset(e, i);
          }
          reset(e, i) {
            ((this.points = e || []), (this._distances = [0]));
            for (let s = 1; s < this.points.length; s++)
              this._distances[s] =
                this._distances[s - 1] +
                this.points[s].dist(this.points[s - 1]);
            ((this.length = this._distances[this._distances.length - 1]),
              (this.padding = Math.min(i || 0, 0.5 * this.length)),
              (this.paddedLength = this.length - 2 * this.padding));
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = u.ab(e, 0, 1);
            let i = 1,
              s = this._distances[i];
            const a = e * this.paddedLength + this.padding;
            for (; s < a && i < this._distances.length; )
              s = this._distances[++i];
            const h = i - 1,
              f = this._distances[h],
              g = s - f,
              y = g > 0 ? (a - f) / g : 0;
            return this.points[h].mult(1 - y).add(this.points[i].mult(y));
          }
        }
        function te(c, e) {
          let i = !0;
          return (
            c === "always" || (c !== "never" && e !== "never") || (i = !1),
            i
          );
        }
        class ue {
          constructor(e, i, s) {
            const a = (this.boxCells = []),
              h = (this.circleCells = []);
            ((this.xCellCount = Math.ceil(e / s)),
              (this.yCellCount = Math.ceil(i / s)));
            for (let f = 0; f < this.xCellCount * this.yCellCount; f++)
              (a.push([]), h.push([]));
            ((this.circleKeys = []),
              (this.boxKeys = []),
              (this.bboxes = []),
              (this.circles = []),
              (this.width = e),
              (this.height = i),
              (this.xScale = this.xCellCount / e),
              (this.yScale = this.yCellCount / i),
              (this.boxUid = 0),
              (this.circleUid = 0));
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e, i, s, a, h) {
            (this._forEachCell(i, s, a, h, this._insertBoxCell, this.boxUid++),
              this.boxKeys.push(e),
              this.bboxes.push(i),
              this.bboxes.push(s),
              this.bboxes.push(a),
              this.bboxes.push(h));
          }
          insertCircle(e, i, s, a) {
            (this._forEachCell(
              i - a,
              s - a,
              i + a,
              s + a,
              this._insertCircleCell,
              this.circleUid++,
            ),
              this.circleKeys.push(e),
              this.circles.push(i),
              this.circles.push(s),
              this.circles.push(a));
          }
          _insertBoxCell(e, i, s, a, h, f) {
            this.boxCells[h].push(f);
          }
          _insertCircleCell(e, i, s, a, h, f) {
            this.circleCells[h].push(f);
          }
          _query(e, i, s, a, h, f, g) {
            if (s < 0 || e > this.width || a < 0 || i > this.height) return [];
            const y = [];
            if (e <= 0 && i <= 0 && this.width <= s && this.height <= a) {
              if (h) return [{ key: null, x1: e, y1: i, x2: s, y2: a }];
              for (let v = 0; v < this.boxKeys.length; v++)
                y.push({
                  key: this.boxKeys[v],
                  x1: this.bboxes[4 * v],
                  y1: this.bboxes[4 * v + 1],
                  x2: this.bboxes[4 * v + 2],
                  y2: this.bboxes[4 * v + 3],
                });
              for (let v = 0; v < this.circleKeys.length; v++) {
                const C = this.circles[3 * v],
                  A = this.circles[3 * v + 1],
                  T = this.circles[3 * v + 2];
                y.push({
                  key: this.circleKeys[v],
                  x1: C - T,
                  y1: A - T,
                  x2: C + T,
                  y2: A + T,
                });
              }
            } else
              this._forEachCell(
                e,
                i,
                s,
                a,
                this._queryCell,
                y,
                {
                  hitTest: h,
                  overlapMode: f,
                  seenUids: { box: {}, circle: {} },
                },
                g,
              );
            return y;
          }
          query(e, i, s, a) {
            return this._query(e, i, s, a, !1, null);
          }
          hitTest(e, i, s, a, h, f) {
            return this._query(e, i, s, a, !0, h, f).length > 0;
          }
          hitTestCircle(e, i, s, a, h) {
            const f = e - s,
              g = e + s,
              y = i - s,
              v = i + s;
            if (g < 0 || f > this.width || v < 0 || y > this.height) return !1;
            const C = [];
            return (
              this._forEachCell(
                f,
                y,
                g,
                v,
                this._queryCellCircle,
                C,
                {
                  hitTest: !0,
                  overlapMode: a,
                  circle: { x: e, y: i, radius: s },
                  seenUids: { box: {}, circle: {} },
                },
                h,
              ),
              C.length > 0
            );
          }
          _queryCell(e, i, s, a, h, f, g, y) {
            const { seenUids: v, hitTest: C, overlapMode: A } = g,
              T = this.boxCells[h];
            if (T !== null) {
              const k = this.bboxes;
              for (const V of T)
                if (!v.box[V]) {
                  v.box[V] = !0;
                  const N = 4 * V,
                    $ = this.boxKeys[V];
                  if (
                    e <= k[N + 2] &&
                    i <= k[N + 3] &&
                    s >= k[N + 0] &&
                    a >= k[N + 1] &&
                    (!y || y($)) &&
                    (!C || !te(A, $.overlapMode)) &&
                    (f.push({
                      key: $,
                      x1: k[N],
                      y1: k[N + 1],
                      x2: k[N + 2],
                      y2: k[N + 3],
                    }),
                    C)
                  )
                    return !0;
                }
            }
            const M = this.circleCells[h];
            if (M !== null) {
              const k = this.circles;
              for (const V of M)
                if (!v.circle[V]) {
                  v.circle[V] = !0;
                  const N = 3 * V,
                    $ = this.circleKeys[V];
                  if (
                    this._circleAndRectCollide(
                      k[N],
                      k[N + 1],
                      k[N + 2],
                      e,
                      i,
                      s,
                      a,
                    ) &&
                    (!y || y($)) &&
                    (!C || !te(A, $.overlapMode))
                  ) {
                    const G = k[N],
                      Y = k[N + 1],
                      Q = k[N + 2];
                    if (
                      (f.push({
                        key: $,
                        x1: G - Q,
                        y1: Y - Q,
                        x2: G + Q,
                        y2: Y + Q,
                      }),
                      C)
                    )
                      return !0;
                  }
                }
            }
            return !1;
          }
          _queryCellCircle(e, i, s, a, h, f, g, y) {
            const { circle: v, seenUids: C, overlapMode: A } = g,
              T = this.boxCells[h];
            if (T !== null) {
              const k = this.bboxes;
              for (const V of T)
                if (!C.box[V]) {
                  C.box[V] = !0;
                  const N = 4 * V,
                    $ = this.boxKeys[V];
                  if (
                    this._circleAndRectCollide(
                      v.x,
                      v.y,
                      v.radius,
                      k[N + 0],
                      k[N + 1],
                      k[N + 2],
                      k[N + 3],
                    ) &&
                    (!y || y($)) &&
                    !te(A, $.overlapMode)
                  )
                    return (f.push(!0), !0);
                }
            }
            const M = this.circleCells[h];
            if (M !== null) {
              const k = this.circles;
              for (const V of M)
                if (!C.circle[V]) {
                  C.circle[V] = !0;
                  const N = 3 * V,
                    $ = this.circleKeys[V];
                  if (
                    this._circlesCollide(
                      k[N],
                      k[N + 1],
                      k[N + 2],
                      v.x,
                      v.y,
                      v.radius,
                    ) &&
                    (!y || y($)) &&
                    !te(A, $.overlapMode)
                  )
                    return (f.push(!0), !0);
                }
            }
          }
          _forEachCell(e, i, s, a, h, f, g, y) {
            const v = this._convertToXCellCoord(e),
              C = this._convertToYCellCoord(i),
              A = this._convertToXCellCoord(s),
              T = this._convertToYCellCoord(a);
            for (let M = v; M <= A; M++)
              for (let k = C; k <= T; k++)
                if (h.call(this, e, i, s, a, this.xCellCount * k + M, f, g, y))
                  return;
          }
          _convertToXCellCoord(e) {
            return Math.max(
              0,
              Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)),
            );
          }
          _convertToYCellCoord(e) {
            return Math.max(
              0,
              Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)),
            );
          }
          _circlesCollide(e, i, s, a, h, f) {
            const g = a - e,
              y = h - i,
              v = s + f;
            return v * v > g * g + y * y;
          }
          _circleAndRectCollide(e, i, s, a, h, f, g) {
            const y = (f - a) / 2,
              v = Math.abs(e - (a + y));
            if (v > y + s) return !1;
            const C = (g - h) / 2,
              A = Math.abs(i - (h + C));
            if (A > C + s) return !1;
            if (v <= y || A <= C) return !0;
            const T = v - y,
              M = A - C;
            return T * T + M * M <= s * s;
          }
        }
        function fe(c, e, i) {
          const s = u.H();
          if (!c) {
            const { vecSouth: A, vecEast: T } = ve(e),
              M = rt();
            ((M[0] = T[0]),
              (M[1] = T[1]),
              (M[2] = A[0]),
              (M[3] = A[1]),
              (a = M),
              (C = (f = (h = M)[0]) * (v = h[3]) - (y = h[2]) * (g = h[1])) &&
                ((a[0] = v * (C = 1 / C)),
                (a[1] = -g * C),
                (a[2] = -y * C),
                (a[3] = f * C)),
              (s[0] = M[0]),
              (s[1] = M[1]),
              (s[4] = M[2]),
              (s[5] = M[3]));
          }
          var a, h, f, g, y, v, C;
          return (u.K(s, s, [1 / i, 1 / i, 1]), s);
        }
        function ae(c, e, i, s) {
          if (c) {
            const a = u.H();
            if (!e) {
              const { vecSouth: h, vecEast: f } = ve(i);
              ((a[0] = f[0]), (a[1] = f[1]), (a[4] = h[0]), (a[5] = h[1]));
            }
            return (u.K(a, a, [s, s, 1]), a);
          }
          return i.pixelsToClipSpaceMatrix;
        }
        function ve(c) {
          const e = Math.cos(c.rollInRadians),
            i = Math.sin(c.rollInRadians),
            s = Math.cos(c.pitchInRadians),
            a = Math.cos(c.bearingInRadians),
            h = Math.sin(c.bearingInRadians),
            f = u.ad();
          ((f[0] = -a * s * i - h * e), (f[1] = -h * s * i + a * e));
          const g = u.ae(f);
          g < 1e-9 ? u.af(f) : u.ag(f, f, 1 / g);
          const y = u.ad();
          ((y[0] = a * s * e - h * i), (y[1] = h * s * e + a * i));
          const v = u.ae(y);
          return (
            v < 1e-9 ? u.af(y) : u.ag(y, y, 1 / v),
            { vecEast: y, vecSouth: f }
          );
        }
        function _e(c, e, i, s) {
          let a;
          s
            ? ((a = [c, e, s(c, e), 1]), u.al(a, a, i))
            : ((a = [c, e, 0, 1]), ni(a, a, i));
          const h = a[3];
          return {
            point: new u.P(a[0] / h, a[1] / h),
            signedDistanceFromCamera: h,
            isOccluded: !1,
          };
        }
        function ce(c, e) {
          return 0.5 + (c / e) * 0.5;
        }
        function oe(c, e) {
          return c.x >= -e[0] && c.x <= e[0] && c.y >= -e[1] && c.y <= e[1];
        }
        function ke(c, e, i, s, a, h, f, g, y, v, C, A, T) {
          const M = i ? c.textSizeData : c.iconSizeData,
            k = u.ah(M, e.transform.zoom),
            V = [(256 / e.width) * 2 + 1, (256 / e.height) * 2 + 1],
            N = i
              ? c.text.dynamicLayoutVertexArray
              : c.icon.dynamicLayoutVertexArray;
          N.clear();
          const $ = c.lineVertexArray,
            G = i ? c.text.placedSymbolArray : c.icon.placedSymbolArray,
            Y = e.transform.width / e.transform.height;
          let Q = !1;
          for (let ee = 0; ee < G.length; ee++) {
            const re = G.get(ee);
            if (re.hidden || (re.writingMode === u.ai.vertical && !Q)) {
              ci(re.numGlyphs, N);
              continue;
            }
            Q = !1;
            const ie = new u.P(re.anchorX, re.anchorY),
              he = {
                getElevation: T,
                pitchedLabelPlaneMatrix: s,
                lineVertexArray: $,
                pitchWithMap: h,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1,
                },
                transform: e.transform,
                tileAnchorPoint: ie,
                unwrappedTileID: y,
                width: v,
                height: C,
                translation: A,
              },
              pe = mt(re.anchorX, re.anchorY, he);
            if (!oe(pe.point, V)) {
              ci(re.numGlyphs, N);
              continue;
            }
            const be = ce(
                e.transform.cameraToCenterDistance,
                pe.signedDistanceFromCamera,
              ),
              Ee = u.aj(M, k, re),
              ye = h
                ? (Ee *
                    e.transform.getPitchedTextCorrection(
                      re.anchorX,
                      re.anchorY,
                      y,
                    )) /
                  be
                : Ee * be,
              Be = nt({
                projectionContext: he,
                pitchedLabelPlaneMatrixInverse: a,
                symbol: re,
                fontSize: ye,
                flip: !1,
                keepUpright: f,
                glyphOffsetArray: c.glyphOffsetArray,
                dynamicLayoutVertexArray: N,
                aspectRatio: Y,
                rotateToLine: g,
              });
            ((Q = Be.useVertical),
              (Be.notEnoughRoom ||
                Q ||
                (Be.needsFlipping &&
                  nt({
                    projectionContext: he,
                    pitchedLabelPlaneMatrixInverse: a,
                    symbol: re,
                    fontSize: ye,
                    flip: !0,
                    keepUpright: f,
                    glyphOffsetArray: c.glyphOffsetArray,
                    dynamicLayoutVertexArray: N,
                    aspectRatio: Y,
                    rotateToLine: g,
                  }).notEnoughRoom)) &&
                ci(re.numGlyphs, N));
          }
          i
            ? c.text.dynamicLayoutVertexBuffer.updateData(N)
            : c.icon.dynamicLayoutVertexBuffer.updateData(N);
        }
        function Ie(c, e, i, s, a, h, f, g) {
          const y = h.glyphStartIndex + h.numGlyphs,
            v = h.lineStartIndex,
            C = h.lineStartIndex + h.lineLength,
            A = e.getoffsetX(h.glyphStartIndex),
            T = e.getoffsetX(y - 1),
            M = Ht(c * A, i, s, a, h.segment, v, C, g, f);
          if (!M) return null;
          const k = Ht(c * T, i, s, a, h.segment, v, C, g, f);
          return k
            ? g.projectionCache.anyProjectionOccluded
              ? null
              : { first: M, last: k }
            : null;
        }
        function Je(c, e, i, s) {
          return c === u.ai.horizontal &&
            Math.abs(i.y - e.y) > Math.abs(i.x - e.x) * s
            ? { useVertical: !0 }
            : (c === u.ai.vertical ? e.y < i.y : e.x > i.x)
              ? { needsFlipping: !0 }
              : null;
        }
        function nt(c) {
          const {
              projectionContext: e,
              pitchedLabelPlaneMatrixInverse: i,
              symbol: s,
              fontSize: a,
              flip: h,
              keepUpright: f,
              glyphOffsetArray: g,
              dynamicLayoutVertexArray: y,
              aspectRatio: v,
              rotateToLine: C,
            } = c,
            A = a / 24,
            T = s.lineOffsetX * A,
            M = s.lineOffsetY * A;
          let k;
          if (s.numGlyphs > 1) {
            const V = s.glyphStartIndex + s.numGlyphs,
              N = s.lineStartIndex,
              $ = s.lineStartIndex + s.lineLength,
              G = Ie(A, g, T, M, h, s, C, e);
            if (!G) return { notEnoughRoom: !0 };
            const Y = lt(G.first.point.x, G.first.point.y, e, i),
              Q = lt(G.last.point.x, G.last.point.y, e, i);
            if (f && !h) {
              const ee = Je(s.writingMode, Y, Q, v);
              if (ee) return ee;
            }
            k = [G.first];
            for (let ee = s.glyphStartIndex + 1; ee < V - 1; ee++)
              k.push(Ht(A * g.getoffsetX(ee), T, M, h, s.segment, N, $, e, C));
            k.push(G.last);
          } else {
            if (f && !h) {
              const N = Ve(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                $ = s.lineStartIndex + s.segment + 1,
                G = new u.P(
                  e.lineVertexArray.getx($),
                  e.lineVertexArray.gety($),
                ),
                Y = Ve(G.x, G.y, e),
                Q =
                  Y.signedDistanceFromCamera > 0
                    ? Y.point
                    : Ce(e.tileAnchorPoint, G, N, 1, e),
                ee = lt(N.x, N.y, e, i),
                re = lt(Q.x, Q.y, e, i),
                ie = Je(s.writingMode, ee, re, v);
              if (ie) return ie;
            }
            const V = Ht(
              A * g.getoffsetX(s.glyphStartIndex),
              T,
              M,
              h,
              s.segment,
              s.lineStartIndex,
              s.lineStartIndex + s.lineLength,
              e,
              C,
            );
            if (!V || e.projectionCache.anyProjectionOccluded)
              return { notEnoughRoom: !0 };
            k = [V];
          }
          for (const V of k) u.ak(y, V.point, V.angle);
          return {};
        }
        function Ce(c, e, i, s, a) {
          const h = c.add(c.sub(e)._unit()),
            f = Ve(h.x, h.y, a).point,
            g = i.sub(f);
          return i.add(g._mult(s / g.mag()));
        }
        function ze(c, e, i) {
          const s = e.projectionCache;
          if (s.projections[c]) return s.projections[c];
          const a = new u.P(
              e.lineVertexArray.getx(c),
              e.lineVertexArray.gety(c),
            ),
            h = Ve(a.x, a.y, e);
          if (h.signedDistanceFromCamera > 0)
            return (
              (s.projections[c] = h.point),
              (s.anyProjectionOccluded =
                s.anyProjectionOccluded || h.isOccluded),
              h.point
            );
          const f = c - i.direction;
          return Ce(
            i.distanceFromAnchor === 0
              ? e.tileAnchorPoint
              : new u.P(e.lineVertexArray.getx(f), e.lineVertexArray.gety(f)),
            a,
            i.previousVertex,
            i.absOffsetX - i.distanceFromAnchor + 1,
            e,
          );
        }
        function Ve(c, e, i) {
          const s = c + i.translation[0],
            a = e + i.translation[1];
          let h;
          return (
            i.pitchWithMap
              ? ((h = _e(s, a, i.pitchedLabelPlaneMatrix, i.getElevation)),
                (h.isOccluded = !1))
              : ((h = i.transform.projectTileCoordinates(
                  s,
                  a,
                  i.unwrappedTileID,
                  i.getElevation,
                )),
                (h.point.x = (0.5 * h.point.x + 0.5) * i.width),
                (h.point.y = (0.5 * -h.point.y + 0.5) * i.height)),
            h
          );
        }
        function lt(c, e, i, s) {
          if (i.pitchWithMap) {
            const a = [c, e, 0, 1];
            return (
              u.al(a, a, s),
              i.transform.projectTileCoordinates(
                a[0] / a[3],
                a[1] / a[3],
                i.unwrappedTileID,
                i.getElevation,
              ).point
            );
          }
          return { x: (c / i.width) * 2 - 1, y: (e / i.height) * 2 - 1 };
        }
        function mt(c, e, i) {
          return i.transform.projectTileCoordinates(
            c,
            e,
            i.unwrappedTileID,
            i.getElevation,
          );
        }
        function it(c, e, i) {
          return c
            ._unit()
            ._perp()
            ._mult(e * i);
        }
        function je(c, e, i, s, a, h, f, g, y) {
          if (g.projectionCache.offsets[c]) return g.projectionCache.offsets[c];
          const v = i.add(e);
          if (c + y.direction < s || c + y.direction >= a)
            return ((g.projectionCache.offsets[c] = v), v);
          const C = ze(c + y.direction, g, y),
            A = it(C.sub(i), f, y.direction),
            T = i.add(A),
            M = C.add(A);
          return (
            (g.projectionCache.offsets[c] = u.am(h, v, T, M) || v),
            g.projectionCache.offsets[c]
          );
        }
        function Ht(c, e, i, s, a, h, f, g, y) {
          const v = s ? c - e : c + e;
          let C = v > 0 ? 1 : -1,
            A = 0;
          (s && ((C *= -1), (A = Math.PI)), C < 0 && (A += Math.PI));
          let T,
            M = C > 0 ? h + a : h + a + 1;
          g.projectionCache.cachedAnchorPoint
            ? (T = g.projectionCache.cachedAnchorPoint)
            : ((T = Ve(g.tileAnchorPoint.x, g.tileAnchorPoint.y, g).point),
              (g.projectionCache.cachedAnchorPoint = T));
          let k,
            V,
            N = T,
            $ = T,
            G = 0,
            Y = 0;
          const Q = Math.abs(v),
            ee = [];
          let re;
          for (; G + Y <= Q; ) {
            if (((M += C), M < h || M >= f)) return null;
            ((G += Y), ($ = N), (V = k));
            const pe = {
              absOffsetX: Q,
              direction: C,
              distanceFromAnchor: G,
              previousVertex: $,
            };
            if (((N = ze(M, g, pe)), i === 0)) (ee.push($), (re = N.sub($)));
            else {
              let be;
              const Ee = N.sub($);
              ((be =
                Ee.mag() === 0
                  ? it(ze(M + C, g, pe).sub(N), i, C)
                  : it(Ee, i, C)),
                V || (V = $.add(be)),
                (k = je(M, be, N, h, f, V, i, g, pe)),
                ee.push(V),
                (re = k.sub(V)));
            }
            Y = re.mag();
          }
          const ie = re._mult((Q - G) / Y)._add(V || $),
            he = A + Math.atan2(N.y - $.y, N.x - $.x);
          return (ee.push(ie), { point: ie, angle: y ? he : 0, path: ee });
        }
        const en = new Float32Array([
          -1 / 0,
          -1 / 0,
          0,
          -1 / 0,
          -1 / 0,
          0,
          -1 / 0,
          -1 / 0,
          0,
          -1 / 0,
          -1 / 0,
          0,
        ]);
        function ci(c, e) {
          for (let i = 0; i < c; i++) {
            const s = e.length;
            (e.resize(s + 4), e.float32.set(en, 3 * s));
          }
        }
        function ni(c, e, i) {
          const s = e[0],
            a = e[1];
          return (
            (c[0] = i[0] * s + i[4] * a + i[12]),
            (c[1] = i[1] * s + i[5] * a + i[13]),
            (c[3] = i[3] * s + i[7] * a + i[15]),
            c
          );
        }
        const kt = 100;
        class Qi {
          constructor(
            e,
            i = new ue(e.width + 200, e.height + 200, 25),
            s = new ue(e.width + 200, e.height + 200, 25),
          ) {
            ((this.transform = e),
              (this.grid = i),
              (this.ignoredGrid = s),
              (this.pitchFactor =
                Math.cos((e.pitch * Math.PI) / 180) * e.cameraToCenterDistance),
              (this.screenRightBoundary = e.width + kt),
              (this.screenBottomBoundary = e.height + kt),
              (this.gridRightBoundary = e.width + 200),
              (this.gridBottomBoundary = e.height + 200),
              (this.perspectiveRatioCutoff = 0.6));
          }
          placeCollisionBox(e, i, s, a, h, f, g, y, v, C, A, T) {
            const M = this.projectAndGetPerspectiveRatio(
                e.anchorPointX + y[0],
                e.anchorPointY + y[1],
                h,
                C,
                T,
              ),
              k = s * M.perspectiveRatio;
            let V;
            if (f || g)
              V = this._projectCollisionBox(e, k, a, h, f, g, y, M, C, A, T);
            else {
              const re = M.x + (A ? A.x * k : 0),
                ie = M.y + (A ? A.y * k : 0);
              V = {
                allPointsOccluded: !1,
                box: [
                  re + e.x1 * k,
                  ie + e.y1 * k,
                  re + e.x2 * k,
                  ie + e.y2 * k,
                ],
              };
            }
            const [N, $, G, Y] = V.box,
              Q = f ? V.allPointsOccluded : M.isOccluded;
            let ee = Q;
            return (
              ee || (ee = M.perspectiveRatio < this.perspectiveRatioCutoff),
              ee || (ee = !this.isInsideGrid(N, $, G, Y)),
              ee || (i !== "always" && this.grid.hitTest(N, $, G, Y, i, v))
                ? {
                    box: [N, $, G, Y],
                    placeable: !1,
                    offscreen: !1,
                    occluded: Q,
                  }
                : {
                    box: [N, $, G, Y],
                    placeable: !0,
                    offscreen: this.isOffscreen(N, $, G, Y),
                    occluded: Q,
                  }
            );
          }
          placeCollisionCircles(e, i, s, a, h, f, g, y, v, C, A, T, M, k) {
            const V = [],
              N = new u.P(i.anchorX, i.anchorY),
              $ = this.getPerspectiveRatio(N.x, N.y, f, k),
              G =
                (v
                  ? (h *
                      this.transform.getPitchedTextCorrection(
                        i.anchorX,
                        i.anchorY,
                        f,
                      )) /
                    $
                  : h * $) / u.as,
              Y = {
                getElevation: k,
                pitchedLabelPlaneMatrix: g,
                lineVertexArray: s,
                pitchWithMap: v,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1,
                },
                transform: this.transform,
                tileAnchorPoint: N,
                unwrappedTileID: f,
                width: this.transform.width,
                height: this.transform.height,
                translation: M,
              },
              Q = Ie(G, a, i.lineOffsetX * G, i.lineOffsetY * G, !1, i, !1, Y);
            let ee = !1,
              re = !1,
              ie = !0;
            if (Q) {
              const he = 0.5 * A * $ + T,
                pe = new u.P(-100, -100),
                be = new u.P(
                  this.screenRightBoundary,
                  this.screenBottomBoundary,
                ),
                Ee = new q(),
                ye = Q.first,
                Be = Q.last;
              let Me = [];
              for (let st = ye.path.length - 1; st >= 1; st--)
                Me.push(ye.path[st]);
              for (let st = 1; st < Be.path.length; st++) Me.push(Be.path[st]);
              const Fe = 2.5 * he;
              if (v) {
                const st = this.projectPathToScreenSpace(Me, Y);
                Me = st.some((gt) => gt.signedDistanceFromCamera <= 0)
                  ? []
                  : st.map((gt) => gt.point);
              }
              let Le = [];
              if (Me.length > 0) {
                const st = Me[0].clone(),
                  gt = Me[0].clone();
                for (let Nt = 1; Nt < Me.length; Nt++)
                  ((st.x = Math.min(st.x, Me[Nt].x)),
                    (st.y = Math.min(st.y, Me[Nt].y)),
                    (gt.x = Math.max(gt.x, Me[Nt].x)),
                    (gt.y = Math.max(gt.y, Me[Nt].y)));
                Le =
                  st.x >= pe.x && gt.x <= be.x && st.y >= pe.y && gt.y <= be.y
                    ? [Me]
                    : gt.x < pe.x || st.x > be.x || gt.y < pe.y || st.y > be.y
                      ? []
                      : u.ao([Me], pe.x, pe.y, be.x, be.y);
              }
              for (const st of Le) {
                Ee.reset(st, 0.25 * he);
                let gt = 0;
                gt =
                  Ee.length <= 0.5 * he
                    ? 1
                    : Math.ceil(Ee.paddedLength / Fe) + 1;
                for (let Nt = 0; Nt < gt; Nt++) {
                  const Tt = Nt / Math.max(gt - 1, 1),
                    Vt = Ee.lerp(Tt),
                    Ft = Vt.x + kt,
                    At = Vt.y + kt;
                  V.push(Ft, At, he, 0);
                  const Pt = Ft - he,
                    vi = At - he,
                    si = Ft + he,
                    ai = At + he;
                  if (
                    ((ie = ie && this.isOffscreen(Pt, vi, si, ai)),
                    (re = re || this.isInsideGrid(Pt, vi, si, ai)),
                    e !== "always" &&
                      this.grid.hitTestCircle(Ft, At, he, e, C) &&
                      ((ee = !0), !y))
                  )
                    return {
                      circles: [],
                      offscreen: !1,
                      collisionDetected: ee,
                    };
                }
              }
            }
            return {
              circles:
                (!y && ee) || !re || $ < this.perspectiveRatioCutoff ? [] : V,
              offscreen: ie,
              collisionDetected: ee,
            };
          }
          projectPathToScreenSpace(e, i) {
            const s = (function (a, h) {
              const f = u.H();
              return (
                u.an(f, h.pitchedLabelPlaneMatrix),
                a.map((g) => {
                  const y = _e(g.x, g.y, f, h.getElevation),
                    v = h.transform.projectTileCoordinates(
                      y.point.x,
                      y.point.y,
                      h.unwrappedTileID,
                      h.getElevation,
                    );
                  return (
                    (v.point.x = (0.5 * v.point.x + 0.5) * h.width),
                    (v.point.y = (0.5 * -v.point.y + 0.5) * h.height),
                    v
                  );
                })
              );
            })(e, i);
            return (function (a) {
              let h = 0,
                f = 0,
                g = 0,
                y = 0;
              for (let v = 0; v < a.length; v++)
                a[v].isOccluded
                  ? ((g = v + 1), (y = 0))
                  : (y++, y > f && ((f = y), (h = g)));
              return a.slice(h, h + f);
            })(s);
          }
          queryRenderedSymbols(e) {
            if (
              e.length === 0 ||
              (this.grid.keysLength() === 0 &&
                this.ignoredGrid.keysLength() === 0)
            )
              return {};
            const i = [];
            let s = 1 / 0,
              a = 1 / 0,
              h = -1 / 0,
              f = -1 / 0;
            for (const C of e) {
              const A = new u.P(C.x + kt, C.y + kt);
              ((s = Math.min(s, A.x)),
                (a = Math.min(a, A.y)),
                (h = Math.max(h, A.x)),
                (f = Math.max(f, A.y)),
                i.push(A));
            }
            const g = this.grid
                .query(s, a, h, f)
                .concat(this.ignoredGrid.query(s, a, h, f)),
              y = {},
              v = {};
            for (const C of g) {
              const A = C.key;
              if (
                (y[A.bucketInstanceId] === void 0 &&
                  (y[A.bucketInstanceId] = {}),
                y[A.bucketInstanceId][A.featureIndex])
              )
                continue;
              const T = [
                new u.P(C.x1, C.y1),
                new u.P(C.x2, C.y1),
                new u.P(C.x2, C.y2),
                new u.P(C.x1, C.y2),
              ];
              u.ap(i, T) &&
                ((y[A.bucketInstanceId][A.featureIndex] = !0),
                v[A.bucketInstanceId] === void 0 &&
                  (v[A.bucketInstanceId] = []),
                v[A.bucketInstanceId].push(A.featureIndex));
            }
            return v;
          }
          insertCollisionBox(e, i, s, a, h, f) {
            (s ? this.ignoredGrid : this.grid).insert(
              {
                bucketInstanceId: a,
                featureIndex: h,
                collisionGroupID: f,
                overlapMode: i,
              },
              e[0],
              e[1],
              e[2],
              e[3],
            );
          }
          insertCollisionCircles(e, i, s, a, h, f) {
            const g = s ? this.ignoredGrid : this.grid,
              y = {
                bucketInstanceId: a,
                featureIndex: h,
                collisionGroupID: f,
                overlapMode: i,
              };
            for (let v = 0; v < e.length; v += 4)
              g.insertCircle(y, e[v], e[v + 1], e[v + 2]);
          }
          projectAndGetPerspectiveRatio(e, i, s, a, h) {
            if (h) {
              let f;
              a
                ? ((f = [e, i, a(e, i), 1]), u.al(f, f, h))
                : ((f = [e, i, 0, 1]), ni(f, f, h));
              const g = f[3];
              return {
                x: ((f[0] / g + 1) / 2) * this.transform.width + kt,
                y: ((-f[1] / g + 1) / 2) * this.transform.height + kt,
                perspectiveRatio:
                  0.5 + (this.transform.cameraToCenterDistance / g) * 0.5,
                isOccluded: !1,
                signedDistanceFromCamera: g,
              };
            }
            {
              const f = this.transform.projectTileCoordinates(e, i, s, a);
              return {
                x: ((f.point.x + 1) / 2) * this.transform.width + kt,
                y: ((1 - f.point.y) / 2) * this.transform.height + kt,
                perspectiveRatio:
                  0.5 +
                  (this.transform.cameraToCenterDistance /
                    f.signedDistanceFromCamera) *
                    0.5,
                isOccluded: f.isOccluded,
                signedDistanceFromCamera: f.signedDistanceFromCamera,
              };
            }
          }
          getPerspectiveRatio(e, i, s, a) {
            const h = this.transform.projectTileCoordinates(e, i, s, a);
            return (
              0.5 +
              (this.transform.cameraToCenterDistance /
                h.signedDistanceFromCamera) *
                0.5
            );
          }
          isOffscreen(e, i, s, a) {
            return (
              s < kt ||
              e >= this.screenRightBoundary ||
              a < kt ||
              i > this.screenBottomBoundary
            );
          }
          isInsideGrid(e, i, s, a) {
            return (
              s >= 0 &&
              e < this.gridRightBoundary &&
              a >= 0 &&
              i < this.gridBottomBoundary
            );
          }
          getViewportMatrix() {
            const e = u.aq([]);
            return (u.J(e, e, [-100, -100, 0]), e);
          }
          _projectCollisionBox(e, i, s, a, h, f, g, y, v, C, A) {
            let T = 1,
              M = 0,
              k = 0,
              V = 1;
            const N = e.anchorPointX + g[0],
              $ = e.anchorPointY + g[1];
            if (f && !h) {
              const Me = this.projectAndGetPerspectiveRatio(N + 1, $, a, v, A),
                Fe = Me.x - y.x,
                Le = Math.atan((Me.y - y.y) / Fe) + (Fe < 0 ? Math.PI : 0),
                st = Math.sin(Le),
                gt = Math.cos(Le);
              ((T = gt), (M = st), (k = -st), (V = gt));
            } else if (!f && h) {
              const Me = ve(this.transform);
              ((T = Me.vecEast[0]),
                (M = Me.vecEast[1]),
                (k = Me.vecSouth[0]),
                (V = Me.vecSouth[1]));
            }
            let G = y.x,
              Y = y.y,
              Q = i;
            (h &&
              ((G = N),
              (Y = $),
              (Q = Math.pow(2, -(this.transform.zoom - s.overscaledZ))),
              (Q *= this.transform.getPitchedTextCorrection(N, $, a)),
              C ||
                (Q *= u.ab(
                  0.5 +
                    (y.signedDistanceFromCamera /
                      this.transform.cameraToCenterDistance) *
                      0.5,
                  0,
                  4,
                ))),
              C &&
                ((G += T * C.x * Q + k * C.y * Q),
                (Y += M * C.x * Q + V * C.y * Q)));
            const ee = e.x1 * Q,
              re = e.x2 * Q,
              ie = (ee + re) / 2,
              he = e.y1 * Q,
              pe = e.y2 * Q,
              be = (he + pe) / 2,
              Ee = [
                { offsetX: ee, offsetY: he },
                { offsetX: ie, offsetY: he },
                { offsetX: re, offsetY: he },
                { offsetX: re, offsetY: be },
                { offsetX: re, offsetY: pe },
                { offsetX: ie, offsetY: pe },
                { offsetX: ee, offsetY: pe },
                { offsetX: ee, offsetY: be },
              ];
            let ye = [];
            for (const { offsetX: Me, offsetY: Fe } of Ee)
              ye.push(new u.P(G + T * Me + k * Fe, Y + M * Me + V * Fe));
            let Be = !1;
            if (h) {
              const Me = ye.map((Fe) =>
                this.projectAndGetPerspectiveRatio(Fe.x, Fe.y, a, v, A),
              );
              ((Be = Me.some((Fe) => !Fe.isOccluded)),
                (ye = Me.map((Fe) => new u.P(Fe.x, Fe.y))));
            } else Be = !0;
            return { box: u.ar(ye), allPointsOccluded: !Be };
          }
        }
        class zt {
          constructor(e, i, s, a) {
            ((this.opacity = e
              ? Math.max(0, Math.min(1, e.opacity + (e.placed ? i : -i)))
              : a && s
                ? 1
                : 0),
              (this.placed = s));
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class Fo {
          constructor(e, i, s, a, h) {
            ((this.text = new zt(e ? e.text : null, i, s, h)),
              (this.icon = new zt(e ? e.icon : null, i, a, h)));
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Hn {
          constructor(e, i, s) {
            ((this.text = e), (this.icon = i), (this.skipFade = s));
          }
        }
        class da {
          constructor(e, i, s, a, h) {
            ((this.bucketInstanceId = e),
              (this.featureIndex = i),
              (this.sourceLayerIndex = s),
              (this.bucketIndex = a),
              (this.tileID = h));
          }
        }
        class Cn {
          constructor(e) {
            ((this.crossSourceCollisions = e),
              (this.maxGroupID = 0),
              (this.collisionGroups = {}));
          }
          get(e) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e]) {
              const i = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: i,
                predicate: (s) => s.collisionGroupID === i,
              };
            }
            return this.collisionGroups[e];
          }
        }
        function En(c, e, i, s, a) {
          const { horizontalAlign: h, verticalAlign: f } = u.ay(c);
          return new u.P(-(h - 0.5) * e + s[0] * a, -(f - 0.5) * i + s[1] * a);
        }
        class Il {
          constructor(e, i, s, a, h) {
            ((this.transform = e.clone()),
              (this.terrain = i),
              (this.collisionIndex = new Qi(this.transform)),
              (this.placements = {}),
              (this.opacities = {}),
              (this.variableOffsets = {}),
              (this.stale = !1),
              (this.commitTime = 0),
              (this.fadeDuration = s),
              (this.retainedQueryData = {}),
              (this.collisionGroups = new Cn(a)),
              (this.collisionCircleArrays = {}),
              (this.collisionBoxArrays = new Map()),
              (this.prevPlacement = h),
              h && (h.prevPlacement = void 0),
              (this.placedOrientations = {}));
          }
          _getTerrainElevationFunc(e) {
            const i = this.terrain;
            return i ? (s, a) => i.getElevation(e, s, a) : null;
          }
          getBucketParts(e, i, s, a) {
            const h = s.getBucket(i),
              f = s.latestFeatureIndex;
            if (!h || !f || i.id !== h.layerIds[0]) return;
            const g = s.collisionBoxArray,
              y = h.layers[0].layout,
              v = h.layers[0].paint,
              C = Math.pow(2, this.transform.zoom - s.tileID.overscaledZ),
              A = s.tileSize / u.X,
              T = s.tileID.toUnwrapped(),
              M = y.get("text-rotation-alignment") === "map",
              k = u.at(s, 1, this.transform.zoom),
              V = u.au(
                this.collisionIndex.transform,
                s,
                v.get("text-translate"),
                v.get("text-translate-anchor"),
              ),
              N = u.au(
                this.collisionIndex.transform,
                s,
                v.get("icon-translate"),
                v.get("icon-translate-anchor"),
              ),
              $ = fe(M, this.transform, k);
            this.retainedQueryData[h.bucketInstanceId] = new da(
              h.bucketInstanceId,
              f,
              h.sourceLayerIndex,
              h.index,
              s.tileID,
            );
            const G = {
              bucket: h,
              layout: y,
              translationText: V,
              translationIcon: N,
              unwrappedTileID: T,
              pitchedLabelPlaneMatrix: $,
              scale: C,
              textPixelRatio: A,
              holdingForFade: s.holdingForFade(),
              collisionBoxArray: g,
              partiallyEvaluatedTextSize: u.ah(
                h.textSizeData,
                this.transform.zoom,
              ),
              collisionGroup: this.collisionGroups.get(h.sourceID),
            };
            if (a)
              for (const Y of h.sortKeyRanges) {
                const {
                  sortKey: Q,
                  symbolInstanceStart: ee,
                  symbolInstanceEnd: re,
                } = Y;
                e.push({
                  sortKey: Q,
                  symbolInstanceStart: ee,
                  symbolInstanceEnd: re,
                  parameters: G,
                });
              }
            else
              e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: h.symbolInstances.length,
                parameters: G,
              });
          }
          attemptAnchorPlacement(
            e,
            i,
            s,
            a,
            h,
            f,
            g,
            y,
            v,
            C,
            A,
            T,
            M,
            k,
            V,
            N,
            $,
            G,
            Y,
            Q,
          ) {
            const ee = u.av[e.textAnchor],
              re = [e.textOffset0, e.textOffset1],
              ie = En(ee, s, a, re, h),
              he = this.collisionIndex.placeCollisionBox(
                i,
                T,
                y,
                v,
                C,
                g,
                f,
                N,
                A.predicate,
                Y,
                ie,
                Q,
              );
            if (
              (!G ||
                this.collisionIndex.placeCollisionBox(
                  G,
                  T,
                  y,
                  v,
                  C,
                  g,
                  f,
                  $,
                  A.predicate,
                  Y,
                  ie,
                  Q,
                ).placeable) &&
              he.placeable
            ) {
              let pe;
              if (
                (this.prevPlacement &&
                  this.prevPlacement.variableOffsets[M.crossTileID] &&
                  this.prevPlacement.placements[M.crossTileID] &&
                  this.prevPlacement.placements[M.crossTileID].text &&
                  (pe =
                    this.prevPlacement.variableOffsets[M.crossTileID].anchor),
                M.crossTileID === 0)
              )
                throw new Error("symbolInstance.crossTileID can't be 0");
              return (
                (this.variableOffsets[M.crossTileID] = {
                  textOffset: re,
                  width: s,
                  height: a,
                  anchor: ee,
                  textBoxScale: h,
                  prevAnchor: pe,
                }),
                this.markUsedJustification(k, ee, M, V),
                k.allowVerticalPlacement &&
                  (this.markUsedOrientation(k, V, M),
                  (this.placedOrientations[M.crossTileID] = V)),
                { shift: ie, placedGlyphBoxes: he }
              );
            }
          }
          placeLayerBucketPart(e, i, s) {
            const {
                bucket: a,
                layout: h,
                translationText: f,
                translationIcon: g,
                unwrappedTileID: y,
                pitchedLabelPlaneMatrix: v,
                textPixelRatio: C,
                holdingForFade: A,
                collisionBoxArray: T,
                partiallyEvaluatedTextSize: M,
                collisionGroup: k,
              } = e.parameters,
              V = h.get("text-optional"),
              N = h.get("icon-optional"),
              $ = u.aw(h, "text-overlap", "text-allow-overlap"),
              G = $ === "always",
              Y = u.aw(h, "icon-overlap", "icon-allow-overlap"),
              Q = Y === "always",
              ee = h.get("text-rotation-alignment") === "map",
              re = h.get("text-pitch-alignment") === "map",
              ie = h.get("icon-text-fit") !== "none",
              he = h.get("symbol-z-order") === "viewport-y",
              pe = G && (Q || !a.hasIconData() || N),
              be = Q && (G || !a.hasTextData() || V);
            !a.collisionArrays && T && a.deserializeCollisionBoxes(T);
            const Ee = this.retainedQueryData[a.bucketInstanceId].tileID,
              ye = this._getTerrainElevationFunc(Ee),
              Be = this.transform.getFastPathSimpleProjectionMatrix(Ee),
              Me = (Fe, Le, st) => {
                var gt, Nt;
                if (i[Fe.crossTileID]) return;
                if (A)
                  return void (this.placements[Fe.crossTileID] = new Hn(
                    !1,
                    !1,
                    !1,
                  ));
                let Tt = !1,
                  Vt = !1,
                  Ft = !0,
                  At = null,
                  Pt = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1,
                  },
                  vi = { box: null, placeable: !1, offscreen: null },
                  si = null,
                  ai = null,
                  Ri = null,
                  Zr = 0,
                  Ir = 0,
                  er = 0;
                (Le.textFeatureIndex
                  ? (Zr = Le.textFeatureIndex)
                  : Fe.useRuntimeCollisionCircles && (Zr = Fe.featureIndex),
                  Le.verticalTextFeatureIndex &&
                    (Ir = Le.verticalTextFeatureIndex));
                const Gr = Le.textBox;
                if (Gr) {
                  const Zi = (St) => {
                      let Ut = u.ai.horizontal;
                      if (
                        a.allowVerticalPlacement &&
                        !St &&
                        this.prevPlacement
                      ) {
                        const ir =
                          this.prevPlacement.placedOrientations[Fe.crossTileID];
                        ir &&
                          ((this.placedOrientations[Fe.crossTileID] = ir),
                          (Ut = ir),
                          this.markUsedOrientation(a, Ut, Fe));
                      }
                      return Ut;
                    },
                    hr = (St, Ut) => {
                      if (
                        a.allowVerticalPlacement &&
                        Fe.numVerticalGlyphVertices > 0 &&
                        Le.verticalTextBox
                      ) {
                        for (const ir of a.writingModes)
                          if (
                            (ir === u.ai.vertical
                              ? ((Pt = Ut()), (vi = Pt))
                              : (Pt = St()),
                            Pt && Pt.placeable)
                          )
                            break;
                      } else Pt = St();
                    },
                    dr = Fe.textAnchorOffsetStartIndex,
                    tr = Fe.textAnchorOffsetEndIndex;
                  if (tr === dr) {
                    const St = (Ut, ir) => {
                      const Gt = this.collisionIndex.placeCollisionBox(
                        Ut,
                        $,
                        C,
                        Ee,
                        y,
                        re,
                        ee,
                        f,
                        k.predicate,
                        ye,
                        void 0,
                        Be,
                      );
                      return (
                        Gt &&
                          Gt.placeable &&
                          (this.markUsedOrientation(a, ir, Fe),
                          (this.placedOrientations[Fe.crossTileID] = ir)),
                        Gt
                      );
                    };
                    (hr(
                      () => St(Gr, u.ai.horizontal),
                      () => {
                        const Ut = Le.verticalTextBox;
                        return a.allowVerticalPlacement &&
                          Fe.numVerticalGlyphVertices > 0 &&
                          Ut
                          ? St(Ut, u.ai.vertical)
                          : { box: null, offscreen: null };
                      },
                    ),
                      Zi(Pt && Pt.placeable));
                  } else {
                    let St =
                      u.av[
                        (Nt =
                          (gt = this.prevPlacement) === null || gt === void 0
                            ? void 0
                            : gt.variableOffsets[Fe.crossTileID]) === null ||
                        Nt === void 0
                          ? void 0
                          : Nt.anchor
                      ];
                    const Ut = (Gt, _c, Su) => {
                      const ol = Gt.x2 - Gt.x1,
                        Du = Gt.y2 - Gt.y1,
                        Nn = Fe.textBoxScale,
                        Vn = ie && Y === "never" ? _c : null;
                      let an = null,
                        Mu = $ === "never" ? 1 : 2,
                        ea = "never";
                      St && Mu++;
                      for (let sl = 0; sl < Mu; sl++) {
                        for (let al = dr; al < tr; al++) {
                          const ll = a.textAnchorOffsets.get(al);
                          if (St && ll.textAnchor !== St) continue;
                          const ul = this.attemptAnchorPlacement(
                            ll,
                            Gt,
                            ol,
                            Du,
                            Nn,
                            ee,
                            re,
                            C,
                            Ee,
                            y,
                            k,
                            ea,
                            Fe,
                            a,
                            Su,
                            f,
                            g,
                            Vn,
                            ye,
                          );
                          if (
                            ul &&
                            ((an = ul.placedGlyphBoxes), an && an.placeable)
                          )
                            return ((Tt = !0), (At = ul.shift), an);
                        }
                        St ? (St = null) : (ea = $);
                      }
                      return (
                        s &&
                          !an &&
                          (an = {
                            box: this.collisionIndex.placeCollisionBox(
                              Gr,
                              "always",
                              C,
                              Ee,
                              y,
                              re,
                              ee,
                              f,
                              k.predicate,
                              ye,
                              void 0,
                              Be,
                            ).box,
                            offscreen: !1,
                            placeable: !1,
                            occluded: !1,
                          }),
                        an
                      );
                    };
                    (hr(
                      () => Ut(Gr, Le.iconBox, u.ai.horizontal),
                      () => {
                        const Gt = Le.verticalTextBox;
                        return a.allowVerticalPlacement &&
                          (!Pt || !Pt.placeable) &&
                          Fe.numVerticalGlyphVertices > 0 &&
                          Gt
                          ? Ut(Gt, Le.verticalIconBox, u.ai.vertical)
                          : { box: null, occluded: !0, offscreen: null };
                      },
                    ),
                      Pt && ((Tt = Pt.placeable), (Ft = Pt.offscreen)));
                    const ir = Zi(Pt && Pt.placeable);
                    if (!Tt && this.prevPlacement) {
                      const Gt =
                        this.prevPlacement.variableOffsets[Fe.crossTileID];
                      Gt &&
                        ((this.variableOffsets[Fe.crossTileID] = Gt),
                        this.markUsedJustification(a, Gt.anchor, Fe, ir));
                    }
                  }
                }
                if (
                  ((si = Pt),
                  (Tt = si && si.placeable),
                  (Ft = si && si.offscreen),
                  Fe.useRuntimeCollisionCircles)
                ) {
                  const Zi = a.text.placedSymbolArray.get(
                      Fe.centerJustifiedTextSymbolIndex,
                    ),
                    hr = u.aj(a.textSizeData, M, Zi),
                    dr = h.get("text-padding");
                  ((ai = this.collisionIndex.placeCollisionCircles(
                    $,
                    Zi,
                    a.lineVertexArray,
                    a.glyphOffsetArray,
                    hr,
                    y,
                    v,
                    s,
                    re,
                    k.predicate,
                    Fe.collisionCircleDiameter,
                    dr,
                    f,
                    ye,
                  )),
                    ai.circles.length &&
                      ai.collisionDetected &&
                      !s &&
                      u.w(
                        "Collisions detected, but collision boxes are not shown",
                      ),
                    (Tt =
                      G || (ai.circles.length > 0 && !ai.collisionDetected)),
                    (Ft = Ft && ai.offscreen));
                }
                if (
                  (Le.iconFeatureIndex && (er = Le.iconFeatureIndex),
                  Le.iconBox)
                ) {
                  const Zi = (hr) =>
                    this.collisionIndex.placeCollisionBox(
                      hr,
                      Y,
                      C,
                      Ee,
                      y,
                      re,
                      ee,
                      g,
                      k.predicate,
                      ye,
                      ie && At ? At : void 0,
                      Be,
                    );
                  (vi && vi.placeable && Le.verticalIconBox
                    ? ((Ri = Zi(Le.verticalIconBox)), (Vt = Ri.placeable))
                    : ((Ri = Zi(Le.iconBox)), (Vt = Ri.placeable)),
                    (Ft = Ft && Ri.offscreen));
                }
                const Ko =
                    V ||
                    (Fe.numHorizontalGlyphVertices === 0 &&
                      Fe.numVerticalGlyphVertices === 0),
                  Yo = N || Fe.numIconVertices === 0;
                Ko || Yo
                  ? Yo
                    ? Ko || (Vt = Vt && Tt)
                    : (Tt = Vt && Tt)
                  : (Vt = Tt = Vt && Tt);
                const go = Vt && Ri.placeable;
                if (
                  (Tt &&
                    si.placeable &&
                    this.collisionIndex.insertCollisionBox(
                      si.box,
                      $,
                      h.get("text-ignore-placement"),
                      a.bucketInstanceId,
                      vi && vi.placeable && Ir ? Ir : Zr,
                      k.ID,
                    ),
                  go &&
                    this.collisionIndex.insertCollisionBox(
                      Ri.box,
                      Y,
                      h.get("icon-ignore-placement"),
                      a.bucketInstanceId,
                      er,
                      k.ID,
                    ),
                  ai &&
                    Tt &&
                    this.collisionIndex.insertCollisionCircles(
                      ai.circles,
                      $,
                      h.get("text-ignore-placement"),
                      a.bucketInstanceId,
                      Zr,
                      k.ID,
                    ),
                  s &&
                    this.storeCollisionData(
                      a.bucketInstanceId,
                      st,
                      Le,
                      si,
                      Ri,
                      ai,
                    ),
                  Fe.crossTileID === 0)
                )
                  throw new Error("symbolInstance.crossTileID can't be 0");
                if (a.bucketInstanceId === 0)
                  throw new Error("bucket.bucketInstanceId can't be 0");
                ((this.placements[Fe.crossTileID] = new Hn(
                  (Tt || pe) && !(si != null && si.occluded),
                  (Vt || be) && !(Ri != null && Ri.occluded),
                  Ft || a.justReloaded,
                )),
                  (i[Fe.crossTileID] = !0));
              };
            if (he) {
              if (e.symbolInstanceStart !== 0)
                throw new Error("bucket.bucketInstanceId should be 0");
              const Fe = a.getSortedSymbolIndexes(
                -this.transform.bearingInRadians,
              );
              for (let Le = Fe.length - 1; Le >= 0; --Le) {
                const st = Fe[Le];
                Me(a.symbolInstances.get(st), a.collisionArrays[st], st);
              }
            } else
              for (
                let Fe = e.symbolInstanceStart;
                Fe < e.symbolInstanceEnd;
                Fe++
              )
                Me(a.symbolInstances.get(Fe), a.collisionArrays[Fe], Fe);
            a.justReloaded = !1;
          }
          storeCollisionData(e, i, s, a, h, f) {
            if (s.textBox || s.iconBox) {
              let g, y;
              (this.collisionBoxArrays.has(e)
                ? (g = this.collisionBoxArrays.get(e))
                : ((g = new Map()), this.collisionBoxArrays.set(e, g)),
                g.has(i)
                  ? (y = g.get(i))
                  : ((y = { text: null, icon: null }), g.set(i, y)),
                s.textBox && (y.text = a.box),
                s.iconBox && (y.icon = h.box));
            }
            if (f) {
              let g = this.collisionCircleArrays[e];
              g === void 0 && (g = this.collisionCircleArrays[e] = []);
              for (let y = 0; y < f.circles.length; y += 4)
                (g.push(f.circles[y + 0] - kt),
                  g.push(f.circles[y + 1] - kt),
                  g.push(f.circles[y + 2]),
                  g.push(f.collisionDetected ? 1 : 0));
            }
          }
          markUsedJustification(e, i, s, a) {
            let h;
            h =
              a === u.ai.vertical
                ? s.verticalPlacedTextSymbolIndex
                : {
                    left: s.leftJustifiedTextSymbolIndex,
                    center: s.centerJustifiedTextSymbolIndex,
                    right: s.rightJustifiedTextSymbolIndex,
                  }[u.ax(i)];
            const f = [
              s.leftJustifiedTextSymbolIndex,
              s.centerJustifiedTextSymbolIndex,
              s.rightJustifiedTextSymbolIndex,
              s.verticalPlacedTextSymbolIndex,
            ];
            for (const g of f)
              g >= 0 &&
                (e.text.placedSymbolArray.get(g).crossTileID =
                  h >= 0 && g !== h ? 0 : s.crossTileID);
          }
          markUsedOrientation(e, i, s) {
            const a =
                i === u.ai.horizontal || i === u.ai.horizontalOnly ? i : 0,
              h = i === u.ai.vertical ? i : 0,
              f = [
                s.leftJustifiedTextSymbolIndex,
                s.centerJustifiedTextSymbolIndex,
                s.rightJustifiedTextSymbolIndex,
              ];
            for (const g of f)
              e.text.placedSymbolArray.get(g).placedOrientation = a;
            s.verticalPlacedTextSymbolIndex &&
              (e.text.placedSymbolArray.get(
                s.verticalPlacedTextSymbolIndex,
              ).placedOrientation = h);
          }
          commit(e) {
            ((this.commitTime = e),
              (this.zoomAtLastRecencyCheck = this.transform.zoom));
            const i = this.prevPlacement;
            let s = !1;
            this.prevZoomAdjustment = i
              ? i.zoomAdjustment(this.transform.zoom)
              : 0;
            const a = i ? i.symbolFadeChange(e) : 1,
              h = i ? i.opacities : {},
              f = i ? i.variableOffsets : {},
              g = i ? i.placedOrientations : {};
            for (const y in this.placements) {
              const v = this.placements[y],
                C = h[y];
              C
                ? ((this.opacities[y] = new Fo(C, a, v.text, v.icon)),
                  (s =
                    s || v.text !== C.text.placed || v.icon !== C.icon.placed))
                : ((this.opacities[y] = new Fo(
                    null,
                    a,
                    v.text,
                    v.icon,
                    v.skipFade,
                  )),
                  (s = s || v.text || v.icon));
            }
            for (const y in h) {
              const v = h[y];
              if (!this.opacities[y]) {
                const C = new Fo(v, a, !1, !1);
                C.isHidden() ||
                  ((this.opacities[y] = C),
                  (s = s || v.text.placed || v.icon.placed));
              }
            }
            for (const y in f)
              this.variableOffsets[y] ||
                !this.opacities[y] ||
                this.opacities[y].isHidden() ||
                (this.variableOffsets[y] = f[y]);
            for (const y in g)
              this.placedOrientations[y] ||
                !this.opacities[y] ||
                this.opacities[y].isHidden() ||
                (this.placedOrientations[y] = g[y]);
            if (i && i.lastPlacementChangeTime === void 0)
              throw new Error(
                "Last placement time for previous placement is not defined",
              );
            s
              ? (this.lastPlacementChangeTime = e)
              : typeof this.lastPlacementChangeTime != "number" &&
                (this.lastPlacementChangeTime = i
                  ? i.lastPlacementChangeTime
                  : e);
          }
          updateLayerOpacities(e, i) {
            const s = {};
            for (const a of i) {
              const h = a.getBucket(e);
              h &&
                a.latestFeatureIndex &&
                e.id === h.layerIds[0] &&
                this.updateBucketOpacities(h, a.tileID, s, a.collisionBoxArray);
            }
          }
          updateBucketOpacities(e, i, s, a) {
            (e.hasTextData() &&
              (e.text.opacityVertexArray.clear(),
              (e.text.hasVisibleVertices = !1)),
              e.hasIconData() &&
                (e.icon.opacityVertexArray.clear(),
                (e.icon.hasVisibleVertices = !1)),
              e.hasIconCollisionBoxData() &&
                e.iconCollisionBox.collisionVertexArray.clear(),
              e.hasTextCollisionBoxData() &&
                e.textCollisionBox.collisionVertexArray.clear());
            const h = e.layers[0],
              f = h.layout,
              g = new Fo(null, 0, !1, !1, !0),
              y = f.get("text-allow-overlap"),
              v = f.get("icon-allow-overlap"),
              C =
                h._unevaluatedLayout.hasValue("text-variable-anchor") ||
                h._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              A = f.get("text-rotation-alignment") === "map",
              T = f.get("text-pitch-alignment") === "map",
              M = f.get("icon-text-fit") !== "none",
              k = new Fo(
                null,
                0,
                y && (v || !e.hasIconData() || f.get("icon-optional")),
                v && (y || !e.hasTextData() || f.get("text-optional")),
                !0,
              );
            !e.collisionArrays &&
              a &&
              (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) &&
              e.deserializeCollisionBoxes(a);
            const V = ($, G, Y) => {
                for (let Q = 0; Q < G / 4; Q++)
                  $.opacityVertexArray.emplaceBack(Y);
                $.hasVisibleVertices = $.hasVisibleVertices || Y !== An;
              },
              N = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let $ = 0; $ < e.symbolInstances.length; $++) {
              const G = e.symbolInstances.get($),
                {
                  numHorizontalGlyphVertices: Y,
                  numVerticalGlyphVertices: Q,
                  crossTileID: ee,
                } = G;
              let re = this.opacities[ee];
              (s[ee] ? (re = g) : re || ((re = k), (this.opacities[ee] = re)),
                (s[ee] = !0));
              const ie = G.numIconVertices > 0,
                he = this.placedOrientations[G.crossTileID],
                pe = he === u.ai.vertical,
                be = he === u.ai.horizontal || he === u.ai.horizontalOnly;
              if (Y > 0 || Q > 0) {
                const ye = fa(re.text);
                (V(e.text, Y, pe ? An : ye), V(e.text, Q, be ? An : ye));
                const Be = re.text.isHidden();
                ([
                  G.rightJustifiedTextSymbolIndex,
                  G.centerJustifiedTextSymbolIndex,
                  G.leftJustifiedTextSymbolIndex,
                ].forEach((Le) => {
                  Le >= 0 &&
                    (e.text.placedSymbolArray.get(Le).hidden =
                      Be || pe ? 1 : 0);
                }),
                  G.verticalPlacedTextSymbolIndex >= 0 &&
                    (e.text.placedSymbolArray.get(
                      G.verticalPlacedTextSymbolIndex,
                    ).hidden = Be || be ? 1 : 0));
                const Me = this.variableOffsets[G.crossTileID];
                Me && this.markUsedJustification(e, Me.anchor, G, he);
                const Fe = this.placedOrientations[G.crossTileID];
                Fe &&
                  (this.markUsedJustification(e, "left", G, Fe),
                  this.markUsedOrientation(e, Fe, G));
              }
              if (ie) {
                const ye = fa(re.icon),
                  Be = !(M && G.verticalPlacedIconSymbolIndex && pe);
                (G.placedIconSymbolIndex >= 0 &&
                  (V(e.icon, G.numIconVertices, Be ? ye : An),
                  (e.icon.placedSymbolArray.get(
                    G.placedIconSymbolIndex,
                  ).hidden = re.icon.isHidden())),
                  G.verticalPlacedIconSymbolIndex >= 0 &&
                    (V(e.icon, G.numVerticalIconVertices, Be ? An : ye),
                    (e.icon.placedSymbolArray.get(
                      G.verticalPlacedIconSymbolIndex,
                    ).hidden = re.icon.isHidden())));
              }
              const Ee = N && N.has($) ? N.get($) : { text: null, icon: null };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const ye = e.collisionArrays[$];
                if (ye) {
                  let Be = new u.P(0, 0);
                  if (ye.textBox || ye.verticalTextBox) {
                    let Me = !0;
                    if (C) {
                      const Fe = this.variableOffsets[ee];
                      Fe
                        ? ((Be = En(
                            Fe.anchor,
                            Fe.width,
                            Fe.height,
                            Fe.textOffset,
                            Fe.textBoxScale,
                          )),
                          A &&
                            Be._rotate(
                              T
                                ? -this.transform.bearingInRadians
                                : this.transform.bearingInRadians,
                            ))
                        : (Me = !1);
                    }
                    if (ye.textBox || ye.verticalTextBox) {
                      let Fe;
                      (ye.textBox && (Fe = pe),
                        ye.verticalTextBox && (Fe = be),
                        pa(
                          e.textCollisionBox.collisionVertexArray,
                          re.text.placed,
                          !Me || Fe,
                          Ee.text,
                          Be.x,
                          Be.y,
                        ));
                    }
                  }
                  if (ye.iconBox || ye.verticalIconBox) {
                    const Me = Boolean(!be && ye.verticalIconBox);
                    let Fe;
                    (ye.iconBox && (Fe = Me),
                      ye.verticalIconBox && (Fe = !Me),
                      pa(
                        e.iconCollisionBox.collisionVertexArray,
                        re.icon.placed,
                        Fe,
                        Ee.icon,
                        M ? Be.x : 0,
                        M ? Be.y : 0,
                      ));
                  }
                }
              }
            }
            if (
              (e.sortFeatures(-this.transform.bearingInRadians),
              this.retainedQueryData[e.bucketInstanceId] &&
                (this.retainedQueryData[e.bucketInstanceId].featureSortOrder =
                  e.featureSortOrder),
              e.hasTextData() &&
                e.text.opacityVertexBuffer &&
                e.text.opacityVertexBuffer.updateData(
                  e.text.opacityVertexArray,
                ),
              e.hasIconData() &&
                e.icon.opacityVertexBuffer &&
                e.icon.opacityVertexBuffer.updateData(
                  e.icon.opacityVertexArray,
                ),
              e.hasIconCollisionBoxData() &&
                e.iconCollisionBox.collisionVertexBuffer &&
                e.iconCollisionBox.collisionVertexBuffer.updateData(
                  e.iconCollisionBox.collisionVertexArray,
                ),
              e.hasTextCollisionBoxData() &&
                e.textCollisionBox.collisionVertexBuffer &&
                e.textCollisionBox.collisionVertexBuffer.updateData(
                  e.textCollisionBox.collisionVertexArray,
                ),
              e.text.opacityVertexArray.length !==
                e.text.layoutVertexArray.length / 4)
            )
              throw new Error(
                `bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`,
              );
            if (
              e.icon.opacityVertexArray.length !==
              e.icon.layoutVertexArray.length / 4
            )
              throw new Error(
                `bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`,
              );
            e.bucketInstanceId in this.collisionCircleArrays &&
              ((e.collisionCircleArray =
                this.collisionCircleArrays[e.bucketInstanceId]),
              delete this.collisionCircleArrays[e.bucketInstanceId]);
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0
              ? 1
              : (e - this.commitTime) / this.fadeDuration +
                  this.prevZoomAdjustment;
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5);
          }
          hasTransitions(e) {
            return (
              this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
            );
          }
          stillRecent(e, i) {
            const s =
              this.zoomAtLastRecencyCheck === i
                ? 1 - this.zoomAdjustment(i)
                : 1;
            return (
              (this.zoomAtLastRecencyCheck = i),
              this.commitTime + this.fadeDuration * s > e
            );
          }
          setStale() {
            this.stale = !0;
          }
        }
        function pa(c, e, i, s, a, h) {
          (s && s.length !== 0) || (s = [0, 0, 0, 0]);
          const f = s[0] - kt,
            g = s[1] - kt,
            y = s[2] - kt,
            v = s[3] - kt;
          (c.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, f, g),
            c.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, y, g),
            c.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, y, v),
            c.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, f, v));
        }
        const Bl = Math.pow(2, 25),
          Xn = Math.pow(2, 24),
          kl = Math.pow(2, 17),
          ec = Math.pow(2, 16),
          tc = Math.pow(2, 9),
          ic = Math.pow(2, 8),
          zl = Math.pow(2, 1);
        function fa(c) {
          if (c.opacity === 0 && !c.placed) return 0;
          if (c.opacity === 1 && c.placed) return 4294967295;
          const e = c.placed ? 1 : 0,
            i = Math.floor(127 * c.opacity);
          return (
            i * Bl + e * Xn + i * kl + e * ec + i * tc + e * ic + i * zl + e
          );
        }
        const An = 0;
        class ma {
          constructor(e) {
            ((this._sortAcrossTiles =
              e.layout.get("symbol-z-order") !== "viewport-y" &&
              !e.layout.get("symbol-sort-key").isConstant()),
              (this._currentTileIndex = 0),
              (this._currentPartIndex = 0),
              (this._seenCrossTileIDs = {}),
              (this._bucketParts = []));
          }
          continuePlacement(e, i, s, a, h) {
            const f = this._bucketParts;
            for (; this._currentTileIndex < e.length; )
              if (
                (i.getBucketParts(
                  f,
                  a,
                  e[this._currentTileIndex],
                  this._sortAcrossTiles,
                ),
                this._currentTileIndex++,
                h())
              )
                return !0;
            for (
              this._sortAcrossTiles &&
              ((this._sortAcrossTiles = !1),
              f.sort((g, y) => g.sortKey - y.sortKey));
              this._currentPartIndex < f.length;

            )
              if (
                (i.placeLayerBucketPart(
                  f[this._currentPartIndex],
                  this._seenCrossTileIDs,
                  s,
                ),
                this._currentPartIndex++,
                h())
              )
                return !0;
            return !1;
          }
        }
        class Ll {
          constructor(e, i, s, a, h, f, g, y) {
            ((this.placement = new Il(e, i, f, g, y)),
              (this._currentPlacementIndex = s.length - 1),
              (this._forceFullPlacement = a),
              (this._showCollisionBoxes = h),
              (this._done = !1));
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e, i, s) {
            const a = Qe.now(),
              h = () => !this._forceFullPlacement && Qe.now() - a > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const f = i[e[this._currentPlacementIndex]],
                g = this.placement.collisionIndex.transform.zoom;
              if (
                f.type === "symbol" &&
                (!f.minzoom || f.minzoom <= g) &&
                (!f.maxzoom || f.maxzoom > g)
              ) {
                if (
                  (this._inProgressLayer || (this._inProgressLayer = new ma(f)),
                  this._inProgressLayer.continuePlacement(
                    s[f.source],
                    this.placement,
                    this._showCollisionBoxes,
                    f,
                    h,
                  ))
                )
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(e) {
            return (this.placement.commit(e), this.placement);
          }
        }
        const Tn = 512 / u.X / 2;
        class ga {
          constructor(e, i, s) {
            ((this.tileID = e),
              (this.bucketInstanceId = s),
              (this._symbolsByKey = {}));
            const a = new Map();
            for (let h = 0; h < i.length; h++) {
              const f = i.get(h),
                g = f.key,
                y = a.get(g);
              y ? y.push(f) : a.set(g, [f]);
            }
            for (const [h, f] of a) {
              const g = {
                positions: f.map((y) => ({
                  x: Math.floor(y.anchorX * Tn),
                  y: Math.floor(y.anchorY * Tn),
                })),
                crossTileIDs: f.map((y) => y.crossTileID),
              };
              if (g.positions.length > 128) {
                const y = new u.az(g.positions.length, 16, Uint16Array);
                for (const { x: v, y: C } of g.positions) y.add(v, C);
                (y.finish(), delete g.positions, (g.index = y));
              }
              this._symbolsByKey[h] = g;
            }
          }
          getScaledCoordinates(e, i) {
            const { x: s, y: a, z: h } = this.tileID.canonical,
              { x: f, y: g, z: y } = i.canonical,
              v = Tn / Math.pow(2, y - h),
              C = (g * u.X + e.anchorY) * v,
              A = a * u.X * Tn;
            return {
              x: Math.floor((f * u.X + e.anchorX) * v - s * u.X * Tn),
              y: Math.floor(C - A),
            };
          }
          findMatches(e, i, s) {
            const a =
              this.tileID.canonical.z < i.canonical.z
                ? 1
                : Math.pow(2, this.tileID.canonical.z - i.canonical.z);
            for (let h = 0; h < e.length; h++) {
              const f = e.get(h);
              if (f.crossTileID) continue;
              const g = this._symbolsByKey[f.key];
              if (!g) continue;
              const y = this.getScaledCoordinates(f, i);
              if (g.index) {
                const v = g.index
                  .range(y.x - a, y.y - a, y.x + a, y.y + a)
                  .sort();
                for (const C of v) {
                  const A = g.crossTileIDs[C];
                  if (!s[A]) {
                    ((s[A] = !0), (f.crossTileID = A));
                    break;
                  }
                }
              } else if (g.positions)
                for (let v = 0; v < g.positions.length; v++) {
                  const C = g.positions[v],
                    A = g.crossTileIDs[v];
                  if (
                    Math.abs(C.x - y.x) <= a &&
                    Math.abs(C.y - y.y) <= a &&
                    !s[A]
                  ) {
                    ((s[A] = !0), (f.crossTileID = A));
                    break;
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(
              ({ crossTileIDs: e }) => e,
            );
          }
        }
        class ss {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Rl {
          constructor() {
            ((this.indexes = {}), (this.usedCrossTileIDs = {}), (this.lng = 0));
          }
          handleWrapJump(e) {
            const i = Math.round((e - this.lng) / 360);
            if (i !== 0)
              for (const s in this.indexes) {
                const a = this.indexes[s],
                  h = {};
                for (const f in a) {
                  const g = a[f];
                  ((g.tileID = g.tileID.unwrapTo(g.tileID.wrap + i)),
                    (h[g.tileID.key] = g));
                }
                this.indexes[s] = h;
              }
            this.lng = e;
          }
          addBucket(e, i, s) {
            if (
              this.indexes[e.overscaledZ] &&
              this.indexes[e.overscaledZ][e.key]
            ) {
              if (
                this.indexes[e.overscaledZ][e.key].bucketInstanceId ===
                i.bucketInstanceId
              )
                return !1;
              this.removeBucketCrossTileIDs(
                e.overscaledZ,
                this.indexes[e.overscaledZ][e.key],
              );
            }
            for (let h = 0; h < i.symbolInstances.length; h++)
              i.symbolInstances.get(h).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] ||
              (this.usedCrossTileIDs[e.overscaledZ] = {});
            const a = this.usedCrossTileIDs[e.overscaledZ];
            for (const h in this.indexes) {
              const f = this.indexes[h];
              if (Number(h) > e.overscaledZ)
                for (const g in f) {
                  const y = f[g];
                  y.tileID.isChildOf(e) &&
                    y.findMatches(i.symbolInstances, e, a);
                }
              else {
                const g = f[e.scaledTo(Number(h)).key];
                g && g.findMatches(i.symbolInstances, e, a);
              }
            }
            for (let h = 0; h < i.symbolInstances.length; h++) {
              const f = i.symbolInstances.get(h);
              f.crossTileID ||
                ((f.crossTileID = s.generate()), (a[f.crossTileID] = !0));
            }
            return (
              this.indexes[e.overscaledZ] === void 0 &&
                (this.indexes[e.overscaledZ] = {}),
              (this.indexes[e.overscaledZ][e.key] = new ga(
                e,
                i.symbolInstances,
                i.bucketInstanceId,
              )),
              !0
            );
          }
          removeBucketCrossTileIDs(e, i) {
            for (const s of i.getCrossTileIDsLists())
              for (const a of s) delete this.usedCrossTileIDs[e][a];
          }
          removeStaleBuckets(e) {
            let i = !1;
            for (const s in this.indexes) {
              const a = this.indexes[s];
              for (const h in a)
                e[a[h].bucketInstanceId] ||
                  (this.removeBucketCrossTileIDs(s, a[h]),
                  delete a[h],
                  (i = !0));
            }
            return i;
          }
        }
        class Fn {
          constructor() {
            ((this.layerIndexes = {}),
              (this.crossTileIDs = new ss()),
              (this.maxBucketInstanceId = 0),
              (this.bucketsInCurrentPlacement = {}));
          }
          addLayer(e, i, s) {
            let a = this.layerIndexes[e.id];
            a === void 0 && (a = this.layerIndexes[e.id] = new Rl());
            let h = !1;
            const f = {};
            a.handleWrapJump(s);
            for (const g of i) {
              const y = g.getBucket(e);
              y &&
                e.id === y.layerIds[0] &&
                (y.bucketInstanceId ||
                  (y.bucketInstanceId = ++this.maxBucketInstanceId),
                a.addBucket(g.tileID, y, this.crossTileIDs) && (h = !0),
                (f[y.bucketInstanceId] = !0));
            }
            return (a.removeStaleBuckets(f) && (h = !0), h);
          }
          pruneUnusedLayers(e) {
            const i = {};
            e.forEach((s) => {
              i[s] = !0;
            });
            for (const s in this.layerIndexes)
              i[s] || delete this.layerIndexes[s];
          }
        }
        var _a = "void main() {fragColor=vec4(1.0);}";
        const Tr = {
          prelude: ut(
            `#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`,
            `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`,
          ),
          projectionMercator: ut(
            "",
            "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}",
          ),
          projectionGlobe: ut(
            "",
            `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`,
          ),
          background: ut(
            `uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}",
          ),
          backgroundPattern: ut(
            `uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}",
          ),
          circle: ut(
            `in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`,
          ),
          clippingMask: ut(
            _a,
            "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}",
          ),
          heatmap: ut(
            `uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`,
          ),
          heatmapTexture: ut(
            `uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`,
            "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}",
          ),
          collisionBox: ut(
            "in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}",
            "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}",
          ),
          collisionCircle: ut(
            "in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}",
            "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}",
          ),
          debug: ut(
            "uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}",
            "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}",
          ),
          depth: ut(
            _a,
            `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`,
          ),
          fill: ut(
            `#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`,
          ),
          fillOutline: ut(
            `in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`,
          ),
          fillOutlinePattern: ut(
            `uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`,
          ),
          fillPattern: ut(
            `#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`,
          ),
          fillExtrusion: ut(
            `in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`,
          ),
          fillExtrusionPattern: ut(
            `uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`,
          ),
          hillshadePrepare: ut(
            `#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));fragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}",
          ),
          hillshade: ut(
            `uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}",
          ),
          line: ut(
            `uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`,
          ),
          lineGradient: ut(
            `uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`,
          ),
          linePattern: ut(
            `#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`,
          ),
          lineSDF: ut(
            `uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`,
          ),
          raster: ut(
            `uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`,
          ),
          symbolIcon: ut(
            `uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`,
          ),
          symbolSDF: ut(
            `#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`,
          ),
          symbolTextAndIcon: ut(
            `#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
            `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`,
          ),
          terrain: ut(
            "uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}",
            "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}",
          ),
          terrainDepth: ut(
            "in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}",
            "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}",
          ),
          terrainCoords: ut(
            "precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}",
            "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}",
          ),
          projectionErrorMeasurement: ut(
            "in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}",
            "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}",
          ),
          atmosphere: ut(
            `in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`,
            "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}",
          ),
          sky: ut(
            "uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}",
            "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}",
          ),
        };
        function ut(c, e) {
          const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            s = e.match(/in ([\w]+) ([\w]+)/g),
            a = c.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            h = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            f = h ? h.concat(a) : a,
            g = {};
          return {
            fragmentSource: (c = c.replace(
              i,
              (y, v, C, A, T) => (
                (g[T] = !0),
                v === "define"
                  ? `
#ifndef HAS_UNIFORM_u_${T}
in ${C} ${A} ${T};
#else
uniform ${C} ${A} u_${T};
#endif
`
                  : `
#ifdef HAS_UNIFORM_u_${T}
    ${C} ${A} ${T} = u_${T};
#endif
`
              ),
            )),
            vertexSource: (e = e.replace(i, (y, v, C, A, T) => {
              const M = A === "float" ? "vec2" : "vec4",
                k = T.match(/color/) ? "color" : M;
              return g[T]
                ? v === "define"
                  ? `
#ifndef HAS_UNIFORM_u_${T}
uniform lowp float u_${T}_t;
in ${C} ${M} a_${T};
out ${C} ${A} ${T};
#else
uniform ${C} ${A} u_${T};
#endif
`
                  : k === "vec4"
                    ? `
#ifndef HAS_UNIFORM_u_${T}
    ${T} = a_${T};
#else
    ${C} ${A} ${T} = u_${T};
#endif
`
                    : `
#ifndef HAS_UNIFORM_u_${T}
    ${T} = unpack_mix_${k}(a_${T}, u_${T}_t);
#else
    ${C} ${A} ${T} = u_${T};
#endif
`
                : v === "define"
                  ? `
#ifndef HAS_UNIFORM_u_${T}
uniform lowp float u_${T}_t;
in ${C} ${M} a_${T};
#else
uniform ${C} ${A} u_${T};
#endif
`
                  : k === "vec4"
                    ? `
#ifndef HAS_UNIFORM_u_${T}
    ${C} ${A} ${T} = a_${T};
#else
    ${C} ${A} ${T} = u_${T};
#endif
`
                    : `
#ifndef HAS_UNIFORM_u_${T}
    ${C} ${A} ${T} = unpack_mix_${k}(a_${T}, u_${T}_t);
#else
    ${C} ${A} ${T} = u_${T};
#endif
`;
            })),
            staticAttributes: s,
            staticUniforms: f,
          };
        }
        class Fr {
          constructor(e, i, s) {
            ((this.vertexBuffer = e),
              (this.indexBuffer = i),
              (this.segments = s));
          }
          destroy() {
            (this.vertexBuffer.destroy(),
              this.indexBuffer.destroy(),
              this.segments.destroy(),
              (this.vertexBuffer = null),
              (this.indexBuffer = null),
              (this.segments = null));
          }
        }
        var ct = u.aA([{ name: "a_pos", type: "Int16", components: 2 }]);
        const as = "#define PROJECTION_MERCATOR",
          ls = "mercator";
        class ki {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return ls;
          }
          get shaderDefine() {
            return as;
          }
          get shaderPreludeCode() {
            return Tr.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return Tr.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return u.aB.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, i, s, a, h) {
            if (this._cachedMesh) return this._cachedMesh;
            const f = new u.aC();
            (f.emplaceBack(0, 0),
              f.emplaceBack(u.X, 0),
              f.emplaceBack(0, u.X),
              f.emplaceBack(u.X, u.X));
            const g = e.createVertexBuffer(f, ct.members),
              y = u.aD.simpleSegment(0, 0, 4, 2),
              v = new u.aE();
            (v.emplaceBack(1, 0, 2), v.emplaceBack(1, 2, 3));
            const C = e.createIndexBuffer(v);
            return ((this._cachedMesh = new Fr(g, C, y)), this._cachedMesh);
          }
          recalculate() {}
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        function Zt(c, e) {
          const i = u.ab(e.lat, -u.aF, u.aF);
          return new u.P(u.O(e.lng) * c, u.Q(i) * c);
        }
        function Lt(c, e) {
          return new u.Y(e.x / c, e.y / c).toLngLat();
        }
        function us(c) {
          return (
            c.cameraToCenterDistance *
            Math.min(
              0.85 * Math.tan(u.aa(90 - c.pitch)),
              Math.tan(u.aa(89.25 - c.pitch)),
            )
          );
        }
        function Ti(c, e) {
          const i = c.canonical,
            s = e / u.aG(i.z),
            a = i.x + Math.pow(2, i.z) * c.wrap,
            h = u.aq(new Float64Array(16));
          return (
            u.J(h, h, [a * s, i.y * s, 0]),
            u.K(h, h, [s / u.X, s / u.X, 1]),
            h
          );
        }
        function Ui(c, e, i, s, a) {
          const h = u.Y.fromLngLat(c, e),
            f = a * u.aH(1, c.lat),
            g = f * Math.cos(u.aa(i)),
            y = Math.sqrt(f * f - g * g),
            v = y * Math.sin(u.aa(-s)),
            C = y * Math.cos(u.aa(-s));
          return new u.Y(h.x + v, h.y + C, h.z + g);
        }
        class xi {
          constructor(e = 0, i = 0, s = 0, a = 0) {
            if (
              isNaN(e) ||
              e < 0 ||
              isNaN(i) ||
              i < 0 ||
              isNaN(s) ||
              s < 0 ||
              isNaN(a) ||
              a < 0
            )
              throw new Error(
                "Invalid value for edge-insets, top, bottom, left and right must all be numbers",
              );
            ((this.top = e),
              (this.bottom = i),
              (this.left = s),
              (this.right = a));
          }
          interpolate(e, i, s) {
            return (
              i.top != null &&
                e.top != null &&
                (this.top = u.y.number(e.top, i.top, s)),
              i.bottom != null &&
                e.bottom != null &&
                (this.bottom = u.y.number(e.bottom, i.bottom, s)),
              i.left != null &&
                e.left != null &&
                (this.left = u.y.number(e.left, i.left, s)),
              i.right != null &&
                e.right != null &&
                (this.right = u.y.number(e.right, i.right, s)),
              this
            );
          }
          getCenter(e, i) {
            const s = u.ab((this.left + e - this.right) / 2, 0, e),
              a = u.ab((this.top + i - this.bottom) / 2, 0, i);
            return new u.P(s, a);
          }
          equals(e) {
            return (
              this.top === e.top &&
              this.bottom === e.bottom &&
              this.left === e.left &&
              this.right === e.right
            );
          }
          clone() {
            return new xi(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right,
            };
          }
        }
        function Po(c, e) {
          if (!c.renderWorldCopies || c.lngRange) return;
          const i = e.lng - c.center.lng;
          e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
        }
        function Wn(c) {
          return Math.max(0, Math.floor(c));
        }
        class Kt {
          constructor(e, i, s, a, h, f) {
            ((this._callbacks = e),
              (this._tileSize = 512),
              (this._renderWorldCopies = f === void 0 || !!f),
              (this._minZoom = i || 0),
              (this._maxZoom = s || 22),
              (this._minPitch = a == null ? 0 : a),
              (this._maxPitch = h == null ? 60 : h),
              this.setMaxBounds(),
              (this._width = 0),
              (this._height = 0),
              (this._center = new u.N(0, 0)),
              (this._elevation = 0),
              (this._zoom = 0),
              (this._tileZoom = Wn(this._zoom)),
              (this._scale = u.aG(this._zoom)),
              (this._bearingInRadians = 0),
              (this._fovInRadians = 0.6435011087932844),
              (this._pitchInRadians = 0),
              (this._rollInRadians = 0),
              (this._unmodified = !0),
              (this._edgeInsets = new xi()),
              (this._minElevationForCurrentTile = 0),
              (this._autoCalculateNearFarZ = !0));
          }
          apply(e, i, s) {
            ((this._latRange = e.latRange),
              (this._lngRange = e.lngRange),
              (this._width = e.width),
              (this._height = e.height),
              (this._center = e.center),
              (this._elevation = e.elevation),
              (this._minElevationForCurrentTile = e.minElevationForCurrentTile),
              (this._zoom = e.zoom),
              (this._tileZoom = Wn(this._zoom)),
              (this._scale = u.aG(this._zoom)),
              (this._bearingInRadians = e.bearingInRadians),
              (this._fovInRadians = e.fovInRadians),
              (this._pitchInRadians = e.pitchInRadians),
              (this._rollInRadians = e.rollInRadians),
              (this._unmodified = e.unmodified),
              (this._edgeInsets = new xi(
                e.padding.top,
                e.padding.bottom,
                e.padding.left,
                e.padding.right,
              )),
              (this._minZoom = e.minZoom),
              (this._maxZoom = e.maxZoom),
              (this._minPitch = e.minPitch),
              (this._maxPitch = e.maxPitch),
              (this._renderWorldCopies = e.renderWorldCopies),
              (this._cameraToCenterDistance = e.cameraToCenterDistance),
              (this._nearZ = e.nearZ),
              (this._farZ = e.farZ),
              (this._autoCalculateNearFarZ = !s && e.autoCalculateNearFarZ),
              i && this._constrain(),
              this._calcMatrices());
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e) {
            this._minZoom !== e &&
              ((this._minZoom = e),
              this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e) {
            this._maxZoom !== e &&
              ((this._maxZoom = e),
              this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e) {
            this._minPitch !== e &&
              ((this._minPitch = e), this.setPitch(Math.max(this.pitch, e)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e) {
            this._maxPitch !== e &&
              ((this._maxPitch = e), this.setPitch(Math.min(this.pitch, e)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e) {
            (e === void 0 ? (e = !0) : e === null && (e = !1),
              (this._renderWorldCopies = e));
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new u.P(this._width, this._height);
          }
          get bearing() {
            return (this._bearingInRadians / Math.PI) * 180;
          }
          setBearing(e) {
            const i = (u.aI(e, -180, 180) * Math.PI) / 180;
            var s, a, h, f, g, y, v, C, A;
            this._bearingInRadians !== i &&
              ((this._unmodified = !1),
              (this._bearingInRadians = i),
              this._calcMatrices(),
              (this._rotationMatrix = rt()),
              (s = this._rotationMatrix),
              (h = -this._bearingInRadians),
              (f = (a = this._rotationMatrix)[0]),
              (g = a[1]),
              (y = a[2]),
              (v = a[3]),
              (C = Math.sin(h)),
              (A = Math.cos(h)),
              (s[0] = f * A + y * C),
              (s[1] = g * A + v * C),
              (s[2] = f * -C + y * A),
              (s[3] = g * -C + v * A));
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return (this._pitchInRadians / Math.PI) * 180;
          }
          setPitch(e) {
            const i = (u.ab(e, this.minPitch, this.maxPitch) / 180) * Math.PI;
            this._pitchInRadians !== i &&
              ((this._unmodified = !1),
              (this._pitchInRadians = i),
              this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return (this._rollInRadians / Math.PI) * 180;
          }
          setRoll(e) {
            const i = (e / 180) * Math.PI;
            this._rollInRadians !== i &&
              ((this._unmodified = !1),
              (this._rollInRadians = i),
              this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return u.aJ(this._fovInRadians);
          }
          setFov(e) {
            ((e = u.ab(e, 0.1, 150)),
              this.fov !== e &&
                ((this._unmodified = !1),
                (this._fovInRadians = u.aa(e)),
                this._calcMatrices()));
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e) {
            const i = this.getConstrained(this._center, e).zoom;
            this._zoom !== i &&
              ((this._unmodified = !1),
              (this._zoom = i),
              (this._tileZoom = Math.max(0, Math.floor(i))),
              (this._scale = u.aG(i)),
              this._constrain(),
              this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e) {
            (e.lat === this._center.lat && e.lng === this._center.lng) ||
              ((this._unmodified = !1),
              (this._center = e),
              this._constrain(),
              this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e) {
            e !== this._elevation &&
              ((this._elevation = e), this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e) {
            this._edgeInsets.equals(e) ||
              ((this._unmodified = !1),
              this._edgeInsets.interpolate(this._edgeInsets, e, 1),
              this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e, i) {
            ((this._autoCalculateNearFarZ = !1),
              (this._nearZ = e),
              (this._farZ = i),
              this._calcMatrices());
          }
          clearNearFarZOverride() {
            ((this._autoCalculateNearFarZ = !0), this._calcMatrices());
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e);
          }
          interpolatePadding(e, i, s) {
            ((this._unmodified = !1),
              this._edgeInsets.interpolate(e, i, s),
              this._constrain(),
              this._calcMatrices());
          }
          resize(e, i, s = !0) {
            ((this._width = e),
              (this._height = i),
              s && this._constrain(),
              this._calcMatrices());
          }
          getMaxBounds() {
            return this._latRange &&
              this._latRange.length === 2 &&
              this._lngRange &&
              this._lngRange.length === 2
              ? new ti(
                  [this._lngRange[0], this._latRange[0]],
                  [this._lngRange[1], this._latRange[1]],
                )
              : null;
          }
          setMaxBounds(e) {
            e
              ? ((this._lngRange = [e.getWest(), e.getEast()]),
                (this._latRange = [e.getSouth(), e.getNorth()]),
                this._constrain())
              : ((this._lngRange = null), (this._latRange = [-u.aF, u.aF]));
          }
          getConstrained(e, i) {
            return this._callbacks.getConstrained(e, i);
          }
          getCameraQueryGeometry(e, i) {
            if (i.length === 1) return [i[0], e];
            {
              let s = e.x,
                a = e.y,
                h = e.x,
                f = e.y;
              for (const g of i)
                ((s = Math.min(s, g.x)),
                  (a = Math.min(a, g.y)),
                  (h = Math.max(h, g.x)),
                  (f = Math.max(f, g.y)));
              return [
                new u.P(s, a),
                new u.P(h, a),
                new u.P(h, f),
                new u.P(s, f),
                new u.P(s, a),
              ];
            }
          }
          _constrain() {
            if (
              !this.center ||
              !this._width ||
              !this._height ||
              this._constraining
            )
              return;
            this._constraining = !0;
            const e = this._unmodified,
              { center: i, zoom: s } = this.getConstrained(
                this.center,
                this.zoom,
              );
            (this.setCenter(i),
              this.setZoom(s),
              (this._unmodified = e),
              (this._constraining = !1));
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = u.aq(new Float64Array(16));
              (u.K(e, e, [this._width / 2, -this._height / 2, 1]),
                u.J(e, e, [1, -1, 0]),
                (this._clipSpaceToPixelsMatrix = e),
                (e = u.aq(new Float64Array(16))),
                u.K(e, e, [1, -1, 1]),
                u.J(e, e, [-1, -1, 0]),
                u.K(e, e, [2 / this._width, 2 / this._height, 1]),
                (this._pixelsToClipSpaceMatrix = e),
                (this._cameraToCenterDistance =
                  (0.5 / Math.tan(this.fovInRadians / 2)) * this._height));
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e, i, s, a) {
            const h = s !== void 0 ? s : this.bearing,
              f = (a = a !== void 0 ? a : this.pitch),
              g = u.Y.fromLngLat(e, i),
              y = -Math.cos(u.aa(f)),
              v = Math.sin(u.aa(f)),
              C = v * Math.sin(u.aa(h)),
              A = -v * Math.cos(u.aa(h));
            let T = this.elevation;
            const M = i - T;
            let k;
            y * M >= 0 || Math.abs(y) < 0.1
              ? ((k = 1e4), (T = i + k * y))
              : (k = -M / y);
            let V,
              N,
              $ = u.aK(1, g.y),
              G = 0;
            do {
              if (((G += 1), G > 10)) break;
              ((N = k / $),
                (V = new u.Y(g.x + C * N, g.y + A * N)),
                ($ = 1 / V.meterInMercatorCoordinateUnits()));
            } while (Math.abs(k - N * $) > 1e-12);
            return {
              center: V.toLngLat(),
              elevation: T,
              zoom: u.a8(
                this.height /
                  2 /
                  Math.tan(this.fovInRadians / 2) /
                  N /
                  this.tileSize,
              ),
            };
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const i = u.aH(1, this.center.lat) * this.worldSize,
              s = this.cameraToCenterDistance / i,
              a = u.Y.fromLngLat(this.center, this.elevation),
              h = Ui(this.center, this.elevation, this.pitch, this.bearing, s);
            this._elevation = e;
            const f = this.calculateCenterFromCameraLngLatAlt(
              h.toLngLat(),
              u.aK(h.z, a.y),
              this.bearing,
              this.pitch,
            );
            ((this._elevation = f.elevation),
              (this._center = f.center),
              this.setZoom(f.zoom));
          }
          getCameraPoint() {
            const e =
              Math.tan(this.pitchInRadians) *
              (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(
              new u.P(
                e * Math.sin(this.rollInRadians),
                e * Math.cos(this.rollInRadians),
              ),
            );
          }
          getCameraAltitude() {
            return (
              (Math.cos(this.pitchInRadians) * this._cameraToCenterDistance) /
                this._pixelPerMeter +
              this.elevation
            );
          }
          getCameraLngLat() {
            const e = u.aH(1, this.center.lat) * this.worldSize;
            return Ui(
              this.center,
              this.elevation,
              this.pitch,
              this.bearing,
              this.cameraToCenterDistance / e,
            ).toLngLat();
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const i =
              e.canonical.z >= 0
                ? 1 << e.canonical.z
                : Math.pow(2, e.canonical.z);
            return [
              e.canonical.x / i,
              e.canonical.y / i,
              1 / i / u.X,
              1 / i / u.X,
            ];
          }
        }
        class _r {
          constructor(e, i) {
            ((this.min = e),
              (this.max = i),
              (this.center = u.aL([], u.aM([], this.min, this.max), 0.5)));
          }
          quadrant(e) {
            const i = [e % 2 == 0, e < 2],
              s = u.aN(this.min),
              a = u.aN(this.max);
            for (let h = 0; h < i.length; h++)
              ((s[h] = i[h] ? this.min[h] : this.center[h]),
                (a[h] = i[h] ? this.center[h] : this.max[h]));
            return ((a[2] = this.max[2]), new _r(s, a));
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          intersectsFrustum(e) {
            let i = !0;
            for (let s = 0; s < e.planes.length; s++) {
              const a = this.intersectsPlane(e.planes[s]);
              if (a === 0) return 0;
              a === 1 && (i = !1);
            }
            return i
              ? 2
              : e.aabb.min[0] > this.max[0] ||
                  e.aabb.min[1] > this.max[1] ||
                  e.aabb.min[2] > this.max[2] ||
                  e.aabb.max[0] < this.min[0] ||
                  e.aabb.max[1] < this.min[1] ||
                  e.aabb.max[2] < this.min[2]
                ? 0
                : 1;
          }
          intersectsPlane(e) {
            let i = e[3],
              s = e[3];
            for (let a = 0; a < 3; a++)
              e[a] > 0
                ? ((i += e[a] * this.min[a]), (s += e[a] * this.max[a]))
                : ((s += e[a] * this.min[a]), (i += e[a] * this.max[a]));
            return i >= 0 ? 2 : s < 0 ? 0 : 1;
          }
        }
        class Pn {
          distanceToTile2d(e, i, s, a) {
            const h = a.distanceX([e, i]),
              f = a.distanceY([e, i]);
            return Math.hypot(h, f);
          }
          getWrap(e, i, s) {
            return s;
          }
          getTileAABB(e, i, s, a) {
            var h, f;
            let g = s,
              y = s;
            if (a.terrain) {
              const C = new u.S(e.z, i, e.z, e.x, e.y),
                A = a.terrain.getMinMaxElevation(C);
              ((g = (h = A.minElevation) !== null && h !== void 0 ? h : s),
                (y = (f = A.maxElevation) !== null && f !== void 0 ? f : s));
            }
            const v = 1 << e.z;
            return new _r(
              [i + e.x / v, e.y / v, g],
              [i + (e.x + 1) / v, (e.y + 1) / v, y],
            );
          }
          allowVariableZoom(e, i) {
            const s =
                (e.fov *
                  (Math.abs(Math.cos(e.rollInRadians)) * e.height +
                    Math.abs(Math.sin(e.rollInRadians)) * e.width)) /
                e.height,
              a = u.ab(78.5 - s / 2, 0, 60);
            return !!i.terrain || e.pitch > a || e.padding.top >= 0.1;
          }
          allowWorldCopies() {
            return !0;
          }
          recalculateCache() {}
        }
        class Sn {
          constructor(e, i, s) {
            ((this.points = e), (this.planes = i), (this.aabb = s));
          }
          static fromInvProjectionMatrix(e, i = 1, s = 0) {
            const a = Math.pow(2, s),
              h = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1],
              ].map((v) => {
                const C = (1 / (v = u.al([], v, e))[3] / i) * a;
                return u.aO(v, v, [C, C, 1 / v[3], C]);
              }),
              f = [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5],
              ].map((v) => {
                const C = u.aP([], h[v[0]], h[v[1]]),
                  A = u.aP([], h[v[2]], h[v[1]]),
                  T = u.aQ([], u.aR([], C, A)),
                  M = -u.aS(T, h[v[1]]);
                return T.concat(M);
              }),
              g = [
                Number.POSITIVE_INFINITY,
                Number.POSITIVE_INFINITY,
                Number.POSITIVE_INFINITY,
              ],
              y = [
                Number.NEGATIVE_INFINITY,
                Number.NEGATIVE_INFINITY,
                Number.NEGATIVE_INFINITY,
              ];
            for (const v of h)
              for (let C = 0; C < 3; C++)
                ((g[C] = Math.min(g[C], v[C])), (y[C] = Math.max(y[C], v[C])));
            return new Sn(h, f, new _r(g, y));
          }
        }
        class Fi {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, i, s) {
            return this._helper.interpolatePadding(e, i, s);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, i, s = !0) {
            this._helper.resize(e, i, s);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(
              this.getCameraPoint(),
              e,
            );
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e, i) {}
          constructor(e, i, s, a, h) {
            ((this._posMatrixCache = new Map()),
              (this._alignedPosMatrixCache = new Map()),
              (this._fogMatrixCacheF32 = new Map()),
              (this._helper = new Kt(
                {
                  calcMatrices: () => {
                    this._calcMatrices();
                  },
                  getConstrained: (f, g) => this.getConstrained(f, g),
                },
                e,
                i,
                s,
                a,
                h,
              )),
              (this._coveringTilesDetailsProvider = new Pn()));
          }
          clone() {
            const e = new Fi();
            return (e.apply(this), e);
          }
          apply(e, i, s) {
            this._helper.apply(e, i, s);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e) {
            const i = [new u.aT(0, e)];
            if (this._helper._renderWorldCopies) {
              const s = this.screenPointToMercatorCoordinate(new u.P(0, 0)),
                a = this.screenPointToMercatorCoordinate(
                  new u.P(this._helper._width, 0),
                ),
                h = this.screenPointToMercatorCoordinate(
                  new u.P(this._helper._width, this._helper._height),
                ),
                f = this.screenPointToMercatorCoordinate(
                  new u.P(0, this._helper._height),
                ),
                g = Math.floor(Math.min(s.x, a.x, h.x, f.x)),
                y = Math.floor(Math.max(s.x, a.x, h.x, f.x)),
                v = 1;
              for (let C = g - v; C <= y + v; C++)
                C !== 0 && i.push(new u.aT(C, e));
            }
            return i;
          }
          getCameraFrustum() {
            return Sn.fromInvProjectionMatrix(
              this._invViewProjMatrix,
              this.worldSize,
            );
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            const i = this.screenPointToLocation(this.centerPoint, e),
              s = e
                ? e.getElevationForLngLatZoom(i, this._helper._tileZoom)
                : 0;
            this._helper.recalculateZoomAndCenter(s);
          }
          setLocationAtPoint(e, i) {
            const s = u.aH(this.elevation, this.center.lat),
              a = this.screenPointToMercatorCoordinateAtZ(i, s),
              h = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, s),
              f = u.Y.fromLngLat(e),
              g = new u.Y(f.x - (a.x - h.x), f.y - (a.y - h.y));
            (this.setCenter(g == null ? void 0 : g.toLngLat()),
              this._helper._renderWorldCopies &&
                this.setCenter(this.center.wrap()));
          }
          locationToScreenPoint(e, i) {
            return i
              ? this.coordinatePoint(
                  u.Y.fromLngLat(e),
                  i.getElevationForLngLatZoom(e, this._helper._tileZoom),
                  this._pixelMatrix3D,
                )
              : this.coordinatePoint(u.Y.fromLngLat(e));
          }
          screenPointToLocation(e, i) {
            var s;
            return (s = this.screenPointToMercatorCoordinate(e, i)) === null ||
              s === void 0
              ? void 0
              : s.toLngLat();
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const s = i.pointCoordinate(e);
              if (s != null) return s;
            }
            return this.screenPointToMercatorCoordinateAtZ(e);
          }
          screenPointToMercatorCoordinateAtZ(e, i) {
            const s = i || 0,
              a = [e.x, e.y, 0, 1],
              h = [e.x, e.y, 1, 1];
            (u.al(a, a, this._pixelMatrixInverse),
              u.al(h, h, this._pixelMatrixInverse));
            const f = a[3],
              g = h[3],
              y = a[1] / f,
              v = h[1] / g,
              C = a[2] / f,
              A = h[2] / g,
              T = C === A ? 0 : (s - C) / (A - C);
            return new u.Y(
              u.y.number(a[0] / f, h[0] / g, T) / this.worldSize,
              u.y.number(y, v, T) / this.worldSize,
              s,
            );
          }
          coordinatePoint(e, i = 0, s = this._pixelMatrix) {
            const a = [e.x * this.worldSize, e.y * this.worldSize, i, 1];
            return (u.al(a, a, s), new u.P(a[0] / a[3], a[1] / a[3]));
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - us(this));
            return new ti()
              .extend(this.screenPointToLocation(new u.P(0, e)))
              .extend(
                this.screenPointToLocation(new u.P(this._helper._width, e)),
              )
              .extend(
                this.screenPointToLocation(
                  new u.P(this._helper._width, this._helper._height),
                ),
              )
              .extend(
                this.screenPointToLocation(new u.P(0, this._helper._height)),
              );
          }
          isPointOnMapSurface(e, i) {
            return i
              ? i.pointCoordinate(e) != null
              : e.y > this.height / 2 - us(this);
          }
          calculatePosMatrix(e, i = !1, s) {
            var a;
            const h =
                (a = e.key) !== null && a !== void 0
                  ? a
                  : u.aU(
                      e.wrap,
                      e.canonical.z,
                      e.canonical.z,
                      e.canonical.x,
                      e.canonical.y,
                    ),
              f = i ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (f.has(h)) {
              const v = f.get(h);
              return s ? v.f32 : v.f64;
            }
            const g = Ti(e, this.worldSize);
            u.L(g, i ? this._alignedProjMatrix : this._viewProjMatrix, g);
            const y = { f64: g, f32: new Float32Array(g) };
            return (f.set(h, y), s ? y.f32 : y.f64);
          }
          calculateFogMatrix(e) {
            const i = e.key,
              s = this._fogMatrixCacheF32;
            if (s.has(i)) return s.get(i);
            const a = Ti(e, this.worldSize);
            return (
              u.L(a, this._fogMatrix, a),
              s.set(i, new Float32Array(a)),
              s.get(i)
            );
          }
          getConstrained(e, i) {
            i = u.ab(+i, this.minZoom, this.maxZoom);
            const s = { center: new u.N(e.lng, e.lat), zoom: i };
            let a = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && a === null) {
              const Y = 179.9999999999;
              a = [-Y, Y];
            }
            const h = this.tileSize * u.aG(s.zoom);
            let f = 0,
              g = h,
              y = 0,
              v = h,
              C = 0,
              A = 0;
            const { x: T, y: M } = this.size;
            if (this._helper._latRange) {
              const Y = this._helper._latRange;
              ((f = u.Q(Y[1]) * h),
                (g = u.Q(Y[0]) * h),
                g - f < M && (C = M / (g - f)));
            }
            a &&
              ((y = u.aI(u.O(a[0]) * h, 0, h)),
              (v = u.aI(u.O(a[1]) * h, 0, h)),
              v < y && (v += h),
              v - y < T && (A = T / (v - y)));
            const { x: k, y: V } = Zt(h, e);
            let N, $;
            const G = Math.max(A || 0, C || 0);
            if (G) {
              const Y = new u.P(A ? (v + y) / 2 : k, C ? (g + f) / 2 : V);
              return ((s.center = Lt(h, Y).wrap()), (s.zoom += u.a8(G)), s);
            }
            if (this._helper._latRange) {
              const Y = M / 2;
              (V - Y < f && ($ = f + Y), V + Y > g && ($ = g - Y));
            }
            if (a) {
              const Y = (y + v) / 2;
              let Q = k;
              this._helper._renderWorldCopies &&
                (Q = u.aI(k, Y - h / 2, Y + h / 2));
              const ee = T / 2;
              (Q - ee < y && (N = y + ee), Q + ee > v && (N = v - ee));
            }
            if (N !== void 0 || $ !== void 0) {
              const Y = new u.P(N != null ? N : k, $ != null ? $ : V);
              s.center = Lt(h, Y).wrap();
            }
            return s;
          }
          calculateCenterFromCameraLngLatAlt(e, i, s, a) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, s, a);
          }
          _calculateNearFarZIfNeeded(e, i, s) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const a = Math.min(
                this.elevation,
                this.minElevationForCurrentTile,
                this.getCameraAltitude() - 100,
              ),
              h = e - (a * this._helper._pixelPerMeter) / Math.cos(i),
              f = a < 0 ? h : e,
              g = Math.PI / 2 + this.pitchInRadians,
              y =
                ((u.aa(this.fov) *
                  (Math.abs(Math.cos(u.aa(this.roll))) * this.height +
                    Math.abs(Math.sin(u.aa(this.roll))) * this.width)) /
                  this.height) *
                (0.5 + s.y / this.height),
              v =
                (Math.sin(y) * f) /
                Math.sin(u.ab(Math.PI - g - y, 0.01, Math.PI - 0.01)),
              C = us(this),
              A = Math.atan(C / this._helper.cameraToCenterDistance),
              T = u.aa(0.75),
              M = A > T ? 2 * A * (0.5 + s.y / (2 * C)) : T,
              k =
                (Math.sin(M) * f) /
                Math.sin(u.ab(Math.PI - g - M, 0.01, Math.PI - 0.01)),
              V = Math.min(v, k);
            ((this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * V + f)),
              (this._helper._nearZ = this._helper._height / 50));
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              i = Zt(this.worldSize, this.center),
              s = i.x,
              a = i.y;
            this._helper._pixelPerMeter =
              u.aH(1, this.center.lat) * this.worldSize;
            const h = u.aa(Math.min(this.pitch, 89.25)),
              f = Math.max(
                this._helper.cameraToCenterDistance / 2,
                this._helper.cameraToCenterDistance +
                  (this._helper._elevation * this._helper._pixelPerMeter) /
                    Math.cos(h),
              );
            let g;
            (this._calculateNearFarZIfNeeded(f, h, e),
              (g = new Float64Array(16)),
              u.aV(
                g,
                this.fovInRadians,
                this._helper._width / this._helper._height,
                this._helper._nearZ,
                this._helper._farZ,
              ),
              (this._invProjMatrix = new Float64Array(16)),
              u.an(this._invProjMatrix, g),
              (g[8] = (2 * -e.x) / this._helper._width),
              (g[9] = (2 * e.y) / this._helper._height),
              (this._projectionMatrix = u.aW(g)),
              u.K(g, g, [1, -1, 1]),
              u.J(g, g, [0, 0, -this._helper.cameraToCenterDistance]),
              u.aX(g, g, -this.rollInRadians),
              u.aY(g, g, this.pitchInRadians),
              u.aX(g, g, -this.bearingInRadians),
              u.J(g, g, [-s, -a, 0]),
              (this._mercatorMatrix = u.K([], g, [
                this.worldSize,
                this.worldSize,
                this.worldSize,
              ])),
              u.K(g, g, [1, 1, this._helper._pixelPerMeter]),
              (this._pixelMatrix = u.L(
                new Float64Array(16),
                this.clipSpaceToPixelsMatrix,
                g,
              )),
              u.J(g, g, [0, 0, -this.elevation]),
              (this._viewProjMatrix = g),
              (this._invViewProjMatrix = u.an([], g)));
            const y = [0, 0, -1, 1];
            (u.al(y, y, this._invViewProjMatrix),
              (this._cameraPosition = [y[0] / y[3], y[1] / y[3], y[2] / y[3]]),
              (this._fogMatrix = new Float64Array(16)),
              u.aV(
                this._fogMatrix,
                this.fovInRadians,
                this.width / this.height,
                f,
                this._helper._farZ,
              ),
              (this._fogMatrix[8] = (2 * -e.x) / this.width),
              (this._fogMatrix[9] = (2 * e.y) / this.height),
              u.K(this._fogMatrix, this._fogMatrix, [1, -1, 1]),
              u.J(this._fogMatrix, this._fogMatrix, [
                0,
                0,
                -this.cameraToCenterDistance,
              ]),
              u.aX(this._fogMatrix, this._fogMatrix, -this.rollInRadians),
              u.aY(this._fogMatrix, this._fogMatrix, this.pitchInRadians),
              u.aX(this._fogMatrix, this._fogMatrix, -this.bearingInRadians),
              u.J(this._fogMatrix, this._fogMatrix, [-s, -a, 0]),
              u.K(this._fogMatrix, this._fogMatrix, [
                1,
                1,
                this._helper._pixelPerMeter,
              ]),
              u.J(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]),
              (this._pixelMatrix3D = u.L(
                new Float64Array(16),
                this.clipSpaceToPixelsMatrix,
                g,
              )));
            const v = (this._helper._width % 2) / 2,
              C = (this._helper._height % 2) / 2,
              A = Math.cos(this.bearingInRadians),
              T = Math.sin(-this.bearingInRadians),
              M = s - Math.round(s) + A * v + T * C,
              k = a - Math.round(a) + A * C + T * v,
              V = new Float64Array(g);
            if (
              (u.J(V, V, [M > 0.5 ? M - 1 : M, k > 0.5 ? k - 1 : k, 0]),
              (this._alignedProjMatrix = V),
              (g = u.an(new Float64Array(16), this._pixelMatrix)),
              !g)
            )
              throw new Error("failed to invert matrix");
            ((this._pixelMatrixInverse = g), this._clearMatrixCaches());
          }
          _clearMatrixCaches() {
            (this._posMatrixCache.clear(),
              this._alignedPosMatrixCache.clear(),
              this._fogMatrixCacheF32.clear());
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new u.P(0, 0)),
              i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return (
              u.al(i, i, this._pixelMatrix)[3] /
              this._helper.cameraToCenterDistance
            );
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e = u.aH(1, this.center.lat) * this.worldSize;
            return Ui(
              this.center,
              this.elevation,
              this.pitch,
              this.bearing,
              this._helper.cameraToCenterDistance / e,
            ).toLngLat();
          }
          lngLatToCameraDepth(e, i) {
            const s = u.Y.fromLngLat(e),
              a = [s.x * this.worldSize, s.y * this.worldSize, i, 1];
            return (u.al(a, a, this._viewProjMatrix), a[2] / a[3]);
          }
          getProjectionData(e) {
            const {
                overscaledTileID: i,
                aligned: s,
                applyTerrainMatrix: a,
              } = e,
              h = this._helper.getMercatorTileCoordinates(i),
              f = i ? this.calculatePosMatrix(i, s, !0) : null;
            let g;
            return (
              (g =
                i && i.terrainRttPosMatrix32f && a
                  ? i.terrainRttPosMatrix32f
                  : f || u.aZ()),
              {
                mainMatrix: g,
                tileMercatorCoords: h,
                clippingPlane: [0, 0, 0, 0],
                projectionTransition: 0,
                fallbackMatrix: g,
              }
            );
          }
          isLocationOccluded(e) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e, i, s) {
            return 1;
          }
          transformLightDirection(e) {
            return u.aN(e);
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e, i, s, a) {
            const h = this.calculatePosMatrix(s);
            let f;
            a
              ? ((f = [e, i, a(e, i), 1]), u.al(f, f, h))
              : ((f = [e, i, 0, 1]), ni(f, f, h));
            const g = f[3];
            return {
              point: new u.P(f[0] / g, f[1] / g),
              signedDistanceFromCamera: g,
              isOccluded: !1,
            };
          }
          populateCache(e) {
            for (const i of e) this.calculatePosMatrix(i);
          }
          getMatrixForModel(e, i) {
            const s = u.Y.fromLngLat(e, i),
              a = s.meterInMercatorCoordinateUnits(),
              h = u.a_();
            return (
              u.J(h, h, [s.x, s.y, s.z]),
              u.aX(h, h, Math.PI),
              u.aY(h, h, Math.PI / 2),
              u.K(h, h, [-a, a, a]),
              h
            );
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = new u.S(0, 0, 0, 0, 0),
              s = this.getProjectionData({
                overscaledTileID: i,
                applyGlobeMatrix: e,
              }),
              a = Ti(i, this.worldSize);
            (u.L(a, this._viewProjMatrix, a),
              (s.tileMercatorCoords = [0, 0, 1, 1]));
            const h = [u.X, u.X, this.worldSize / this._helper.pixelsPerMeter],
              f = u.a$();
            return (
              u.K(f, a, h),
              (s.fallbackMatrix = f),
              (s.mainMatrix = f),
              s
            );
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e);
          }
        }
        function ya() {
          u.w(
            "Map cannot fit within canvas with the given bounds, padding, and/or offset.",
          );
        }
        function Or(c) {
          if (c.useSlerp)
            if (c.k < 1) {
              const e = u.b0(
                  c.startEulerAngles.roll,
                  c.startEulerAngles.pitch,
                  c.startEulerAngles.bearing,
                ),
                i = u.b0(
                  c.endEulerAngles.roll,
                  c.endEulerAngles.pitch,
                  c.endEulerAngles.bearing,
                ),
                s = new Float64Array(4);
              u.b1(s, e, i, c.k);
              const a = u.b2(s);
              (c.tr.setRoll(a.roll),
                c.tr.setPitch(a.pitch),
                c.tr.setBearing(a.bearing));
            } else
              (c.tr.setRoll(c.endEulerAngles.roll),
                c.tr.setPitch(c.endEulerAngles.pitch),
                c.tr.setBearing(c.endEulerAngles.bearing));
          else
            (c.tr.setRoll(
              u.y.number(c.startEulerAngles.roll, c.endEulerAngles.roll, c.k),
            ),
              c.tr.setPitch(
                u.y.number(
                  c.startEulerAngles.pitch,
                  c.endEulerAngles.pitch,
                  c.k,
                ),
              ),
              c.tr.setBearing(
                u.y.number(
                  c.startEulerAngles.bearing,
                  c.endEulerAngles.bearing,
                  c.k,
                ),
              ));
        }
        function xa(c, e, i, s, a) {
          const h = a.padding,
            f = Zt(a.worldSize, i.getNorthWest()),
            g = Zt(a.worldSize, i.getNorthEast()),
            y = Zt(a.worldSize, i.getSouthEast()),
            v = Zt(a.worldSize, i.getSouthWest()),
            C = u.aa(-s),
            A = f.rotate(C),
            T = g.rotate(C),
            M = y.rotate(C),
            k = v.rotate(C),
            V = new u.P(
              Math.max(A.x, T.x, k.x, M.x),
              Math.max(A.y, T.y, k.y, M.y),
            ),
            N = new u.P(
              Math.min(A.x, T.x, k.x, M.x),
              Math.min(A.y, T.y, k.y, M.y),
            ),
            $ = V.sub(N),
            G = (a.width - (h.left + h.right + e.left + e.right)) / $.x,
            Y = (a.height - (h.top + h.bottom + e.top + e.bottom)) / $.y;
          if (Y < 0 || G < 0) return void ya();
          const Q = Math.min(u.a8(a.scale * Math.min(G, Y)), c.maxZoom),
            ee = u.P.convert(c.offset),
            re = new u.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(
              u.aa(s),
            ),
            ie = ee.add(re).mult(a.scale / u.aG(Q));
          return {
            center: Lt(a.worldSize, f.add(y).div(2).sub(ie)),
            zoom: Q,
            bearing: s,
          };
        }
        class tn {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(e, i) {
            return { easingOffset: e, easingCenter: i.center };
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            (e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta),
              e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta),
              e.rollDelta && i.setRoll(i.roll + e.rollDelta),
              e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta));
          }
          handleMapControlsPan(e, i, s) {
            e.around.distSqr(i.centerPoint) < 0.01 ||
              i.setLocationAtPoint(s, e.around);
          }
          cameraForBoxAndBearing(e, i, s, a, h) {
            return xa(e, i, s, a, h);
          }
          handleJumpToCenterZoom(e, i) {
            (e.zoom !== (i.zoom !== void 0 ? +i.zoom : e.zoom) &&
              e.setZoom(+i.zoom),
              i.center !== void 0 && e.setCenter(u.N.convert(i.center)));
          }
          handleEaseTo(e, i) {
            const s = e.zoom,
              a = e.padding,
              h = { roll: e.roll, pitch: e.pitch, bearing: e.bearing },
              f = {
                roll: i.roll === void 0 ? e.roll : i.roll,
                pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                bearing: i.bearing === void 0 ? e.bearing : i.bearing,
              },
              g = i.zoom !== void 0,
              y = !e.isPaddingEqual(i.padding);
            let v = !1;
            const C = g ? +i.zoom : e.zoom;
            let A = e.centerPoint.add(i.offsetAsPoint);
            const T = e.screenPointToLocation(A),
              { center: M, zoom: k } = e.getConstrained(
                u.N.convert(i.center || T),
                C != null ? C : s,
              );
            Po(e, M);
            const V = Zt(e.worldSize, T),
              N = Zt(e.worldSize, M).sub(V),
              $ = u.aG(k - s);
            return (
              (v = k !== s),
              {
                easeFunc: (G) => {
                  if (
                    (v && e.setZoom(u.y.number(s, k, G)),
                    u.b3(h, f) ||
                      Or({
                        startEulerAngles: h,
                        endEulerAngles: f,
                        tr: e,
                        k: G,
                        useSlerp: h.roll != f.roll,
                      }),
                    y &&
                      (e.interpolatePadding(a, i.padding, G),
                      (A = e.centerPoint.add(i.offsetAsPoint))),
                    i.around)
                  )
                    e.setLocationAtPoint(i.around, i.aroundPoint);
                  else {
                    const Y = u.aG(e.zoom - s),
                      Q = k > s ? Math.min(2, $) : Math.max(0.5, $),
                      ee = Math.pow(Q, 1 - G),
                      re = Lt(e.worldSize, V.add(N.mult(G * ee)).mult(Y));
                    e.setLocationAtPoint(
                      e.renderWorldCopies ? re.wrap() : re,
                      A,
                    );
                  }
                },
                isZooming: v,
                elevationCenter: M,
              }
            );
          }
          handleFlyTo(e, i) {
            const s = i.zoom !== void 0,
              a = e.zoom,
              h = e.getConstrained(
                u.N.convert(i.center || i.locationAtOffset),
                s ? +i.zoom : a,
              ),
              f = h.center,
              g = h.zoom;
            Po(e, f);
            const y = Zt(e.worldSize, i.locationAtOffset),
              v = Zt(e.worldSize, f).sub(y),
              C = v.mag(),
              A = u.aG(g - a);
            let T;
            if (i.minZoom !== void 0) {
              const M = Math.min(+i.minZoom, a, g),
                k = e.getConstrained(f, M).zoom;
              T = u.aG(k - a);
            }
            return {
              easeFunc: (M, k, V, N) => {
                e.setZoom(M === 1 ? g : a + u.a8(k));
                const $ =
                  M === 1 ? f : Lt(e.worldSize, y.add(v.mult(V)).mult(k));
                e.setLocationAtPoint(e.renderWorldCopies ? $.wrap() : $, N);
              },
              scaleOfZoom: A,
              targetCenter: f,
              scaleOfMinZoom: T,
              pixelPathLength: C,
            };
          }
        }
        class Rt {
          constructor(e, i, s) {
            ((this.blendFunction = e), (this.blendColor = i), (this.mask = s));
          }
        }
        ((Rt.Replace = [1, 0]),
          (Rt.disabled = new Rt(Rt.Replace, u.b4.transparent, [
            !1,
            !1,
            !1,
            !1,
          ])),
          (Rt.unblended = new Rt(Rt.Replace, u.b4.transparent, [
            !0,
            !0,
            !0,
            !0,
          ])),
          (Rt.alphaBlended = new Rt([1, 771], u.b4.transparent, [
            !0,
            !0,
            !0,
            !0,
          ])));
        const Kn = 2305;
        class xt {
          constructor(e, i, s) {
            ((this.enable = e), (this.mode = i), (this.frontFace = s));
          }
        }
        ((xt.disabled = new xt(!1, 1029, Kn)),
          (xt.backCCW = new xt(!0, 1029, Kn)),
          (xt.frontCCW = new xt(!0, 1028, Kn)));
        class at {
          constructor(e, i, s) {
            ((this.func = e), (this.mask = i), (this.range = s));
          }
        }
        ((at.ReadOnly = !1),
          (at.ReadWrite = !0),
          (at.disabled = new at(519, at.ReadOnly, [0, 1])));
        const cs = 7680;
        class vt {
          constructor(e, i, s, a, h, f) {
            ((this.test = e),
              (this.ref = i),
              (this.mask = s),
              (this.fail = a),
              (this.depthFail = h),
              (this.pass = f));
          }
        }
        vt.disabled = new vt({ func: 519, mask: 0 }, 0, 0, cs, cs, cs);
        const hs = new WeakMap();
        function lr(c) {
          var e;
          if (hs.has(c)) return hs.get(c);
          {
            const i =
              (e = c.getParameter(c.VERSION)) === null || e === void 0
                ? void 0
                : e.startsWith("WebGL 2.0");
            return (hs.set(c, i), i);
          }
        }
        class Yn {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e) {
            ((this._readbackWaitFrames = 4),
              (this._measureWaitFrames = 6),
              (this._texWidth = 1),
              (this._texHeight = 1),
              (this._measuredError = 0),
              (this._updateCount = 0),
              (this._lastReadbackFrame = -1e3),
              (this._readbackQueue = null),
              (this._cachedRenderContext = e));
            const i = e.context,
              s = i.gl;
            ((this._texFormat = s.RGBA), (this._texType = s.UNSIGNED_BYTE));
            const a = new u.aC();
            (a.emplaceBack(-1, -1), a.emplaceBack(2, -1), a.emplaceBack(-1, 2));
            const h = new u.aE();
            (h.emplaceBack(0, 1, 2),
              (this._fullscreenTriangle = new Fr(
                i.createVertexBuffer(a, ct.members),
                i.createIndexBuffer(h),
                u.aD.simpleSegment(0, 0, a.length, h.length),
              )),
              (this._resultBuffer = new Uint8Array(4)),
              i.activeTexture.set(s.TEXTURE1));
            const f = s.createTexture();
            (s.bindTexture(s.TEXTURE_2D, f),
              s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
              s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
              s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST),
              s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST),
              s.texImage2D(
                s.TEXTURE_2D,
                0,
                this._texFormat,
                this._texWidth,
                this._texHeight,
                0,
                this._texFormat,
                this._texType,
                null,
              ),
              (this._fbo = i.createFramebuffer(
                this._texWidth,
                this._texHeight,
                !1,
                !1,
              )),
              this._fbo.colorAttachment.set(f),
              lr(s) &&
                ((this._pbo = s.createBuffer()),
                s.bindBuffer(s.PIXEL_PACK_BUFFER, this._pbo),
                s.bufferData(s.PIXEL_PACK_BUFFER, 4, s.STREAM_READ),
                s.bindBuffer(s.PIXEL_PACK_BUFFER, null)));
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            (this._fullscreenTriangle.destroy(),
              this._fbo.destroy(),
              e.deleteBuffer(this._pbo),
              (this._fullscreenTriangle = null),
              (this._fbo = null),
              (this._pbo = null),
              (this._resultBuffer = null));
          }
          updateErrorLoop(e, i) {
            const s = this._updateCount;
            return (
              this._readbackQueue
                ? s >=
                    this._readbackQueue.frameNumberIssued +
                      this._readbackWaitFrames && this._tryReadback()
                : s >= this._lastReadbackFrame + this._measureWaitFrames &&
                  this._renderErrorTexture(e, i),
              this._updateCount++,
              this._measuredError
            );
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              i = e.gl;
            (e.activeTexture.set(i.TEXTURE1),
              i.bindTexture(i.TEXTURE_2D, this._fbo.colorAttachment.get()),
              e.bindFramebuffer.set(this._fbo.framebuffer));
          }
          _renderErrorTexture(e, i) {
            const s = this._cachedRenderContext.context,
              a = s.gl;
            if (
              (this._bindFramebuffer(),
              s.viewport.set([0, 0, this._texWidth, this._texHeight]),
              s.clear({ color: u.b4.transparent }),
              this._cachedRenderContext
                .useProgram("projectionErrorMeasurement")
                .draw(
                  s,
                  a.TRIANGLES,
                  at.disabled,
                  vt.disabled,
                  Rt.unblended,
                  xt.disabled,
                  ((h, f) => ({ u_input: h, u_output_expected: f }))(e, i),
                  null,
                  null,
                  "$clipping",
                  this._fullscreenTriangle.vertexBuffer,
                  this._fullscreenTriangle.indexBuffer,
                  this._fullscreenTriangle.segments,
                ),
              this._pbo && lr(a))
            ) {
              (a.bindBuffer(a.PIXEL_PACK_BUFFER, this._pbo),
                a.readBuffer(a.COLOR_ATTACHMENT0),
                a.readPixels(
                  0,
                  0,
                  this._texWidth,
                  this._texHeight,
                  this._texFormat,
                  this._texType,
                  0,
                ),
                a.bindBuffer(a.PIXEL_PACK_BUFFER, null));
              const h = a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE, 0);
              (a.flush(),
                (this._readbackQueue = {
                  frameNumberIssued: this._updateCount,
                  sync: h,
                }));
            } else
              this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: null,
              };
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && lr(e)) {
              const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (i === e.WAIT_FAILED)
                return (
                  u.w("WebGL2 clientWaitSync failed."),
                  (this._readbackQueue = null),
                  void (this._lastReadbackFrame = this._updateCount)
                );
              if (i === e.TIMEOUT_EXPIRED) return;
              (e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo),
                e.getBufferSubData(
                  e.PIXEL_PACK_BUFFER,
                  0,
                  this._resultBuffer,
                  0,
                  4,
                ),
                e.bindBuffer(e.PIXEL_PACK_BUFFER, null));
            } else
              (this._bindFramebuffer(),
                e.readPixels(
                  0,
                  0,
                  this._texWidth,
                  this._texHeight,
                  this._texFormat,
                  this._texType,
                  this._resultBuffer,
                ));
            ((this._readbackQueue = null),
              (this._measuredError = Yn._parseRGBA8float(this._resultBuffer)),
              (this._lastReadbackFrame = this._updateCount));
          }
          static _parseRGBA8float(e) {
            let i = 0;
            return (
              (i += e[0] / 256),
              (i += e[1] / 65536),
              (i += e[2] / 16777216),
              e[3] < 127 && (i = -i),
              i / 128
            );
          }
        }
        const Dn = u.X / 128;
        function ds(c, e) {
          const i = c.granularity !== void 0 ? Math.max(c.granularity, 1) : 1,
            s = i + (c.generateBorders ? 2 : 0),
            a =
              i +
              (c.extendToNorthPole || c.generateBorders ? 1 : 0) +
              (c.extendToSouthPole || c.generateBorders ? 1 : 0),
            h = s + 1,
            f = a + 1,
            g = c.generateBorders ? -1 : 0,
            y = c.generateBorders || c.extendToNorthPole ? -1 : 0,
            v = i + (c.generateBorders ? 1 : 0),
            C = i + (c.generateBorders || c.extendToSouthPole ? 1 : 0),
            A = h * f,
            T = s * a * 6,
            M = h * f > 65536;
          if (M && e === "16bit")
            throw new Error(
              "Granularity is too large and meshes would not fit inside 16 bit vertex indices.",
            );
          const k = M || e === "32bit",
            V = new Int16Array(2 * A);
          let N = 0;
          for (let Y = y; Y <= C; Y++)
            for (let Q = g; Q <= v; Q++) {
              let ee = (Q / i) * u.X;
              (Q === -1 && (ee = -Dn), Q === i + 1 && (ee = u.X + Dn));
              let re = (Y / i) * u.X;
              (Y === -1 && (re = c.extendToNorthPole ? u.b6 : -Dn),
                Y === i + 1 && (re = c.extendToSouthPole ? u.b7 : u.X + Dn),
                (V[N++] = ee),
                (V[N++] = re));
            }
          const $ = k ? new Uint32Array(T) : new Uint16Array(T);
          let G = 0;
          for (let Y = 0; Y < a; Y++)
            for (let Q = 0; Q < s; Q++) {
              const ee = Q + 1 + Y * h,
                re = Q + (Y + 1) * h,
                ie = Q + 1 + (Y + 1) * h;
              (($[G++] = Q + Y * h),
                ($[G++] = re),
                ($[G++] = ee),
                ($[G++] = ee),
                ($[G++] = re),
                ($[G++] = ie));
            }
          return {
            vertices: V.buffer.slice(0),
            indices: $.buffer.slice(0),
            uses32bitIndices: k,
          };
        }
        const So = new u.aB({
          fill: new u.b8(128, 2),
          line: new u.b8(512, 0),
          tile: new u.b8(128, 32),
          stencil: new u.b8(128, 1),
          circle: 3,
        });
        class Do {
          constructor() {
            ((this._tileMeshCache = {}),
              (this._errorCorrectionUsable = 0),
              (this._errorMeasurementLastValue = 0),
              (this._errorCorrectionPreviousValue = 0),
              (this._errorMeasurementLastChangeTime = -1e3));
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return Tr.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return Tr.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return So;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new Yn(e));
            const i = u.Q(this._errorQueryLatitudeDegrees),
              s =
                2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) -
                0.5 * Math.PI,
              a = this._errorMeasurement.updateErrorLoop(i, s),
              h = Qe.now();
            a !== this._errorMeasurementLastValue &&
              ((this._errorCorrectionPreviousValue =
                this._errorCorrectionUsable),
              (this._errorMeasurementLastValue = a),
              (this._errorMeasurementLastChangeTime = h));
            const f = Math.min(
              Math.max(
                (h - this._errorMeasurementLastChangeTime) / 1e3 / 0.5,
                0,
              ),
              1,
            );
            this._errorCorrectionUsable = u.b9(
              this._errorCorrectionPreviousValue,
              -this._errorMeasurementLastValue,
              u.ba(f),
            );
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e, i, s, a, h) {
            const f = (
              h === "stencil" ? So.stencil : So.tile
            ).getGranularityForZoomLevel(i.z);
            return this._getMesh(e, {
              granularity: f,
              generateBorders: s,
              extendToNorthPole: i.y === 0 && a,
              extendToSouthPole: i.y === (1 << i.z) - 1 && a,
            });
          }
          _getMesh(e, i) {
            const s = this._getMeshKey(i);
            if (s in this._tileMeshCache) return this._tileMeshCache[s];
            const a = (function (h, f) {
              const g = ds(f, "16bit"),
                y = u.aC.deserialize({
                  arrayBuffer: g.vertices,
                  length: g.vertices.byteLength / 2 / 2,
                }),
                v = u.aE.deserialize({
                  arrayBuffer: g.indices,
                  length: g.indices.byteLength / 2 / 3,
                });
              return new Fr(
                h.createVertexBuffer(y, ct.members),
                h.createIndexBuffer(v),
                u.aD.simpleSegment(0, 0, y.length, v.length),
              );
            })(e, i);
            return ((this._tileMeshCache[s] = a), a);
          }
          recalculate(e) {}
          hasTransition() {
            const e = Qe.now();
            let i = !1;
            return (
              (i = i || (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7),
              (i =
                i ||
                (this._errorMeasurement &&
                  this._errorMeasurement.awaitingQuery)),
              i
            );
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e;
          }
        }
        const va = new u.q({ type: new u.D(u.v.projection.type) });
        class ps extends u.E {
          constructor(e) {
            (super(),
              (this._transitionable = new u.T(va)),
              this.setProjection(e),
              (this._transitioning = this._transitionable.untransitioned()),
              this.recalculate(new u.z(0)),
              (this._mercatorProjection = new ki()),
              (this._verticalPerspectiveProjection = new Do()));
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof u.bb) {
              if (e.from === "vertical-perspective" && e.to === "mercator")
                return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective")
                return e.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection
              .latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering
              ? this._verticalPerspectiveProjection
              : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            (this._mercatorProjection.destroy(),
              this._verticalPerspectiveProjection.destroy());
          }
          updateGPUdependent(e) {
            (this._mercatorProjection.updateGPUdependent(e),
              this._verticalPerspectiveProjection.updateGPUdependent(e));
          }
          getMeshFromTileID(e, i, s, a, h) {
            return this.currentProjection.getMeshFromTileID(e, i, s, a, h);
          }
          setProjection(e) {
            this._transitionable.setValue(
              "type",
              (e == null ? void 0 : e.type) || "mercator",
            );
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(
              e,
              this._transitioning,
            );
          }
          hasTransition() {
            return (
              this._transitioning.hasTransition() ||
              this.currentProjection.hasTransition()
            );
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          setErrorQueryLatitudeDegrees(e) {
            (this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(
              e,
            ),
              this._mercatorProjection.setErrorQueryLatitudeDegrees(e));
          }
        }
        function Mo(c) {
          const e = fs(c.worldSize, c.center.lat);
          return 2 * Math.PI * e;
        }
        function rn(c, e, i, s, a) {
          const h = 1 / (1 << a),
            f = (e / u.X) * h + s * h,
            g = u.bd(
              ((c / u.X) * h + i * h) * Math.PI * 2 + Math.PI,
              2 * Math.PI,
            ),
            y =
              2 * Math.atan(Math.exp(Math.PI - f * Math.PI * 2)) -
              0.5 * Math.PI,
            v = Math.cos(y),
            C = new Float64Array(3);
          return (
            (C[0] = Math.sin(g) * v),
            (C[1] = Math.sin(y)),
            (C[2] = Math.cos(g) * v),
            C
          );
        }
        function oi(c) {
          return (function (e, i) {
            const s = Math.cos(i),
              a = new Float64Array(3);
            return (
              (a[0] = Math.sin(e) * s),
              (a[1] = Math.sin(i)),
              (a[2] = Math.cos(e) * s),
              a
            );
          })((c.lng * Math.PI) / 180, (c.lat * Math.PI) / 180);
        }
        function fs(c, e) {
          return c / (2 * Math.PI) / Math.cos((e * Math.PI) / 180);
        }
        function ms(c) {
          const e = (Math.asin(c[1]) / Math.PI) * 180,
            i = Math.sqrt(c[0] * c[0] + c[2] * c[2]);
          if (i > 1e-6) {
            const s = c[0] / i,
              a = Math.acos(c[2] / i),
              h = ((s > 0 ? a : -a) / Math.PI) * 180;
            return new u.N(u.aI(h, -180, 180), e);
          }
          return new u.N(0, e);
        }
        function Io(c) {
          return Math.cos((c * Math.PI) / 180);
        }
        function mi(c, e) {
          const i = Io(c),
            s = Io(e);
          return u.a8(s / i);
        }
        function Ol(c, e) {
          const i = c.rotate(e.bearingInRadians),
            s = e.zoom + mi(e.center.lat, 0),
            a = u.b9(
              1 / Io(e.center.lat),
              1 / Io(Math.min(Math.abs(e.center.lat), 60)),
              u.bc(s, 7, 3, 0, 1),
            ),
            h =
              360 /
              Mo({ worldSize: e.worldSize, center: { lat: e.center.lat } });
          return new u.N(
            e.center.lng - i.x * h * a,
            u.ab(e.center.lat + i.y * h, -u.aF, u.aF),
          );
        }
        function zi(c) {
          const e = 0.5 * c,
            i = Math.sin(e),
            s = Math.cos(e);
          return Math.log(i + s) - Math.log(s - i);
        }
        function gs(c, e, i, s) {
          const a = c.lat + i * s;
          if (Math.abs(i) > 1) {
            const h =
                ((Math.sign(c.lat + i) !== Math.sign(c.lat)
                  ? -Math.abs(c.lat)
                  : Math.abs(c.lat)) *
                  Math.PI) /
                180,
              f = (Math.abs(c.lat + i) * Math.PI) / 180,
              g = zi(h + s * (f - h)),
              y = zi(h),
              v = zi(f);
            return new u.N(c.lng + e * ((g - y) / (v - y)), a);
          }
          return new u.N(c.lng + e * s, a);
        }
        class Pr {
          constructor(e) {
            ((this._cachePrevious = new Map()),
              (this._cache = new Map()),
              (this._hadAnyChanges = !1),
              (this._aabbFactory = e));
          }
          recalculateCache() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            ((this._cachePrevious = this._cache),
              (this._cache = e),
              this._cache.clear(),
              (this._hadAnyChanges = !1));
          }
          getTileAABB(e, i, s, a) {
            const h = `${e.z}_${e.x}_${e.y}`,
              f = this._cache.get(h);
            if (f) return f;
            const g = this._cachePrevious.get(h);
            if (g) return (this._cache.set(h, g), g);
            const y = this._aabbFactory(e, i, s, a);
            return (this._cache.set(h, y), (this._hadAnyChanges = !0), y);
          }
        }
        function Mn(c, e, i) {
          const s = c - e;
          return s < 0 ? -s : Math.max(0, s - i);
        }
        function _s(c, e, i, s, a) {
          const h = c - i;
          let f;
          return (
            (f =
              h < 0
                ? Math.min(-h, 1 + h - a)
                : h > 1
                  ? Math.min(Math.max(h - a, 0), 1 - h)
                  : 0),
            Math.max(f, Mn(e, s, a))
          );
        }
        class jl {
          constructor() {
            this._aabbCache = new Pr(this._computeTileAABB);
          }
          recalculateCache() {
            this._aabbCache.recalculateCache();
          }
          distanceToTile2d(e, i, s, a) {
            const h = 1 << s.z,
              f = 1 / h,
              g = s.x / h,
              y = s.y / h;
            let v = 2;
            return (
              (v = Math.min(v, _s(e, i, g, y, f))),
              (v = Math.min(v, _s(e, i, g + 0.5, -y - f, f))),
              (v = Math.min(v, _s(e, i, g + 0.5, 2 - y - f, f))),
              v
            );
          }
          getWrap(e, i, s) {
            const a = 1 << i.z,
              h = 1 / a,
              f = i.x / a,
              g = Mn(e.x, f, h),
              y = Mn(e.x, f - 1, h),
              v = Mn(e.x, f + 1, h),
              C = Math.min(g, y, v);
            return C === v ? 1 : C === y ? -1 : 0;
          }
          allowVariableZoom(e, i) {
            return Qr(e, i) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileAABB(e, i, s, a) {
            return this._aabbCache.getTileAABB(e, i, s, a);
          }
          _computeTileAABB(e, i, s, a) {
            if (e.z <= 0) return new _r([-1, -1, -1], [1, 1, 1]);
            if (e.z === 1)
              return new _r(
                [e.x === 0 ? -1 : 0, e.y === 0 ? 0 : -1, -1],
                [e.x === 0 ? 0 : 1, e.y === 0 ? 1 : 0, 1],
              );
            {
              const h = [
                  rn(0, 0, e.x, e.y, e.z),
                  rn(u.X, 0, e.x, e.y, e.z),
                  rn(u.X, u.X, e.x, e.y, e.z),
                  rn(0, u.X, e.x, e.y, e.z),
                ],
                f = [1, 1, 1],
                g = [-1, -1, -1];
              for (const y of h)
                for (let v = 0; v < 3; v++)
                  ((f[v] = Math.min(f[v], y[v])),
                    (g[v] = Math.max(g[v], y[v])));
              if (e.y === 0 || e.y === (1 << e.z) - 1) {
                const y = [0, e.y === 0 ? 1 : -1, 0];
                for (let v = 0; v < 3; v++)
                  ((f[v] = Math.min(f[v], y[v])),
                    (g[v] = Math.max(g[v], y[v])));
              }
              return new _r(f, g);
            }
          }
        }
        class jr {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, i, s) {
            return this._helper.interpolatePadding(e, i, s);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, i) {
            this._helper.resize(e, i);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(
              this.getCameraPoint(),
              e,
            );
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e) {}
          constructor() {
            ((this._cachedClippingPlane = u.be()),
              (this._projectionMatrix = u.a_()),
              (this._globeViewProjMatrix32f = u.aZ()),
              (this._globeViewProjMatrixNoCorrection = u.a_()),
              (this._globeViewProjMatrixNoCorrectionInverted = u.a_()),
              (this._globeProjMatrixInverted = u.a_()),
              (this._cameraPosition = u.bf()),
              (this._globeLatitudeErrorCorrectionRadians = 0),
              (this._helper = new Kt({
                calcMatrices: () => {
                  this._calcMatrices();
                },
                getConstrained: (e, i) => this.getConstrained(e, i),
              })),
              (this._coveringTilesDetailsProvider = new jl()));
          }
          clone() {
            const e = new jr();
            return (e.apply(this), e);
          }
          apply(e, i) {
            ((this._globeLatitudeErrorCorrectionRadians = i || 0),
              this._helper.apply(e));
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e = u.bf();
            return (
              (e[0] = this._cameraPosition[0]),
              (e[1] = this._cameraPosition[1]),
              (e[2] = this._cameraPosition[2]),
              e
            );
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e) {
            const { overscaledTileID: i, applyGlobeMatrix: s } = e,
              a = this._helper.getMercatorTileCoordinates(i);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: a,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: s ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f,
            };
          }
          _computeClippingPlane(e) {
            const i = this.pitchInRadians,
              s = this.cameraToCenterDistance / e,
              a = Math.sin(i) * s,
              h = Math.cos(i) * s + 1,
              f = (1 / Math.sqrt(a * a + h * h)) * 1;
            let g = -a,
              y = h;
            const v = Math.sqrt(g * g + y * y);
            ((g /= v), (y /= v));
            const C = [0, g, y];
            return (
              u.bg(C, C, [0, 0, 0], -this.bearingInRadians),
              u.bh(C, C, [0, 0, 0], (-1 * this.center.lat * Math.PI) / 180),
              u.bi(C, C, [0, 0, 0], (this.center.lng * Math.PI) / 180),
              u.aL(C, C, 0.25),
              [...C, 0.25 * -f]
            );
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(oi(e));
          }
          transformLightDirection(e) {
            const i = (this._helper._center.lng * Math.PI) / 180,
              s = (this._helper._center.lat * Math.PI) / 180,
              a = Math.cos(s),
              h = [Math.sin(i) * a, Math.sin(s), Math.cos(i) * a],
              f = [h[2], 0, -h[0]],
              g = [0, 0, 0];
            (u.aR(g, f, h), u.aQ(f, f), u.aQ(g, g));
            const y = [0, 0, 0];
            return (
              u.aQ(y, [
                f[0] * e[0] + g[0] * e[1] + h[0] * e[2],
                f[1] * e[0] + g[1] * e[1] + h[1] * e[2],
                f[2] * e[0] + g[2] * e[1] + h[2] * e[2],
              ]),
              y
            );
          }
          getPixelScale() {
            return 1 / Math.cos((this._helper._center.lat * Math.PI) / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos((this._helper._center.lat * Math.PI) / 180);
          }
          getPitchedTextCorrection(e, i, s) {
            const a = (function (g, y, v) {
                const C = 1 / (1 << v.z);
                return new u.Y(
                  (g / u.X) * C + v.x * C,
                  (y / u.X) * C + v.y * C,
                );
              })(e, i, s.canonical),
              h =
                ((f = a.y),
                [
                  u.bd(a.x * Math.PI * 2 + Math.PI, 2 * Math.PI),
                  2 * Math.atan(Math.exp(Math.PI - f * Math.PI * 2)) -
                    0.5 * Math.PI,
                ]);
            var f;
            return this.getCircleRadiusCorrection() / Math.cos(h[1]);
          }
          projectTileCoordinates(e, i, s, a) {
            const h = s.canonical,
              f = rn(e, i, h.x, h.y, h.z),
              g = 1 + (a ? a(e, i) : 0) / u.bo,
              y = [f[0] * g, f[1] * g, f[2] * g, 1];
            u.al(y, y, this._globeViewProjMatrixNoCorrection);
            const v = this._cachedClippingPlane,
              C = v[0] * f[0] + v[1] * f[1] + v[2] * f[2] + v[3] < 0;
            return {
              point: new u.P(y[0] / y[3], y[1] / y[3]),
              signedDistanceFromCamera: y[3],
              isOccluded: C,
            };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = fs(this.worldSize, this.center.lat),
              i = u.a$(),
              s = u.a$();
            (this._helper.autoCalculateNearFarZ &&
              ((this._helper._nearZ = 0.5),
              (this._helper._farZ = this.cameraToCenterDistance + 2 * e)),
              u.aV(
                i,
                this.fovInRadians,
                this.width / this.height,
                this._helper._nearZ,
                this._helper._farZ,
              ));
            const a = this.centerOffset;
            ((i[8] = (2 * -a.x) / this._helper._width),
              (i[9] = (2 * a.y) / this._helper._height),
              (this._projectionMatrix = u.aW(i)),
              (this._globeProjMatrixInverted = u.a$()),
              u.an(this._globeProjMatrixInverted, i),
              u.J(i, i, [0, 0, -this.cameraToCenterDistance]),
              u.aX(i, i, this.rollInRadians),
              u.aY(i, i, -this.pitchInRadians),
              u.aX(i, i, this.bearingInRadians),
              u.J(i, i, [0, 0, -e]));
            const h = u.bf();
            ((h[0] = e),
              (h[1] = e),
              (h[2] = e),
              u.aY(s, i, (this.center.lat * Math.PI) / 180),
              u.bj(s, s, (-this.center.lng * Math.PI) / 180),
              u.K(s, s, h),
              (this._globeViewProjMatrixNoCorrection = s),
              u.aY(
                i,
                i,
                (this.center.lat * Math.PI) / 180 -
                  this._globeLatitudeErrorCorrectionRadians,
              ),
              u.bj(i, i, (-this.center.lng * Math.PI) / 180),
              u.K(i, i, h),
              (this._globeViewProjMatrix32f = new Float32Array(i)),
              (this._globeViewProjMatrixNoCorrectionInverted = u.a$()),
              u.an(this._globeViewProjMatrixNoCorrectionInverted, s));
            const f = u.bf();
            ((this._cameraPosition = u.bf()),
              (this._cameraPosition[2] = this.cameraToCenterDistance / e),
              u.bg(
                this._cameraPosition,
                this._cameraPosition,
                f,
                -this.rollInRadians,
              ),
              u.bh(
                this._cameraPosition,
                this._cameraPosition,
                f,
                this.pitchInRadians,
              ),
              u.bg(
                this._cameraPosition,
                this._cameraPosition,
                f,
                -this.bearingInRadians,
              ),
              u.aM(this._cameraPosition, this._cameraPosition, [0, 0, 1]),
              u.bh(
                this._cameraPosition,
                this._cameraPosition,
                f,
                (-this.center.lat * Math.PI) / 180,
              ),
              u.bi(
                this._cameraPosition,
                this._cameraPosition,
                f,
                (this.center.lng * Math.PI) / 180,
              ),
              (this._cachedClippingPlane = this._computeClippingPlane(e)));
            const g = u.aW(this._globeViewProjMatrixNoCorrectionInverted);
            (u.K(g, g, [1, 1, -1]),
              (this._cachedFrustum = Sn.fromInvProjectionMatrix(g)));
          }
          calculateFogMatrix(e) {
            u.w("calculateFogMatrix is not supported on globe projection.");
            const i = u.a$();
            return (u.aq(i), i);
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new u.aT(0, e)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            (e &&
              u.w(
                "terrain is not fully supported on vertical perspective projection.",
              ),
              this._helper.recalculateZoomAndCenter(0));
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, i) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const s = oi(e);
            u.aL(s, s, 1 + i / u.bo);
            const a = u.be();
            return (
              u.al(
                a,
                [s[0], s[1], s[2], 1],
                this._globeViewProjMatrixNoCorrection,
              ),
              a[2] / a[3]
            );
          }
          populateCache(e) {}
          getBounds() {
            const e = 0.5 * this.width,
              i = 0.5 * this.height,
              s = [
                new u.P(0, 0),
                new u.P(e, 0),
                new u.P(this.width, 0),
                new u.P(this.width, i),
                new u.P(this.width, this.height),
                new u.P(e, this.height),
                new u.P(0, this.height),
                new u.P(0, i),
              ],
              a = [];
            for (const A of s) a.push(this.unprojectScreenPoint(A));
            let h = 0,
              f = 0,
              g = 0,
              y = 0;
            const v = this.center;
            for (const A of a) {
              const T = u.bk(v.lng, A.lng),
                M = u.bk(v.lat, A.lat);
              (T < f && (f = T),
                T > h && (h = T),
                M < y && (y = M),
                M > g && (g = M));
            }
            const C = [v.lng + f, v.lat + y, v.lng + h, v.lat + g];
            return (
              this.isSurfacePointOnScreen([0, 1, 0]) &&
                ((C[3] = 90), (C[0] = -180), (C[2] = 180)),
              this.isSurfacePointOnScreen([0, -1, 0]) &&
                ((C[1] = -90), (C[0] = -180), (C[2] = 180)),
              new ti(C)
            );
          }
          getConstrained(e, i) {
            const s = u.ab(e.lat, -u.aF, u.aF),
              a = u.ab(+i, this.minZoom + mi(0, s), this.maxZoom);
            return { center: new u.N(e.lng, s), zoom: a };
          }
          calculateCenterFromCameraLngLatAlt(e, i, s, a) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, s, a);
          }
          setLocationAtPoint(e, i) {
            const s = oi(this.unprojectScreenPoint(i)),
              a = oi(e),
              h = u.bf();
            u.bl(h);
            const f = u.bf();
            (u.bi(f, s, h, (-this.center.lng * Math.PI) / 180),
              u.bh(f, f, h, (this.center.lat * Math.PI) / 180));
            const g = a[0] * a[0] + a[2] * a[2],
              y = f[0] * f[0];
            if (g < y) return;
            const v = Math.sqrt(g - y),
              C = -v,
              A = u.bm(a[0], a[2], f[0], v),
              T = u.bm(a[0], a[2], f[0], C),
              M = u.bf();
            u.bi(M, a, h, -A);
            const k = u.bm(M[1], M[2], f[1], f[2]),
              V = u.bf();
            u.bi(V, a, h, -T);
            const N = u.bm(V[1], V[2], f[1], f[2]),
              $ = 0.5 * Math.PI,
              G = k >= -$ && k <= $,
              Y = N >= -$ && N <= $;
            let Q, ee;
            if (G && Y) {
              const pe = (this.center.lng * Math.PI) / 180,
                be = (this.center.lat * Math.PI) / 180;
              u.bp(A, pe) + u.bp(k, be) < u.bp(T, pe) + u.bp(N, be)
                ? ((Q = A), (ee = k))
                : ((Q = T), (ee = N));
            } else if (G) ((Q = A), (ee = k));
            else {
              if (!Y) return;
              ((Q = T), (ee = N));
            }
            const re = (Q / Math.PI) * 180,
              ie = (ee / Math.PI) * 180,
              he = this.center.lat;
            (this.setCenter(new u.N(re, u.ab(ie, -90, 90))),
              this.setZoom(this.zoom + mi(he, this.center.lat)));
          }
          locationToScreenPoint(e, i) {
            const s = oi(e);
            if (i) {
              const a = i.getElevationForLngLatZoom(e, this._helper._tileZoom);
              u.aL(s, s, 1 + a / u.bo);
            }
            return this._projectSurfacePointToScreen(s);
          }
          _projectSurfacePointToScreen(e) {
            const i = u.be();
            return (
              u.al(i, [...e, 1], this._globeViewProjMatrixNoCorrection),
              (i[0] /= i[3]),
              (i[1] /= i[3]),
              new u.P(
                (0.5 * i[0] + 0.5) * this.width,
                (0.5 * -i[1] + 0.5) * this.height,
              )
            );
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const s = i.pointCoordinate(e);
              if (s) return s;
            }
            return u.Y.fromLngLat(this.unprojectScreenPoint(e));
          }
          screenPointToLocation(e, i) {
            var s;
            return (s = this.screenPointToMercatorCoordinate(e, i)) === null ||
              s === void 0
              ? void 0
              : s.toLngLat();
          }
          isPointOnMapSurface(e, i) {
            const s = this._cameraPosition,
              a = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(s, a);
          }
          getRayDirectionFromPixel(e) {
            const i = u.be();
            ((i[0] = (e.x / this.width) * 2 - 1),
              (i[1] = -1 * ((e.y / this.height) * 2 - 1)),
              (i[2] = 1),
              (i[3] = 1),
              u.al(i, i, this._globeViewProjMatrixNoCorrectionInverted),
              (i[0] /= i[3]),
              (i[1] /= i[3]),
              (i[2] /= i[3]));
            const s = u.bf();
            ((s[0] = i[0] - this._cameraPosition[0]),
              (s[1] = i[1] - this._cameraPosition[1]),
              (s[2] = i[2] - this._cameraPosition[2]));
            const a = u.bf();
            return (u.aQ(a, s), a);
          }
          isSurfacePointVisible(e) {
            const i = this._cachedClippingPlane;
            return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] >= 0;
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const i = u.be();
            return (
              u.al(i, [...e, 1], this._globeViewProjMatrixNoCorrection),
              (i[0] /= i[3]),
              (i[1] /= i[3]),
              (i[2] /= i[3]),
              i[0] > -1 &&
                i[0] < 1 &&
                i[1] > -1 &&
                i[1] < 1 &&
                i[2] > -1 &&
                i[2] < 1
            );
          }
          rayPlanetIntersection(e, i) {
            const s = u.aS(e, i),
              a = u.bf(),
              h = u.bf();
            (u.aL(h, i, s), u.aP(a, e, h));
            const f = 1 - u.aS(a, a);
            if (f < 0) return null;
            const g = u.aS(e, e) - 1,
              y = -s + (s < 0 ? 1 : -1) * Math.sqrt(f),
              v = g / y,
              C = y;
            return { tMin: Math.min(v, C), tMax: Math.max(v, C) };
          }
          unprojectScreenPoint(e) {
            const i = this._cameraPosition,
              s = this.getRayDirectionFromPixel(e),
              a = this.rayPlanetIntersection(i, s);
            if (a) {
              const v = u.bf();
              u.aM(v, i, [s[0] * a.tMin, s[1] * a.tMin, s[2] * a.tMin]);
              const C = u.bf();
              return (u.aQ(C, v), ms(C));
            }
            const h =
                this._cachedClippingPlane[0] * s[0] +
                this._cachedClippingPlane[1] * s[1] +
                this._cachedClippingPlane[2] * s[2],
              f = -u.bn(this._cachedClippingPlane, i) / h,
              g = u.bf();
            if (f > 0) u.aM(g, i, [s[0] * f, s[1] * f, s[2] * f]);
            else {
              const v = u.bf();
              u.aM(v, i, [2 * s[0], 2 * s[1], 2 * s[2]]);
              const C = u.bn(this._cachedClippingPlane, v);
              u.aP(g, v, [
                this._cachedClippingPlane[0] * C,
                this._cachedClippingPlane[1] * C,
                this._cachedClippingPlane[2] * C,
              ]);
            }
            const y = u.bf();
            return (u.aQ(y, g), ms(y));
          }
          getMatrixForModel(e, i) {
            const s = u.N.convert(e),
              a = 1 / u.bo,
              h = u.a_();
            return (
              u.bj(h, h, (s.lng / 180) * Math.PI),
              u.aY(h, h, (-s.lat / 180) * Math.PI),
              u.J(h, h, [0, 0, 1 + i / u.bo]),
              u.aY(h, h, 0.5 * Math.PI),
              u.K(h, h, [a, a, a]),
              h
            );
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = this.getProjectionData({
              overscaledTileID: new u.S(0, 0, 0, 0, 0),
              applyGlobeMatrix: e,
            });
            return ((i.tileMercatorCoords = [0, 0, 1, 1]), i);
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class ys {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, i, s) {
            return this._helper.interpolatePadding(e, i, s);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, i, s = !0) {
            this._helper.resize(e, i, s);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(
              this.getCameraPoint(),
              e,
            );
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e, i) {
            ((this._globeness = e),
              (this._globeLatitudeErrorCorrectionRadians = i),
              this._calcMatrices(),
              this._verticalPerspectiveTransform
                .getCoveringTilesDetailsProvider()
                .recalculateCache(),
              this._mercatorTransform
                .getCoveringTilesDetailsProvider()
                .recalculateCache());
          }
          get currentTransform() {
            return this.isGlobeRendering
              ? this._verticalPerspectiveTransform
              : this._mercatorTransform;
          }
          constructor() {
            ((this._globeLatitudeErrorCorrectionRadians = 0),
              (this._globeness = 1),
              (this._helper = new Kt({
                calcMatrices: () => {
                  this._calcMatrices();
                },
                getConstrained: (e, i) => this.getConstrained(e, i),
              })),
              (this._globeness = 1),
              (this._mercatorTransform = new Fi()),
              (this._verticalPerspectiveTransform = new jr()));
          }
          clone() {
            const e = new ys();
            return (
              (e._globeness = this._globeness),
              (e._globeLatitudeErrorCorrectionRadians =
                this._globeLatitudeErrorCorrectionRadians),
              e.apply(this),
              e
            );
          }
          apply(e) {
            (this._helper.apply(e),
              this._mercatorTransform.apply(this),
              this._verticalPerspectiveTransform.apply(
                this,
                this._globeLatitudeErrorCorrectionRadians,
              ));
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e) {
            const i = this._mercatorTransform.getProjectionData(e),
              s = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? s.mainMatrix : i.mainMatrix,
              clippingPlane: s.clippingPlane,
              tileMercatorCoords: s.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: i.fallbackMatrix,
            };
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e);
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e);
          }
          getPixelScale() {
            return u.b9(
              this._mercatorTransform.getPixelScale(),
              this._verticalPerspectiveTransform.getPixelScale(),
              this._globeness,
            );
          }
          getCircleRadiusCorrection() {
            return u.b9(
              this._mercatorTransform.getCircleRadiusCorrection(),
              this._verticalPerspectiveTransform.getCircleRadiusCorrection(),
              this._globeness,
            );
          }
          getPitchedTextCorrection(e, i, s) {
            const a = this._mercatorTransform.getPitchedTextCorrection(e, i, s),
              h = this._verticalPerspectiveTransform.getPitchedTextCorrection(
                e,
                i,
                s,
              );
            return u.b9(a, h, this._globeness);
          }
          projectTileCoordinates(e, i, s, a) {
            return this.currentTransform.projectTileCoordinates(e, i, s, a);
          }
          _calcMatrices() {
            this._helper._width &&
              this._helper._height &&
              (this._verticalPerspectiveTransform.apply(
                this,
                this._globeLatitudeErrorCorrectionRadians,
              ),
              (this._helper._nearZ = this._verticalPerspectiveTransform.nearZ),
              (this._helper._farZ = this._verticalPerspectiveTransform.farZ),
              this._mercatorTransform.apply(this, !0, this.isGlobeRendering),
              (this._helper._nearZ = this._mercatorTransform.nearZ),
              (this._helper._farZ = this._mercatorTransform.farZ));
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e);
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e) {
            (this._mercatorTransform.recalculateZoomAndCenter(e),
              this._verticalPerspectiveTransform.recalculateZoomAndCenter(e));
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, i) {
            return this.currentTransform.lngLatToCameraDepth(e, i);
          }
          populateCache(e) {
            (this._mercatorTransform.populateCache(e),
              this._verticalPerspectiveTransform.populateCache(e));
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(e, i) {
            return this.currentTransform.getConstrained(e, i);
          }
          calculateCenterFromCameraLngLatAlt(e, i, s, a) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, s, a);
          }
          setLocationAtPoint(e, i) {
            if (!this.isGlobeRendering)
              return (
                this._mercatorTransform.setLocationAtPoint(e, i),
                void this.apply(this._mercatorTransform)
              );
            (this._verticalPerspectiveTransform.setLocationAtPoint(e, i),
              this.apply(this._verticalPerspectiveTransform));
          }
          locationToScreenPoint(e, i) {
            return this.currentTransform.locationToScreenPoint(e, i);
          }
          screenPointToMercatorCoordinate(e, i) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, i);
          }
          screenPointToLocation(e, i) {
            return this.currentTransform.screenPointToLocation(e, i);
          }
          isPointOnMapSurface(e, i) {
            return this.currentTransform.isPointOnMapSurface(e, i);
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(
              e,
            );
          }
          getMatrixForModel(e, i) {
            return this.currentTransform.getMatrixForModel(e, i);
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i =
              this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return i;
            const s =
              this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(
                e,
              );
            return ((s.fallbackMatrix = i.mainMatrix), s);
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
          }
        }
        class yr {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(e, i) {
            const s = Ol(e, i);
            return (
              Math.abs(s.lng - i.center.lng) > 180 &&
                (s.lng =
                  i.center.lng + 179.5 * Math.sign(s.lng - i.center.lng)),
              { easingCenter: s, easingOffset: new u.P(0, 0) }
            );
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            const s = e.around,
              a = i.screenPointToLocation(s);
            (e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta),
              e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta),
              e.rollDelta && i.setRoll(i.roll + e.rollDelta));
            const h = i.zoom;
            e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
            const f = i.zoom - h;
            if (f === 0) return;
            const g = u.bk(i.center.lng, a.lng),
              y = g / (Math.abs(g / 180) + 1),
              v = u.bk(i.center.lat, a.lat),
              C = i.getRayDirectionFromPixel(s),
              A = i.cameraPosition,
              T = -1 * u.aS(A, C),
              M = u.bf();
            u.aM(M, A, [C[0] * T, C[1] * T, C[2] * T]);
            const k = u.bq(M) - 1,
              V = Math.exp(0.5 * -Math.max(k - 0.3, 0)),
              N = fs(i.worldSize, i.center.lat) / Math.min(i.width, i.height),
              $ = u.bc(N, 0.9, 0.5, 1, 0.25),
              G = (1 - u.aG(-f)) * Math.min(V, $),
              Y = i.center.lat,
              Q = i.zoom,
              ee = new u.N(
                i.center.lng + y * G,
                u.ab(i.center.lat + v * G, -u.aF, u.aF),
              );
            i.setLocationAtPoint(a, s);
            const re = i.center,
              ie = u.bc(Math.abs(g), 45, 85, 0, 1),
              he = u.bc(N, 0.75, 0.35, 0, 1),
              pe = Math.pow(Math.max(ie, he), 0.25),
              be = u.bk(re.lng, ee.lng),
              Ee = u.bk(re.lat, ee.lat);
            (i.setCenter(new u.N(re.lng + be * pe, re.lat + Ee * pe).wrap()),
              i.setZoom(Q + mi(Y, i.center.lat)));
          }
          handleMapControlsPan(e, i, s) {
            if (!e.panDelta) return;
            const a = i.center.lat,
              h = i.zoom;
            (i.setCenter(Ol(e.panDelta, i).wrap()),
              i.setZoom(h + mi(a, i.center.lat)));
          }
          cameraForBoxAndBearing(e, i, s, a, h) {
            const f = xa(e, i, s, a, h),
              g = (i.left / h.width) * 2 - 1,
              y = ((h.width - i.right) / h.width) * 2 - 1,
              v = (i.top / h.height) * -2 + 1,
              C = ((h.height - i.bottom) / h.height) * -2 + 1,
              A = u.bk(s.getWest(), s.getEast()) < 0,
              T = A ? s.getEast() : s.getWest(),
              M = A ? s.getWest() : s.getEast(),
              k = Math.max(s.getNorth(), s.getSouth()),
              V = Math.min(s.getNorth(), s.getSouth()),
              N = T + 0.5 * u.bk(T, M),
              $ = k + 0.5 * u.bk(k, V),
              G = h.clone();
            (G.setCenter(f.center),
              G.setBearing(f.bearing),
              G.setPitch(0),
              G.setRoll(0),
              G.setZoom(f.zoom));
            const Y = G.modelViewProjectionMatrix,
              Q = [
                oi(s.getNorthWest()),
                oi(s.getNorthEast()),
                oi(s.getSouthWest()),
                oi(s.getSouthEast()),
                oi(new u.N(M, $)),
                oi(new u.N(T, $)),
                oi(new u.N(N, k)),
                oi(new u.N(N, V)),
              ],
              ee = oi(f.center);
            let re = Number.POSITIVE_INFINITY;
            for (const ie of Q)
              (g < 0 &&
                (re = yr.getLesserNonNegativeNonNull(
                  re,
                  yr.solveVectorScale(ie, ee, Y, "x", g),
                )),
                y > 0 &&
                  (re = yr.getLesserNonNegativeNonNull(
                    re,
                    yr.solveVectorScale(ie, ee, Y, "x", y),
                  )),
                v > 0 &&
                  (re = yr.getLesserNonNegativeNonNull(
                    re,
                    yr.solveVectorScale(ie, ee, Y, "y", v),
                  )),
                C < 0 &&
                  (re = yr.getLesserNonNegativeNonNull(
                    re,
                    yr.solveVectorScale(ie, ee, Y, "y", C),
                  )));
            if (Number.isFinite(re) && re !== 0)
              return ((f.zoom = G.zoom + u.a8(re)), f);
            ya();
          }
          handleJumpToCenterZoom(e, i) {
            const s = e.center.lat,
              a = e.getConstrained(
                i.center ? u.N.convert(i.center) : e.center,
                e.zoom,
              ).center;
            e.setCenter(a.wrap());
            const h = i.zoom !== void 0 ? +i.zoom : e.zoom + mi(s, a.lat);
            e.zoom !== h && e.setZoom(h);
          }
          handleEaseTo(e, i) {
            const s = e.zoom,
              a = e.center,
              h = e.padding,
              f = { roll: e.roll, pitch: e.pitch, bearing: e.bearing },
              g = {
                roll: i.roll === void 0 ? e.roll : i.roll,
                pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                bearing: i.bearing === void 0 ? e.bearing : i.bearing,
              },
              y = i.zoom !== void 0,
              v = !e.isPaddingEqual(i.padding);
            let C = !1;
            const A = i.center ? u.N.convert(i.center) : a,
              T = e.getConstrained(A, s).center;
            Po(e, T);
            const M = e.clone();
            (M.setCenter(T),
              M.setZoom(y ? +i.zoom : s + mi(a.lat, A.lat)),
              M.setBearing(i.bearing));
            const k = new u.P(
              u.ab(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width),
              u.ab(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height),
            );
            M.setLocationAtPoint(T, k);
            const V = (i.offset && i.offsetAsPoint.mag()) > 0 ? M.center : T,
              N = y ? +i.zoom : s + mi(a.lat, V.lat),
              $ = s + mi(a.lat, 0),
              G = N + mi(V.lat, 0),
              Y = u.bk(a.lng, V.lng),
              Q = u.bk(a.lat, V.lat),
              ee = u.aG(G - $);
            return (
              (C = N !== s),
              {
                easeFunc: (re) => {
                  if (
                    (u.b3(f, g) ||
                      Or({
                        startEulerAngles: f,
                        endEulerAngles: g,
                        tr: e,
                        k: re,
                        useSlerp: f.roll != g.roll,
                      }),
                    v && e.interpolatePadding(h, i.padding, re),
                    i.around)
                  )
                    (u.w(
                      "Easing around a point is not supported under globe projection.",
                    ),
                      e.setLocationAtPoint(i.around, i.aroundPoint));
                  else {
                    const ie = G > $ ? Math.min(2, ee) : Math.max(0.5, ee),
                      he = Math.pow(ie, 1 - re),
                      pe = gs(a, Y, Q, re * he);
                    e.setCenter(pe.wrap());
                  }
                  if (C) {
                    const ie = u.y.number($, G, re) + mi(0, e.center.lat);
                    e.setZoom(ie);
                  }
                },
                isZooming: C,
                elevationCenter: V,
              }
            );
          }
          handleFlyTo(e, i) {
            const s = i.zoom !== void 0,
              a = e.center,
              h = e.zoom,
              f = !e.isPaddingEqual(i.padding),
              g = e.getConstrained(
                u.N.convert(i.center || i.locationAtOffset),
                h,
              ).center,
              y = s ? +i.zoom : e.zoom + mi(e.center.lat, g.lat),
              v = e.clone();
            (v.setCenter(g),
              f && v.setPadding(i.padding),
              v.setZoom(y),
              v.setBearing(i.bearing));
            const C = new u.P(
              u.ab(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width),
              u.ab(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height),
            );
            v.setLocationAtPoint(g, C);
            const A = v.center;
            Po(e, A);
            const T = (function (Y, Q, ee) {
                const re = oi(Q),
                  ie = oi(ee),
                  he = u.aS(re, ie),
                  pe = Math.acos(he),
                  be = Mo(Y);
                return (pe / (2 * Math.PI)) * be;
              })(e, a, A),
              M = h + mi(a.lat, 0),
              k = y + mi(A.lat, 0),
              V = u.aG(k - M);
            let N;
            if (typeof i.minZoom == "number") {
              const Y = +i.minZoom + mi(A.lat, 0),
                Q = Math.min(Y, M, k) + mi(0, A.lat),
                ee = e.getConstrained(A, Q).zoom + mi(A.lat, 0);
              N = u.aG(ee - M);
            }
            const $ = u.bk(a.lng, A.lng),
              G = u.bk(a.lat, A.lat);
            return {
              easeFunc: (Y, Q, ee, re) => {
                const ie = gs(a, $, G, ee),
                  he = Y === 1 ? A : ie;
                e.setCenter(he.wrap());
                const pe = M + u.a8(Q);
                e.setZoom(Y === 1 ? y : pe + mi(0, he.lat));
              },
              scaleOfZoom: V,
              targetCenter: A,
              scaleOfMinZoom: N,
              pixelPathLength: T,
            };
          }
          static solveVectorScale(e, i, s, a, h) {
            const f =
                a === "x"
                  ? [s[0], s[4], s[8], s[12]]
                  : [s[1], s[5], s[9], s[13]],
              g = [s[3], s[7], s[11], s[15]],
              y = e[0] * f[0] + e[1] * f[1] + e[2] * f[2],
              v = e[0] * g[0] + e[1] * g[1] + e[2] * g[2],
              C = i[0] * f[0] + i[1] * f[1] + i[2] * f[2],
              A = i[0] * g[0] + i[1] * g[1] + i[2] * g[2];
            return C + h * v === y + h * A ||
              g[3] * (y - C) + f[3] * (A - v) + y * A == C * v
              ? null
              : (C + f[3] - h * A - h * g[3]) / (C - y - h * A + h * v);
          }
          static getLesserNonNegativeNonNull(e, i) {
            return i !== null && i >= 0 && i < e ? i : e;
          }
        }
        class Nl {
          constructor(e) {
            ((this._globe = e),
              (this._mercatorCameraHelper = new tn()),
              (this._verticalPerspectiveCameraHelper = new yr()));
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls
              ? this._verticalPerspectiveCameraHelper
              : this._mercatorCameraHelper;
          }
          handlePanInertia(e, i) {
            return this.currentHelper.handlePanInertia(e, i);
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(
              e,
              i,
            );
          }
          handleMapControlsPan(e, i, s) {
            this.currentHelper.handleMapControlsPan(e, i, s);
          }
          cameraForBoxAndBearing(e, i, s, a, h) {
            return this.currentHelper.cameraForBoxAndBearing(e, i, s, a, h);
          }
          handleJumpToCenterZoom(e, i) {
            this.currentHelper.handleJumpToCenterZoom(e, i);
          }
          handleEaseTo(e, i) {
            return this.currentHelper.handleEaseTo(e, i);
          }
          handleFlyTo(e, i) {
            return this.currentHelper.handleFlyTo(e, i);
          }
        }
        const xs = (c, e) =>
            u.t(c, e && e.filter((i) => i.identifier !== "source.canvas")),
          rc = u.br();
        class ba extends u.E {
          constructor(e, i = {}) {
            (super(),
              (this._rtlPluginLoaded = () => {
                for (const s in this.sourceCaches) {
                  const a = this.sourceCaches[s].getSource().type;
                  (a !== "vector" && a !== "geojson") ||
                    this.sourceCaches[s].reload();
                }
              }),
              (this.map = e),
              (this.dispatcher = new fn(pn(), e._getMapId())),
              this.dispatcher.registerMessageHandler("GG", (s, a) =>
                this.getGlyphs(s, a),
              ),
              this.dispatcher.registerMessageHandler("GI", (s, a) =>
                this.getImages(s, a),
              ),
              (this.imageManager = new dn()),
              this.imageManager.setEventedParent(this),
              (this.glyphManager = new Oe(
                e._requestManager,
                i.localIdeographFontFamily,
              )),
              (this.lineAtlas = new $t(256, 512)),
              (this.crossTileSymbolIndex = new Fn()),
              (this._spritesImagesIds = {}),
              (this._layers = {}),
              (this._order = []),
              (this.sourceCaches = {}),
              (this.zoomHistory = new u.bs()),
              (this._loaded = !1),
              (this._availableImages = []),
              this._resetUpdates(),
              this.dispatcher.broadcast("SR", u.bt()),
              Rr().on(vn, this._rtlPluginLoaded),
              this.on("data", (s) => {
                if (s.dataType !== "source" || s.sourceDataType !== "metadata")
                  return;
                const a = this.sourceCaches[s.sourceId];
                if (!a) return;
                const h = a.getSource();
                if (h && h.vectorLayerIds)
                  for (const f in this._layers) {
                    const g = this._layers[f];
                    g.source === h.id && this._validateLayer(g);
                  }
              }));
          }
          loadURL(e, i = {}, s) {
            (this.fire(new u.k("dataloading", { dataType: "style" })),
              (i.validate = typeof i.validate != "boolean" || i.validate));
            const a = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController();
            const h = this._loadStyleRequest;
            u.h(a, this._loadStyleRequest)
              .then((f) => {
                ((this._loadStyleRequest = null), this._load(f.data, i, s));
              })
              .catch((f) => {
                ((this._loadStyleRequest = null),
                  f && !h.signal.aborted && this.fire(new u.j(f)));
              });
          }
          loadJSON(e, i = {}, s) {
            (this.fire(new u.k("dataloading", { dataType: "style" })),
              (this._frameRequest = new AbortController()),
              Qe.frameAsync(this._frameRequest)
                .then(() => {
                  ((this._frameRequest = null),
                    (i.validate = i.validate !== !1),
                    this._load(e, i, s));
                })
                .catch(() => {}));
          }
          loadEmpty() {
            (this.fire(new u.k("dataloading", { dataType: "style" })),
              this._load(rc, { validate: !1 }));
          }
          _load(e, i, s) {
            var a, h;
            const f = i.transformStyle ? i.transformStyle(s, e) : e;
            if (!i.validate || !xs(this, u.u(f))) {
              ((this._loaded = !0), (this.stylesheet = f));
              for (const g in f.sources)
                this.addSource(g, f.sources[g], { validate: !1 });
              (f.sprite
                ? this._loadSprite(f.sprite)
                : this.imageManager.setLoaded(!0),
                this.glyphManager.setURL(f.glyphs),
                this._createLayers(),
                (this.light = new pt(this.stylesheet.light)),
                this._setProjectionInternal(
                  ((a = this.stylesheet.projection) === null || a === void 0
                    ? void 0
                    : a.type) || "mercator",
                ),
                (this.sky = new Et(this.stylesheet.sky)),
                this.map.setTerrain(
                  (h = this.stylesheet.terrain) !== null && h !== void 0
                    ? h
                    : null,
                ),
                this.fire(new u.k("data", { dataType: "style" })),
                this.fire(new u.k("style.load")));
            }
          }
          _createLayers() {
            const e = u.bu(this.stylesheet.layers);
            (this.dispatcher.broadcast("SL", e),
              (this._order = e.map((i) => i.id)),
              (this._layers = {}),
              (this._serializedLayers = null));
            for (const i of e) {
              const s = u.bv(i);
              (s.setEventedParent(this, { layer: { id: i.id } }),
                (this._layers[i.id] = s));
            }
          }
          _loadSprite(e, i = !1, s = void 0) {
            let a;
            (this.imageManager.setLoaded(!1),
              (this._spriteRequest = new AbortController()),
              (function (h, f, g, y) {
                return u._(this, void 0, void 0, function* () {
                  const v = It(h),
                    C = g > 1 ? "@2x" : "",
                    A = {},
                    T = {};
                  for (const { id: M, url: k } of v) {
                    const V = f.transformRequest(
                      Dt(k, C, ".json"),
                      "SpriteJSON",
                    );
                    A[M] = u.h(V, y);
                    const N = f.transformRequest(
                      Dt(k, C, ".png"),
                      "SpriteImage",
                    );
                    T[M] = ei.getImage(N, y);
                  }
                  return (
                    yield Promise.all([
                      ...Object.values(A),
                      ...Object.values(T),
                    ]),
                    (function (M, k) {
                      return u._(this, void 0, void 0, function* () {
                        const V = {};
                        for (const N in M) {
                          V[N] = {};
                          const $ = Qe.getImageCanvasContext((yield k[N]).data),
                            G = (yield M[N]).data;
                          for (const Y in G) {
                            const {
                              width: Q,
                              height: ee,
                              x: re,
                              y: ie,
                              sdf: he,
                              pixelRatio: pe,
                              stretchX: be,
                              stretchY: Ee,
                              content: ye,
                              textFitWidth: Be,
                              textFitHeight: Me,
                            } = G[Y];
                            V[N][Y] = {
                              data: null,
                              pixelRatio: pe,
                              sdf: he,
                              stretchX: be,
                              stretchY: Ee,
                              content: ye,
                              textFitWidth: Be,
                              textFitHeight: Me,
                              spriteData: {
                                width: Q,
                                height: ee,
                                x: re,
                                y: ie,
                                context: $,
                              },
                            };
                          }
                        }
                        return V;
                      });
                    })(A, T)
                  );
                });
              })(
                e,
                this.map._requestManager,
                this.map.getPixelRatio(),
                this._spriteRequest,
              )
                .then((h) => {
                  if (((this._spriteRequest = null), h))
                    for (const f in h) {
                      this._spritesImagesIds[f] = [];
                      const g = this._spritesImagesIds[f]
                        ? this._spritesImagesIds[f].filter((y) => !(y in h))
                        : [];
                      for (const y of g)
                        (this.imageManager.removeImage(y),
                          (this._changedImages[y] = !0));
                      for (const y in h[f]) {
                        const v = f === "default" ? y : `${f}:${y}`;
                        (this._spritesImagesIds[f].push(v),
                          v in this.imageManager.images
                            ? this.imageManager.updateImage(v, h[f][y], !1)
                            : this.imageManager.addImage(v, h[f][y]),
                          i && (this._changedImages[v] = !0));
                      }
                    }
                })
                .catch((h) => {
                  ((this._spriteRequest = null),
                    (a = h),
                    this.fire(new u.j(a)));
                })
                .finally(() => {
                  (this.imageManager.setLoaded(!0),
                    (this._availableImages = this.imageManager.listImages()),
                    i && (this._changed = !0),
                    this.dispatcher.broadcast("SI", this._availableImages),
                    this.fire(new u.k("data", { dataType: "style" })),
                    s && s(a));
                }));
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat())
              (this.imageManager.removeImage(e), (this._changedImages[e] = !0));
            ((this._spritesImagesIds = {}),
              (this._availableImages = this.imageManager.listImages()),
              (this._changed = !0),
              this.dispatcher.broadcast("SI", this._availableImages),
              this.fire(new u.k("data", { dataType: "style" })));
          }
          _validateLayer(e) {
            const i = this.sourceCaches[e.source];
            if (!i) return;
            const s = e.sourceLayer;
            if (!s) return;
            const a = i.getSource();
            (a.type === "geojson" ||
              (a.vectorLayerIds && a.vectorLayerIds.indexOf(s) === -1)) &&
              this.fire(
                new u.j(
                  new Error(
                    `Source layer "${s}" does not exist on source "${a.id}" as specified by style layer "${e.id}".`,
                  ),
                ),
              );
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length)
              return !1;
            for (const e in this.sourceCaches)
              if (!this.sourceCaches[e].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e, i = !1) {
            const s = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(i ? u.bw(s) : s);
            const a = [];
            for (const h of e)
              if (s[h]) {
                const f = i ? u.bw(s[h]) : s[h];
                a.push(f);
              }
            return a;
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const i = Object.keys(this._layers);
            for (const s of i) {
              const a = this._layers[s];
              a.type !== "custom" && (e[s] = a.serialize());
            }
            return e;
          }
          hasTransitions() {
            var e, i, s;
            if (
              (!((e = this.light) === null || e === void 0) &&
                e.hasTransition()) ||
              (!((i = this.sky) === null || i === void 0) &&
                i.hasTransition()) ||
              (!((s = this.projection) === null || s === void 0) &&
                s.hasTransition())
            )
              return !0;
            for (const a in this.sourceCaches)
              if (this.sourceCaches[a].hasTransition()) return !0;
            for (const a in this._layers)
              if (this._layers[a].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e) {
            if (!this._loaded) return;
            const i = this._changed;
            if (i) {
              const a = Object.keys(this._updatedLayers),
                h = Object.keys(this._removedLayers);
              (a.length || h.length) && this._updateWorkerLayers(a, h);
              for (const f in this._updatedSources) {
                const g = this._updatedSources[f];
                if (g === "reload") this._reloadSource(f);
                else {
                  if (g !== "clear") throw new Error(`Invalid action ${g}`);
                  this._clearSource(f);
                }
              }
              (this._updateTilesForChangedImages(),
                this._updateTilesForChangedGlyphs());
              for (const f in this._updatedPaintProps)
                this._layers[f].updateTransitions(e);
              (this.light.updateTransitions(e),
                this.sky.updateTransitions(e),
                this._resetUpdates());
            }
            const s = {};
            for (const a in this.sourceCaches) {
              const h = this.sourceCaches[a];
              ((s[a] = h.used), (h.used = !1));
            }
            for (const a of this._order) {
              const h = this._layers[a];
              (h.recalculate(e, this._availableImages),
                !h.isHidden(e.zoom) &&
                  h.source &&
                  (this.sourceCaches[h.source].used = !0));
            }
            for (const a in s) {
              const h = this.sourceCaches[a];
              !!s[a] != !!h.used &&
                h.fire(
                  new u.k("data", {
                    sourceDataType: "visibility",
                    dataType: "source",
                    sourceId: a,
                  }),
                );
            }
            (this.light.recalculate(e),
              this.sky.recalculate(e),
              this.projection.recalculate(e),
              (this.z = e.zoom),
              i && this.fire(new u.k("data", { dataType: "style" })));
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const i in this.sourceCaches)
                this.sourceCaches[i].reloadTilesForDependencies(
                  ["icons", "patterns"],
                  e,
                );
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches)
                this.sourceCaches[e].reloadTilesForDependencies(
                  ["glyphs"],
                  [""],
                );
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(e, i) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: i,
            });
          }
          _resetUpdates() {
            ((this._changed = !1),
              (this._updatedLayers = {}),
              (this._removedLayers = {}),
              (this._updatedSources = {}),
              (this._updatedPaintProps = {}),
              (this._changedImages = {}),
              (this._glyphsDidChange = !1));
          }
          setState(e, i = {}) {
            var s;
            this._checkLoaded();
            const a = this.serialize();
            if (
              ((e = i.transformStyle ? i.transformStyle(a, e) : e),
              ((s = i.validate) === null || s === void 0 || s) &&
                xs(this, u.u(e)))
            )
              return !1;
            (e = u.bw(e)).layers = u.bu(e.layers);
            const h = u.bx(a, e),
              f = this._getOperationsToPerform(h);
            if (f.unimplemented.length > 0)
              throw new Error(`Unimplemented: ${f.unimplemented.join(", ")}.`);
            if (f.operations.length === 0) return !1;
            for (const g of f.operations) g();
            return ((this.stylesheet = e), (this._serializedLayers = null), !0);
          }
          _getOperationsToPerform(e) {
            const i = [],
              s = [];
            for (const a of e)
              switch (a.command) {
                case "setCenter":
                case "setZoom":
                case "setBearing":
                case "setPitch":
                case "setRoll":
                  continue;
                case "addLayer":
                  i.push(() => this.addLayer.apply(this, a.args));
                  break;
                case "removeLayer":
                  i.push(() => this.removeLayer.apply(this, a.args));
                  break;
                case "setPaintProperty":
                  i.push(() => this.setPaintProperty.apply(this, a.args));
                  break;
                case "setLayoutProperty":
                  i.push(() => this.setLayoutProperty.apply(this, a.args));
                  break;
                case "setFilter":
                  i.push(() => this.setFilter.apply(this, a.args));
                  break;
                case "addSource":
                  i.push(() => this.addSource.apply(this, a.args));
                  break;
                case "removeSource":
                  i.push(() => this.removeSource.apply(this, a.args));
                  break;
                case "setLayerZoomRange":
                  i.push(() => this.setLayerZoomRange.apply(this, a.args));
                  break;
                case "setLight":
                  i.push(() => this.setLight.apply(this, a.args));
                  break;
                case "setGeoJSONSourceData":
                  i.push(() => this.setGeoJSONSourceData.apply(this, a.args));
                  break;
                case "setGlyphs":
                  i.push(() => this.setGlyphs.apply(this, a.args));
                  break;
                case "setSprite":
                  i.push(() => this.setSprite.apply(this, a.args));
                  break;
                case "setTerrain":
                  i.push(() => this.map.setTerrain.apply(this, a.args));
                  break;
                case "setSky":
                  i.push(() => this.setSky.apply(this, a.args));
                  break;
                case "setProjection":
                  this.setProjection.apply(this, a.args);
                  break;
                case "setTransition":
                  i.push(() => {});
                  break;
                default:
                  s.push(a.command);
              }
            return { operations: i, unimplemented: s };
          }
          addImage(e, i) {
            if (this.getImage(e))
              return this.fire(
                new u.j(new Error(`An image named "${e}" already exists.`)),
              );
            (this.imageManager.addImage(e, i), this._afterImageUpdated(e));
          }
          updateImage(e, i) {
            this.imageManager.updateImage(e, i);
          }
          getImage(e) {
            return this.imageManager.getImage(e);
          }
          removeImage(e) {
            if (!this.getImage(e))
              return this.fire(
                new u.j(new Error(`An image named "${e}" does not exist.`)),
              );
            (this.imageManager.removeImage(e), this._afterImageUpdated(e));
          }
          _afterImageUpdated(e) {
            ((this._availableImages = this.imageManager.listImages()),
              (this._changedImages[e] = !0),
              (this._changed = !0),
              this.dispatcher.broadcast("SI", this._availableImages),
              this.fire(new u.k("data", { dataType: "style" })));
          }
          listImages() {
            return (this._checkLoaded(), this.imageManager.listImages());
          }
          addSource(e, i, s = {}) {
            if ((this._checkLoaded(), this.sourceCaches[e] !== void 0))
              throw new Error(`Source "${e}" already exists.`);
            if (!i.type)
              throw new Error(
                `The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`,
              );
            if (
              ["vector", "raster", "geojson", "video", "image"].indexOf(
                i.type,
              ) >= 0 &&
              this._validate(u.u.source, `sources.${e}`, i, null, s)
            )
              return;
            this.map &&
              this.map._collectResourceTiming &&
              (i.collectResourceTiming = !0);
            const a = (this.sourceCaches[e] = new B(e, i, this.dispatcher));
            ((a.style = this),
              a.setEventedParent(this, () => ({
                isSourceLoaded: a.loaded(),
                source: a.serialize(),
                sourceId: e,
              })),
              a.onAdd(this.map),
              (this._changed = !0));
          }
          removeSource(e) {
            if ((this._checkLoaded(), this.sourceCaches[e] === void 0))
              throw new Error("There is no source with this ID");
            for (const s in this._layers)
              if (this._layers[s].source === e)
                return this.fire(
                  new u.j(
                    new Error(
                      `Source "${e}" cannot be removed while layer "${s}" is using it.`,
                    ),
                  ),
                );
            const i = this.sourceCaches[e];
            (delete this.sourceCaches[e],
              delete this._updatedSources[e],
              i.fire(
                new u.k("data", {
                  sourceDataType: "metadata",
                  dataType: "source",
                  sourceId: e,
                }),
              ),
              i.setEventedParent(null),
              i.onRemove(this.map),
              (this._changed = !0));
          }
          setGeoJSONSourceData(e, i) {
            if ((this._checkLoaded(), this.sourceCaches[e] === void 0))
              throw new Error(`There is no source with this ID=${e}`);
            const s = this.sourceCaches[e].getSource();
            if (s.type !== "geojson")
              throw new Error(
                `geojsonSource.type is ${s.type}, which is !== 'geojson`,
              );
            (s.setData(i), (this._changed = !0));
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource();
          }
          addLayer(e, i, s = {}) {
            this._checkLoaded();
            const a = e.id;
            if (this.getLayer(a))
              return void this.fire(
                new u.j(new Error(`Layer "${a}" already exists on this map.`)),
              );
            let h;
            if (e.type === "custom") {
              if (xs(this, u.by(e))) return;
              h = u.bv(e);
            } else {
              if (
                ("source" in e &&
                  typeof e.source == "object" &&
                  (this.addSource(a, e.source),
                  (e = u.bw(e)),
                  (e = u.e(e, { source: a }))),
                this._validate(
                  u.u.layer,
                  `layers.${a}`,
                  e,
                  { arrayIndex: -1 },
                  s,
                ))
              )
                return;
              ((h = u.bv(e)),
                this._validateLayer(h),
                h.setEventedParent(this, { layer: { id: a } }));
            }
            const f = i ? this._order.indexOf(i) : this._order.length;
            if (i && f === -1)
              this.fire(
                new u.j(
                  new Error(
                    `Cannot add layer "${a}" before non-existing layer "${i}".`,
                  ),
                ),
              );
            else {
              if (
                (this._order.splice(f, 0, a),
                (this._layerOrderChanged = !0),
                (this._layers[a] = h),
                this._removedLayers[a] && h.source && h.type !== "custom")
              ) {
                const g = this._removedLayers[a];
                (delete this._removedLayers[a],
                  g.type !== h.type
                    ? (this._updatedSources[h.source] = "clear")
                    : ((this._updatedSources[h.source] = "reload"),
                      this.sourceCaches[h.source].pause()));
              }
              (this._updateLayer(h), h.onAdd && h.onAdd(this.map));
            }
          }
          moveLayer(e, i) {
            if ((this._checkLoaded(), (this._changed = !0), !this._layers[e]))
              return void this.fire(
                new u.j(
                  new Error(
                    `The layer '${e}' does not exist in the map's style and cannot be moved.`,
                  ),
                ),
              );
            if (e === i) return;
            const s = this._order.indexOf(e);
            this._order.splice(s, 1);
            const a = i ? this._order.indexOf(i) : this._order.length;
            i && a === -1
              ? this.fire(
                  new u.j(
                    new Error(
                      `Cannot move layer "${e}" before non-existing layer "${i}".`,
                    ),
                  ),
                )
              : (this._order.splice(a, 0, e), (this._layerOrderChanged = !0));
          }
          removeLayer(e) {
            this._checkLoaded();
            const i = this._layers[e];
            if (!i)
              return void this.fire(
                new u.j(new Error(`Cannot remove non-existing layer "${e}".`)),
              );
            i.setEventedParent(null);
            const s = this._order.indexOf(e);
            (this._order.splice(s, 1),
              (this._layerOrderChanged = !0),
              (this._changed = !0),
              (this._removedLayers[e] = i),
              delete this._layers[e],
              this._serializedLayers && delete this._serializedLayers[e],
              delete this._updatedLayers[e],
              delete this._updatedPaintProps[e],
              i.onRemove && i.onRemove(this.map));
          }
          getLayer(e) {
            return this._layers[e];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e) {
            return e in this._layers;
          }
          setLayerZoomRange(e, i, s) {
            this._checkLoaded();
            const a = this.getLayer(e);
            a
              ? (a.minzoom === i && a.maxzoom === s) ||
                (i != null && (a.minzoom = i),
                s != null && (a.maxzoom = s),
                this._updateLayer(a))
              : this.fire(
                  new u.j(
                    new Error(
                      `Cannot set the zoom range of non-existing layer "${e}".`,
                    ),
                  ),
                );
          }
          setFilter(e, i, s = {}) {
            this._checkLoaded();
            const a = this.getLayer(e);
            if (a) {
              if (!u.bz(a.filter, i))
                return i == null
                  ? ((a.filter = void 0), void this._updateLayer(a))
                  : void (
                      this._validate(
                        u.u.filter,
                        `layers.${a.id}.filter`,
                        i,
                        null,
                        s,
                      ) || ((a.filter = u.bw(i)), this._updateLayer(a))
                    );
            } else
              this.fire(
                new u.j(new Error(`Cannot filter non-existing layer "${e}".`)),
              );
          }
          getFilter(e) {
            return u.bw(this.getLayer(e).filter);
          }
          setLayoutProperty(e, i, s, a = {}) {
            this._checkLoaded();
            const h = this.getLayer(e);
            h
              ? u.bz(h.getLayoutProperty(i), s) ||
                (h.setLayoutProperty(i, s, a), this._updateLayer(h))
              : this.fire(
                  new u.j(new Error(`Cannot style non-existing layer "${e}".`)),
                );
          }
          getLayoutProperty(e, i) {
            const s = this.getLayer(e);
            if (s) return s.getLayoutProperty(i);
            this.fire(
              new u.j(
                new Error(`Cannot get style of non-existing layer "${e}".`),
              ),
            );
          }
          setPaintProperty(e, i, s, a = {}) {
            this._checkLoaded();
            const h = this.getLayer(e);
            h
              ? u.bz(h.getPaintProperty(i), s) ||
                (h.setPaintProperty(i, s, a) && this._updateLayer(h),
                (this._changed = !0),
                (this._updatedPaintProps[e] = !0),
                (this._serializedLayers = null))
              : this.fire(
                  new u.j(new Error(`Cannot style non-existing layer "${e}".`)),
                );
          }
          getPaintProperty(e, i) {
            return this.getLayer(e).getPaintProperty(i);
          }
          setFeatureState(e, i) {
            this._checkLoaded();
            const s = e.source,
              a = e.sourceLayer,
              h = this.sourceCaches[s];
            if (h === void 0)
              return void this.fire(
                new u.j(
                  new Error(
                    `The source '${s}' does not exist in the map's style.`,
                  ),
                ),
              );
            const f = h.getSource().type;
            f === "geojson" && a
              ? this.fire(
                  new u.j(
                    new Error(
                      "GeoJSON sources cannot have a sourceLayer parameter.",
                    ),
                  ),
                )
              : f !== "vector" || a
                ? (e.id === void 0 &&
                    this.fire(
                      new u.j(
                        new Error("The feature id parameter must be provided."),
                      ),
                    ),
                  h.setFeatureState(a, e.id, i))
                : this.fire(
                    new u.j(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types.",
                      ),
                    ),
                  );
          }
          removeFeatureState(e, i) {
            this._checkLoaded();
            const s = e.source,
              a = this.sourceCaches[s];
            if (a === void 0)
              return void this.fire(
                new u.j(
                  new Error(
                    `The source '${s}' does not exist in the map's style.`,
                  ),
                ),
              );
            const h = a.getSource().type,
              f = h === "vector" ? e.sourceLayer : void 0;
            h !== "vector" || f
              ? i && typeof e.id != "string" && typeof e.id != "number"
                ? this.fire(
                    new u.j(
                      new Error(
                        "A feature id is required to remove its specific state property.",
                      ),
                    ),
                  )
                : a.removeFeatureState(f, e.id, i)
              : this.fire(
                  new u.j(
                    new Error(
                      "The sourceLayer parameter must be provided for vector source types.",
                    ),
                  ),
                );
          }
          getFeatureState(e) {
            this._checkLoaded();
            const i = e.source,
              s = e.sourceLayer,
              a = this.sourceCaches[i];
            if (a !== void 0)
              return a.getSource().type !== "vector" || s
                ? (e.id === void 0 &&
                    this.fire(
                      new u.j(
                        new Error("The feature id parameter must be provided."),
                      ),
                    ),
                  a.getFeatureState(s, e.id))
                : void this.fire(
                    new u.j(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types.",
                      ),
                    ),
                  );
            this.fire(
              new u.j(
                new Error(
                  `The source '${i}' does not exist in the map's style.`,
                ),
              ),
            );
          }
          getTransition() {
            return u.e(
              { duration: 300, delay: 0 },
              this.stylesheet && this.stylesheet.transition,
            );
          }
          serialize() {
            if (!this._loaded) return;
            const e = u.bA(this.sourceCaches, (h) => h.serialize()),
              i = this._serializeByIds(this._order, !0),
              s = this.map.getTerrain() || void 0,
              a = this.stylesheet;
            return u.bB(
              {
                version: a.version,
                name: a.name,
                metadata: a.metadata,
                light: a.light,
                sky: a.sky,
                center: a.center,
                zoom: a.zoom,
                bearing: a.bearing,
                pitch: a.pitch,
                sprite: a.sprite,
                glyphs: a.glyphs,
                transition: a.transition,
                projection: a.projection,
                sources: e,
                layers: i,
                terrain: s,
              },
              (h) => h !== void 0,
            );
          }
          _updateLayer(e) {
            ((this._updatedLayers[e.id] = !0),
              e.source &&
                !this._updatedSources[e.source] &&
                this.sourceCaches[e.source].getSource().type !== "raster" &&
                ((this._updatedSources[e.source] = "reload"),
                this.sourceCaches[e.source].pause()),
              (this._serializedLayers = null),
              (this._changed = !0));
          }
          _flattenAndSortRenderedFeatures(e) {
            const i = (f) => this._layers[f].type === "fill-extrusion",
              s = {},
              a = [];
            for (let f = this._order.length - 1; f >= 0; f--) {
              const g = this._order[f];
              if (i(g)) {
                s[g] = f;
                for (const y of e) {
                  const v = y[g];
                  if (v) for (const C of v) a.push(C);
                }
              }
            }
            a.sort((f, g) => g.intersectionZ - f.intersectionZ);
            const h = [];
            for (let f = this._order.length - 1; f >= 0; f--) {
              const g = this._order[f];
              if (i(g))
                for (let y = a.length - 1; y >= 0; y--) {
                  const v = a[y].feature;
                  if (s[v.layer.id] < f) break;
                  (h.push(v), a.pop());
                }
              else
                for (const y of e) {
                  const v = y[g];
                  if (v) for (const C of v) h.push(C.feature);
                }
            }
            return h;
          }
          queryRenderedFeatures(e, i, s) {
            i &&
              i.filter &&
              this._validate(
                u.u.filter,
                "queryRenderedFeatures.filter",
                i.filter,
                null,
                i,
              );
            const a = {};
            if (i && i.layers) {
              if (!(Array.isArray(i.layers) || i.layers instanceof Set))
                return (
                  this.fire(
                    new u.j(
                      new Error(
                        "parameters.layers must be an Array or a Set of strings",
                      ),
                    ),
                  ),
                  []
                );
              for (const v of i.layers) {
                const C = this._layers[v];
                if (!C)
                  return (
                    this.fire(
                      new u.j(
                        new Error(
                          `The layer '${v}' does not exist in the map's style and cannot be queried for features.`,
                        ),
                      ),
                    ),
                    []
                  );
                a[C.source] = !0;
              }
            }
            const h = [];
            i.availableImages = this._availableImages;
            const f = this._serializedAllLayers(),
              g =
                i.layers instanceof Set
                  ? i.layers
                  : Array.isArray(i.layers)
                    ? new Set(i.layers)
                    : null,
              y = Object.assign(Object.assign({}, i), { layers: g });
            for (const v in this.sourceCaches)
              (i.layers && !a[v]) ||
                h.push(Eo(this.sourceCaches[v], this._layers, f, e, y, s));
            return (
              this.placement &&
                h.push(
                  (function (v, C, A, T, M, k, V) {
                    const N = {},
                      $ = k.queryRenderedSymbols(T),
                      G = [];
                    for (const Y of Object.keys($).map(Number)) G.push(V[Y]);
                    G.sort(Ai);
                    for (const Y of G) {
                      const Q = Y.featureIndex.lookupSymbolFeatures(
                        $[Y.bucketInstanceId],
                        C,
                        Y.bucketIndex,
                        Y.sourceLayerIndex,
                        M.filter,
                        M.layers,
                        M.availableImages,
                        v,
                      );
                      for (const ee in Q) {
                        const re = (N[ee] = N[ee] || []),
                          ie = Q[ee];
                        ie.sort((he, pe) => {
                          const be = Y.featureSortOrder;
                          if (be) {
                            const Ee = be.indexOf(he.featureIndex);
                            return be.indexOf(pe.featureIndex) - Ee;
                          }
                          return pe.featureIndex - he.featureIndex;
                        });
                        for (const he of ie) re.push(he);
                      }
                    }
                    return (function (Y, Q, ee) {
                      for (const re in Y)
                        for (const ie of Y[re]) ui(ie, ee[Q[re].source]);
                      return Y;
                    })(N, v, A);
                  })(
                    this._layers,
                    f,
                    this.sourceCaches,
                    e,
                    y,
                    this.placement.collisionIndex,
                    this.placement.retainedQueryData,
                  ),
                ),
              this._flattenAndSortRenderedFeatures(h)
            );
          }
          querySourceFeatures(e, i) {
            i &&
              i.filter &&
              this._validate(
                u.u.filter,
                "querySourceFeatures.filter",
                i.filter,
                null,
                i,
              );
            const s = this.sourceCaches[e];
            return s
              ? (function (a, h) {
                  const f = a.getRenderableIds().map((v) => a.getTileByID(v)),
                    g = [],
                    y = {};
                  for (let v = 0; v < f.length; v++) {
                    const C = f[v],
                      A = C.tileID.canonical.key;
                    y[A] || ((y[A] = !0), C.querySourceFeatures(g, h));
                  }
                  return g;
                })(s, i)
              : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e, i = {}) {
            this._checkLoaded();
            const s = this.light.getLight();
            let a = !1;
            for (const f in e)
              if (!u.bz(e[f], s[f])) {
                a = !0;
                break;
              }
            if (!a) return;
            const h = {
              now: Qe.now(),
              transition: u.e(
                { duration: 300, delay: 0 },
                this.stylesheet.transition,
              ),
            };
            (this.light.setLight(e, i), this.light.updateTransitions(h));
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0
              ? void 0
              : e.projection;
          }
          setProjection(e) {
            if ((this._checkLoaded(), this.projection)) {
              if (this.projection.name === e.type) return;
              (this.projection.destroy(), delete this.projection);
            }
            ((this.stylesheet.projection = e),
              this._setProjectionInternal(e.type));
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0
              ? void 0
              : e.sky;
          }
          setSky(e, i = {}) {
            this._checkLoaded();
            const s = this.getSky();
            let a = !1;
            if (!e && !s) return;
            if (e && !s) a = !0;
            else if (!e && s) a = !0;
            else
              for (const f in e)
                if (!u.bz(e[f], s[f])) {
                  a = !0;
                  break;
                }
            if (!a) return;
            const h = {
              now: Qe.now(),
              transition: u.e(
                { duration: 300, delay: 0 },
                this.stylesheet.transition,
              ),
            };
            ((this.stylesheet.sky = e),
              this.sky.setSky(e, i),
              this.sky.updateTransitions(h));
          }
          _setProjectionInternal(e) {
            const i = (function (s) {
              if (Array.isArray(s)) {
                const a = new ps({ type: s });
                return {
                  projection: a,
                  transform: new ys(),
                  cameraHelper: new Nl(a),
                };
              }
              switch (s) {
                case "mercator":
                  return {
                    projection: new ki(),
                    transform: new Fi(),
                    cameraHelper: new tn(),
                  };
                case "globe": {
                  const a = new ps({
                    type: [
                      "interpolate",
                      ["linear"],
                      ["zoom"],
                      11,
                      "vertical-perspective",
                      12,
                      "mercator",
                    ],
                  });
                  return {
                    projection: a,
                    transform: new ys(),
                    cameraHelper: new Nl(a),
                  };
                }
                case "vertical-perspective":
                  return {
                    projection: new Do(),
                    transform: new jr(),
                    cameraHelper: new yr(),
                  };
                default:
                  return (
                    u.w(
                      `Unknown projection name: ${s}. Falling back to mercator projection.`,
                    ),
                    {
                      projection: new ki(),
                      transform: new Fi(),
                      cameraHelper: new tn(),
                    }
                  );
              }
            })(e);
            ((this.projection = i.projection),
              this.map.migrateProjection(i.transform, i.cameraHelper));
            for (const s in this.sourceCaches) this.sourceCaches[s].reload();
          }
          _validate(e, i, s, a, h = {}) {
            return (
              (!h || h.validate !== !1) &&
              xs(
                this,
                e.call(
                  u.u,
                  u.e(
                    {
                      key: i,
                      style: this.serialize(),
                      value: s,
                      styleSpec: u.v,
                    },
                    a,
                  ),
                ),
              )
            );
          }
          _remove(e = !0) {
            (this._frameRequest &&
              (this._frameRequest.abort(), (this._frameRequest = null)),
              this._loadStyleRequest &&
                (this._loadStyleRequest.abort(),
                (this._loadStyleRequest = null)),
              this._spriteRequest &&
                (this._spriteRequest.abort(), (this._spriteRequest = null)),
              Rr().off(vn, this._rtlPluginLoaded));
            for (const i in this._layers)
              this._layers[i].setEventedParent(null);
            for (const i in this.sourceCaches) {
              const s = this.sourceCaches[i];
              (s.setEventedParent(null), s.onRemove(this.map));
            }
            (this.imageManager.setEventedParent(null),
              this.setEventedParent(null),
              e && this.dispatcher.broadcast("RM", void 0),
              this.dispatcher.remove(e));
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles();
          }
          _reloadSource(e) {
            (this.sourceCaches[e].resume(), this.sourceCaches[e].reload());
          }
          _updateSources(e) {
            for (const i in this.sourceCaches)
              this.sourceCaches[i].update(e, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e);
          }
          _updatePlacement(e, i, s, a, h = !1) {
            let f = !1,
              g = !1;
            const y = {};
            for (const v of this._order) {
              const C = this._layers[v];
              if (C.type !== "symbol") continue;
              if (!y[C.source]) {
                const T = this.sourceCaches[C.source];
                y[C.source] = T.getRenderableIds(!0)
                  .map((M) => T.getTileByID(M))
                  .sort(
                    (M, k) =>
                      k.tileID.overscaledZ - M.tileID.overscaledZ ||
                      (M.tileID.isLessThan(k.tileID) ? -1 : 1),
                  );
              }
              const A = this.crossTileSymbolIndex.addLayer(
                C,
                y[C.source],
                e.center.lng,
              );
              f = f || A;
            }
            if (
              (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
              ((h = h || this._layerOrderChanged || s === 0) ||
                !this.pauseablePlacement ||
                (this.pauseablePlacement.isDone() &&
                  !this.placement.stillRecent(Qe.now(), e.zoom))) &&
                ((this.pauseablePlacement = new Ll(
                  e,
                  this.map.terrain,
                  this._order,
                  h,
                  i,
                  s,
                  a,
                  this.placement,
                )),
                (this._layerOrderChanged = !1)),
              this.pauseablePlacement.isDone()
                ? this.placement.setStale()
                : (this.pauseablePlacement.continuePlacement(
                    this._order,
                    this._layers,
                    y,
                  ),
                  this.pauseablePlacement.isDone() &&
                    ((this.placement = this.pauseablePlacement.commit(
                      Qe.now(),
                    )),
                    (g = !0)),
                  f && this.pauseablePlacement.placement.setStale()),
              g || f)
            )
              for (const v of this._order) {
                const C = this._layers[v];
                C.type === "symbol" &&
                  this.placement.updateLayerOpacities(C, y[C.source]);
              }
            return (
              !this.pauseablePlacement.isDone() ||
              this.placement.hasTransitions(Qe.now())
            );
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches)
              this.sourceCaches[e].releaseSymbolFadeTiles();
          }
          getImages(e, i) {
            return u._(this, void 0, void 0, function* () {
              const s = yield this.imageManager.getImages(i.icons);
              this._updateTilesForChangedImages();
              const a = this.sourceCaches[i.source];
              return (a && a.setDependencies(i.tileID.key, i.type, i.icons), s);
            });
          }
          getGlyphs(e, i) {
            return u._(this, void 0, void 0, function* () {
              const s = yield this.glyphManager.getGlyphs(i.stacks),
                a = this.sourceCaches[i.source];
              return (a && a.setDependencies(i.tileID.key, i.type, [""]), s);
            });
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e, i = {}) {
            (this._checkLoaded(),
              (e && this._validate(u.u.glyphs, "glyphs", e, null, i)) ||
                ((this._glyphsDidChange = !0),
                (this.stylesheet.glyphs = e),
                (this.glyphManager.entries = {}),
                this.glyphManager.setURL(e)));
          }
          addSprite(e, i, s = {}, a) {
            this._checkLoaded();
            const h = [{ id: e, url: i }],
              f = [...It(this.stylesheet.sprite), ...h];
            this._validate(u.u.sprite, "sprite", f, null, s) ||
              ((this.stylesheet.sprite = f), this._loadSprite(h, !0, a));
          }
          removeSprite(e) {
            this._checkLoaded();
            const i = It(this.stylesheet.sprite);
            if (i.find((s) => s.id === e)) {
              if (this._spritesImagesIds[e])
                for (const s of this._spritesImagesIds[e])
                  (this.imageManager.removeImage(s),
                    (this._changedImages[s] = !0));
              (i.splice(
                i.findIndex((s) => s.id === e),
                1,
              ),
                (this.stylesheet.sprite = i.length > 0 ? i : void 0),
                delete this._spritesImagesIds[e],
                (this._availableImages = this.imageManager.listImages()),
                (this._changed = !0),
                this.dispatcher.broadcast("SI", this._availableImages),
                this.fire(new u.k("data", { dataType: "style" })));
            } else
              this.fire(
                new u.j(new Error(`Sprite "${e}" doesn't exists on this map.`)),
              );
          }
          getSprite() {
            return It(this.stylesheet.sprite);
          }
          setSprite(e, i = {}, s) {
            (this._checkLoaded(),
              (e && this._validate(u.u.sprite, "sprite", e, null, i)) ||
                ((this.stylesheet.sprite = e),
                e
                  ? this._loadSprite(e, !0, s)
                  : (this._unloadSprite(), s && s(null))));
          }
        }
        var vs = u.aA([
          { name: "a_pos", type: "Int16", components: 2 },
          { name: "a_texture_pos", type: "Int16", components: 2 },
        ]);
        class wa {
          constructor() {
            ((this.boundProgram = null),
              (this.boundLayoutVertexBuffer = null),
              (this.boundPaintVertexBuffers = []),
              (this.boundIndexBuffer = null),
              (this.boundVertexOffset = null),
              (this.boundDynamicVertexBuffer = null),
              (this.vao = null));
          }
          bind(e, i, s, a, h, f, g, y, v) {
            this.context = e;
            let C = this.boundPaintVertexBuffers.length !== a.length;
            for (let A = 0; !C && A < a.length; A++)
              this.boundPaintVertexBuffers[A] !== a[A] && (C = !0);
            !this.vao ||
            this.boundProgram !== i ||
            this.boundLayoutVertexBuffer !== s ||
            C ||
            this.boundIndexBuffer !== h ||
            this.boundVertexOffset !== f ||
            this.boundDynamicVertexBuffer !== g ||
            this.boundDynamicVertexBuffer2 !== y ||
            this.boundDynamicVertexBuffer3 !== v
              ? this.freshBind(i, s, a, h, f, g, y, v)
              : (e.bindVertexArray.set(this.vao),
                g && g.bind(),
                h && h.dynamicDraw && h.bind(),
                y && y.bind(),
                v && v.bind());
          }
          freshBind(e, i, s, a, h, f, g, y) {
            const v = e.numAttributes,
              C = this.context,
              A = C.gl;
            (this.vao && this.destroy(),
              (this.vao = C.createVertexArray()),
              C.bindVertexArray.set(this.vao),
              (this.boundProgram = e),
              (this.boundLayoutVertexBuffer = i),
              (this.boundPaintVertexBuffers = s),
              (this.boundIndexBuffer = a),
              (this.boundVertexOffset = h),
              (this.boundDynamicVertexBuffer = f),
              (this.boundDynamicVertexBuffer2 = g),
              (this.boundDynamicVertexBuffer3 = y),
              i.enableAttributes(A, e));
            for (const T of s) T.enableAttributes(A, e);
            (f && f.enableAttributes(A, e),
              g && g.enableAttributes(A, e),
              y && y.enableAttributes(A, e),
              i.bind(),
              i.setVertexAttribPointers(A, e, h));
            for (const T of s) (T.bind(), T.setVertexAttribPointers(A, e, h));
            (f && (f.bind(), f.setVertexAttribPointers(A, e, h)),
              a && a.bind(),
              g && (g.bind(), g.setVertexAttribPointers(A, e, h)),
              y && (y.bind(), y.setVertexAttribPointers(A, e, h)),
              (C.currentNumAttributes = v));
          }
          destroy() {
            this.vao &&
              (this.context.deleteVertexArray(this.vao), (this.vao = null));
          }
        }
        const bs = (c, e, i, s, a) => ({
            u_texture: 0,
            u_ele_delta: c,
            u_fog_matrix: e,
            u_fog_color: i ? i.properties.get("fog-color") : u.b4.white,
            u_fog_ground_blend: i ? i.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: a
              ? 0
              : i
                ? i.calculateFogBlendOpacity(s)
                : 0,
            u_horizon_color: i ? i.properties.get("horizon-color") : u.b4.white,
            u_horizon_fog_blend: i ? i.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: a ? 1 : 0,
          }),
          Ca = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix",
          };
        function Jn(c) {
          const e = [];
          for (let i = 0; i < c.length; i++) {
            if (c[i] === null) continue;
            const s = c[i].split(" ");
            e.push(s.pop());
          }
          return e;
        }
        class Sr {
          constructor(e, i, s, a, h, f, g, y) {
            const v = e.gl;
            this.program = v.createProgram();
            const C = Jn(i.staticAttributes),
              A = s ? s.getBinderAttributes() : [],
              T = C.concat(A),
              M = Tr.prelude.staticUniforms
                ? Jn(Tr.prelude.staticUniforms)
                : [],
              k = g.staticUniforms ? Jn(g.staticUniforms) : [],
              V = i.staticUniforms ? Jn(i.staticUniforms) : [],
              N = s ? s.getBinderUniforms() : [],
              $ = M.concat(k).concat(V).concat(N),
              G = [];
            for (const pe of $) G.indexOf(pe) < 0 && G.push(pe);
            const Y = s ? s.defines() : [];
            (lr(v) && Y.unshift("#version 300 es"),
              h && Y.push("#define OVERDRAW_INSPECTOR;"),
              f && Y.push("#define TERRAIN3D;"),
              y && Y.push(y));
            let Q = Y.concat(
                Tr.prelude.fragmentSource,
                g.fragmentSource,
                i.fragmentSource,
              ).join(`
`),
              ee = Y.concat(
                Tr.prelude.vertexSource,
                g.vertexSource,
                i.vertexSource,
              ).join(`
`);
            lr(v) ||
              ((Q = (function (pe) {
                return pe
                  .replace(/\bin\s/g, "varying ")
                  .replace("out highp vec4 fragColor;", "")
                  .replace(/fragColor/g, "gl_FragColor")
                  .replace(/texture\(/g, "texture2D(");
              })(Q)),
              (ee = (function (pe) {
                return pe
                  .replace(/\bin\s/g, "attribute ")
                  .replace(/\bout\s/g, "varying ")
                  .replace(/texture\(/g, "texture2D(");
              })(ee)));
            const re = v.createShader(v.FRAGMENT_SHADER);
            if (v.isContextLost()) return void (this.failedToCreate = !0);
            if (
              (v.shaderSource(re, Q),
              v.compileShader(re),
              !v.getShaderParameter(re, v.COMPILE_STATUS))
            )
              throw new Error(
                `Could not compile fragment shader: ${v.getShaderInfoLog(re)}`,
              );
            v.attachShader(this.program, re);
            const ie = v.createShader(v.VERTEX_SHADER);
            if (v.isContextLost()) return void (this.failedToCreate = !0);
            if (
              (v.shaderSource(ie, ee),
              v.compileShader(ie),
              !v.getShaderParameter(ie, v.COMPILE_STATUS))
            )
              throw new Error(
                `Could not compile vertex shader: ${v.getShaderInfoLog(ie)}`,
              );
            (v.attachShader(this.program, ie), (this.attributes = {}));
            const he = {};
            this.numAttributes = T.length;
            for (let pe = 0; pe < this.numAttributes; pe++)
              T[pe] &&
                (v.bindAttribLocation(this.program, pe, T[pe]),
                (this.attributes[T[pe]] = pe));
            if (
              (v.linkProgram(this.program),
              !v.getProgramParameter(this.program, v.LINK_STATUS))
            )
              throw new Error(
                `Program failed to link: ${v.getProgramInfoLog(this.program)}`,
              );
            (v.deleteShader(ie), v.deleteShader(re));
            for (let pe = 0; pe < G.length; pe++) {
              const be = G[pe];
              if (be && !he[be]) {
                const Ee = v.getUniformLocation(this.program, be);
                Ee && (he[be] = Ee);
              }
            }
            ((this.fixedUniforms = a(e, he)),
              (this.terrainUniforms = ((pe, be) => ({
                u_depth: new u.bC(pe, be.u_depth),
                u_terrain: new u.bC(pe, be.u_terrain),
                u_terrain_dim: new u.b5(pe, be.u_terrain_dim),
                u_terrain_matrix: new u.bD(pe, be.u_terrain_matrix),
                u_terrain_unpack: new u.bE(pe, be.u_terrain_unpack),
                u_terrain_exaggeration: new u.b5(pe, be.u_terrain_exaggeration),
              }))(e, he)),
              (this.projectionUniforms = ((pe, be) => ({
                u_projection_matrix: new u.bD(pe, be.u_projection_matrix),
                u_projection_tile_mercator_coords: new u.bE(
                  pe,
                  be.u_projection_tile_mercator_coords,
                ),
                u_projection_clipping_plane: new u.bE(
                  pe,
                  be.u_projection_clipping_plane,
                ),
                u_projection_transition: new u.b5(
                  pe,
                  be.u_projection_transition,
                ),
                u_projection_fallback_matrix: new u.bD(
                  pe,
                  be.u_projection_fallback_matrix,
                ),
              }))(e, he)),
              (this.binderUniforms = s ? s.getUniforms(e, he) : []));
          }
          draw(e, i, s, a, h, f, g, y, v, C, A, T, M, k, V, N, $, G, Y) {
            const Q = e.gl;
            if (this.failedToCreate) return;
            if (
              (e.program.set(this.program),
              e.setDepthMode(s),
              e.setStencilMode(a),
              e.setColorMode(h),
              e.setCullFace(f),
              y)
            ) {
              (e.activeTexture.set(Q.TEXTURE2),
                Q.bindTexture(Q.TEXTURE_2D, y.depthTexture),
                e.activeTexture.set(Q.TEXTURE3),
                Q.bindTexture(Q.TEXTURE_2D, y.texture));
              for (const re in this.terrainUniforms)
                this.terrainUniforms[re].set(y[re]);
            }
            if (v)
              for (const re in v) this.projectionUniforms[Ca[re]].set(v[re]);
            if (g)
              for (const re in this.fixedUniforms)
                this.fixedUniforms[re].set(g[re]);
            N && N.setUniforms(e, this.binderUniforms, k, { zoom: V });
            let ee = 0;
            switch (i) {
              case Q.LINES:
                ee = 2;
                break;
              case Q.TRIANGLES:
                ee = 3;
                break;
              case Q.LINE_STRIP:
                ee = 1;
            }
            for (const re of M.get()) {
              const ie = re.vaos || (re.vaos = {});
              ((ie[C] || (ie[C] = new wa())).bind(
                e,
                this,
                A,
                N ? N.getPaintVertexBuffers() : [],
                T,
                re.vertexOffset,
                $,
                G,
                Y,
              ),
                Q.drawElements(
                  i,
                  re.primitiveLength * ee,
                  Q.UNSIGNED_SHORT,
                  re.primitiveOffset * ee * 2,
                ));
            }
          }
        }
        function Vl(c, e, i) {
          const s = 1 / u.at(i, 1, e.transform.tileZoom),
            a = Math.pow(2, i.tileID.overscaledZ),
            h = (i.tileSize * Math.pow(2, e.transform.tileZoom)) / a,
            f = h * (i.tileID.canonical.x + i.tileID.wrap * a),
            g = h * i.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: i.imageAtlasTexture.size,
            u_scale: [s, c.fromScale, c.toScale],
            u_fade: c.t,
            u_pixel_coord_upper: [f >> 16, g >> 16],
            u_pixel_coord_lower: [65535 & f, 65535 & g],
          };
        }
        const ws = (c, e, i, s) => {
            const a = c.style.light,
              h = a.properties.get("position"),
              f = [h.x, h.y, h.z],
              g = u.bI();
            (a.properties.get("anchor") === "viewport" &&
              u.bJ(g, c.transform.bearingInRadians),
              u.bK(f, f, g));
            const y = c.transform.transformLightDirection(f),
              v = a.properties.get("color");
            return {
              u_lightpos: f,
              u_lightpos_globe: y,
              u_lightintensity: a.properties.get("intensity"),
              u_lightcolor: [v.r, v.g, v.b],
              u_vertical_gradient: +e,
              u_opacity: i,
              u_fill_translate: s,
            };
          },
          Bo = (c, e, i, s, a, h, f) =>
            u.e(ws(c, e, i, s), Vl(h, c, f), {
              u_height_factor: -Math.pow(2, a.overscaledZ) / f.tileSize / 8,
            }),
          Qn = (c, e, i, s) => u.e(Vl(e, c, i), { u_fill_translate: s }),
          nc = (c, e) => ({ u_world: c, u_fill_translate: e }),
          Cs = (c, e, i, s, a) => u.e(Qn(c, e, i, a), { u_world: s }),
          oc = (c, e, i, s, a) => {
            const h = c.transform;
            let f,
              g,
              y = 0;
            if (i.paint.get("circle-pitch-alignment") === "map") {
              const v = u.at(e, 1, h.zoom);
              ((f = !0),
                (g = [v, v]),
                (y =
                  (v / (u.X * Math.pow(2, e.tileID.overscaledZ))) *
                  2 *
                  Math.PI *
                  a));
            } else ((f = !1), (g = h.pixelsToGLUnits));
            return {
              u_camera_to_center_distance: h.cameraToCenterDistance,
              u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +f,
              u_device_pixel_ratio: c.pixelRatio,
              u_extrude_scale: g,
              u_globe_extrude_scale: y,
              u_translate: s,
            };
          },
          eo = (c) => ({ u_pixel_extrude_scale: [1 / c.width, 1 / c.height] }),
          sc = (c) => ({ u_viewport_size: [c.width, c.height] }),
          Ea = (c, e = 1) => ({ u_color: c, u_overlay: 0, u_overlay_scale: e }),
          Ul = (c, e, i, s) => {
            const a =
              (u.at(c, 1, e) / (u.X * Math.pow(2, c.tileID.overscaledZ))) *
              2 *
              Math.PI *
              s;
            return {
              u_extrude_scale: u.at(c, 1, e),
              u_intensity: i,
              u_globe_extrude_scale: a,
            };
          },
          Aa = (c, e, i, s) => {
            const a = u.H();
            u.bL(a, 0, c.width, c.height, 0, 0, 1);
            const h = c.context.gl;
            return {
              u_matrix: a,
              u_world: [h.drawingBufferWidth, h.drawingBufferHeight],
              u_image: i,
              u_color_ramp: s,
              u_opacity: e.paint.get("heatmap-opacity"),
            };
          },
          Ta = (c, e, i) => {
            const s = i.paint.get("hillshade-shadow-color"),
              a = i.paint.get("hillshade-highlight-color"),
              h = i.paint.get("hillshade-accent-color");
            let f =
              i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            return (
              i.paint.get("hillshade-illumination-anchor") === "viewport" &&
                (f += c.transform.bearingInRadians),
              {
                u_image: 0,
                u_latrange: Zl(0, e.tileID),
                u_light: [i.paint.get("hillshade-exaggeration"), f],
                u_shadow: s,
                u_highlight: a,
                u_accent: h,
              }
            );
          },
          $l = (c, e) => {
            const i = e.stride,
              s = u.H();
            return (
              u.bL(s, 0, u.X, -u.X, 0, 0, 1),
              u.J(s, s, [0, -u.X, 0]),
              {
                u_matrix: s,
                u_image: 1,
                u_dimension: [i, i],
                u_zoom: c.overscaledZ,
                u_unpack: e.getUnpackVector(),
              }
            );
          };
        function Zl(c, e) {
          const i = Math.pow(2, e.canonical.z),
            s = e.canonical.y;
          return [
            new u.Y(0, s / i).toLngLat().lat,
            new u.Y(0, (s + 1) / i).toLngLat().lat,
          ];
        }
        const Es = (c, e, i, s) => {
            const a = c.transform;
            return {
              u_translation: Pa(c, e, i),
              u_ratio: s / u.at(e, 1, a.zoom),
              u_device_pixel_ratio: c.pixelRatio,
              u_units_to_pixels: [
                1 / a.pixelsToGLUnits[0],
                1 / a.pixelsToGLUnits[1],
              ],
            };
          },
          Gl = (c, e, i, s, a) =>
            u.e(Es(c, e, i, s), { u_image: 0, u_image_height: a }),
          In = (c, e, i, s, a) => {
            const h = c.transform,
              f = Fa(e, h);
            return {
              u_translation: Pa(c, e, i),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: s / u.at(e, 1, h.zoom),
              u_device_pixel_ratio: c.pixelRatio,
              u_image: 0,
              u_scale: [f, a.fromScale, a.toScale],
              u_fade: a.t,
              u_units_to_pixels: [
                1 / h.pixelsToGLUnits[0],
                1 / h.pixelsToGLUnits[1],
              ],
            };
          },
          ql = (c, e, i, s, a, h) => {
            const f = c.lineAtlas,
              g = Fa(e, c.transform),
              y = i.layout.get("line-cap") === "round",
              v = f.getDash(a.from, y),
              C = f.getDash(a.to, y),
              A = v.width * h.fromScale,
              T = C.width * h.toScale;
            return u.e(Es(c, e, i, s), {
              u_patternscale_a: [g / A, -v.height / 2],
              u_patternscale_b: [g / T, -C.height / 2],
              u_sdfgamma: f.width / (256 * Math.min(A, T) * c.pixelRatio) / 2,
              u_image: 0,
              u_tex_y_a: v.y,
              u_tex_y_b: C.y,
              u_mix: h.t,
            });
          };
        function Fa(c, e) {
          return 1 / u.at(c, 1, e.tileZoom);
        }
        function Pa(c, e, i) {
          return u.au(
            c.transform,
            e,
            i.paint.get("line-translate"),
            i.paint.get("line-translate-anchor"),
          );
        }
        const Hl = (c, e, i, s, a) => {
          return {
            u_tl_parent: c,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: i.mix,
            u_opacity: i.opacity * s.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: s.paint.get("raster-brightness-min"),
            u_brightness_high: s.paint.get("raster-brightness-max"),
            u_saturation_factor:
              ((f = s.paint.get("raster-saturation")),
              f > 0 ? 1 - 1 / (1.001 - f) : -f),
            u_contrast_factor:
              ((h = s.paint.get("raster-contrast")),
              h > 0 ? 1 / (1 - h) : 1 + h),
            u_spin_weights: Sa(s.paint.get("raster-hue-rotate")),
            u_coords_top: [a[0].x, a[0].y, a[1].x, a[1].y],
            u_coords_bottom: [a[3].x, a[3].y, a[2].x, a[2].y],
          };
          var h, f;
        };
        function Sa(c) {
          c *= Math.PI / 180;
          const e = Math.sin(c),
            i = Math.cos(c);
          return [
            (2 * i + 1) / 3,
            (-Math.sqrt(3) * e - i + 1) / 3,
            (Math.sqrt(3) * e - i + 1) / 3,
          ];
        }
        const Da = (c, e, i, s, a, h, f, g, y, v, C, A, T) => {
            const M = f.transform;
            return {
              u_is_size_zoom_constant: +(c === "constant" || c === "source"),
              u_is_size_feature_constant: +(c === "constant" || c === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: M.cameraToCenterDistance,
              u_pitch: (M.pitch / 360) * 2 * Math.PI,
              u_rotate_symbol: +i,
              u_aspect_ratio: M.width / M.height,
              u_fade_change: f.options.fadeDuration ? f.symbolFadeChange : 1,
              u_label_plane_matrix: g,
              u_coord_matrix: y,
              u_is_text: +C,
              u_pitch_with_map: +s,
              u_is_along_line: a,
              u_is_variable_anchor: h,
              u_texsize: A,
              u_texture: 0,
              u_translation: v,
              u_pitched_scale: T,
            };
          },
          ko = (c, e, i, s, a, h, f, g, y, v, C, A, T, M) => {
            const k = f.transform;
            return u.e(Da(c, e, i, s, a, h, f, g, y, v, C, A, M), {
              u_gamma_scale: s
                ? Math.cos((k.pitch * Math.PI) / 180) * k.cameraToCenterDistance
                : 1,
              u_device_pixel_ratio: f.pixelRatio,
              u_is_halo: +T,
            });
          },
          Nr = (c, e, i, s, a, h, f, g, y, v, C, A, T) =>
            u.e(ko(c, e, i, s, a, h, f, g, y, v, !0, C, !0, T), {
              u_texsize_icon: A,
              u_texture_icon: 1,
            }),
          Ma = (c, e) => ({ u_opacity: c, u_color: e }),
          Ia = (c, e, i, s, a) =>
            u.e(
              (function (h, f, g, y) {
                const v = g.imageManager.getPattern(h.from.toString()),
                  C = g.imageManager.getPattern(h.to.toString()),
                  { width: A, height: T } = g.imageManager.getPixelSize(),
                  M = Math.pow(2, y.tileID.overscaledZ),
                  k = (y.tileSize * Math.pow(2, g.transform.tileZoom)) / M,
                  V = k * (y.tileID.canonical.x + y.tileID.wrap * M),
                  N = k * y.tileID.canonical.y;
                return {
                  u_image: 0,
                  u_pattern_tl_a: v.tl,
                  u_pattern_br_a: v.br,
                  u_pattern_tl_b: C.tl,
                  u_pattern_br_b: C.br,
                  u_texsize: [A, T],
                  u_mix: f.t,
                  u_pattern_size_a: v.displaySize,
                  u_pattern_size_b: C.displaySize,
                  u_scale_a: f.fromScale,
                  u_scale_b: f.toScale,
                  u_tile_units_to_pixels: 1 / u.at(y, 1, g.transform.tileZoom),
                  u_pixel_coord_upper: [V >> 16, N >> 16],
                  u_pixel_coord_lower: [65535 & V, 65535 & N],
                };
              })(i, a, e, s),
              { u_opacity: c },
            ),
          As = (c, e) => {},
          Xl = {
            fillExtrusion: (c, e) => ({
              u_lightpos: new u.bG(c, e.u_lightpos),
              u_lightpos_globe: new u.bG(c, e.u_lightpos_globe),
              u_lightintensity: new u.b5(c, e.u_lightintensity),
              u_lightcolor: new u.bG(c, e.u_lightcolor),
              u_vertical_gradient: new u.b5(c, e.u_vertical_gradient),
              u_opacity: new u.b5(c, e.u_opacity),
              u_fill_translate: new u.bH(c, e.u_fill_translate),
            }),
            fillExtrusionPattern: (c, e) => ({
              u_lightpos: new u.bG(c, e.u_lightpos),
              u_lightpos_globe: new u.bG(c, e.u_lightpos_globe),
              u_lightintensity: new u.b5(c, e.u_lightintensity),
              u_lightcolor: new u.bG(c, e.u_lightcolor),
              u_vertical_gradient: new u.b5(c, e.u_vertical_gradient),
              u_height_factor: new u.b5(c, e.u_height_factor),
              u_opacity: new u.b5(c, e.u_opacity),
              u_fill_translate: new u.bH(c, e.u_fill_translate),
              u_image: new u.bC(c, e.u_image),
              u_texsize: new u.bH(c, e.u_texsize),
              u_pixel_coord_upper: new u.bH(c, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new u.bH(c, e.u_pixel_coord_lower),
              u_scale: new u.bG(c, e.u_scale),
              u_fade: new u.b5(c, e.u_fade),
            }),
            fill: (c, e) => ({
              u_fill_translate: new u.bH(c, e.u_fill_translate),
            }),
            fillPattern: (c, e) => ({
              u_image: new u.bC(c, e.u_image),
              u_texsize: new u.bH(c, e.u_texsize),
              u_pixel_coord_upper: new u.bH(c, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new u.bH(c, e.u_pixel_coord_lower),
              u_scale: new u.bG(c, e.u_scale),
              u_fade: new u.b5(c, e.u_fade),
              u_fill_translate: new u.bH(c, e.u_fill_translate),
            }),
            fillOutline: (c, e) => ({
              u_world: new u.bH(c, e.u_world),
              u_fill_translate: new u.bH(c, e.u_fill_translate),
            }),
            fillOutlinePattern: (c, e) => ({
              u_world: new u.bH(c, e.u_world),
              u_image: new u.bC(c, e.u_image),
              u_texsize: new u.bH(c, e.u_texsize),
              u_pixel_coord_upper: new u.bH(c, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new u.bH(c, e.u_pixel_coord_lower),
              u_scale: new u.bG(c, e.u_scale),
              u_fade: new u.b5(c, e.u_fade),
              u_fill_translate: new u.bH(c, e.u_fill_translate),
            }),
            circle: (c, e) => ({
              u_camera_to_center_distance: new u.b5(
                c,
                e.u_camera_to_center_distance,
              ),
              u_scale_with_map: new u.bC(c, e.u_scale_with_map),
              u_pitch_with_map: new u.bC(c, e.u_pitch_with_map),
              u_extrude_scale: new u.bH(c, e.u_extrude_scale),
              u_device_pixel_ratio: new u.b5(c, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new u.b5(c, e.u_globe_extrude_scale),
              u_translate: new u.bH(c, e.u_translate),
            }),
            collisionBox: (c, e) => ({
              u_pixel_extrude_scale: new u.bH(c, e.u_pixel_extrude_scale),
            }),
            collisionCircle: (c, e) => ({
              u_viewport_size: new u.bH(c, e.u_viewport_size),
            }),
            debug: (c, e) => ({
              u_color: new u.bF(c, e.u_color),
              u_overlay: new u.bC(c, e.u_overlay),
              u_overlay_scale: new u.b5(c, e.u_overlay_scale),
            }),
            depth: As,
            clippingMask: As,
            heatmap: (c, e) => ({
              u_extrude_scale: new u.b5(c, e.u_extrude_scale),
              u_intensity: new u.b5(c, e.u_intensity),
              u_globe_extrude_scale: new u.b5(c, e.u_globe_extrude_scale),
            }),
            heatmapTexture: (c, e) => ({
              u_matrix: new u.bD(c, e.u_matrix),
              u_world: new u.bH(c, e.u_world),
              u_image: new u.bC(c, e.u_image),
              u_color_ramp: new u.bC(c, e.u_color_ramp),
              u_opacity: new u.b5(c, e.u_opacity),
            }),
            hillshade: (c, e) => ({
              u_image: new u.bC(c, e.u_image),
              u_latrange: new u.bH(c, e.u_latrange),
              u_light: new u.bH(c, e.u_light),
              u_shadow: new u.bF(c, e.u_shadow),
              u_highlight: new u.bF(c, e.u_highlight),
              u_accent: new u.bF(c, e.u_accent),
            }),
            hillshadePrepare: (c, e) => ({
              u_matrix: new u.bD(c, e.u_matrix),
              u_image: new u.bC(c, e.u_image),
              u_dimension: new u.bH(c, e.u_dimension),
              u_zoom: new u.b5(c, e.u_zoom),
              u_unpack: new u.bE(c, e.u_unpack),
            }),
            line: (c, e) => ({
              u_translation: new u.bH(c, e.u_translation),
              u_ratio: new u.b5(c, e.u_ratio),
              u_device_pixel_ratio: new u.b5(c, e.u_device_pixel_ratio),
              u_units_to_pixels: new u.bH(c, e.u_units_to_pixels),
            }),
            lineGradient: (c, e) => ({
              u_translation: new u.bH(c, e.u_translation),
              u_ratio: new u.b5(c, e.u_ratio),
              u_device_pixel_ratio: new u.b5(c, e.u_device_pixel_ratio),
              u_units_to_pixels: new u.bH(c, e.u_units_to_pixels),
              u_image: new u.bC(c, e.u_image),
              u_image_height: new u.b5(c, e.u_image_height),
            }),
            linePattern: (c, e) => ({
              u_translation: new u.bH(c, e.u_translation),
              u_texsize: new u.bH(c, e.u_texsize),
              u_ratio: new u.b5(c, e.u_ratio),
              u_device_pixel_ratio: new u.b5(c, e.u_device_pixel_ratio),
              u_image: new u.bC(c, e.u_image),
              u_units_to_pixels: new u.bH(c, e.u_units_to_pixels),
              u_scale: new u.bG(c, e.u_scale),
              u_fade: new u.b5(c, e.u_fade),
            }),
            lineSDF: (c, e) => ({
              u_translation: new u.bH(c, e.u_translation),
              u_ratio: new u.b5(c, e.u_ratio),
              u_device_pixel_ratio: new u.b5(c, e.u_device_pixel_ratio),
              u_units_to_pixels: new u.bH(c, e.u_units_to_pixels),
              u_patternscale_a: new u.bH(c, e.u_patternscale_a),
              u_patternscale_b: new u.bH(c, e.u_patternscale_b),
              u_sdfgamma: new u.b5(c, e.u_sdfgamma),
              u_image: new u.bC(c, e.u_image),
              u_tex_y_a: new u.b5(c, e.u_tex_y_a),
              u_tex_y_b: new u.b5(c, e.u_tex_y_b),
              u_mix: new u.b5(c, e.u_mix),
            }),
            raster: (c, e) => ({
              u_tl_parent: new u.bH(c, e.u_tl_parent),
              u_scale_parent: new u.b5(c, e.u_scale_parent),
              u_buffer_scale: new u.b5(c, e.u_buffer_scale),
              u_fade_t: new u.b5(c, e.u_fade_t),
              u_opacity: new u.b5(c, e.u_opacity),
              u_image0: new u.bC(c, e.u_image0),
              u_image1: new u.bC(c, e.u_image1),
              u_brightness_low: new u.b5(c, e.u_brightness_low),
              u_brightness_high: new u.b5(c, e.u_brightness_high),
              u_saturation_factor: new u.b5(c, e.u_saturation_factor),
              u_contrast_factor: new u.b5(c, e.u_contrast_factor),
              u_spin_weights: new u.bG(c, e.u_spin_weights),
              u_coords_top: new u.bE(c, e.u_coords_top),
              u_coords_bottom: new u.bE(c, e.u_coords_bottom),
            }),
            symbolIcon: (c, e) => ({
              u_is_size_zoom_constant: new u.bC(c, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new u.bC(
                c,
                e.u_is_size_feature_constant,
              ),
              u_size_t: new u.b5(c, e.u_size_t),
              u_size: new u.b5(c, e.u_size),
              u_camera_to_center_distance: new u.b5(
                c,
                e.u_camera_to_center_distance,
              ),
              u_pitch: new u.b5(c, e.u_pitch),
              u_rotate_symbol: new u.bC(c, e.u_rotate_symbol),
              u_aspect_ratio: new u.b5(c, e.u_aspect_ratio),
              u_fade_change: new u.b5(c, e.u_fade_change),
              u_label_plane_matrix: new u.bD(c, e.u_label_plane_matrix),
              u_coord_matrix: new u.bD(c, e.u_coord_matrix),
              u_is_text: new u.bC(c, e.u_is_text),
              u_pitch_with_map: new u.bC(c, e.u_pitch_with_map),
              u_is_along_line: new u.bC(c, e.u_is_along_line),
              u_is_variable_anchor: new u.bC(c, e.u_is_variable_anchor),
              u_texsize: new u.bH(c, e.u_texsize),
              u_texture: new u.bC(c, e.u_texture),
              u_translation: new u.bH(c, e.u_translation),
              u_pitched_scale: new u.b5(c, e.u_pitched_scale),
            }),
            symbolSDF: (c, e) => ({
              u_is_size_zoom_constant: new u.bC(c, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new u.bC(
                c,
                e.u_is_size_feature_constant,
              ),
              u_size_t: new u.b5(c, e.u_size_t),
              u_size: new u.b5(c, e.u_size),
              u_camera_to_center_distance: new u.b5(
                c,
                e.u_camera_to_center_distance,
              ),
              u_pitch: new u.b5(c, e.u_pitch),
              u_rotate_symbol: new u.bC(c, e.u_rotate_symbol),
              u_aspect_ratio: new u.b5(c, e.u_aspect_ratio),
              u_fade_change: new u.b5(c, e.u_fade_change),
              u_label_plane_matrix: new u.bD(c, e.u_label_plane_matrix),
              u_coord_matrix: new u.bD(c, e.u_coord_matrix),
              u_is_text: new u.bC(c, e.u_is_text),
              u_pitch_with_map: new u.bC(c, e.u_pitch_with_map),
              u_is_along_line: new u.bC(c, e.u_is_along_line),
              u_is_variable_anchor: new u.bC(c, e.u_is_variable_anchor),
              u_texsize: new u.bH(c, e.u_texsize),
              u_texture: new u.bC(c, e.u_texture),
              u_gamma_scale: new u.b5(c, e.u_gamma_scale),
              u_device_pixel_ratio: new u.b5(c, e.u_device_pixel_ratio),
              u_is_halo: new u.bC(c, e.u_is_halo),
              u_translation: new u.bH(c, e.u_translation),
              u_pitched_scale: new u.b5(c, e.u_pitched_scale),
            }),
            symbolTextAndIcon: (c, e) => ({
              u_is_size_zoom_constant: new u.bC(c, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new u.bC(
                c,
                e.u_is_size_feature_constant,
              ),
              u_size_t: new u.b5(c, e.u_size_t),
              u_size: new u.b5(c, e.u_size),
              u_camera_to_center_distance: new u.b5(
                c,
                e.u_camera_to_center_distance,
              ),
              u_pitch: new u.b5(c, e.u_pitch),
              u_rotate_symbol: new u.bC(c, e.u_rotate_symbol),
              u_aspect_ratio: new u.b5(c, e.u_aspect_ratio),
              u_fade_change: new u.b5(c, e.u_fade_change),
              u_label_plane_matrix: new u.bD(c, e.u_label_plane_matrix),
              u_coord_matrix: new u.bD(c, e.u_coord_matrix),
              u_is_text: new u.bC(c, e.u_is_text),
              u_pitch_with_map: new u.bC(c, e.u_pitch_with_map),
              u_is_along_line: new u.bC(c, e.u_is_along_line),
              u_is_variable_anchor: new u.bC(c, e.u_is_variable_anchor),
              u_texsize: new u.bH(c, e.u_texsize),
              u_texsize_icon: new u.bH(c, e.u_texsize_icon),
              u_texture: new u.bC(c, e.u_texture),
              u_texture_icon: new u.bC(c, e.u_texture_icon),
              u_gamma_scale: new u.b5(c, e.u_gamma_scale),
              u_device_pixel_ratio: new u.b5(c, e.u_device_pixel_ratio),
              u_is_halo: new u.bC(c, e.u_is_halo),
              u_translation: new u.bH(c, e.u_translation),
              u_pitched_scale: new u.b5(c, e.u_pitched_scale),
            }),
            background: (c, e) => ({
              u_opacity: new u.b5(c, e.u_opacity),
              u_color: new u.bF(c, e.u_color),
            }),
            backgroundPattern: (c, e) => ({
              u_opacity: new u.b5(c, e.u_opacity),
              u_image: new u.bC(c, e.u_image),
              u_pattern_tl_a: new u.bH(c, e.u_pattern_tl_a),
              u_pattern_br_a: new u.bH(c, e.u_pattern_br_a),
              u_pattern_tl_b: new u.bH(c, e.u_pattern_tl_b),
              u_pattern_br_b: new u.bH(c, e.u_pattern_br_b),
              u_texsize: new u.bH(c, e.u_texsize),
              u_mix: new u.b5(c, e.u_mix),
              u_pattern_size_a: new u.bH(c, e.u_pattern_size_a),
              u_pattern_size_b: new u.bH(c, e.u_pattern_size_b),
              u_scale_a: new u.b5(c, e.u_scale_a),
              u_scale_b: new u.b5(c, e.u_scale_b),
              u_pixel_coord_upper: new u.bH(c, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new u.bH(c, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new u.b5(c, e.u_tile_units_to_pixels),
            }),
            terrain: (c, e) => ({
              u_texture: new u.bC(c, e.u_texture),
              u_ele_delta: new u.b5(c, e.u_ele_delta),
              u_fog_matrix: new u.bD(c, e.u_fog_matrix),
              u_fog_color: new u.bF(c, e.u_fog_color),
              u_fog_ground_blend: new u.b5(c, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new u.b5(
                c,
                e.u_fog_ground_blend_opacity,
              ),
              u_horizon_color: new u.bF(c, e.u_horizon_color),
              u_horizon_fog_blend: new u.b5(c, e.u_horizon_fog_blend),
              u_is_globe_mode: new u.b5(c, e.u_is_globe_mode),
            }),
            terrainDepth: (c, e) => ({
              u_ele_delta: new u.b5(c, e.u_ele_delta),
            }),
            terrainCoords: (c, e) => ({
              u_texture: new u.bC(c, e.u_texture),
              u_terrain_coords_id: new u.b5(c, e.u_terrain_coords_id),
              u_ele_delta: new u.b5(c, e.u_ele_delta),
            }),
            projectionErrorMeasurement: (c, e) => ({
              u_input: new u.b5(c, e.u_input),
              u_output_expected: new u.b5(c, e.u_output_expected),
            }),
            atmosphere: (c, e) => ({
              u_sun_pos: new u.bG(c, e.u_sun_pos),
              u_atmosphere_blend: new u.b5(c, e.u_atmosphere_blend),
              u_globe_position: new u.bG(c, e.u_globe_position),
              u_globe_radius: new u.b5(c, e.u_globe_radius),
              u_inv_proj_matrix: new u.bD(c, e.u_inv_proj_matrix),
            }),
            sky: (c, e) => ({
              u_sky_color: new u.bF(c, e.u_sky_color),
              u_horizon_color: new u.bF(c, e.u_horizon_color),
              u_horizon: new u.bH(c, e.u_horizon),
              u_horizon_normal: new u.bH(c, e.u_horizon_normal),
              u_sky_horizon_blend: new u.b5(c, e.u_sky_horizon_blend),
              u_sky_blend: new u.b5(c, e.u_sky_blend),
            }),
          };
        class Ba {
          constructor(e, i, s) {
            this.context = e;
            const a = e.gl;
            ((this.buffer = a.createBuffer()),
              (this.dynamicDraw = Boolean(s)),
              this.context.unbindVAO(),
              e.bindElementBuffer.set(this.buffer),
              a.bufferData(
                a.ELEMENT_ARRAY_BUFFER,
                i.arrayBuffer,
                this.dynamicDraw ? a.DYNAMIC_DRAW : a.STATIC_DRAW,
              ),
              this.dynamicDraw || delete i.arrayBuffer);
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e) {
            const i = this.context.gl;
            if (!this.dynamicDraw)
              throw new Error(
                "Attempted to update data while not in dynamic mode.",
              );
            (this.context.unbindVAO(),
              this.bind(),
              i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer));
          }
          destroy() {
            this.buffer &&
              (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Bn = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT",
        };
        class ka {
          constructor(e, i, s, a) {
            ((this.length = i.length),
              (this.attributes = s),
              (this.itemSize = i.bytesPerElement),
              (this.dynamicDraw = a),
              (this.context = e));
            const h = e.gl;
            ((this.buffer = h.createBuffer()),
              e.bindVertexBuffer.set(this.buffer),
              h.bufferData(
                h.ARRAY_BUFFER,
                i.arrayBuffer,
                this.dynamicDraw ? h.DYNAMIC_DRAW : h.STATIC_DRAW,
              ),
              this.dynamicDraw || delete i.arrayBuffer);
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e) {
            if (e.length !== this.length)
              throw new Error(
                `Length of new data is ${e.length}, which doesn't match current length of ${this.length}`,
              );
            const i = this.context.gl;
            (this.bind(), i.bufferSubData(i.ARRAY_BUFFER, 0, e.arrayBuffer));
          }
          enableAttributes(e, i) {
            for (let s = 0; s < this.attributes.length; s++) {
              const a = i.attributes[this.attributes[s].name];
              a !== void 0 && e.enableVertexAttribArray(a);
            }
          }
          setVertexAttribPointers(e, i, s) {
            for (let a = 0; a < this.attributes.length; a++) {
              const h = this.attributes[a],
                f = i.attributes[h.name];
              f !== void 0 &&
                e.vertexAttribPointer(
                  f,
                  h.components,
                  e[Bn[h.type]],
                  !1,
                  this.itemSize,
                  h.offset + this.itemSize * (s || 0),
                );
            }
          }
          destroy() {
            this.buffer &&
              (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Ct {
          constructor(e) {
            ((this.gl = e.gl),
              (this.default = this.getDefault()),
              (this.current = this.default),
              (this.dirty = !1));
          }
          get() {
            return this.current;
          }
          set(e) {}
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class ac extends Ct {
          getDefault() {
            return u.b4.transparent;
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r ||
              e.g !== i.g ||
              e.b !== i.b ||
              e.a !== i.a ||
              this.dirty) &&
              (this.gl.clearColor(e.r, e.g, e.b, e.a),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class lc extends Ct {
          getDefault() {
            return 1;
          }
          set(e) {
            (e !== this.current || this.dirty) &&
              (this.gl.clearDepth(e), (this.current = e), (this.dirty = !1));
          }
        }
        class uc extends Ct {
          getDefault() {
            return 0;
          }
          set(e) {
            (e !== this.current || this.dirty) &&
              (this.gl.clearStencil(e), (this.current = e), (this.dirty = !1));
          }
        }
        class Wl extends Ct {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] ||
              e[1] !== i[1] ||
              e[2] !== i[2] ||
              e[3] !== i[3] ||
              this.dirty) &&
              (this.gl.colorMask(e[0], e[1], e[2], e[3]),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class cc extends Ct {
          getDefault() {
            return !0;
          }
          set(e) {
            (e !== this.current || this.dirty) &&
              (this.gl.depthMask(e), (this.current = e), (this.dirty = !1));
          }
        }
        class Kl extends Ct {
          getDefault() {
            return 255;
          }
          set(e) {
            (e !== this.current || this.dirty) &&
              (this.gl.stencilMask(e), (this.current = e), (this.dirty = !1));
          }
        }
        class Ts extends Ct {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e) {
            const i = this.current;
            (e.func !== i.func ||
              e.ref !== i.ref ||
              e.mask !== i.mask ||
              this.dirty) &&
              (this.gl.stencilFunc(e.func, e.ref, e.mask),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class Fs extends Ct {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP];
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || this.dirty) &&
              (this.gl.stencilOp(e[0], e[1], e[2]),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class Ps extends Ct {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            (e ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class za extends Ct {
          getDefault() {
            return [0, 1];
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) &&
              (this.gl.depthRange(e[0], e[1]),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class kn extends Ct {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            (e ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class to extends Ct {
          getDefault() {
            return this.gl.LESS;
          }
          set(e) {
            (e !== this.current || this.dirty) &&
              (this.gl.depthFunc(e), (this.current = e), (this.dirty = !1));
          }
        }
        class ur extends Ct {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            (e ? i.enable(i.BLEND) : i.disable(i.BLEND),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class Yl extends Ct {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO];
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) &&
              (this.gl.blendFunc(e[0], e[1]),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class Jl extends Ct {
          getDefault() {
            return u.b4.transparent;
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r ||
              e.g !== i.g ||
              e.b !== i.b ||
              e.a !== i.a ||
              this.dirty) &&
              (this.gl.blendColor(e.r, e.g, e.b, e.a),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class La extends Ct {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e) {
            (e !== this.current || this.dirty) &&
              (this.gl.blendEquation(e), (this.current = e), (this.dirty = !1));
          }
        }
        class zn extends Ct {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            (e ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class Ss extends Ct {
          getDefault() {
            return this.gl.BACK;
          }
          set(e) {
            (e !== this.current || this.dirty) &&
              (this.gl.cullFace(e), (this.current = e), (this.dirty = !1));
          }
        }
        class Ds extends Ct {
          getDefault() {
            return this.gl.CCW;
          }
          set(e) {
            (e !== this.current || this.dirty) &&
              (this.gl.frontFace(e), (this.current = e), (this.dirty = !1));
          }
        }
        class zo extends Ct {
          getDefault() {
            return null;
          }
          set(e) {
            (e !== this.current || this.dirty) &&
              (this.gl.useProgram(e), (this.current = e), (this.dirty = !1));
          }
        }
        class Ms extends Ct {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e) {
            (e !== this.current || this.dirty) &&
              (this.gl.activeTexture(e), (this.current = e), (this.dirty = !1));
          }
        }
        class Ql extends Ct {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] ||
              e[1] !== i[1] ||
              e[2] !== i[2] ||
              e[3] !== i[3] ||
              this.dirty) &&
              (this.gl.viewport(e[0], e[1], e[2], e[3]),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class io extends Ct {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            (i.bindFramebuffer(i.FRAMEBUFFER, e),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class ro extends Ct {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            (i.bindRenderbuffer(i.RENDERBUFFER, e),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class eu extends Ct {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            (i.bindTexture(i.TEXTURE_2D, e),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class Ra extends Ct {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            (i.bindBuffer(i.ARRAY_BUFFER, e),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class yt extends Ct {
          getDefault() {
            return null;
          }
          set(e) {
            const i = this.gl;
            (i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class Is extends Ct {
          getDefault() {
            return null;
          }
          set(e) {
            var i;
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            (lr(s)
              ? s.bindVertexArray(e)
              : (i = s.getExtension("OES_vertex_array_object")) === null ||
                i === void 0 ||
                i.bindVertexArrayOES(e),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class hc extends Ct {
          getDefault() {
            return 4;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            (i.pixelStorei(i.UNPACK_ALIGNMENT, e),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class tu extends Ct {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            (i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class Lo extends Ct {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            (i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, e),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class Oa extends Ct {
          constructor(e, i) {
            (super(e), (this.context = e), (this.parent = i));
          }
          getDefault() {
            return null;
          }
        }
        class dc extends Oa {
          setDirty() {
            this.dirty = !0;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            (i.framebufferTexture2D(
              i.FRAMEBUFFER,
              i.COLOR_ATTACHMENT0,
              i.TEXTURE_2D,
              e,
              0,
            ),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class iu extends Oa {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            (i.framebufferRenderbuffer(
              i.FRAMEBUFFER,
              i.DEPTH_ATTACHMENT,
              i.RENDERBUFFER,
              e,
            ),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        class pc extends Oa {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            (i.framebufferRenderbuffer(
              i.FRAMEBUFFER,
              i.DEPTH_STENCIL_ATTACHMENT,
              i.RENDERBUFFER,
              e,
            ),
              (this.current = e),
              (this.dirty = !1));
          }
        }
        const Bs = "Framebuffer is not complete";
        class ks {
          constructor(e, i, s, a, h) {
            ((this.context = e), (this.width = i), (this.height = s));
            const f = e.gl,
              g = (this.framebuffer = f.createFramebuffer());
            if (((this.colorAttachment = new dc(e, g)), a))
              this.depthAttachment = h ? new pc(e, g) : new iu(e, g);
            else if (h) throw new Error("Stencil cannot be set without depth");
            if (
              f.checkFramebufferStatus(f.FRAMEBUFFER) !== f.FRAMEBUFFER_COMPLETE
            )
              throw new Error(Bs);
          }
          destroy() {
            const e = this.context.gl,
              i = this.colorAttachment.get();
            if ((i && e.deleteTexture(i), this.depthAttachment)) {
              const s = this.depthAttachment.get();
              s && e.deleteRenderbuffer(s);
            }
            e.deleteFramebuffer(this.framebuffer);
          }
        }
        class zs {
          constructor(e) {
            var i, s;
            if (
              ((this.gl = e),
              (this.clearColor = new ac(this)),
              (this.clearDepth = new lc(this)),
              (this.clearStencil = new uc(this)),
              (this.colorMask = new Wl(this)),
              (this.depthMask = new cc(this)),
              (this.stencilMask = new Kl(this)),
              (this.stencilFunc = new Ts(this)),
              (this.stencilOp = new Fs(this)),
              (this.stencilTest = new Ps(this)),
              (this.depthRange = new za(this)),
              (this.depthTest = new kn(this)),
              (this.depthFunc = new to(this)),
              (this.blend = new ur(this)),
              (this.blendFunc = new Yl(this)),
              (this.blendColor = new Jl(this)),
              (this.blendEquation = new La(this)),
              (this.cullFace = new zn(this)),
              (this.cullFaceSide = new Ss(this)),
              (this.frontFace = new Ds(this)),
              (this.program = new zo(this)),
              (this.activeTexture = new Ms(this)),
              (this.viewport = new Ql(this)),
              (this.bindFramebuffer = new io(this)),
              (this.bindRenderbuffer = new ro(this)),
              (this.bindTexture = new eu(this)),
              (this.bindVertexBuffer = new Ra(this)),
              (this.bindElementBuffer = new yt(this)),
              (this.bindVertexArray = new Is(this)),
              (this.pixelStoreUnpack = new hc(this)),
              (this.pixelStoreUnpackPremultiplyAlpha = new tu(this)),
              (this.pixelStoreUnpackFlipY = new Lo(this)),
              (this.extTextureFilterAnisotropic =
                e.getExtension("EXT_texture_filter_anisotropic") ||
                e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                e.getExtension("WEBKIT_EXT_texture_filter_anisotropic")),
              this.extTextureFilterAnisotropic &&
                (this.extTextureFilterAnisotropicMax = e.getParameter(
                  this.extTextureFilterAnisotropic
                    .MAX_TEXTURE_MAX_ANISOTROPY_EXT,
                )),
              (this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE)),
              lr(e))
            ) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const a = e.getExtension("EXT_color_buffer_half_float");
              ((this.RGBA16F =
                (i = e.RGBA16F) !== null && i !== void 0
                  ? i
                  : a == null
                    ? void 0
                    : a.RGBA16F_EXT),
                (this.RGB16F =
                  (s = e.RGB16F) !== null && s !== void 0
                    ? s
                    : a == null
                      ? void 0
                      : a.RGB16F_EXT),
                e.getExtension("EXT_color_buffer_float"));
            } else {
              (e.getExtension("EXT_color_buffer_half_float"),
                e.getExtension("OES_texture_half_float_linear"));
              const a = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = a == null ? void 0 : a.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            (this.unbindVAO(),
              this.clearColor.setDefault(),
              this.clearDepth.setDefault(),
              this.clearStencil.setDefault(),
              this.colorMask.setDefault(),
              this.depthMask.setDefault(),
              this.stencilMask.setDefault(),
              this.stencilFunc.setDefault(),
              this.stencilOp.setDefault(),
              this.stencilTest.setDefault(),
              this.depthRange.setDefault(),
              this.depthTest.setDefault(),
              this.depthFunc.setDefault(),
              this.blend.setDefault(),
              this.blendFunc.setDefault(),
              this.blendColor.setDefault(),
              this.blendEquation.setDefault(),
              this.cullFace.setDefault(),
              this.cullFaceSide.setDefault(),
              this.frontFace.setDefault(),
              this.program.setDefault(),
              this.activeTexture.setDefault(),
              this.bindFramebuffer.setDefault(),
              this.pixelStoreUnpack.setDefault(),
              this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
              this.pixelStoreUnpackFlipY.setDefault());
          }
          setDirty() {
            ((this.clearColor.dirty = !0),
              (this.clearDepth.dirty = !0),
              (this.clearStencil.dirty = !0),
              (this.colorMask.dirty = !0),
              (this.depthMask.dirty = !0),
              (this.stencilMask.dirty = !0),
              (this.stencilFunc.dirty = !0),
              (this.stencilOp.dirty = !0),
              (this.stencilTest.dirty = !0),
              (this.depthRange.dirty = !0),
              (this.depthTest.dirty = !0),
              (this.depthFunc.dirty = !0),
              (this.blend.dirty = !0),
              (this.blendFunc.dirty = !0),
              (this.blendColor.dirty = !0),
              (this.blendEquation.dirty = !0),
              (this.cullFace.dirty = !0),
              (this.cullFaceSide.dirty = !0),
              (this.frontFace.dirty = !0),
              (this.program.dirty = !0),
              (this.activeTexture.dirty = !0),
              (this.viewport.dirty = !0),
              (this.bindFramebuffer.dirty = !0),
              (this.bindRenderbuffer.dirty = !0),
              (this.bindTexture.dirty = !0),
              (this.bindVertexBuffer.dirty = !0),
              (this.bindElementBuffer.dirty = !0),
              (this.bindVertexArray.dirty = !0),
              (this.pixelStoreUnpack.dirty = !0),
              (this.pixelStoreUnpackPremultiplyAlpha.dirty = !0),
              (this.pixelStoreUnpackFlipY.dirty = !0));
          }
          createIndexBuffer(e, i) {
            return new Ba(this, e, i);
          }
          createVertexBuffer(e, i, s) {
            return new ka(this, e, i, s);
          }
          createRenderbuffer(e, i, s) {
            const a = this.gl,
              h = a.createRenderbuffer();
            return (
              this.bindRenderbuffer.set(h),
              a.renderbufferStorage(a.RENDERBUFFER, e, i, s),
              this.bindRenderbuffer.set(null),
              h
            );
          }
          createFramebuffer(e, i, s, a) {
            return new ks(this, e, i, s, a);
          }
          clear({ color: e, depth: i, stencil: s }) {
            const a = this.gl;
            let h = 0;
            (e &&
              ((h |= a.COLOR_BUFFER_BIT),
              this.clearColor.set(e),
              this.colorMask.set([!0, !0, !0, !0])),
              i !== void 0 &&
                ((h |= a.DEPTH_BUFFER_BIT),
                this.depthRange.set([0, 1]),
                this.clearDepth.set(i),
                this.depthMask.set(!0)),
              s !== void 0 &&
                ((h |= a.STENCIL_BUFFER_BIT),
                this.clearStencil.set(s),
                this.stencilMask.set(255)),
              a.clear(h));
          }
          setCullFace(e) {
            e.enable === !1
              ? this.cullFace.set(!1)
              : (this.cullFace.set(!0),
                this.cullFaceSide.set(e.mode),
                this.frontFace.set(e.frontFace));
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask
              ? (this.depthTest.set(!0),
                this.depthFunc.set(e.func),
                this.depthMask.set(e.mask),
                this.depthRange.set(e.range))
              : this.depthTest.set(!1);
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask
              ? (this.stencilTest.set(!0),
                this.stencilMask.set(e.mask),
                this.stencilOp.set([e.fail, e.depthFail, e.pass]),
                this.stencilFunc.set({
                  func: e.test.func,
                  ref: e.ref,
                  mask: e.test.mask,
                }))
              : this.stencilTest.set(!1);
          }
          setColorMode(e) {
            (u.bz(e.blendFunction, Rt.Replace)
              ? this.blend.set(!1)
              : (this.blend.set(!0),
                this.blendFunc.set(e.blendFunction),
                this.blendColor.set(e.blendColor)),
              this.colorMask.set(e.mask));
          }
          createVertexArray() {
            var e;
            return lr(this.gl)
              ? this.gl.createVertexArray()
              : (e = this.gl.getExtension("OES_vertex_array_object")) ===
                    null || e === void 0
                ? void 0
                : e.createVertexArrayOES();
          }
          deleteVertexArray(e) {
            var i;
            return lr(this.gl)
              ? this.gl.deleteVertexArray(e)
              : (i = this.gl.getExtension("OES_vertex_array_object")) ===
                    null || i === void 0
                ? void 0
                : i.deleteVertexArrayOES(e);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let no;
        function Ls(c, e, i, s, a) {
          const h = c.context,
            f = c.transform,
            g = h.gl,
            y = c.useProgram("collisionBox"),
            v = [];
          let C = 0,
            A = 0;
          for (let $ = 0; $ < s.length; $++) {
            const G = s[$],
              Y = e.getTile(G).getBucket(i);
            if (!Y) continue;
            const Q = a ? Y.textCollisionBox : Y.iconCollisionBox,
              ee = Y.collisionCircleArray;
            (ee.length > 0 &&
              (v.push({ circleArray: ee, circleOffset: A, coord: G }),
              (C += ee.length / 4),
              (A = C)),
              Q &&
                y.draw(
                  h,
                  g.LINES,
                  at.disabled,
                  vt.disabled,
                  c.colorModeForRenderPass(),
                  xt.disabled,
                  eo(c.transform),
                  c.style.map.terrain && c.style.map.terrain.getTerrainData(G),
                  f.getProjectionData({
                    overscaledTileID: G,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0,
                  }),
                  i.id,
                  Q.layoutVertexBuffer,
                  Q.indexBuffer,
                  Q.segments,
                  null,
                  c.transform.zoom,
                  null,
                  null,
                  Q.collisionVertexBuffer,
                ));
          }
          if (!a || !v.length) return;
          const T = c.useProgram("collisionCircle"),
            M = new u.bM();
          (M.resize(4 * C), M._trim());
          let k = 0;
          for (const $ of v)
            for (let G = 0; G < $.circleArray.length / 4; G++) {
              const Y = 4 * G,
                Q = $.circleArray[Y + 0],
                ee = $.circleArray[Y + 1],
                re = $.circleArray[Y + 2],
                ie = $.circleArray[Y + 3];
              (M.emplace(k++, Q, ee, re, ie, 0),
                M.emplace(k++, Q, ee, re, ie, 1),
                M.emplace(k++, Q, ee, re, ie, 2),
                M.emplace(k++, Q, ee, re, ie, 3));
            }
          (!no || no.length < 2 * C) &&
            (no = (function ($) {
              const G = 2 * $,
                Y = new u.bO();
              (Y.resize(G), Y._trim());
              for (let Q = 0; Q < G; Q++) {
                const ee = 6 * Q;
                ((Y.uint16[ee + 0] = 4 * Q + 0),
                  (Y.uint16[ee + 1] = 4 * Q + 1),
                  (Y.uint16[ee + 2] = 4 * Q + 2),
                  (Y.uint16[ee + 3] = 4 * Q + 2),
                  (Y.uint16[ee + 4] = 4 * Q + 3),
                  (Y.uint16[ee + 5] = 4 * Q + 0));
              }
              return Y;
            })(C));
          const V = h.createIndexBuffer(no, !0),
            N = h.createVertexBuffer(M, u.bN.members, !0);
          for (const $ of v) {
            const G = sc(c.transform);
            T.draw(
              h,
              g.TRIANGLES,
              at.disabled,
              vt.disabled,
              c.colorModeForRenderPass(),
              xt.disabled,
              G,
              c.style.map.terrain &&
                c.style.map.terrain.getTerrainData($.coord),
              null,
              i.id,
              N,
              V,
              u.aD.simpleSegment(
                0,
                2 * $.circleOffset,
                $.circleArray.length,
                $.circleArray.length / 2,
              ),
              null,
              c.transform.zoom,
              null,
              null,
              null,
            );
          }
          (N.destroy(), V.destroy());
        }
        const ru = u.aq(new Float32Array(16));
        function Rs(c, e, i, s, a, h) {
          const { horizontalAlign: f, verticalAlign: g } = u.ay(c);
          return new u.P(
            ((-(f - 0.5) * e) / a + s[0]) * h,
            ((-(g - 0.5) * i) / a + s[1]) * h,
          );
        }
        function Os(c, e, i, s, a, h) {
          const f = e.tileAnchorPoint.add(
            new u.P(e.translation[0], e.translation[1]),
          );
          if (e.pitchWithMap) {
            let g = s.mult(h);
            i || (g = g.rotate(-a));
            const y = f.add(g);
            return _e(y.x, y.y, e.pitchedLabelPlaneMatrix, e.getElevation)
              .point;
          }
          if (i) {
            const g = Ve(
                e.tileAnchorPoint.x + 1,
                e.tileAnchorPoint.y,
                e,
              ).point.sub(c),
              y = Math.atan(g.y / g.x) + (g.x < 0 ? Math.PI : 0);
            return c.add(s.rotate(y));
          }
          return c.add(s);
        }
        function ja(c, e, i, s, a, h, f, g, y, v, C, A) {
          const T = c.text.placedSymbolArray,
            M = c.text.dynamicLayoutVertexArray,
            k = c.icon.dynamicLayoutVertexArray,
            V = {};
          M.clear();
          for (let N = 0; N < T.length; N++) {
            const $ = T.get(N),
              G =
                $.hidden ||
                !$.crossTileID ||
                (c.allowVerticalPlacement && !$.placedOrientation)
                  ? null
                  : s[$.crossTileID];
            if (G) {
              const Y = new u.P($.anchorX, $.anchorY),
                Q = {
                  getElevation: A,
                  width: a.width,
                  height: a.height,
                  pitchedLabelPlaneMatrix: h,
                  lineVertexArray: null,
                  pitchWithMap: i,
                  transform: a,
                  projectionCache: null,
                  tileAnchorPoint: Y,
                  translation: v,
                  unwrappedTileID: C,
                },
                ee = i ? mt(Y.x, Y.y, Q) : Ve(Y.x, Y.y, Q),
                re = ce(a.cameraToCenterDistance, ee.signedDistanceFromCamera);
              let ie = (u.aj(c.textSizeData, g, $) * re) / u.as;
              i && (ie *= c.tilePixelRatio / f);
              const {
                  width: he,
                  height: pe,
                  anchor: be,
                  textOffset: Ee,
                  textBoxScale: ye,
                } = G,
                Be = Rs(be, he, pe, Ee, ye, ie),
                Me = a.getPitchedTextCorrection(Y.x + v[0], Y.y + v[1], C),
                Fe = Os(ee.point, Q, e, Be, -a.bearingInRadians, Me),
                Le =
                  c.allowVerticalPlacement &&
                  $.placedOrientation === u.ai.vertical
                    ? Math.PI / 2
                    : 0;
              for (let st = 0; st < $.numGlyphs; st++) u.ak(M, Fe, Le);
              y &&
                $.associatedIconIndex >= 0 &&
                (V[$.associatedIconIndex] = { shiftedAnchor: Fe, angle: Le });
            } else ci($.numGlyphs, M);
          }
          if (y) {
            k.clear();
            const N = c.icon.placedSymbolArray;
            for (let $ = 0; $ < N.length; $++) {
              const G = N.get($);
              if (G.hidden) ci(G.numGlyphs, k);
              else {
                const Y = V[$];
                if (Y)
                  for (let Q = 0; Q < G.numGlyphs; Q++)
                    u.ak(k, Y.shiftedAnchor, Y.angle);
                else ci(G.numGlyphs, k);
              }
            }
            c.icon.dynamicLayoutVertexBuffer.updateData(k);
          }
          c.text.dynamicLayoutVertexBuffer.updateData(M);
        }
        function fc(c, e, i) {
          return i.iconsInText && e
            ? "symbolTextAndIcon"
            : c
              ? "symbolSDF"
              : "symbolIcon";
        }
        function js(c, e, i, s, a, h, f, g, y, v, C, A, T) {
          const M = c.context,
            k = M.gl,
            V = c.transform,
            N = g === "map",
            $ = y === "map",
            G =
              g !== "viewport" && i.layout.get("symbol-placement") !== "point",
            Y = N && !$ && !G,
            Q = !i.layout.get("symbol-sort-key").isConstant();
          let ee = !1;
          const re = c.getDepthModeForSublayer(0, at.ReadOnly),
            ie =
              i._unevaluatedLayout.hasValue("text-variable-anchor") ||
              i._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            he = [],
            pe = V.getCircleRadiusCorrection();
          for (const be of s) {
            const Ee = e.getTile(be),
              ye = Ee.getBucket(i);
            if (!ye) continue;
            const Be = a ? ye.text : ye.icon;
            if (!Be || !Be.segments.get().length || !Be.hasVisibleVertices)
              continue;
            const Me = Be.programConfigurations.get(i.id),
              Fe = a || ye.sdfIcons,
              Le = a ? ye.textSizeData : ye.iconSizeData,
              st = $ || V.pitch !== 0,
              gt = c.useProgram(fc(Fe, a, ye), Me),
              Nt = u.ah(Le, V.zoom),
              Tt =
                c.style.map.terrain && c.style.map.terrain.getTerrainData(be);
            let Vt,
              Ft,
              At,
              Pt,
              vi = [0, 0],
              si = null;
            if (a)
              ((Ft = Ee.glyphAtlasTexture),
                (At = k.LINEAR),
                (Vt = Ee.glyphAtlasTexture.size),
                ye.iconsInText &&
                  ((vi = Ee.imageAtlasTexture.size),
                  (si = Ee.imageAtlasTexture),
                  (Pt =
                    st ||
                    c.options.rotating ||
                    c.options.zooming ||
                    Le.kind === "composite" ||
                    Le.kind === "camera"
                      ? k.LINEAR
                      : k.NEAREST)));
            else {
              const St =
                i.layout.get("icon-size").constantOr(0) !== 1 ||
                ye.iconsNeedLinear;
              ((Ft = Ee.imageAtlasTexture),
                (At =
                  Fe || c.options.rotating || c.options.zooming || St || st
                    ? k.LINEAR
                    : k.NEAREST),
                (Vt = Ee.imageAtlasTexture.size));
            }
            const ai = u.at(Ee, 1, c.transform.zoom),
              Ri = fe(N, c.transform, ai),
              Zr = u.H();
            u.an(Zr, Ri);
            const Ir = ae($, N, c.transform, ai),
              er = u.au(V, Ee, h, f),
              Gr = V.getProjectionData({
                overscaledTileID: be,
                applyGlobeMatrix: !T,
                applyTerrainMatrix: !0,
              }),
              Ko = ie && ye.hasTextData(),
              Yo =
                i.layout.get("icon-text-fit") !== "none" &&
                Ko &&
                ye.hasIconData();
            if (G) {
              const St = c.style.map.terrain
                  ? (ir, Gt) => c.style.map.terrain.getElevation(be, ir, Gt)
                  : null,
                Ut = i.layout.get("text-rotation-alignment") === "map";
              ke(
                ye,
                c,
                a,
                Ri,
                Zr,
                $,
                v,
                Ut,
                be.toUnwrapped(),
                V.width,
                V.height,
                er,
                St,
              );
            }
            const go = (a && ie) || Yo,
              Zi = G || go ? ru : $ ? Ri : c.transform.clipSpaceToPixelsMatrix,
              hr =
                Fe &&
                i.paint
                  .get(a ? "text-halo-width" : "icon-halo-width")
                  .constantOr(1) !== 0;
            let dr;
            dr = Fe
              ? ye.iconsInText
                ? Nr(Le.kind, Nt, Y, $, G, go, c, Zi, Ir, er, Vt, vi, pe)
                : ko(Le.kind, Nt, Y, $, G, go, c, Zi, Ir, er, a, Vt, !0, pe)
              : Da(Le.kind, Nt, Y, $, G, go, c, Zi, Ir, er, a, Vt, pe);
            const tr = {
              program: gt,
              buffers: Be,
              uniformValues: dr,
              projectionData: Gr,
              atlasTexture: Ft,
              atlasTextureIcon: si,
              atlasInterpolation: At,
              atlasInterpolationIcon: Pt,
              isSDF: Fe,
              hasHalo: hr,
            };
            if (Q && ye.canOverlap) {
              ee = !0;
              const St = Be.segments.get();
              for (const Ut of St)
                he.push({
                  segments: new u.aD([Ut]),
                  sortKey: Ut.sortKey,
                  state: tr,
                  terrainData: Tt,
                });
            } else
              he.push({
                segments: Be.segments,
                sortKey: 0,
                state: tr,
                terrainData: Tt,
              });
          }
          ee && he.sort((be, Ee) => be.sortKey - Ee.sortKey);
          for (const be of he) {
            const Ee = be.state;
            if (
              (M.activeTexture.set(k.TEXTURE0),
              Ee.atlasTexture.bind(Ee.atlasInterpolation, k.CLAMP_TO_EDGE),
              Ee.atlasTextureIcon &&
                (M.activeTexture.set(k.TEXTURE1),
                Ee.atlasTextureIcon &&
                  Ee.atlasTextureIcon.bind(
                    Ee.atlasInterpolationIcon,
                    k.CLAMP_TO_EDGE,
                  )),
              Ee.isSDF)
            ) {
              const ye = Ee.uniformValues;
              (Ee.hasHalo &&
                ((ye.u_is_halo = 1),
                nu(
                  Ee.buffers,
                  be.segments,
                  i,
                  c,
                  Ee.program,
                  re,
                  C,
                  A,
                  ye,
                  Ee.projectionData,
                  be.terrainData,
                )),
                (ye.u_is_halo = 0));
            }
            nu(
              Ee.buffers,
              be.segments,
              i,
              c,
              Ee.program,
              re,
              C,
              A,
              Ee.uniformValues,
              Ee.projectionData,
              be.terrainData,
            );
          }
        }
        function nu(c, e, i, s, a, h, f, g, y, v, C) {
          const A = s.context;
          a.draw(
            A,
            A.gl.TRIANGLES,
            h,
            f,
            g,
            xt.backCCW,
            y,
            C,
            v,
            i.id,
            c.layoutVertexBuffer,
            c.indexBuffer,
            e,
            i.paint,
            s.transform.zoom,
            c.programConfigurations.get(i.id),
            c.dynamicLayoutVertexBuffer,
            c.opacityVertexBuffer,
          );
        }
        function ou(c, e, i, s, a) {
          const h = c.context,
            f = h.gl,
            g = vt.disabled,
            y = new Rt([f.ONE, f.ONE], u.b4.transparent, [!0, !0, !0, !0]),
            v = e.getBucket(i);
          if (!v) return;
          const C = s.key;
          let A = i.heatmapFbos.get(C);
          (A || ((A = Vs(h, e.tileSize, e.tileSize)), i.heatmapFbos.set(C, A)),
            h.bindFramebuffer.set(A.framebuffer),
            h.viewport.set([0, 0, e.tileSize, e.tileSize]),
            h.clear({ color: u.b4.transparent }));
          const T = v.programConfigurations.get(i.id),
            M = c.useProgram("heatmap", T, !a),
            k = c.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0,
            }),
            V = c.style.map.terrain.getTerrainData(s);
          M.draw(
            h,
            f.TRIANGLES,
            at.disabled,
            g,
            y,
            xt.disabled,
            Ul(e, c.transform.zoom, i.paint.get("heatmap-intensity"), 1),
            V,
            k,
            i.id,
            v.layoutVertexBuffer,
            v.indexBuffer,
            v.segments,
            i.paint,
            c.transform.zoom,
            T,
          );
        }
        function Ns(c, e, i, s, a) {
          const h = c.context,
            f = h.gl,
            g = c.transform;
          h.setColorMode(c.colorModeForRenderPass());
          const y = Na(h, e),
            v = i.key,
            C = e.heatmapFbos.get(v);
          if (!C) return;
          (h.activeTexture.set(f.TEXTURE0),
            f.bindTexture(f.TEXTURE_2D, C.colorAttachment.get()),
            h.activeTexture.set(f.TEXTURE1),
            y.bind(f.LINEAR, f.CLAMP_TO_EDGE));
          const A = g.getProjectionData({
            overscaledTileID: i,
            applyTerrainMatrix: a,
            applyGlobeMatrix: !s,
          });
          (c
            .useProgram("heatmapTexture")
            .draw(
              h,
              f.TRIANGLES,
              at.disabled,
              vt.disabled,
              c.colorModeForRenderPass(),
              xt.disabled,
              Aa(c, e, 0, 1),
              null,
              A,
              e.id,
              c.rasterBoundsBuffer,
              c.quadTriangleIndexBuffer,
              c.rasterBoundsSegments,
              e.paint,
              g.zoom,
            ),
            C.destroy(),
            e.heatmapFbos.delete(v));
        }
        function Vs(c, e, i) {
          var s, a;
          const h = c.gl,
            f = h.createTexture();
          (h.bindTexture(h.TEXTURE_2D, f),
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE),
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE),
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR),
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR));
          const g =
              (s = c.HALF_FLOAT) !== null && s !== void 0 ? s : h.UNSIGNED_BYTE,
            y = (a = c.RGBA16F) !== null && a !== void 0 ? a : h.RGBA;
          h.texImage2D(h.TEXTURE_2D, 0, y, e, i, 0, h.RGBA, g, null);
          const v = c.createFramebuffer(e, i, !1, !1);
          return (v.colorAttachment.set(f), v);
        }
        function Na(c, e) {
          return (
            e.colorRampTexture ||
              (e.colorRampTexture = new Bt(c, e.colorRamp, c.gl.RGBA)),
            e.colorRampTexture
          );
        }
        function Va(c, e, i, s, a) {
          if (!i || !s || !s.imageAtlas) return;
          const h = s.imageAtlas.patternPositions;
          let f = h[i.to.toString()],
            g = h[i.from.toString()];
          if ((!f && g && (f = g), !g && f && (g = f), !f || !g)) {
            const y = a.getPaintProperty(e);
            ((f = h[y]), (g = h[y]));
          }
          f && g && c.setConstantPatternPositions(f, g);
        }
        function Ro(c, e, i, s, a, h, f, g) {
          const y = c.context.gl,
            v = "fill-pattern",
            C = i.paint.get(v),
            A = C && C.constantOr(1),
            T = i.getCrossfadeParameters();
          let M, k, V, N, $;
          const G = c.transform,
            Y = i.paint.get("fill-translate"),
            Q = i.paint.get("fill-translate-anchor");
          f
            ? ((k =
                A && !i.getPaintProperty("fill-outline-color")
                  ? "fillOutlinePattern"
                  : "fillOutline"),
              (M = y.LINES))
            : ((k = A ? "fillPattern" : "fill"), (M = y.TRIANGLES));
          const ee = C.constantOr(null);
          for (const re of s) {
            const ie = e.getTile(re);
            if (A && !ie.patternsLoaded()) continue;
            const he = ie.getBucket(i);
            if (!he) continue;
            const pe = he.programConfigurations.get(i.id),
              be = c.useProgram(k, pe),
              Ee =
                c.style.map.terrain && c.style.map.terrain.getTerrainData(re);
            (A &&
              (c.context.activeTexture.set(y.TEXTURE0),
              ie.imageAtlasTexture.bind(y.LINEAR, y.CLAMP_TO_EDGE),
              pe.updatePaintBuffers(T)),
              Va(pe, v, ee, ie, i));
            const ye = G.getProjectionData({
                overscaledTileID: re,
                applyGlobeMatrix: !g,
                applyTerrainMatrix: !0,
              }),
              Be = u.au(G, ie, Y, Q);
            if (f) {
              ((N = he.indexBuffer2), ($ = he.segments2));
              const Fe = [y.drawingBufferWidth, y.drawingBufferHeight];
              V =
                k === "fillOutlinePattern" && A
                  ? Cs(c, T, ie, Fe, Be)
                  : nc(Fe, Be);
            } else
              ((N = he.indexBuffer),
                ($ = he.segments),
                (V = A ? Qn(c, T, ie, Be) : { u_fill_translate: Be }));
            let Me;
            if (c.renderPass === "translucent" && g) {
              const [Fe] = c.getStencilConfigForOverlapAndUpdateStencilID(s);
              Me = Fe[re.overscaledZ];
            } else Me = c.stencilModeForClipping(re);
            be.draw(
              c.context,
              M,
              a,
              Me,
              h,
              xt.backCCW,
              V,
              Ee,
              ye,
              i.id,
              he.layoutVertexBuffer,
              N,
              $,
              i.paint,
              c.transform.zoom,
              pe,
            );
          }
        }
        function Oo(c, e, i, s, a, h, f, g) {
          const y = c.context,
            v = y.gl,
            C = "fill-extrusion-pattern",
            A = i.paint.get(C),
            T = A.constantOr(1),
            M = i.getCrossfadeParameters(),
            k = i.paint.get("fill-extrusion-opacity"),
            V = A.constantOr(null),
            N = c.transform;
          for (const $ of s) {
            const G = e.getTile($),
              Y = G.getBucket(i);
            if (!Y) continue;
            const Q =
                c.style.map.terrain && c.style.map.terrain.getTerrainData($),
              ee = Y.programConfigurations.get(i.id),
              re = c.useProgram(
                T ? "fillExtrusionPattern" : "fillExtrusion",
                ee,
              );
            T &&
              (c.context.activeTexture.set(v.TEXTURE0),
              G.imageAtlasTexture.bind(v.LINEAR, v.CLAMP_TO_EDGE),
              ee.updatePaintBuffers(M));
            const ie = N.getProjectionData({
              overscaledTileID: $,
              applyGlobeMatrix: !g,
              applyTerrainMatrix: !0,
            });
            Va(ee, C, V, G, i);
            const he = u.au(
                N,
                G,
                i.paint.get("fill-extrusion-translate"),
                i.paint.get("fill-extrusion-translate-anchor"),
              ),
              pe = i.paint.get("fill-extrusion-vertical-gradient"),
              be = T ? Bo(c, pe, k, he, $, M, G) : ws(c, pe, k, he);
            re.draw(
              y,
              y.gl.TRIANGLES,
              a,
              h,
              f,
              xt.backCCW,
              be,
              Q,
              ie,
              i.id,
              Y.layoutVertexBuffer,
              Y.indexBuffer,
              Y.segments,
              i.paint,
              c.transform.zoom,
              ee,
              c.style.map.terrain && Y.centroidVertexBuffer,
            );
          }
        }
        function Ua(c, e, i, s, a, h, f, g, y) {
          var v;
          const C = c.style.projection,
            A = c.context,
            T = c.transform,
            M = A.gl,
            k = c.useProgram("hillshade"),
            V = !c.options.moving;
          for (const N of s) {
            const $ = e.getTile(N),
              G = $.fbo;
            if (!G) continue;
            const Y = C.getMeshFromTileID(A, N.canonical, g, !0, "raster"),
              Q =
                (v = c.style.map.terrain) === null || v === void 0
                  ? void 0
                  : v.getTerrainData(N);
            (A.activeTexture.set(M.TEXTURE0),
              M.bindTexture(M.TEXTURE_2D, G.colorAttachment.get()));
            const ee = T.getProjectionData({
              overscaledTileID: N,
              aligned: V,
              applyGlobeMatrix: !y,
              applyTerrainMatrix: !0,
            });
            k.draw(
              A,
              M.TRIANGLES,
              h,
              a[N.overscaledZ],
              f,
              xt.backCCW,
              Ta(c, $, i),
              Q,
              ee,
              i.id,
              Y.vertexBuffer,
              Y.indexBuffer,
              Y.segments,
            );
          }
        }
        const Us = [
          new u.P(0, 0),
          new u.P(u.X, 0),
          new u.P(u.X, u.X),
          new u.P(0, u.X),
        ];
        function Ot(c, e, i, s, a, h, f, g, y = !1, v = !1) {
          const C = s[s.length - 1].overscaledZ,
            A = c.context,
            T = A.gl,
            M = c.useProgram("raster"),
            k = c.transform,
            V = c.style.projection,
            N = c.colorModeForRenderPass(),
            $ = !c.options.moving;
          for (const G of s) {
            const Y = c.getDepthModeForSublayer(
                G.overscaledZ - C,
                i.paint.get("raster-opacity") === 1
                  ? at.ReadWrite
                  : at.ReadOnly,
                T.LESS,
              ),
              Q = e.getTile(G);
            Q.registerFadeDuration(i.paint.get("raster-fade-duration"));
            const ee = e.findLoadedParent(G, 0),
              re = e.findLoadedSibling(G),
              ie = Ln(
                Q,
                ee || re || null,
                e,
                i,
                c.transform,
                c.style.map.terrain,
              );
            let he, pe;
            const be =
              i.paint.get("raster-resampling") === "nearest"
                ? T.NEAREST
                : T.LINEAR;
            (A.activeTexture.set(T.TEXTURE0),
              Q.texture.bind(be, T.CLAMP_TO_EDGE, T.LINEAR_MIPMAP_NEAREST),
              A.activeTexture.set(T.TEXTURE1),
              ee
                ? (ee.texture.bind(
                    be,
                    T.CLAMP_TO_EDGE,
                    T.LINEAR_MIPMAP_NEAREST,
                  ),
                  (he = Math.pow(
                    2,
                    ee.tileID.overscaledZ - Q.tileID.overscaledZ,
                  )),
                  (pe = [
                    (Q.tileID.canonical.x * he) % 1,
                    (Q.tileID.canonical.y * he) % 1,
                  ]))
                : Q.texture.bind(be, T.CLAMP_TO_EDGE, T.LINEAR_MIPMAP_NEAREST),
              Q.texture.useMipmap &&
                A.extTextureFilterAnisotropic &&
                c.transform.pitch > 20 &&
                T.texParameterf(
                  T.TEXTURE_2D,
                  A.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
                  A.extTextureFilterAnisotropicMax,
                ));
            const Ee =
                c.style.map.terrain && c.style.map.terrain.getTerrainData(G),
              ye = k.getProjectionData({
                overscaledTileID: G,
                aligned: $,
                applyGlobeMatrix: !v,
                applyTerrainMatrix: !0,
              }),
              Be = Hl(pe || [0, 0], he || 1, ie, i, g),
              Me = V.getMeshFromTileID(A, G.canonical, h, f, "raster");
            M.draw(
              A,
              T.TRIANGLES,
              Y,
              a ? a[G.overscaledZ] : vt.disabled,
              N,
              y ? xt.frontCCW : xt.backCCW,
              Be,
              Ee,
              ye,
              i.id,
              Me.vertexBuffer,
              Me.indexBuffer,
              Me.segments,
            );
          }
        }
        function Ln(c, e, i, s, a, h) {
          const f = s.paint.get("raster-fade-duration");
          if (!h && f > 0) {
            const g = Qe.now(),
              y = (g - c.timeAdded) / f,
              v = e ? (g - e.timeAdded) / f : -1,
              C = i.getSource(),
              A = Qr(a, { tileSize: C.tileSize, roundZoom: C.roundZoom }),
              T =
                !e ||
                Math.abs(e.tileID.overscaledZ - A) >
                  Math.abs(c.tileID.overscaledZ - A),
              M =
                T && c.refreshedUponExpiration ? 1 : u.ab(T ? y : 1 - v, 0, 1);
            return (
              c.refreshedUponExpiration &&
                y >= 1 &&
                (c.refreshedUponExpiration = !1),
              e ? { opacity: 1, mix: 1 - M } : { opacity: M, mix: 0 }
            );
          }
          return { opacity: 1, mix: 0 };
        }
        const cr = new u.b4(1, 0, 0, 1),
          $a = new u.b4(0, 1, 0, 1),
          Za = new u.b4(0, 0, 1, 1),
          su = new u.b4(1, 0, 1, 1),
          oo = new u.b4(0, 1, 1, 1);
        function so(c, e, i, s) {
          jo(c, 0, e + i / 2, c.transform.width, i, s);
        }
        function $s(c, e, i, s) {
          jo(c, e - i / 2, 0, i, c.transform.height, s);
        }
        function jo(c, e, i, s, a, h) {
          const f = c.context,
            g = f.gl;
          (g.enable(g.SCISSOR_TEST),
            g.scissor(
              e * c.pixelRatio,
              i * c.pixelRatio,
              s * c.pixelRatio,
              a * c.pixelRatio,
            ),
            f.clear({ color: h }),
            g.disable(g.SCISSOR_TEST));
        }
        function au(c, e, i) {
          const s = c.context,
            a = s.gl,
            h = c.useProgram("debug"),
            f = at.disabled,
            g = vt.disabled,
            y = c.colorModeForRenderPass(),
            v = "$debug",
            C = c.style.map.terrain && c.style.map.terrain.getTerrainData(i);
          s.activeTexture.set(a.TEXTURE0);
          const A = e.getTileByID(i.key).latestRawTileData,
            T = Math.floor(((A && A.byteLength) || 0) / 1024),
            M = e.getTile(i).tileSize,
            k =
              (512 / Math.min(M, 512)) *
              (i.overscaledZ / c.transform.zoom) *
              0.5;
          let V = i.canonical.toString();
          (i.overscaledZ !== i.canonical.z && (V += ` => ${i.overscaledZ}`),
            (function ($, G) {
              $.initDebugOverlayCanvas();
              const Y = $.debugOverlayCanvas,
                Q = $.context.gl,
                ee = $.debugOverlayCanvas.getContext("2d");
              (ee.clearRect(0, 0, Y.width, Y.height),
                (ee.shadowColor = "white"),
                (ee.shadowBlur = 2),
                (ee.lineWidth = 1.5),
                (ee.strokeStyle = "white"),
                (ee.textBaseline = "top"),
                (ee.font = "bold 36px Open Sans, sans-serif"),
                ee.fillText(G, 5, 5),
                ee.strokeText(G, 5, 5),
                $.debugOverlayTexture.update(Y),
                $.debugOverlayTexture.bind(Q.LINEAR, Q.CLAMP_TO_EDGE));
            })(c, `${V} ${T}kB`));
          const N = c.transform.getProjectionData({
            overscaledTileID: i,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0,
          });
          (h.draw(
            s,
            a.TRIANGLES,
            f,
            g,
            Rt.alphaBlended,
            xt.disabled,
            Ea(u.b4.transparent, k),
            null,
            N,
            v,
            c.debugBuffer,
            c.quadTriangleIndexBuffer,
            c.debugSegments,
          ),
            h.draw(
              s,
              a.LINE_STRIP,
              f,
              g,
              y,
              xt.disabled,
              Ea(u.b4.red),
              C,
              N,
              v,
              c.debugBuffer,
              c.tileBorderIndexBuffer,
              c.debugSegments,
            ));
        }
        function Ga(c, e, i, s) {
          const { isRenderingGlobe: a } = s,
            h = c.context,
            f = h.gl,
            g = c.transform,
            y = c.colorModeForRenderPass(),
            v = c.getDepthModeFor3D(),
            C = c.useProgram("terrain");
          (h.bindFramebuffer.set(null),
            h.viewport.set([0, 0, c.width, c.height]));
          for (const A of i) {
            const T = e.getTerrainMesh(A.tileID),
              M = c.renderToTexture.getTexture(A),
              k = e.getTerrainData(A.tileID);
            (h.activeTexture.set(f.TEXTURE0),
              f.bindTexture(f.TEXTURE_2D, M.texture));
            const V = e.getMeshFrameDelta(g.zoom),
              N = g.calculateFogMatrix(A.tileID.toUnwrapped()),
              $ = bs(V, N, c.style.sky, g.pitch, a),
              G = g.getProjectionData({
                overscaledTileID: A.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0,
              });
            C.draw(
              h,
              f.TRIANGLES,
              v,
              vt.disabled,
              y,
              xt.backCCW,
              $,
              k,
              G,
              "terrain",
              T.vertexBuffer,
              T.indexBuffer,
              T.segments,
            );
          }
        }
        function qa(c, e) {
          if (!e.mesh) {
            const i = new u.aC();
            (i.emplaceBack(-1, -1),
              i.emplaceBack(1, -1),
              i.emplaceBack(1, 1),
              i.emplaceBack(-1, 1));
            const s = new u.aE();
            (s.emplaceBack(0, 1, 2),
              s.emplaceBack(0, 2, 3),
              (e.mesh = new Fr(
                c.createVertexBuffer(i, ct.members),
                c.createIndexBuffer(s),
                u.aD.simpleSegment(0, 0, i.length, s.length),
              )));
          }
          return e.mesh;
        }
        class lu {
          constructor(e, i) {
            ((this.context = new zs(e)),
              (this.transform = i),
              (this._tileTextures = {}),
              (this.terrainFacilitator = {
                dirty: !0,
                matrix: u.aq(new Float64Array(16)),
                renderTime: 0,
              }),
              this.setup(),
              (this.numSublayers = B.maxUnderzooming + B.maxOverzooming + 1),
              (this.depthEpsilon = 1 / Math.pow(2, 16)),
              (this.crossTileSymbolIndex = new Fn()));
          }
          resize(e, i, s) {
            if (
              ((this.width = Math.floor(e * s)),
              (this.height = Math.floor(i * s)),
              (this.pixelRatio = s),
              this.context.viewport.set([0, 0, this.width, this.height]),
              this.style)
            )
              for (const a of this.style._order) this.style._layers[a].resize();
          }
          setup() {
            const e = this.context,
              i = new u.aC();
            (i.emplaceBack(0, 0),
              i.emplaceBack(u.X, 0),
              i.emplaceBack(0, u.X),
              i.emplaceBack(u.X, u.X),
              (this.tileExtentBuffer = e.createVertexBuffer(i, ct.members)),
              (this.tileExtentSegments = u.aD.simpleSegment(0, 0, 4, 2)));
            const s = new u.aC();
            (s.emplaceBack(0, 0),
              s.emplaceBack(u.X, 0),
              s.emplaceBack(0, u.X),
              s.emplaceBack(u.X, u.X),
              (this.debugBuffer = e.createVertexBuffer(s, ct.members)),
              (this.debugSegments = u.aD.simpleSegment(0, 0, 4, 5)));
            const a = new u.bT();
            (a.emplaceBack(0, 0, 0, 0),
              a.emplaceBack(u.X, 0, u.X, 0),
              a.emplaceBack(0, u.X, 0, u.X),
              a.emplaceBack(u.X, u.X, u.X, u.X),
              (this.rasterBoundsBuffer = e.createVertexBuffer(a, vs.members)),
              (this.rasterBoundsSegments = u.aD.simpleSegment(0, 0, 4, 2)));
            const h = new u.aC();
            (h.emplaceBack(0, 0),
              h.emplaceBack(u.X, 0),
              h.emplaceBack(0, u.X),
              h.emplaceBack(u.X, u.X),
              (this.rasterBoundsBufferPosOnly = e.createVertexBuffer(
                h,
                ct.members,
              )),
              (this.rasterBoundsSegmentsPosOnly = u.aD.simpleSegment(
                0,
                0,
                4,
                5,
              )));
            const f = new u.aC();
            (f.emplaceBack(0, 0),
              f.emplaceBack(1, 0),
              f.emplaceBack(0, 1),
              f.emplaceBack(1, 1),
              (this.viewportBuffer = e.createVertexBuffer(f, ct.members)),
              (this.viewportSegments = u.aD.simpleSegment(0, 0, 4, 2)));
            const g = new u.bU();
            (g.emplaceBack(0),
              g.emplaceBack(1),
              g.emplaceBack(3),
              g.emplaceBack(2),
              g.emplaceBack(0),
              (this.tileBorderIndexBuffer = e.createIndexBuffer(g)));
            const y = new u.aE();
            (y.emplaceBack(1, 0, 2),
              y.emplaceBack(1, 2, 3),
              (this.quadTriangleIndexBuffer = e.createIndexBuffer(y)));
            const v = this.context.gl;
            ((this.stencilClearMode = new vt(
              { func: v.ALWAYS, mask: 0 },
              0,
              255,
              v.ZERO,
              v.ZERO,
              v.ZERO,
            )),
              (this.tileExtentMesh = new Fr(
                this.tileExtentBuffer,
                this.quadTriangleIndexBuffer,
                this.tileExtentSegments,
              )));
          }
          clearStencil() {
            const e = this.context,
              i = e.gl;
            ((this.nextStencilID = 1), (this.currentStencilSource = void 0));
            const s = u.H();
            (u.bL(s, 0, this.width, this.height, 0, 0, 1),
              u.K(s, s, [i.drawingBufferWidth, i.drawingBufferHeight, 0]));
            const a = {
              mainMatrix: s,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: s,
            };
            this.useProgram("clippingMask", null, !0).draw(
              e,
              i.TRIANGLES,
              at.disabled,
              this.stencilClearMode,
              Rt.disabled,
              xt.disabled,
              null,
              null,
              a,
              "$clipping",
              this.viewportBuffer,
              this.quadTriangleIndexBuffer,
              this.viewportSegments,
            );
          }
          _renderTileClippingMasks(e, i, s) {
            if (
              this.currentStencilSource === e.source ||
              !e.isTileClipped() ||
              !i ||
              !i.length
            )
              return;
            ((this.currentStencilSource = e.source),
              this.nextStencilID + i.length > 256 && this.clearStencil());
            const a = this.context;
            (a.setColorMode(Rt.disabled), a.setDepthMode(at.disabled));
            const h = {};
            for (const f of i) h[f.key] = this.nextStencilID++;
            (this._renderTileMasks(h, i, s, !0),
              this._renderTileMasks(h, i, s, !1),
              (this._tileClippingMaskIDs = h));
          }
          _renderTileMasks(e, i, s, a) {
            const h = this.context,
              f = h.gl,
              g = this.style.projection,
              y = this.transform,
              v = this.useProgram("clippingMask");
            for (const C of i) {
              const A = e[C.key],
                T =
                  this.style.map.terrain &&
                  this.style.map.terrain.getTerrainData(C),
                M = g.getMeshFromTileID(
                  this.context,
                  C.canonical,
                  a,
                  !0,
                  "stencil",
                ),
                k = y.getProjectionData({
                  overscaledTileID: C,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0,
                });
              v.draw(
                h,
                f.TRIANGLES,
                at.disabled,
                new vt(
                  { func: f.ALWAYS, mask: 0 },
                  A,
                  255,
                  f.KEEP,
                  f.KEEP,
                  f.REPLACE,
                ),
                Rt.disabled,
                s ? xt.disabled : xt.backCCW,
                null,
                T,
                k,
                "$clipping",
                M.vertexBuffer,
                M.indexBuffer,
                M.segments,
              );
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              i = e.gl,
              s = this.style.projection,
              a = this.transform,
              h = this.useProgram("depth"),
              f = this.getDepthModeFor3D(),
              g = j(a, { tileSize: a.tileSize });
            for (const y of g) {
              const v =
                  this.style.map.terrain &&
                  this.style.map.terrain.getTerrainData(y),
                C = s.getMeshFromTileID(
                  this.context,
                  y.canonical,
                  !0,
                  !0,
                  "raster",
                ),
                A = a.getProjectionData({
                  overscaledTileID: y,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0,
                });
              h.draw(
                e,
                i.TRIANGLES,
                f,
                vt.disabled,
                Rt.disabled,
                xt.backCCW,
                null,
                v,
                A,
                "$clipping",
                C.vertexBuffer,
                C.indexBuffer,
                C.segments,
              );
            }
          }
          stencilModeFor3D() {
            ((this.currentStencilSource = void 0),
              this.nextStencilID + 1 > 256 && this.clearStencil());
            const e = this.nextStencilID++,
              i = this.context.gl;
            return new vt(
              { func: i.NOTEQUAL, mask: 255 },
              e,
              255,
              i.KEEP,
              i.KEEP,
              i.REPLACE,
            );
          }
          stencilModeForClipping(e) {
            const i = this.context.gl;
            return new vt(
              { func: i.EQUAL, mask: 255 },
              this._tileClippingMaskIDs[e.key],
              0,
              i.KEEP,
              i.KEEP,
              i.REPLACE,
            );
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const i = this.context.gl,
              s = e.sort((f, g) => g.overscaledZ - f.overscaledZ),
              a = s[s.length - 1].overscaledZ,
              h = s[0].overscaledZ - a + 1;
            if (h > 1) {
              ((this.currentStencilSource = void 0),
                this.nextStencilID + h > 256 && this.clearStencil());
              const f = {};
              for (let g = 0; g < h; g++)
                f[g + a] = new vt(
                  { func: i.GEQUAL, mask: 255 },
                  g + this.nextStencilID,
                  255,
                  i.KEEP,
                  i.KEEP,
                  i.REPLACE,
                );
              return ((this.nextStencilID += h), [f, s]);
            }
            return [{ [a]: vt.disabled }, s];
          }
          stencilConfigForOverlapTwoPass(e) {
            const i = this.context.gl,
              s = e.sort((f, g) => g.overscaledZ - f.overscaledZ),
              a = s[s.length - 1].overscaledZ,
              h = s[0].overscaledZ - a + 1;
            if ((this.clearStencil(), h > 1)) {
              const f = {},
                g = {};
              for (let y = 0; y < h; y++)
                ((f[y + a] = new vt(
                  { func: i.GREATER, mask: 255 },
                  h + 1 + y,
                  255,
                  i.KEEP,
                  i.KEEP,
                  i.REPLACE,
                )),
                  (g[y + a] = new vt(
                    { func: i.GREATER, mask: 255 },
                    1 + y,
                    255,
                    i.KEEP,
                    i.KEEP,
                    i.REPLACE,
                  )));
              return ((this.nextStencilID = 2 * h + 1), [f, g, s]);
            }
            return (
              (this.nextStencilID = 3),
              [
                {
                  [a]: new vt(
                    { func: i.GREATER, mask: 255 },
                    2,
                    255,
                    i.KEEP,
                    i.KEEP,
                    i.REPLACE,
                  ),
                },
                {
                  [a]: new vt(
                    { func: i.GREATER, mask: 255 },
                    1,
                    255,
                    i.KEEP,
                    i.KEEP,
                    i.REPLACE,
                  ),
                },
                s,
              ]
            );
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector
              ? new Rt(
                  [e.CONSTANT_COLOR, e.ONE],
                  new u.b4(0.125, 0.125, 0.125, 0),
                  [!0, !0, !0, !0],
                )
              : this.renderPass === "opaque"
                ? Rt.unblended
                : Rt.alphaBlended;
          }
          getDepthModeForSublayer(e, i, s) {
            if (!this.opaquePassEnabledForLayer()) return at.disabled;
            const a =
              1 -
              ((1 + this.currentLayer) * this.numSublayers + e) *
                this.depthEpsilon;
            return new at(s || this.context.gl.LEQUAL, i, [a, a]);
          }
          getDepthModeFor3D() {
            return new at(
              this.context.gl.LEQUAL,
              at.ReadWrite,
              this.depthRangeFor3D,
            );
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e, i) {
            var s, a;
            ((this.style = e),
              (this.options = i),
              (this.lineAtlas = e.lineAtlas),
              (this.imageManager = e.imageManager),
              (this.glyphManager = e.glyphManager),
              (this.symbolFadeChange = e.placement.symbolFadeChange(Qe.now())),
              this.imageManager.beginFrame());
            const h = this.style._order,
              f = this.style.sourceCaches,
              g = {},
              y = {},
              v = {},
              C = {
                isRenderingToTexture: !1,
                isRenderingGlobe:
                  ((s = e.projection) === null || s === void 0
                    ? void 0
                    : s.transitionState) > 0,
              };
            for (const T in f) {
              const M = f[T];
              (M.used && M.prepare(this.context),
                (g[T] = M.getVisibleCoordinates(!1)),
                (y[T] = g[T].slice().reverse()),
                (v[T] = M.getVisibleCoordinates(!0).reverse()));
            }
            this.opaquePassCutoff = 1 / 0;
            for (let T = 0; T < h.length; T++)
              if (this.style._layers[h[T]].is3D()) {
                this.opaquePassCutoff = T;
                break;
              }
            (this.maybeDrawDepthAndCoords(!1),
              this.renderToTexture &&
                (this.renderToTexture.prepareForRender(
                  this.style,
                  this.transform.zoom,
                ),
                (this.opaquePassCutoff = 0)),
              (this.renderPass = "offscreen"));
            for (const T of h) {
              const M = this.style._layers[T];
              if (!M.hasOffscreenPass() || M.isHidden(this.transform.zoom))
                continue;
              const k = y[M.source];
              (M.type === "custom" || k.length) &&
                this.renderLayer(this, f[M.source], M, k, C);
            }
            if (
              ((a = this.style.projection) === null ||
                a === void 0 ||
                a.updateGPUdependent({
                  context: this.context,
                  useProgram: (T) => this.useProgram(T),
                }),
              this.context.viewport.set([0, 0, this.width, this.height]),
              this.context.bindFramebuffer.set(null),
              this.context.clear({
                color: i.showOverdrawInspector ? u.b4.black : u.b4.transparent,
                depth: 1,
              }),
              this.clearStencil(),
              this.style.sky &&
                (function (T, M) {
                  const k = T.context,
                    V = k.gl,
                    N = ((re, ie, he) => {
                      const pe = Math.cos(ie.rollInRadians),
                        be = Math.sin(ie.rollInRadians),
                        Ee = us(ie),
                        ye = ie.getProjectionData({
                          overscaledTileID: null,
                          applyGlobeMatrix: !0,
                          applyTerrainMatrix: !0,
                        }).projectionTransition;
                      return {
                        u_sky_color: re.properties.get("sky-color"),
                        u_horizon_color: re.properties.get("horizon-color"),
                        u_horizon: [
                          (ie.width / 2 - Ee * be) * he,
                          (ie.height / 2 + Ee * pe) * he,
                        ],
                        u_horizon_normal: [-be, pe],
                        u_sky_horizon_blend:
                          ((re.properties.get("sky-horizon-blend") *
                            ie.height) /
                            2) *
                          he,
                        u_sky_blend: ye,
                      };
                    })(M, T.style.map.transform, T.pixelRatio),
                    $ = new at(V.LEQUAL, at.ReadWrite, [0, 1]),
                    G = vt.disabled,
                    Y = T.colorModeForRenderPass(),
                    Q = T.useProgram("sky"),
                    ee = qa(k, M);
                  Q.draw(
                    k,
                    V.TRIANGLES,
                    $,
                    G,
                    Y,
                    xt.disabled,
                    N,
                    null,
                    void 0,
                    "sky",
                    ee.vertexBuffer,
                    ee.indexBuffer,
                    ee.segments,
                  );
                })(this, this.style.sky),
              (this._showOverdrawInspector = i.showOverdrawInspector),
              (this.depthRangeFor3D = [
                0,
                1 -
                  (e._order.length + 2) * this.numSublayers * this.depthEpsilon,
              ]),
              !this.renderToTexture)
            )
              for (
                this.renderPass = "opaque", this.currentLayer = h.length - 1;
                this.currentLayer >= 0;
                this.currentLayer--
              ) {
                const T = this.style._layers[h[this.currentLayer]],
                  M = f[T.source],
                  k = g[T.source];
                (this._renderTileClippingMasks(T, k, !1),
                  this.renderLayer(this, M, T, k, C));
              }
            this.renderPass = "translucent";
            let A = !1;
            for (
              this.currentLayer = 0;
              this.currentLayer < h.length;
              this.currentLayer++
            ) {
              const T = this.style._layers[h[this.currentLayer]],
                M = f[T.source];
              if (
                this.renderToTexture &&
                this.renderToTexture.renderLayer(T, C)
              )
                continue;
              this.opaquePassEnabledForLayer() ||
                A ||
                ((A = !0),
                C.isRenderingGlobe &&
                  !this.style.map.terrain &&
                  this._renderTilesDepthBuffer());
              const k = (T.type === "symbol" ? v : y)[T.source];
              (this._renderTileClippingMasks(T, g[T.source], !1),
                this.renderLayer(this, M, T, k, C));
            }
            if (
              (C.isRenderingGlobe &&
                (function (T, M, k) {
                  const V = T.context,
                    N = V.gl,
                    $ = T.useProgram("atmosphere"),
                    G = new at(N.LEQUAL, at.ReadOnly, [0, 1]),
                    Y = T.transform,
                    Q = (function (ye, Be) {
                      const Me = ye.properties.get("position"),
                        Fe = [-Me.x, -Me.y, -Me.z],
                        Le = u.aq(new Float64Array(16));
                      return (
                        ye.properties.get("anchor") === "map" &&
                          (u.aX(Le, Le, Be.rollInRadians),
                          u.aY(Le, Le, -Be.pitchInRadians),
                          u.aX(Le, Le, Be.bearingInRadians),
                          u.aY(Le, Le, (Be.center.lat * Math.PI) / 180),
                          u.bj(Le, Le, (-Be.center.lng * Math.PI) / 180)),
                        u.bS(Fe, Fe, Le),
                        Fe
                      );
                    })(k, T.transform),
                    ee = Y.getProjectionData({
                      overscaledTileID: null,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !0,
                    }),
                    re =
                      M.properties.get("atmosphere-blend") *
                      ee.projectionTransition;
                  if (re === 0) return;
                  const ie = fs(Y.worldSize, Y.center.lat),
                    he = Y.inverseProjectionMatrix,
                    pe = new Float64Array(4);
                  ((pe[3] = 1),
                    u.al(pe, pe, Y.modelViewProjectionMatrix),
                    (pe[0] /= pe[3]),
                    (pe[1] /= pe[3]),
                    (pe[2] /= pe[3]),
                    (pe[3] = 1),
                    u.al(pe, pe, he),
                    (pe[0] /= pe[3]),
                    (pe[1] /= pe[3]),
                    (pe[2] /= pe[3]),
                    (pe[3] = 1));
                  const be = ((ye, Be, Me, Fe, Le) => ({
                      u_sun_pos: ye,
                      u_atmosphere_blend: Be,
                      u_globe_position: Me,
                      u_globe_radius: Fe,
                      u_inv_proj_matrix: Le,
                    }))(Q, re, [pe[0], pe[1], pe[2]], ie, he),
                    Ee = qa(V, M);
                  $.draw(
                    V,
                    N.TRIANGLES,
                    G,
                    vt.disabled,
                    Rt.alphaBlended,
                    xt.disabled,
                    be,
                    null,
                    null,
                    "atmosphere",
                    Ee.vertexBuffer,
                    Ee.indexBuffer,
                    Ee.segments,
                  );
                })(this, this.style.sky, this.style.light),
              this.options.showTileBoundaries)
            ) {
              const T = (function (M, k) {
                let V = null;
                const N = Object.values(M._layers).flatMap((Q) =>
                    Q.source && !Q.isHidden(k)
                      ? [M.sourceCaches[Q.source]]
                      : [],
                  ),
                  $ = N.filter((Q) => Q.getSource().type === "vector"),
                  G = N.filter((Q) => Q.getSource().type !== "vector"),
                  Y = (Q) => {
                    (!V || V.getSource().maxzoom < Q.getSource().maxzoom) &&
                      (V = Q);
                  };
                return ($.forEach((Q) => Y(Q)), V || G.forEach((Q) => Y(Q)), V);
              })(this.style, this.transform.zoom);
              T &&
                (function (M, k, V) {
                  for (let N = 0; N < V.length; N++) au(M, k, V[N]);
                })(this, T, T.getVisibleCoordinates());
            }
            (this.options.showPadding &&
              (function (T) {
                const M = T.transform.padding;
                (so(T, T.transform.height - (M.top || 0), 3, cr),
                  so(T, M.bottom || 0, 3, $a),
                  $s(T, M.left || 0, 3, Za),
                  $s(T, T.transform.width - (M.right || 0), 3, su));
                const k = T.transform.centerPoint;
                (function (V, N, $, G) {
                  (jo(V, N - 1, $ - 10, 2, 20, G),
                    jo(V, N - 10, $ - 1, 20, 2, G));
                })(T, k.x, T.transform.height - k.y, oo);
              })(this),
              this.context.setDefault());
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain)
              return;
            const i = this.terrainFacilitator.matrix,
              s = this.transform.modelViewProjectionMatrix;
            let a = this.terrainFacilitator.dirty;
            (a || (a = e ? !u.bV(i, s) : !u.bW(i, s)),
              a ||
                (a = this.style.map.terrain.sourceCache.anyTilesAfterTime(
                  this.terrainFacilitator.renderTime,
                )),
              a &&
                (u.bX(i, s),
                (this.terrainFacilitator.renderTime = Date.now()),
                (this.terrainFacilitator.dirty = !1),
                (function (h, f) {
                  const g = h.context,
                    y = g.gl,
                    v = h.transform,
                    C = Rt.unblended,
                    A = new at(y.LEQUAL, at.ReadWrite, [0, 1]),
                    T = f.sourceCache.getRenderableTiles(),
                    M = h.useProgram("terrainDepth");
                  (g.bindFramebuffer.set(f.getFramebuffer("depth").framebuffer),
                    g.viewport.set([
                      0,
                      0,
                      h.width / devicePixelRatio,
                      h.height / devicePixelRatio,
                    ]),
                    g.clear({ color: u.b4.transparent, depth: 1 }));
                  for (const k of T) {
                    const V = f.getTerrainMesh(k.tileID),
                      N = f.getTerrainData(k.tileID),
                      $ = v.getProjectionData({
                        overscaledTileID: k.tileID,
                        applyTerrainMatrix: !1,
                        applyGlobeMatrix: !0,
                      }),
                      G = { u_ele_delta: f.getMeshFrameDelta(v.zoom) };
                    M.draw(
                      g,
                      y.TRIANGLES,
                      A,
                      vt.disabled,
                      C,
                      xt.backCCW,
                      G,
                      N,
                      $,
                      "terrain",
                      V.vertexBuffer,
                      V.indexBuffer,
                      V.segments,
                    );
                  }
                  (g.bindFramebuffer.set(null),
                    g.viewport.set([0, 0, h.width, h.height]));
                })(this, this.style.map.terrain),
                (function (h, f) {
                  const g = h.context,
                    y = g.gl,
                    v = h.transform,
                    C = Rt.unblended,
                    A = new at(y.LEQUAL, at.ReadWrite, [0, 1]),
                    T = f.getCoordsTexture(),
                    M = f.sourceCache.getRenderableTiles(),
                    k = h.useProgram("terrainCoords");
                  (g.bindFramebuffer.set(
                    f.getFramebuffer("coords").framebuffer,
                  ),
                    g.viewport.set([
                      0,
                      0,
                      h.width / devicePixelRatio,
                      h.height / devicePixelRatio,
                    ]),
                    g.clear({ color: u.b4.transparent, depth: 1 }),
                    (f.coordsIndex = []));
                  for (const V of M) {
                    const N = f.getTerrainMesh(V.tileID),
                      $ = f.getTerrainData(V.tileID);
                    (g.activeTexture.set(y.TEXTURE0),
                      y.bindTexture(y.TEXTURE_2D, T.texture));
                    const G = {
                        u_terrain_coords_id: (255 - f.coordsIndex.length) / 255,
                        u_texture: 0,
                        u_ele_delta: f.getMeshFrameDelta(v.zoom),
                      },
                      Y = v.getProjectionData({
                        overscaledTileID: V.tileID,
                        applyTerrainMatrix: !1,
                        applyGlobeMatrix: !0,
                      });
                    (k.draw(
                      g,
                      y.TRIANGLES,
                      A,
                      vt.disabled,
                      C,
                      xt.backCCW,
                      G,
                      $,
                      Y,
                      "terrain",
                      N.vertexBuffer,
                      N.indexBuffer,
                      N.segments,
                    ),
                      f.coordsIndex.push(V.tileID.key));
                  }
                  (g.bindFramebuffer.set(null),
                    g.viewport.set([0, 0, h.width, h.height]));
                })(this, this.style.map.terrain)));
          }
          renderLayer(e, i, s, a, h) {
            s.isHidden(this.transform.zoom) ||
              ((s.type === "background" ||
                s.type === "custom" ||
                (a || []).length) &&
                ((this.id = s.id),
                u.bY(s)
                  ? (function (f, g, y, v, C, A) {
                      if (f.renderPass !== "translucent") return;
                      const { isRenderingToTexture: T } = A,
                        M = vt.disabled,
                        k = f.colorModeForRenderPass();
                      ((y._unevaluatedLayout.hasValue("text-variable-anchor") ||
                        y._unevaluatedLayout.hasValue(
                          "text-variable-anchor-offset",
                        )) &&
                        (function (V, N, $, G, Y, Q, ee, re, ie) {
                          const he = N.transform,
                            pe = N.style.map.terrain,
                            be = Y === "map",
                            Ee = Q === "map";
                          for (const ye of V) {
                            const Be = G.getTile(ye),
                              Me = Be.getBucket($);
                            if (
                              !Me ||
                              !Me.text ||
                              !Me.text.segments.get().length
                            )
                              continue;
                            const Fe = u.ah(Me.textSizeData, he.zoom),
                              Le = u.at(Be, 1, N.transform.zoom),
                              st = fe(be, N.transform, Le),
                              gt =
                                $.layout.get("icon-text-fit") !== "none" &&
                                Me.hasIconData();
                            {
                              const Nt = Math.pow(
                                  2,
                                  he.zoom - Be.tileID.overscaledZ,
                                ),
                                Tt = pe
                                  ? (Vt, Ft) => pe.getElevation(ye, Vt, Ft)
                                  : null;
                              ja(
                                Me,
                                be,
                                Ee,
                                ie,
                                he,
                                st,
                                Nt,
                                Fe,
                                gt,
                                u.au(he, Be, ee, re),
                                ye.toUnwrapped(),
                                Tt,
                              );
                            }
                          }
                        })(
                          v,
                          f,
                          y,
                          g,
                          y.layout.get("text-rotation-alignment"),
                          y.layout.get("text-pitch-alignment"),
                          y.paint.get("text-translate"),
                          y.paint.get("text-translate-anchor"),
                          C,
                        ),
                        y.paint.get("icon-opacity").constantOr(1) !== 0 &&
                          js(
                            f,
                            g,
                            y,
                            v,
                            !1,
                            y.paint.get("icon-translate"),
                            y.paint.get("icon-translate-anchor"),
                            y.layout.get("icon-rotation-alignment"),
                            y.layout.get("icon-pitch-alignment"),
                            y.layout.get("icon-keep-upright"),
                            M,
                            k,
                            T,
                          ),
                        y.paint.get("text-opacity").constantOr(1) !== 0 &&
                          js(
                            f,
                            g,
                            y,
                            v,
                            !0,
                            y.paint.get("text-translate"),
                            y.paint.get("text-translate-anchor"),
                            y.layout.get("text-rotation-alignment"),
                            y.layout.get("text-pitch-alignment"),
                            y.layout.get("text-keep-upright"),
                            M,
                            k,
                            T,
                          ),
                        g.map.showCollisionBoxes &&
                          (Ls(f, g, y, v, !0), Ls(f, g, y, v, !1)));
                    })(e, i, s, a, this.style.placement.variableOffsets, h)
                  : u.bZ(s)
                    ? (function (f, g, y, v, C) {
                        if (f.renderPass !== "translucent") return;
                        const { isRenderingToTexture: A } = C,
                          T = y.paint.get("circle-opacity"),
                          M = y.paint.get("circle-stroke-width"),
                          k = y.paint.get("circle-stroke-opacity"),
                          V = !y.layout.get("circle-sort-key").isConstant();
                        if (
                          T.constantOr(1) === 0 &&
                          (M.constantOr(1) === 0 || k.constantOr(1) === 0)
                        )
                          return;
                        const N = f.context,
                          $ = N.gl,
                          G = f.transform,
                          Y = f.getDepthModeForSublayer(0, at.ReadOnly),
                          Q = vt.disabled,
                          ee = f.colorModeForRenderPass(),
                          re = [],
                          ie = G.getCircleRadiusCorrection();
                        for (let he = 0; he < v.length; he++) {
                          const pe = v[he],
                            be = g.getTile(pe),
                            Ee = be.getBucket(y);
                          if (!Ee) continue;
                          const ye = y.paint.get("circle-translate"),
                            Be = y.paint.get("circle-translate-anchor"),
                            Me = u.au(G, be, ye, Be),
                            Fe = Ee.programConfigurations.get(y.id),
                            Le = f.useProgram("circle", Fe),
                            st = Ee.layoutVertexBuffer,
                            gt = Ee.indexBuffer,
                            Nt =
                              f.style.map.terrain &&
                              f.style.map.terrain.getTerrainData(pe),
                            Tt = {
                              programConfiguration: Fe,
                              program: Le,
                              layoutVertexBuffer: st,
                              indexBuffer: gt,
                              uniformValues: oc(f, be, y, Me, ie),
                              terrainData: Nt,
                              projectionData: G.getProjectionData({
                                overscaledTileID: pe,
                                applyGlobeMatrix: !A,
                                applyTerrainMatrix: !0,
                              }),
                            };
                          if (V) {
                            const Vt = Ee.segments.get();
                            for (const Ft of Vt)
                              re.push({
                                segments: new u.aD([Ft]),
                                sortKey: Ft.sortKey,
                                state: Tt,
                              });
                          } else
                            re.push({
                              segments: Ee.segments,
                              sortKey: 0,
                              state: Tt,
                            });
                        }
                        V && re.sort((he, pe) => he.sortKey - pe.sortKey);
                        for (const he of re) {
                          const {
                            programConfiguration: pe,
                            program: be,
                            layoutVertexBuffer: Ee,
                            indexBuffer: ye,
                            uniformValues: Be,
                            terrainData: Me,
                            projectionData: Fe,
                          } = he.state;
                          be.draw(
                            N,
                            $.TRIANGLES,
                            Y,
                            Q,
                            ee,
                            xt.backCCW,
                            Be,
                            Me,
                            Fe,
                            y.id,
                            Ee,
                            ye,
                            he.segments,
                            y.paint,
                            f.transform.zoom,
                            pe,
                          );
                        }
                      })(e, i, s, a, h)
                    : u.b_(s)
                      ? (function (f, g, y, v, C) {
                          if (y.paint.get("heatmap-opacity") === 0) return;
                          const A = f.context,
                            { isRenderingToTexture: T, isRenderingGlobe: M } =
                              C;
                          if (f.style.map.terrain) {
                            for (const k of v) {
                              const V = g.getTile(k);
                              g.hasRenderableParent(k) ||
                                (f.renderPass === "offscreen"
                                  ? ou(f, V, y, k, M)
                                  : f.renderPass === "translucent" &&
                                    Ns(f, y, k, T, M));
                            }
                            A.viewport.set([0, 0, f.width, f.height]);
                          } else
                            f.renderPass === "offscreen"
                              ? (function (k, V, N, $) {
                                  const G = k.context,
                                    Y = G.gl,
                                    Q = k.transform,
                                    ee = vt.disabled,
                                    re = new Rt(
                                      [Y.ONE, Y.ONE],
                                      u.b4.transparent,
                                      [!0, !0, !0, !0],
                                    );
                                  ((function (ie, he, pe) {
                                    const be = ie.gl;
                                    (ie.activeTexture.set(be.TEXTURE1),
                                      ie.viewport.set([
                                        0,
                                        0,
                                        he.width / 4,
                                        he.height / 4,
                                      ]));
                                    let Ee = pe.heatmapFbos.get(u.bP);
                                    Ee
                                      ? (be.bindTexture(
                                          be.TEXTURE_2D,
                                          Ee.colorAttachment.get(),
                                        ),
                                        ie.bindFramebuffer.set(Ee.framebuffer))
                                      : ((Ee = Vs(
                                          ie,
                                          he.width / 4,
                                          he.height / 4,
                                        )),
                                        pe.heatmapFbos.set(u.bP, Ee));
                                  })(G, k, N),
                                    G.clear({ color: u.b4.transparent }));
                                  for (let ie = 0; ie < $.length; ie++) {
                                    const he = $[ie];
                                    if (V.hasRenderableParent(he)) continue;
                                    const pe = V.getTile(he),
                                      be = pe.getBucket(N);
                                    if (!be) continue;
                                    const Ee = be.programConfigurations.get(
                                        N.id,
                                      ),
                                      ye = k.useProgram("heatmap", Ee),
                                      Be = Q.getProjectionData({
                                        overscaledTileID: he,
                                        applyGlobeMatrix: !0,
                                        applyTerrainMatrix: !1,
                                      }),
                                      Me = Q.getCircleRadiusCorrection();
                                    ye.draw(
                                      G,
                                      Y.TRIANGLES,
                                      at.disabled,
                                      ee,
                                      re,
                                      xt.backCCW,
                                      Ul(
                                        pe,
                                        Q.zoom,
                                        N.paint.get("heatmap-intensity"),
                                        Me,
                                      ),
                                      null,
                                      Be,
                                      N.id,
                                      be.layoutVertexBuffer,
                                      be.indexBuffer,
                                      be.segments,
                                      N.paint,
                                      Q.zoom,
                                      Ee,
                                    );
                                  }
                                  G.viewport.set([0, 0, k.width, k.height]);
                                })(f, g, y, v)
                              : f.renderPass === "translucent" &&
                                (function (k, V) {
                                  const N = k.context,
                                    $ = N.gl;
                                  N.setColorMode(k.colorModeForRenderPass());
                                  const G = V.heatmapFbos.get(u.bP);
                                  G &&
                                    (N.activeTexture.set($.TEXTURE0),
                                    $.bindTexture(
                                      $.TEXTURE_2D,
                                      G.colorAttachment.get(),
                                    ),
                                    N.activeTexture.set($.TEXTURE1),
                                    Na(N, V).bind($.LINEAR, $.CLAMP_TO_EDGE),
                                    k
                                      .useProgram("heatmapTexture")
                                      .draw(
                                        N,
                                        $.TRIANGLES,
                                        at.disabled,
                                        vt.disabled,
                                        k.colorModeForRenderPass(),
                                        xt.disabled,
                                        Aa(k, V, 0, 1),
                                        null,
                                        null,
                                        V.id,
                                        k.viewportBuffer,
                                        k.quadTriangleIndexBuffer,
                                        k.viewportSegments,
                                        V.paint,
                                        k.transform.zoom,
                                      ));
                                })(f, y);
                        })(e, i, s, a, h)
                      : u.b$(s)
                        ? (function (f, g, y, v, C) {
                            if (f.renderPass !== "translucent") return;
                            const { isRenderingToTexture: A } = C,
                              T = y.paint.get("line-opacity"),
                              M = y.paint.get("line-width");
                            if (T.constantOr(1) === 0 || M.constantOr(1) === 0)
                              return;
                            const k = f.getDepthModeForSublayer(0, at.ReadOnly),
                              V = f.colorModeForRenderPass(),
                              N = y.paint.get("line-dasharray"),
                              $ = y.paint.get("line-pattern"),
                              G = $.constantOr(1),
                              Y = y.paint.get("line-gradient"),
                              Q = y.getCrossfadeParameters(),
                              ee = G
                                ? "linePattern"
                                : N
                                  ? "lineSDF"
                                  : Y
                                    ? "lineGradient"
                                    : "line",
                              re = f.context,
                              ie = re.gl,
                              he = f.transform;
                            let pe = !0;
                            for (const be of v) {
                              const Ee = g.getTile(be);
                              if (G && !Ee.patternsLoaded()) continue;
                              const ye = Ee.getBucket(y);
                              if (!ye) continue;
                              const Be = ye.programConfigurations.get(y.id),
                                Me = f.context.program.get(),
                                Fe = f.useProgram(ee, Be),
                                Le = pe || Fe.program !== Me,
                                st =
                                  f.style.map.terrain &&
                                  f.style.map.terrain.getTerrainData(be),
                                gt = $.constantOr(null);
                              if (gt && Ee.imageAtlas) {
                                const At = Ee.imageAtlas,
                                  Pt = At.patternPositions[gt.to.toString()],
                                  vi = At.patternPositions[gt.from.toString()];
                                Pt &&
                                  vi &&
                                  Be.setConstantPatternPositions(Pt, vi);
                              }
                              const Nt = he.getProjectionData({
                                  overscaledTileID: be,
                                  applyGlobeMatrix: !A,
                                  applyTerrainMatrix: !0,
                                }),
                                Tt = he.getPixelScale(),
                                Vt = G
                                  ? In(f, Ee, y, Tt, Q)
                                  : N
                                    ? ql(f, Ee, y, Tt, N, Q)
                                    : Y
                                      ? Gl(
                                          f,
                                          Ee,
                                          y,
                                          Tt,
                                          ye.lineClipsArray.length,
                                        )
                                      : Es(f, Ee, y, Tt);
                              if (G)
                                (re.activeTexture.set(ie.TEXTURE0),
                                  Ee.imageAtlasTexture.bind(
                                    ie.LINEAR,
                                    ie.CLAMP_TO_EDGE,
                                  ),
                                  Be.updatePaintBuffers(Q));
                              else if (N && (Le || f.lineAtlas.dirty))
                                (re.activeTexture.set(ie.TEXTURE0),
                                  f.lineAtlas.bind(re));
                              else if (Y) {
                                const At = ye.gradients[y.id];
                                let Pt = At.texture;
                                if (y.gradientVersion !== At.version) {
                                  let vi = 256;
                                  if (y.stepInterpolant) {
                                    const si = g.getSource().maxzoom,
                                      ai =
                                        be.canonical.z === si
                                          ? Math.ceil(
                                              1 <<
                                                (f.transform.maxZoom -
                                                  be.canonical.z),
                                            )
                                          : 1;
                                    vi = u.ab(
                                      u.bQ(
                                        (ye.maxLineLength / u.X) * 1024 * ai,
                                      ),
                                      256,
                                      re.maxTextureSize,
                                    );
                                  }
                                  ((At.gradient = u.bR({
                                    expression: y.gradientExpression(),
                                    evaluationKey: "lineProgress",
                                    resolution: vi,
                                    image: At.gradient || void 0,
                                    clips: ye.lineClipsArray,
                                  })),
                                    At.texture
                                      ? At.texture.update(At.gradient)
                                      : (At.texture = new Bt(
                                          re,
                                          At.gradient,
                                          ie.RGBA,
                                        )),
                                    (At.version = y.gradientVersion),
                                    (Pt = At.texture));
                                }
                                (re.activeTexture.set(ie.TEXTURE0),
                                  Pt.bind(
                                    y.stepInterpolant ? ie.NEAREST : ie.LINEAR,
                                    ie.CLAMP_TO_EDGE,
                                  ));
                              }
                              let Ft;
                              if (A) {
                                const [At] =
                                  f.getStencilConfigForOverlapAndUpdateStencilID(
                                    v,
                                  );
                                Ft = At[be.overscaledZ];
                              } else Ft = f.stencilModeForClipping(be);
                              (Fe.draw(
                                re,
                                ie.TRIANGLES,
                                k,
                                Ft,
                                V,
                                xt.disabled,
                                Vt,
                                st,
                                Nt,
                                y.id,
                                ye.layoutVertexBuffer,
                                ye.indexBuffer,
                                ye.segments,
                                y.paint,
                                f.transform.zoom,
                                Be,
                                ye.layoutVertexBuffer2,
                              ),
                                (pe = !1));
                            }
                          })(e, i, s, a, h)
                        : u.c0(s)
                          ? (function (f, g, y, v, C) {
                              const A = y.paint.get("fill-color"),
                                T = y.paint.get("fill-opacity");
                              if (T.constantOr(1) === 0) return;
                              const { isRenderingToTexture: M } = C,
                                k = f.colorModeForRenderPass(),
                                V = y.paint.get("fill-pattern"),
                                N =
                                  f.opaquePassEnabledForLayer() &&
                                  !V.constantOr(1) &&
                                  A.constantOr(u.b4.transparent).a === 1 &&
                                  T.constantOr(0) === 1
                                    ? "opaque"
                                    : "translucent";
                              if (f.renderPass === N) {
                                const $ = f.getDepthModeForSublayer(
                                  1,
                                  f.renderPass === "opaque"
                                    ? at.ReadWrite
                                    : at.ReadOnly,
                                );
                                Ro(f, g, y, v, $, k, !1, M);
                              }
                              if (
                                f.renderPass === "translucent" &&
                                y.paint.get("fill-antialias")
                              ) {
                                const $ = f.getDepthModeForSublayer(
                                  y.getPaintProperty("fill-outline-color")
                                    ? 2
                                    : 0,
                                  at.ReadOnly,
                                );
                                Ro(f, g, y, v, $, k, !0, M);
                              }
                            })(e, i, s, a, h)
                          : u.c1(s)
                            ? (function (f, g, y, v, C) {
                                const A = y.paint.get("fill-extrusion-opacity");
                                if (A === 0) return;
                                const { isRenderingToTexture: T } = C;
                                if (f.renderPass === "translucent") {
                                  const M = new at(
                                    f.context.gl.LEQUAL,
                                    at.ReadWrite,
                                    f.depthRangeFor3D,
                                  );
                                  if (
                                    A !== 1 ||
                                    y.paint
                                      .get("fill-extrusion-pattern")
                                      .constantOr(1)
                                  )
                                    (Oo(
                                      f,
                                      g,
                                      y,
                                      v,
                                      M,
                                      vt.disabled,
                                      Rt.disabled,
                                      T,
                                    ),
                                      Oo(
                                        f,
                                        g,
                                        y,
                                        v,
                                        M,
                                        f.stencilModeFor3D(),
                                        f.colorModeForRenderPass(),
                                        T,
                                      ));
                                  else {
                                    const k = f.colorModeForRenderPass();
                                    Oo(f, g, y, v, M, vt.disabled, k, T);
                                  }
                                }
                              })(e, i, s, a, h)
                            : u.c2(s)
                              ? (function (f, g, y, v, C) {
                                  if (
                                    f.renderPass !== "offscreen" &&
                                    f.renderPass !== "translucent"
                                  )
                                    return;
                                  const { isRenderingToTexture: A } = C,
                                    T = f.context,
                                    M = f.style.projection.useSubdivision,
                                    k = f.getDepthModeForSublayer(
                                      0,
                                      at.ReadOnly,
                                    ),
                                    V = f.colorModeForRenderPass();
                                  if (f.renderPass === "offscreen")
                                    ((function (N, $, G, Y, Q, ee, re) {
                                      const ie = N.context,
                                        he = ie.gl;
                                      for (const pe of G) {
                                        const be = $.getTile(pe),
                                          Ee = be.dem;
                                        if (
                                          !Ee ||
                                          !Ee.data ||
                                          !be.needsHillshadePrepare
                                        )
                                          continue;
                                        const ye = Ee.dim,
                                          Be = Ee.stride,
                                          Me = Ee.getPixels();
                                        if (
                                          (ie.activeTexture.set(he.TEXTURE1),
                                          ie.pixelStoreUnpackPremultiplyAlpha.set(
                                            !1,
                                          ),
                                          (be.demTexture =
                                            be.demTexture ||
                                            N.getTileTexture(Be)),
                                          be.demTexture)
                                        ) {
                                          const Le = be.demTexture;
                                          (Le.update(Me, { premultiply: !1 }),
                                            Le.bind(
                                              he.NEAREST,
                                              he.CLAMP_TO_EDGE,
                                            ));
                                        } else
                                          ((be.demTexture = new Bt(
                                            ie,
                                            Me,
                                            he.RGBA,
                                            { premultiply: !1 },
                                          )),
                                            be.demTexture.bind(
                                              he.NEAREST,
                                              he.CLAMP_TO_EDGE,
                                            ));
                                        ie.activeTexture.set(he.TEXTURE0);
                                        let Fe = be.fbo;
                                        if (!Fe) {
                                          const Le = new Bt(
                                            ie,
                                            {
                                              width: ye,
                                              height: ye,
                                              data: null,
                                            },
                                            he.RGBA,
                                          );
                                          (Le.bind(he.LINEAR, he.CLAMP_TO_EDGE),
                                            (Fe = be.fbo =
                                              ie.createFramebuffer(
                                                ye,
                                                ye,
                                                !0,
                                                !1,
                                              )),
                                            Fe.colorAttachment.set(Le.texture));
                                        }
                                        (ie.bindFramebuffer.set(Fe.framebuffer),
                                          ie.viewport.set([0, 0, ye, ye]),
                                          N.useProgram("hillshadePrepare").draw(
                                            ie,
                                            he.TRIANGLES,
                                            Q,
                                            ee,
                                            re,
                                            xt.disabled,
                                            $l(be.tileID, Ee),
                                            null,
                                            null,
                                            Y.id,
                                            N.rasterBoundsBuffer,
                                            N.quadTriangleIndexBuffer,
                                            N.rasterBoundsSegments,
                                          ),
                                          (be.needsHillshadePrepare = !1));
                                      }
                                    })(f, g, v, y, k, vt.disabled, V),
                                      T.viewport.set([
                                        0,
                                        0,
                                        f.width,
                                        f.height,
                                      ]));
                                  else if (f.renderPass === "translucent")
                                    if (M) {
                                      const [N, $, G] =
                                        f.stencilConfigForOverlapTwoPass(v);
                                      (Ua(f, g, y, G, N, k, V, !1, A),
                                        Ua(f, g, y, G, $, k, V, !0, A));
                                    } else {
                                      const [N, $] =
                                        f.getStencilConfigForOverlapAndUpdateStencilID(
                                          v,
                                        );
                                      Ua(f, g, y, $, N, k, V, !1, A);
                                    }
                                })(e, i, s, a, h)
                              : u.c3(s)
                                ? (function (f, g, y, v, C) {
                                    if (
                                      f.renderPass !== "translucent" ||
                                      y.paint.get("raster-opacity") === 0 ||
                                      !v.length
                                    )
                                      return;
                                    const { isRenderingToTexture: A } = C,
                                      T = g.getSource(),
                                      M = f.style.projection.useSubdivision;
                                    if (T instanceof Ji)
                                      Ot(
                                        f,
                                        g,
                                        y,
                                        v,
                                        null,
                                        !1,
                                        !1,
                                        T.tileCoords,
                                        T.flippedWindingOrder,
                                        A,
                                      );
                                    else if (M) {
                                      const [k, V, N] =
                                        f.stencilConfigForOverlapTwoPass(v);
                                      (Ot(f, g, y, N, k, !1, !0, Us, !1, A),
                                        Ot(f, g, y, N, V, !0, !0, Us, !1, A));
                                    } else {
                                      const [k, V] =
                                        f.getStencilConfigForOverlapAndUpdateStencilID(
                                          v,
                                        );
                                      Ot(f, g, y, V, k, !1, !0, Us, !1, A);
                                    }
                                  })(e, i, s, a, h)
                                : u.c4(s)
                                  ? (function (f, g, y, v, C) {
                                      const A = y.paint.get("background-color"),
                                        T = y.paint.get("background-opacity");
                                      if (T === 0) return;
                                      const { isRenderingToTexture: M } = C,
                                        k = f.context,
                                        V = k.gl,
                                        N = f.style.projection,
                                        $ = f.transform,
                                        G = $.tileSize,
                                        Y = y.paint.get("background-pattern");
                                      if (f.isPatternMissing(Y)) return;
                                      const Q =
                                        !Y &&
                                        A.a === 1 &&
                                        T === 1 &&
                                        f.opaquePassEnabledForLayer()
                                          ? "opaque"
                                          : "translucent";
                                      if (f.renderPass !== Q) return;
                                      const ee = vt.disabled,
                                        re = f.getDepthModeForSublayer(
                                          0,
                                          Q === "opaque"
                                            ? at.ReadWrite
                                            : at.ReadOnly,
                                        ),
                                        ie = f.colorModeForRenderPass(),
                                        he = f.useProgram(
                                          Y
                                            ? "backgroundPattern"
                                            : "background",
                                        ),
                                        pe =
                                          v ||
                                          j($, {
                                            tileSize: G,
                                            terrain: f.style.map.terrain,
                                          });
                                      Y &&
                                        (k.activeTexture.set(V.TEXTURE0),
                                        f.imageManager.bind(f.context));
                                      const be = y.getCrossfadeParameters();
                                      for (const Ee of pe) {
                                        const ye = $.getProjectionData({
                                            overscaledTileID: Ee,
                                            applyGlobeMatrix: !M,
                                            applyTerrainMatrix: !0,
                                          }),
                                          Be = Y
                                            ? Ia(
                                                T,
                                                f,
                                                Y,
                                                { tileID: Ee, tileSize: G },
                                                be,
                                              )
                                            : Ma(T, A),
                                          Me =
                                            f.style.map.terrain &&
                                            f.style.map.terrain.getTerrainData(
                                              Ee,
                                            ),
                                          Fe = N.getMeshFromTileID(
                                            k,
                                            Ee.canonical,
                                            !1,
                                            !0,
                                            "raster",
                                          );
                                        he.draw(
                                          k,
                                          V.TRIANGLES,
                                          re,
                                          ee,
                                          ie,
                                          xt.backCCW,
                                          Be,
                                          Me,
                                          ye,
                                          y.id,
                                          Fe.vertexBuffer,
                                          Fe.indexBuffer,
                                          Fe.segments,
                                        );
                                      }
                                    })(e, 0, s, a, h)
                                  : u.c5(s) &&
                                    (function (f, g, y, v) {
                                      const { isRenderingGlobe: C } = v,
                                        A = f.context,
                                        T = y.implementation,
                                        M = f.style.projection,
                                        k = f.transform,
                                        V =
                                          k.getProjectionDataForCustomLayer(C),
                                        N = {
                                          farZ: k.farZ,
                                          nearZ: k.nearZ,
                                          fov: (k.fov * Math.PI) / 180,
                                          modelViewProjectionMatrix:
                                            k.modelViewProjectionMatrix,
                                          projectionMatrix: k.projectionMatrix,
                                          shaderData: {
                                            variantName: M.shaderVariantName,
                                            vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${M.shaderPreludeCode.vertexSource}`,
                                            define: M.shaderDefine,
                                          },
                                          defaultProjectionData: V,
                                        },
                                        $ = T.renderingMode
                                          ? T.renderingMode
                                          : "2d";
                                      if (f.renderPass === "offscreen") {
                                        const G = T.prerender;
                                        G &&
                                          (f.setCustomLayerDefaults(),
                                          A.setColorMode(
                                            f.colorModeForRenderPass(),
                                          ),
                                          G.call(T, A.gl, N),
                                          A.setDirty(),
                                          f.setBaseState());
                                      } else if (
                                        f.renderPass === "translucent"
                                      ) {
                                        (f.setCustomLayerDefaults(),
                                          A.setColorMode(
                                            f.colorModeForRenderPass(),
                                          ),
                                          A.setStencilMode(vt.disabled));
                                        const G =
                                          $ === "3d"
                                            ? f.getDepthModeFor3D()
                                            : f.getDepthModeForSublayer(
                                                0,
                                                at.ReadOnly,
                                              );
                                        (A.setDepthMode(G),
                                          T.render(A.gl, N),
                                          A.setDirty(),
                                          f.setBaseState(),
                                          A.bindFramebuffer.set(null));
                                      }
                                    })(e, 0, s, h)));
          }
          saveTileTexture(e) {
            const i = this._tileTextures[e.size[0]];
            i ? i.push(e) : (this._tileTextures[e.size[0]] = [e]);
          }
          getTileTexture(e) {
            const i = this._tileTextures[e];
            return i && i.length > 0 ? i.pop() : null;
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const i = this.imageManager.getPattern(e.from.toString()),
              s = this.imageManager.getPattern(e.to.toString());
            return !i || !s;
          }
          useProgram(e, i, s = !1) {
            this.cache = this.cache || {};
            const a = !!this.style.map.terrain,
              h = this.style.projection,
              f =
                e +
                (i ? i.cacheKey : "") +
                `/${s ? ls : h.shaderVariantName}` +
                (this._showOverdrawInspector ? "/overdraw" : "") +
                (a ? "/terrain" : "");
            return (
              this.cache[f] ||
                (this.cache[f] = new Sr(
                  this.context,
                  Tr[e],
                  i,
                  Xl[e],
                  this._showOverdrawInspector,
                  a,
                  s ? Tr.projectionMercator : h.shaderPreludeCode,
                  s ? as : h.shaderDefine,
                )),
              this.cache[f]
            );
          }
          setCustomLayerDefaults() {
            (this.context.unbindVAO(),
              this.context.cullFace.setDefault(),
              this.context.activeTexture.setDefault(),
              this.context.pixelStoreUnpack.setDefault(),
              this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
              this.context.pixelStoreUnpackFlipY.setDefault());
          }
          setBaseState() {
            const e = this.context.gl;
            (this.context.cullFace.set(!1),
              this.context.viewport.set([0, 0, this.width, this.height]),
              this.context.blendEquation.set(e.FUNC_ADD));
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null &&
              ((this.debugOverlayCanvas = document.createElement("canvas")),
              (this.debugOverlayCanvas.width = 512),
              (this.debugOverlayCanvas.height = 512),
              (this.debugOverlayTexture = new Bt(
                this.context,
                this.debugOverlayCanvas,
                this.context.gl.RGBA,
              )));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: e, drawingBufferHeight: i } =
              this.context.gl;
            return this.width !== e || this.height !== i;
          }
        }
        function nn(c, e) {
          let i,
            s = !1,
            a = null,
            h = null;
          const f = () => {
            ((a = null),
              s && (c.apply(h, i), (a = setTimeout(f, e)), (s = !1)));
          };
          return (...g) => ((s = !0), (h = this), (i = g), a || f(), a);
        }
        class Ha {
          constructor(e) {
            ((this._getCurrentHash = () => {
              const i = window.location.hash.replace("#", "");
              if (this._hashName) {
                let s;
                return (
                  i
                    .split("&")
                    .map((a) => a.split("="))
                    .forEach((a) => {
                      a[0] === this._hashName && (s = a);
                    }),
                  ((s && s[1]) || "").split("/")
                );
              }
              return i.split("/");
            }),
              (this._onHashChange = () => {
                const i = this._getCurrentHash();
                if (!this._isValidHash(i)) return !1;
                const s =
                  this._map.dragRotate.isEnabled() &&
                  this._map.touchZoomRotate.isEnabled()
                    ? +(i[3] || 0)
                    : this._map.getBearing();
                return (
                  this._map.jumpTo({
                    center: [+i[2], +i[1]],
                    zoom: +i[0],
                    bearing: s,
                    pitch: +(i[4] || 0),
                  }),
                  !0
                );
              }),
              (this._updateHashUnthrottled = () => {
                const i = window.location.href.replace(
                  /(#.*)?$/,
                  this.getHashString(),
                );
                window.history.replaceState(window.history.state, null, i);
              }),
              (this._removeHash = () => {
                const i = this._getCurrentHash();
                if (i.length === 0) return;
                const s = i.join("/");
                let a = s;
                (a.split("&").length > 0 && (a = a.split("&")[0]),
                  this._hashName && (a = `${this._hashName}=${s}`));
                let h = window.location.hash.replace(a, "");
                h.startsWith("#&")
                  ? (h = h.slice(0, 1) + h.slice(2))
                  : h === "#" && (h = "");
                let f = window.location.href.replace(/(#.+)?$/, h);
                ((f = f.replace("&&", "&")),
                  window.history.replaceState(window.history.state, null, f));
              }),
              (this._updateHash = nn(this._updateHashUnthrottled, 300)),
              (this._hashName = e && encodeURIComponent(e)));
          }
          addTo(e) {
            return (
              (this._map = e),
              addEventListener("hashchange", this._onHashChange, !1),
              this._map.on("moveend", this._updateHash),
              this
            );
          }
          remove() {
            return (
              removeEventListener("hashchange", this._onHashChange, !1),
              this._map.off("moveend", this._updateHash),
              clearTimeout(this._updateHash()),
              this._removeHash(),
              delete this._map,
              this
            );
          }
          getHashString(e) {
            const i = this._map.getCenter(),
              s = Math.round(100 * this._map.getZoom()) / 100,
              a = Math.ceil(
                (s * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10,
              ),
              h = Math.pow(10, a),
              f = Math.round(i.lng * h) / h,
              g = Math.round(i.lat * h) / h,
              y = this._map.getBearing(),
              v = this._map.getPitch();
            let C = "";
            if (
              ((C += e ? `/${f}/${g}/${s}` : `${s}/${g}/${f}`),
              (y || v) && (C += "/" + Math.round(10 * y) / 10),
              v && (C += `/${Math.round(v)}`),
              this._hashName)
            ) {
              const A = this._hashName;
              let T = !1;
              const M = window.location.hash
                .slice(1)
                .split("&")
                .map((k) => {
                  const V = k.split("=")[0];
                  return V === A ? ((T = !0), `${V}=${C}`) : k;
                })
                .filter((k) => k);
              return (T || M.push(`${A}=${C}`), `#${M.join("&")}`);
            }
            return `#${C}`;
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new u.N(+e[2], +e[1]);
            } catch {
              return !1;
            }
            const i = +e[0],
              s = +(e[3] || 0),
              a = +(e[4] || 0);
            return (
              i >= this._map.getMinZoom() &&
              i <= this._map.getMaxZoom() &&
              s >= 0 &&
              s <= 180 &&
              a >= this._map.getMinPitch() &&
              a <= this._map.getMaxPitch()
            );
          }
        }
        const ao = { linearity: 0.3, easing: u.c6(0, 0, 0.3, 1) },
          uu = u.e({ deceleration: 2500, maxSpeed: 1400 }, ao),
          cu = u.e({ deceleration: 20, maxSpeed: 1400 }, ao),
          hu = u.e({ deceleration: 1e3, maxSpeed: 360 }, ao),
          du = u.e({ deceleration: 1e3, maxSpeed: 90 }, ao),
          pu = u.e({ deceleration: 1e3, maxSpeed: 360 }, ao);
        class No {
          constructor(e) {
            ((this._map = e), this.clear());
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e) {
            (this._drainInertiaBuffer(),
              this._inertiaBuffer.push({ time: Qe.now(), settings: e }));
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              i = Qe.now();
            for (; e.length > 0 && i - e[0].time > 160; ) e.shift();
          }
          _onMoveEnd(e) {
            if ((this._drainInertiaBuffer(), this._inertiaBuffer.length < 2))
              return;
            const i = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new u.P(0, 0),
              pinchAround: void 0,
              around: void 0,
            };
            for (const { settings: h } of this._inertiaBuffer)
              ((i.zoom += h.zoomDelta || 0),
                (i.bearing += h.bearingDelta || 0),
                (i.pitch += h.pitchDelta || 0),
                (i.roll += h.rollDelta || 0),
                h.panDelta && i.pan._add(h.panDelta),
                h.around && (i.around = h.around),
                h.pinchAround && (i.pinchAround = h.pinchAround));
            const s =
                this._inertiaBuffer[this._inertiaBuffer.length - 1].time -
                this._inertiaBuffer[0].time,
              a = {};
            if (i.pan.mag()) {
              const h = Li(i.pan.mag(), s, u.e({}, uu, e || {})),
                f = i.pan.mult(h.amount / i.pan.mag()),
                g = this._map.cameraHelper.handlePanInertia(
                  f,
                  this._map.transform,
                );
              ((a.center = g.easingCenter),
                (a.offset = g.easingOffset),
                lo(a, h));
            }
            if (i.zoom) {
              const h = Li(i.zoom, s, cu);
              ((a.zoom = this._map.transform.zoom + h.amount), lo(a, h));
            }
            if (i.bearing) {
              const h = Li(i.bearing, s, hu);
              ((a.bearing =
                this._map.transform.bearing + u.ab(h.amount, -179, 179)),
                lo(a, h));
            }
            if (i.pitch) {
              const h = Li(i.pitch, s, du);
              ((a.pitch = this._map.transform.pitch + h.amount), lo(a, h));
            }
            if (i.roll) {
              const h = Li(i.roll, s, pu);
              ((a.roll = this._map.transform.roll + u.ab(h.amount, -179, 179)),
                lo(a, h));
            }
            if (a.zoom || a.bearing) {
              const h = i.pinchAround === void 0 ? i.around : i.pinchAround;
              a.around = h ? this._map.unproject(h) : this._map.getCenter();
            }
            return (this.clear(), u.e(a, { noMoveStart: !0 }));
          }
        }
        function lo(c, e) {
          (!c.duration || c.duration < e.duration) &&
            ((c.duration = e.duration), (c.easing = e.easing));
        }
        function Li(c, e, i) {
          const { maxSpeed: s, linearity: a, deceleration: h } = i,
            f = u.ab((c * a) / (e / 1e3), -s, s),
            g = Math.abs(f) / (h * a);
          return { easing: i.easing, duration: 1e3 * g, amount: f * (g / 2) };
        }
        class Yt extends u.k {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, i, s, a = {}) {
            const h = me.mousePos(i.getCanvas(), s),
              f = i.unproject(h);
            (super(e, u.e({ point: h, lngLat: f, originalEvent: s }, a)),
              (this._defaultPrevented = !1),
              (this.target = i));
          }
        }
        class uo extends u.k {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, i, s) {
            const a = e === "touchend" ? s.changedTouches : s.touches,
              h = me.touchPos(i.getCanvasContainer(), a),
              f = h.map((y) => i.unproject(y)),
              g = h.reduce(
                (y, v, C, A) => y.add(v.div(A.length)),
                new u.P(0, 0),
              );
            (super(e, {
              points: h,
              point: g,
              lngLats: f,
              lngLat: i.unproject(g),
              originalEvent: s,
            }),
              (this._defaultPrevented = !1));
          }
        }
        class xr extends u.k {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, i, s) {
            (super(e, { originalEvent: s }), (this._defaultPrevented = !1));
          }
        }
        class co {
          constructor(e, i) {
            ((this._map = e), (this._clickTolerance = i.clickTolerance));
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e) {
            return this._firePreventable(new xr(e.type, this._map, e));
          }
          mousedown(e, i) {
            return (
              (this._mousedownPos = i),
              this._firePreventable(new Yt(e.type, this._map, e))
            );
          }
          mouseup(e) {
            this._map.fire(new Yt(e.type, this._map, e));
          }
          click(e, i) {
            (this._mousedownPos &&
              this._mousedownPos.dist(i) >= this._clickTolerance) ||
              this._map.fire(new Yt(e.type, this._map, e));
          }
          dblclick(e) {
            return this._firePreventable(new Yt(e.type, this._map, e));
          }
          mouseover(e) {
            this._map.fire(new Yt(e.type, this._map, e));
          }
          mouseout(e) {
            this._map.fire(new Yt(e.type, this._map, e));
          }
          touchstart(e) {
            return this._firePreventable(new uo(e.type, this._map, e));
          }
          touchmove(e) {
            this._map.fire(new uo(e.type, this._map, e));
          }
          touchend(e) {
            this._map.fire(new uo(e.type, this._map, e));
          }
          touchcancel(e) {
            this._map.fire(new uo(e.type, this._map, e));
          }
          _firePreventable(e) {
            if ((this._map.fire(e), e.defaultPrevented)) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {}
          disable() {}
        }
        class mc {
          constructor(e) {
            this._map = e;
          }
          reset() {
            ((this._delayContextMenu = !1),
              (this._ignoreContextMenu = !0),
              delete this._contextMenuEvent);
          }
          mousemove(e) {
            this._map.fire(new Yt(e.type, this._map, e));
          }
          mousedown() {
            ((this._delayContextMenu = !0), (this._ignoreContextMenu = !1));
          }
          mouseup() {
            ((this._delayContextMenu = !1),
              this._contextMenuEvent &&
                (this._map.fire(
                  new Yt("contextmenu", this._map, this._contextMenuEvent),
                ),
                delete this._contextMenuEvent));
          }
          contextmenu(e) {
            (this._delayContextMenu
              ? (this._contextMenuEvent = e)
              : this._ignoreContextMenu ||
                this._map.fire(new Yt(e.type, this._map, e)),
              this._map.listens("contextmenu") && e.preventDefault());
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {}
          disable() {}
        }
        class Vo {
          constructor(e) {
            this._map = e;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat,
            };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e) {
            return this.transform.screenPointToLocation(
              u.P.convert(e),
              this._map.terrain,
            );
          }
        }
        class fu {
          constructor(e, i) {
            ((this._map = e),
              (this._tr = new Vo(e)),
              (this._el = e.getCanvasContainer()),
              (this._container = e.getContainer()),
              (this._clickTolerance = i.clickTolerance || 1));
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(e, i) {
            this.isEnabled() &&
              e.shiftKey &&
              e.button === 0 &&
              (me.disableDrag(),
              (this._startPos = this._lastPos = i),
              (this._active = !0));
          }
          mousemoveWindow(e, i) {
            if (!this._active) return;
            const s = i;
            if (
              this._lastPos.equals(s) ||
              (!this._box && s.dist(this._startPos) < this._clickTolerance)
            )
              return;
            const a = this._startPos;
            ((this._lastPos = s),
              this._box ||
                ((this._box = me.create(
                  "div",
                  "maplibregl-boxzoom",
                  this._container,
                )),
                this._container.classList.add("maplibregl-crosshair"),
                this._fireEvent("boxzoomstart", e)));
            const h = Math.min(a.x, s.x),
              f = Math.max(a.x, s.x),
              g = Math.min(a.y, s.y),
              y = Math.max(a.y, s.y);
            (me.setTransform(this._box, `translate(${h}px,${g}px)`),
              (this._box.style.width = f - h + "px"),
              (this._box.style.height = y - g + "px"));
          }
          mouseupWindow(e, i) {
            if (!this._active || e.button !== 0) return;
            const s = this._startPos,
              a = i;
            if ((this.reset(), me.suppressClick(), s.x !== a.x || s.y !== a.y))
              return (
                this._map.fire(new u.k("boxzoomend", { originalEvent: e })),
                {
                  cameraAnimation: (h) =>
                    h.fitScreenCoordinates(s, a, this._tr.bearing, {
                      linear: !0,
                    }),
                }
              );
            this._fireEvent("boxzoomcancel", e);
          }
          keydown(e) {
            this._active &&
              e.keyCode === 27 &&
              (this.reset(), this._fireEvent("boxzoomcancel", e));
          }
          reset() {
            ((this._active = !1),
              this._container.classList.remove("maplibregl-crosshair"),
              this._box && (me.remove(this._box), (this._box = null)),
              me.enableDrag(),
              delete this._startPos,
              delete this._lastPos);
          }
          _fireEvent(e, i) {
            return this._map.fire(new u.k(e, { originalEvent: i }));
          }
        }
        function Xa(c, e) {
          if (c.length !== e.length)
            throw new Error(
              `The number of touches and points are not equal - touches ${c.length}, points ${e.length}`,
            );
          const i = {};
          for (let s = 0; s < c.length; s++) i[c[s].identifier] = e[s];
          return i;
        }
        class mu {
          constructor(e) {
            (this.reset(), (this.numTouches = e.numTouches));
          }
          reset() {
            (delete this.centroid,
              delete this.startTime,
              delete this.touches,
              (this.aborted = !1));
          }
          touchstart(e, i, s) {
            ((this.centroid || s.length > this.numTouches) &&
              (this.aborted = !0),
              this.aborted ||
                (this.startTime === void 0 && (this.startTime = e.timeStamp),
                s.length === this.numTouches &&
                  ((this.centroid = (function (a) {
                    const h = new u.P(0, 0);
                    for (const f of a) h._add(f);
                    return h.div(a.length);
                  })(i)),
                  (this.touches = Xa(s, i)))));
          }
          touchmove(e, i, s) {
            if (this.aborted || !this.centroid) return;
            const a = Xa(s, i);
            for (const h in this.touches) {
              const f = a[h];
              (!f || f.dist(this.touches[h]) > 30) && (this.aborted = !0);
            }
          }
          touchend(e, i, s) {
            if (
              ((!this.centroid || e.timeStamp - this.startTime > 500) &&
                (this.aborted = !0),
              s.length === 0)
            ) {
              const a = !this.aborted && this.centroid;
              if ((this.reset(), a)) return a;
            }
          }
        }
        class Rn {
          constructor(e) {
            ((this.singleTap = new mu(e)),
              (this.numTaps = e.numTaps),
              this.reset());
          }
          reset() {
            ((this.lastTime = 1 / 0),
              delete this.lastTap,
              (this.count = 0),
              this.singleTap.reset());
          }
          touchstart(e, i, s) {
            this.singleTap.touchstart(e, i, s);
          }
          touchmove(e, i, s) {
            this.singleTap.touchmove(e, i, s);
          }
          touchend(e, i, s) {
            const a = this.singleTap.touchend(e, i, s);
            if (a) {
              const h = e.timeStamp - this.lastTime < 500,
                f = !this.lastTap || this.lastTap.dist(a) < 30;
              if (
                ((h && f) || this.reset(),
                this.count++,
                (this.lastTime = e.timeStamp),
                (this.lastTap = a),
                this.count === this.numTaps)
              )
                return (this.reset(), a);
            }
          }
        }
        class Vr {
          constructor(e) {
            ((this._tr = new Vo(e)),
              (this._zoomIn = new Rn({ numTouches: 1, numTaps: 2 })),
              (this._zoomOut = new Rn({ numTouches: 2, numTaps: 1 })),
              this.reset());
          }
          reset() {
            ((this._active = !1), this._zoomIn.reset(), this._zoomOut.reset());
          }
          touchstart(e, i, s) {
            (this._zoomIn.touchstart(e, i, s),
              this._zoomOut.touchstart(e, i, s));
          }
          touchmove(e, i, s) {
            (this._zoomIn.touchmove(e, i, s), this._zoomOut.touchmove(e, i, s));
          }
          touchend(e, i, s) {
            const a = this._zoomIn.touchend(e, i, s),
              h = this._zoomOut.touchend(e, i, s),
              f = this._tr;
            return a
              ? ((this._active = !0),
                e.preventDefault(),
                setTimeout(() => this.reset(), 0),
                {
                  cameraAnimation: (g) =>
                    g.easeTo(
                      {
                        duration: 300,
                        zoom: f.zoom + 1,
                        around: f.unproject(a),
                      },
                      { originalEvent: e },
                    ),
                })
              : h
                ? ((this._active = !0),
                  e.preventDefault(),
                  setTimeout(() => this.reset(), 0),
                  {
                    cameraAnimation: (g) =>
                      g.easeTo(
                        {
                          duration: 300,
                          zoom: f.zoom - 1,
                          around: f.unproject(h),
                        },
                        { originalEvent: e },
                      ),
                  })
                : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            ((this._enabled = !1), this.reset());
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Re {
          constructor(e) {
            ((this._enabled = !!e.enable),
              (this._moveStateManager = e.moveStateManager),
              (this._clickTolerance = e.clickTolerance || 1),
              (this._moveFunction = e.move),
              (this._activateOnStart = !!e.activateOnStart),
              e.assignEvents(this),
              this.reset());
          }
          reset(e) {
            ((this._active = !1),
              (this._moved = !1),
              delete this._lastPoint,
              this._moveStateManager.endMove(e));
          }
          _move(...e) {
            const i = this._moveFunction(...e);
            if (
              i.bearingDelta ||
              i.pitchDelta ||
              i.rollDelta ||
              i.around ||
              i.panDelta
            )
              return ((this._active = !0), i);
          }
          dragStart(e, i) {
            this.isEnabled() &&
              !this._lastPoint &&
              this._moveStateManager.isValidStartEvent(e) &&
              (this._moveStateManager.startMove(e),
              (this._lastPoint = Array.isArray(i) ? i[0] : i),
              this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(e, i) {
            if (!this.isEnabled()) return;
            const s = this._lastPoint;
            if (!s) return;
            if (
              (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e))
            )
              return void this.reset(e);
            const a = Array.isArray(i) ? i[0] : i;
            return !this._moved && a.dist(s) < this._clickTolerance
              ? void 0
              : ((this._moved = !0), (this._lastPoint = a), this._move(s, a));
          }
          dragEnd(e) {
            this.isEnabled() &&
              this._lastPoint &&
              this._moveStateManager.isValidEndEvent(e) &&
              (this._moved && me.suppressClick(), this.reset(e));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            ((this._enabled = !1), this.reset());
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const gu = { 0: 1, 2: 2 };
        class On {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent;
          }
          startMove(e) {
            const i = me.mouseButton(e);
            this._eventButton = i;
          }
          endMove(e) {
            delete this._eventButton;
          }
          isValidStartEvent(e) {
            return this._correctEvent(e);
          }
          isValidMoveEvent(e) {
            return !(function (i, s) {
              const a = gu[s];
              return i.buttons === void 0 || (i.buttons & a) !== a;
            })(e, this._eventButton);
          }
          isValidEndEvent(e) {
            return me.mouseButton(e) === this._eventButton;
          }
        }
        class _u {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1;
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier;
          }
          endMove(e) {
            delete this._firstTouch;
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e);
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
        }
        class Uo {
          constructor(
            e = new On({ checkCorrectEvent: () => !0 }),
            i = new _u(),
          ) {
            ((this.mouseMoveStateManager = e),
              (this.oneFingerTouchMoveStateManager = i));
          }
          _executeRelevantHandler(e, i, s) {
            return e instanceof MouseEvent
              ? i(e)
              : typeof TouchEvent < "u" && e instanceof TouchEvent
                ? s(e)
                : void 0;
          }
          startMove(e) {
            this._executeRelevantHandler(
              e,
              (i) => this.mouseMoveStateManager.startMove(i),
              (i) => this.oneFingerTouchMoveStateManager.startMove(i),
            );
          }
          endMove(e) {
            this._executeRelevantHandler(
              e,
              (i) => this.mouseMoveStateManager.endMove(i),
              (i) => this.oneFingerTouchMoveStateManager.endMove(i),
            );
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(
              e,
              (i) => this.mouseMoveStateManager.isValidStartEvent(i),
              (i) => this.oneFingerTouchMoveStateManager.isValidStartEvent(i),
            );
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(
              e,
              (i) => this.mouseMoveStateManager.isValidMoveEvent(i),
              (i) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(i),
            );
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(
              e,
              (i) => this.mouseMoveStateManager.isValidEndEvent(i),
              (i) => this.oneFingerTouchMoveStateManager.isValidEndEvent(i),
            );
          }
        }
        const on = (c) => {
          ((c.mousedown = c.dragStart),
            (c.mousemoveWindow = c.dragMove),
            (c.mouseup = c.dragEnd),
            (c.contextmenu = (e) => {
              e.preventDefault();
            }));
        };
        class yu {
          constructor(e, i) {
            ((this._clickTolerance = e.clickTolerance || 1),
              (this._map = i),
              this.reset());
          }
          reset() {
            ((this._active = !1),
              (this._touches = {}),
              (this._sum = new u.P(0, 0)));
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e, i, s) {
            return this._calculateTransform(e, i, s);
          }
          touchmove(e, i, s) {
            if (this._active) {
              if (!this._shouldBePrevented(s.length))
                return (e.preventDefault(), this._calculateTransform(e, i, s));
              this._map.cooperativeGestures.notifyGestureBlocked(
                "touch_pan",
                e,
              );
            }
          }
          touchend(e, i, s) {
            (this._calculateTransform(e, i, s),
              this._active &&
                this._shouldBePrevented(s.length) &&
                this.reset());
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e, i, s) {
            s.length > 0 && (this._active = !0);
            const a = Xa(s, i),
              h = new u.P(0, 0),
              f = new u.P(0, 0);
            let g = 0;
            for (const v in a) {
              const C = a[v],
                A = this._touches[v];
              A && (h._add(C), f._add(C.sub(A)), g++, (a[v] = C));
            }
            if (((this._touches = a), this._shouldBePrevented(g) || !f.mag()))
              return;
            const y = f.div(g);
            return (
              this._sum._add(y),
              this._sum.mag() < this._clickTolerance
                ? void 0
                : { around: h.div(g), panDelta: y }
            );
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            ((this._enabled = !1), this.reset());
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ht {
          constructor() {
            this.reset();
          }
          reset() {
            ((this._active = !1), delete this._firstTwoTouches);
          }
          touchstart(e, i, s) {
            this._firstTwoTouches ||
              s.length < 2 ||
              ((this._firstTwoTouches = [s[0].identifier, s[1].identifier]),
              this._start([i[0], i[1]]));
          }
          touchmove(e, i, s) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [a, h] = this._firstTwoTouches,
              f = ho(s, i, a),
              g = ho(s, i, h);
            if (!f || !g) return;
            const y = this._aroundCenter ? null : f.add(g).div(2);
            return this._move([f, g], y, e);
          }
          touchend(e, i, s) {
            if (!this._firstTwoTouches) return;
            const [a, h] = this._firstTwoTouches,
              f = ho(s, i, a),
              g = ho(s, i, h);
            (f && g) || (this._active && me.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e) {
            ((this._enabled = !0),
              (this._aroundCenter = !!e && e.around === "center"));
          }
          disable() {
            ((this._enabled = !1), this.reset());
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function ho(c, e, i) {
          for (let s = 0; s < c.length; s++)
            if (c[s].identifier === i) return e[s];
        }
        function xu(c, e) {
          return Math.log(c / e) / Math.LN2;
        }
        class Zs extends ht {
          reset() {
            (super.reset(), delete this._distance, delete this._startDistance);
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1]);
          }
          _move(e, i) {
            const s = this._distance;
            if (
              ((this._distance = e[0].dist(e[1])),
              this._active ||
                !(Math.abs(xu(this._distance, this._startDistance)) < 0.1))
            )
              return (
                (this._active = !0),
                { zoomDelta: xu(this._distance, s), pinchAround: i }
              );
          }
        }
        function vu(c, e) {
          return (180 * c.angleWith(e)) / Math.PI;
        }
        class bu extends ht {
          reset() {
            (super.reset(),
              delete this._minDiameter,
              delete this._startVector,
              delete this._vector);
          }
          _start(e) {
            ((this._startVector = this._vector = e[0].sub(e[1])),
              (this._minDiameter = e[0].dist(e[1])));
          }
          _move(e, i, s) {
            const a = this._vector;
            if (
              ((this._vector = e[0].sub(e[1])),
              this._active || !this._isBelowThreshold(this._vector))
            )
              return (
                (this._active = !0),
                { bearingDelta: vu(this._vector, a), pinchAround: i }
              );
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const i = (25 / (Math.PI * this._minDiameter)) * 360,
              s = vu(e, this._startVector);
            return Math.abs(s) < i;
          }
        }
        function Gs(c) {
          return Math.abs(c.y) > Math.abs(c.x);
        }
        class qs extends ht {
          constructor(e) {
            (super(), (this._currentTouchCount = 0), (this._map = e));
          }
          reset() {
            (super.reset(),
              (this._valid = void 0),
              delete this._firstMove,
              delete this._lastPoints);
          }
          touchstart(e, i, s) {
            (super.touchstart(e, i, s), (this._currentTouchCount = s.length));
          }
          _start(e) {
            ((this._lastPoints = e), Gs(e[0].sub(e[1])) && (this._valid = !1));
          }
          _move(e, i, s) {
            if (
              this._map.cooperativeGestures.isEnabled() &&
              this._currentTouchCount < 3
            )
              return;
            const a = e[0].sub(this._lastPoints[0]),
              h = e[1].sub(this._lastPoints[1]);
            return (
              (this._valid = this.gestureBeginsVertically(a, h, s.timeStamp)),
              this._valid
                ? ((this._lastPoints = e),
                  (this._active = !0),
                  { pitchDelta: ((a.y + h.y) / 2) * -0.5 })
                : void 0
            );
          }
          gestureBeginsVertically(e, i, s) {
            if (this._valid !== void 0) return this._valid;
            const a = e.mag() >= 2,
              h = i.mag() >= 2;
            if (!a && !h) return;
            if (!a || !h)
              return (
                this._firstMove === void 0 && (this._firstMove = s),
                s - this._firstMove < 100 && void 0
              );
            const f = e.y > 0 == i.y > 0;
            return Gs(e) && Gs(i) && f;
          }
        }
        const wu = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Cu {
          constructor(e) {
            this._tr = new Vo(e);
            const i = wu;
            ((this._panStep = i.panStep),
              (this._bearingStep = i.bearingStep),
              (this._pitchStep = i.pitchStep),
              (this._rotationDisabled = !1));
          }
          reset() {
            this._active = !1;
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let i = 0,
              s = 0,
              a = 0,
              h = 0,
              f = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                i = 1;
                break;
              case 189:
              case 109:
              case 173:
                i = -1;
                break;
              case 37:
                e.shiftKey ? (s = -1) : (e.preventDefault(), (h = -1));
                break;
              case 39:
                e.shiftKey ? (s = 1) : (e.preventDefault(), (h = 1));
                break;
              case 38:
                e.shiftKey ? (a = 1) : (e.preventDefault(), (f = -1));
                break;
              case 40:
                e.shiftKey ? (a = -1) : (e.preventDefault(), (f = 1));
                break;
              default:
                return;
            }
            return (
              this._rotationDisabled && ((s = 0), (a = 0)),
              {
                cameraAnimation: (g) => {
                  const y = this._tr;
                  g.easeTo(
                    {
                      duration: 300,
                      easeId: "keyboardHandler",
                      easing: Eu,
                      zoom: i
                        ? Math.round(y.zoom) + i * (e.shiftKey ? 2 : 1)
                        : y.zoom,
                      bearing: y.bearing + s * this._bearingStep,
                      pitch: y.pitch + a * this._pitchStep,
                      offset: [-h * this._panStep, -f * this._panStep],
                      center: y.center,
                    },
                    { originalEvent: e },
                  );
                },
              }
            );
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            ((this._enabled = !1), this.reset());
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function Eu(c) {
          return c * (2 - c);
        }
        const Au = 4.000244140625;
        class Tu {
          constructor(e, i) {
            ((this._onTimeout = (s) => {
              ((this._type = "wheel"),
                (this._delta -= this._lastValue),
                this._active || this._start(s));
            }),
              (this._map = e),
              (this._tr = new Vo(e)),
              (this._triggerRenderFrame = i),
              (this._delta = 0),
              (this._defaultZoomRate = 0.01),
              (this._wheelZoomRate = 0.0022222222222222222));
          }
          setZoomRate(e) {
            this._defaultZoomRate = e;
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e) {
            this.isEnabled() ||
              ((this._enabled = !0),
              (this._aroundCenter = !!e && e.around === "center"));
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(e) {
            return (
              !!this._map.cooperativeGestures.isEnabled() &&
              !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
            );
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e))
              return void this._map.cooperativeGestures.notifyGestureBlocked(
                "wheel_zoom",
                e,
              );
            let i =
              e.deltaMode === WheelEvent.DOM_DELTA_LINE
                ? 40 * e.deltaY
                : e.deltaY;
            const s = Qe.now(),
              a = s - (this._lastWheelEventTime || 0);
            ((this._lastWheelEventTime = s),
              i !== 0 && i % Au == 0
                ? (this._type = "wheel")
                : i !== 0 && Math.abs(i) < 4
                  ? (this._type = "trackpad")
                  : a > 400
                    ? ((this._type = null),
                      (this._lastValue = i),
                      (this._timeout = setTimeout(this._onTimeout, 40, e)))
                    : this._type ||
                      ((this._type =
                        Math.abs(a * i) < 200 ? "trackpad" : "wheel"),
                      this._timeout &&
                        (clearTimeout(this._timeout),
                        (this._timeout = null),
                        (i += this._lastValue))),
              e.shiftKey && i && (i /= 4),
              this._type &&
                ((this._lastWheelEvent = e),
                (this._delta -= i),
                this._active || this._start(e)),
              e.preventDefault());
          }
          _start(e) {
            if (!this._delta) return;
            (this._frameId && (this._frameId = null),
              (this._active = !0),
              this.isZooming() || (this._zooming = !0),
              this._finishTimeout &&
                (clearTimeout(this._finishTimeout),
                delete this._finishTimeout));
            const i = me.mousePos(this._map.getCanvas(), e),
              s = this._tr;
            ((this._aroundPoint = this._aroundCenter
              ? s.transform.locationToScreenPoint(u.N.convert(s.center))
              : i),
              this._frameId ||
                ((this._frameId = !0), this._triggerRenderFrame()));
          }
          renderFrame() {
            if (!this._frameId || ((this._frameId = null), !this.isActive()))
              return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const g = e.zoom - this._lastExpectedZoom;
              (typeof this._startZoom == "number" && (this._startZoom += g),
                typeof this._targetZoom == "number" && (this._targetZoom += g));
            }
            if (this._delta !== 0) {
              const g =
                this._type === "wheel" && Math.abs(this._delta) > Au
                  ? this._wheelZoomRate
                  : this._defaultZoomRate;
              let y = 2 / (1 + Math.exp(-Math.abs(this._delta * g)));
              this._delta < 0 && y !== 0 && (y = 1 / y);
              const v =
                typeof this._targetZoom != "number"
                  ? e.scale
                  : u.aG(this._targetZoom);
              ((this._targetZoom = Math.min(
                e.maxZoom,
                Math.max(e.minZoom, u.a8(v * y)),
              )),
                this._type === "wheel" &&
                  ((this._startZoom = e.zoom),
                  (this._easing = this._smoothOutEasing(200))),
                (this._delta = 0));
            }
            const i =
                typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              s = this._startZoom,
              a = this._easing;
            let h,
              f = !1;
            if (this._type === "wheel" && s && a) {
              const g = Qe.now() - this._lastWheelEventTime,
                y = Math.min((g + 5) / 200, 1),
                v = a(y);
              ((h = u.y.number(s, i, v)),
                y < 1 ? this._frameId || (this._frameId = !0) : (f = !0));
            } else ((h = i), (f = !0));
            return (
              (this._active = !0),
              f &&
                ((this._active = !1),
                (this._finishTimeout = setTimeout(() => {
                  ((this._zooming = !1),
                    this._triggerRenderFrame(),
                    delete this._targetZoom,
                    delete this._lastExpectedZoom,
                    delete this._finishTimeout);
                }, 200))),
              (this._lastExpectedZoom = h),
              {
                noInertia: !0,
                needsRenderFrame: !f,
                zoomDelta: h - e.zoom,
                around: this._aroundPoint,
                originalEvent: this._lastWheelEvent,
              }
            );
          }
          _smoothOutEasing(e) {
            let i = u.c8;
            if (this._prevEase) {
              const s = this._prevEase,
                a = (Qe.now() - s.start) / s.duration,
                h = s.easing(a + 0.01) - s.easing(a),
                f = (0.27 / Math.sqrt(h * h + 1e-4)) * 0.01,
                g = Math.sqrt(0.0729 - f * f);
              i = u.c6(f, g, 0.25, 1);
            }
            return (
              (this._prevEase = { start: Qe.now(), duration: e, easing: i }),
              i
            );
          }
          reset() {
            ((this._active = !1),
              (this._zooming = !1),
              delete this._targetZoom,
              delete this._lastExpectedZoom,
              this._finishTimeout &&
                (clearTimeout(this._finishTimeout),
                delete this._finishTimeout));
          }
        }
        class Ur {
          constructor(e, i) {
            ((this._clickZoom = e), (this._tapZoom = i));
          }
          enable() {
            (this._clickZoom.enable(), this._tapZoom.enable());
          }
          disable() {
            (this._clickZoom.disable(), this._tapZoom.disable());
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class jt {
          constructor(e) {
            ((this._tr = new Vo(e)), this.reset());
          }
          reset() {
            this._active = !1;
          }
          dblclick(e, i) {
            return (
              e.preventDefault(),
              {
                cameraAnimation: (s) => {
                  s.easeTo(
                    {
                      duration: 300,
                      zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                      around: this._tr.unproject(i),
                    },
                    { originalEvent: e },
                  );
                },
              }
            );
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            ((this._enabled = !1), this.reset());
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Hs {
          constructor() {
            ((this._tap = new Rn({ numTouches: 1, numTaps: 1 })), this.reset());
          }
          reset() {
            ((this._active = !1),
              delete this._swipePoint,
              delete this._swipeTouch,
              delete this._tapTime,
              delete this._tapPoint,
              this._tap.reset());
          }
          touchstart(e, i, s) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const a = i[0],
                  h = e.timeStamp - this._tapTime < 500,
                  f = this._tapPoint.dist(a) < 30;
                h && f
                  ? s.length > 0 &&
                    ((this._swipePoint = a),
                    (this._swipeTouch = s[0].identifier))
                  : this.reset();
              } else this._tap.touchstart(e, i, s);
          }
          touchmove(e, i, s) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (s[0].identifier !== this._swipeTouch) return;
                const a = i[0],
                  h = a.y - this._swipePoint.y;
                return (
                  (this._swipePoint = a),
                  e.preventDefault(),
                  (this._active = !0),
                  { zoomDelta: h / 128 }
                );
              }
            } else this._tap.touchmove(e, i, s);
          }
          touchend(e, i, s) {
            if (this._tapTime)
              this._swipePoint && s.length === 0 && this.reset();
            else {
              const a = this._tap.touchend(e, i, s);
              a && ((this._tapTime = e.timeStamp), (this._tapPoint = a));
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            ((this._enabled = !1), this.reset());
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Xs {
          constructor(e, i, s) {
            ((this._el = e), (this._mousePan = i), (this._touchPan = s));
          }
          enable(e) {
            ((this._inertiaOptions = e || {}),
              this._mousePan.enable(),
              this._touchPan.enable(),
              this._el.classList.add("maplibregl-touch-drag-pan"));
          }
          disable() {
            (this._mousePan.disable(),
              this._touchPan.disable(),
              this._el.classList.remove("maplibregl-touch-drag-pan"));
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Wa {
          constructor(e, i, s, a) {
            ((this._pitchWithRotate = e.pitchWithRotate),
              (this._rollEnabled = e.rollEnabled),
              (this._mouseRotate = i),
              (this._mousePitch = s),
              (this._mouseRoll = a));
          }
          enable() {
            (this._mouseRotate.enable(),
              this._pitchWithRotate && this._mousePitch.enable(),
              this._rollEnabled && this._mouseRoll.enable());
          }
          disable() {
            (this._mouseRotate.disable(),
              this._mousePitch.disable(),
              this._mouseRoll.disable());
          }
          isEnabled() {
            return (
              this._mouseRotate.isEnabled() &&
              (!this._pitchWithRotate || this._mousePitch.isEnabled()) &&
              (!this._rollEnabled || this._mouseRoll.isEnabled())
            );
          }
          isActive() {
            return (
              this._mouseRotate.isActive() ||
              this._mousePitch.isActive() ||
              this._mouseRoll.isActive()
            );
          }
        }
        class Ka {
          constructor(e, i, s, a) {
            ((this._el = e),
              (this._touchZoom = i),
              (this._touchRotate = s),
              (this._tapDragZoom = a),
              (this._rotationDisabled = !1),
              (this._enabled = !0));
          }
          enable(e) {
            (this._touchZoom.enable(e),
              this._rotationDisabled || this._touchRotate.enable(e),
              this._tapDragZoom.enable(),
              this._el.classList.add("maplibregl-touch-zoom-rotate"));
          }
          disable() {
            (this._touchZoom.disable(),
              this._touchRotate.disable(),
              this._tapDragZoom.disable(),
              this._el.classList.remove("maplibregl-touch-zoom-rotate"));
          }
          isEnabled() {
            return (
              this._touchZoom.isEnabled() &&
              (this._rotationDisabled || this._touchRotate.isEnabled()) &&
              this._tapDragZoom.isEnabled()
            );
          }
          isActive() {
            return (
              this._touchZoom.isActive() ||
              this._touchRotate.isActive() ||
              this._tapDragZoom.isActive()
            );
          }
          disableRotation() {
            ((this._rotationDisabled = !0), this._touchRotate.disable());
          }
          enableRotation() {
            ((this._rotationDisabled = !1),
              this._touchZoom.isEnabled() && this._touchRotate.enable());
          }
        }
        class Ya {
          constructor(e, i) {
            ((this._bypassKey =
              navigator.userAgent.indexOf("Mac") !== -1
                ? "metaKey"
                : "ctrlKey"),
              (this._map = e),
              (this._options = i),
              (this._enabled = !1));
          }
          isActive() {
            return !1;
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            (e.classList.add("maplibregl-cooperative-gestures"),
              (this._container = me.create(
                "div",
                "maplibregl-cooperative-gesture-screen",
                e,
              )));
            let i = this._map._getUIString(
              "CooperativeGesturesHandler.WindowsHelpText",
            );
            this._bypassKey === "metaKey" &&
              (i = this._map._getUIString(
                "CooperativeGesturesHandler.MacHelpText",
              ));
            const s = this._map._getUIString(
                "CooperativeGesturesHandler.MobileHelpText",
              ),
              a = document.createElement("div");
            ((a.className = "maplibregl-desktop-message"),
              (a.textContent = i),
              this._container.appendChild(a));
            const h = document.createElement("div");
            ((h.className = "maplibregl-mobile-message"),
              (h.textContent = s),
              this._container.appendChild(h),
              this._container.setAttribute("aria-hidden", "true"));
          }
          _destroyUI() {
            (this._container &&
              (me.remove(this._container),
              this._map
                .getCanvasContainer()
                .classList.remove("maplibregl-cooperative-gestures")),
              delete this._container);
          }
          enable() {
            (this._setupUI(), (this._enabled = !0));
          }
          disable() {
            ((this._enabled = !1), this._destroyUI());
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e) {
            return e[this._bypassKey];
          }
          notifyGestureBlocked(e, i) {
            this._enabled &&
              (this._map.fire(
                new u.k("cooperativegestureprevented", {
                  gestureType: e,
                  originalEvent: i,
                }),
              ),
              this._container.classList.add("maplibregl-show"),
              setTimeout(() => {
                this._container.classList.remove("maplibregl-show");
              }, 100));
          }
        }
        const Ws = (c) => c.zoom || c.drag || c.roll || c.pitch || c.rotate;
        class Dr extends u.k {}
        function po(c) {
          return (
            (c.panDelta && c.panDelta.mag()) ||
            c.zoomDelta ||
            c.bearingDelta ||
            c.pitchDelta ||
            c.rollDelta
          );
        }
        class He {
          constructor(e, i) {
            ((this.handleWindowEvent = (a) => {
              this.handleEvent(a, `${a.type}Window`);
            }),
              (this.handleEvent = (a, h) => {
                if (a.type === "blur") return void this.stop(!0);
                this._updatingCamera = !0;
                const f = a.type === "renderFrame" ? void 0 : a,
                  g = { needsRenderFrame: !1 },
                  y = {},
                  v = {},
                  C = a.touches,
                  A = C ? this._getMapTouches(C) : void 0,
                  T = A
                    ? me.touchPos(this._map.getCanvas(), A)
                    : me.mousePos(this._map.getCanvas(), a);
                for (const { handlerName: V, handler: N, allowed: $ } of this
                  ._handlers) {
                  if (!N.isEnabled()) continue;
                  let G;
                  (this._blockedByActive(v, $, V)
                    ? N.reset()
                    : N[h || a.type] &&
                      ((G = N[h || a.type](a, T, A)),
                      this.mergeHandlerResult(g, y, G, V, f),
                      G && G.needsRenderFrame && this._triggerRenderFrame()),
                    (G || N.isActive()) && (v[V] = N));
                }
                const M = {};
                for (const V in this._previousActiveHandlers)
                  v[V] || (M[V] = f);
                ((this._previousActiveHandlers = v),
                  (Object.keys(M).length || po(g)) &&
                    (this._changes.push([g, y, M]), this._triggerRenderFrame()),
                  (Object.keys(v).length || po(g)) && this._map._stop(!0),
                  (this._updatingCamera = !1));
                const { cameraAnimation: k } = g;
                k &&
                  (this._inertia.clear(),
                  this._fireEvents({}, {}, !0),
                  (this._changes = []),
                  k(this._map));
              }),
              (this._map = e),
              (this._el = this._map.getCanvasContainer()),
              (this._handlers = []),
              (this._handlersById = {}),
              (this._changes = []),
              (this._inertia = new No(e)),
              (this._bearingSnap = i.bearingSnap),
              (this._previousActiveHandlers = {}),
              (this._eventsInProgress = {}),
              this._addDefaultHandlers(i));
            const s = this._el;
            this._listeners = [
              [s, "touchstart", { passive: !0 }],
              [s, "touchmove", { passive: !1 }],
              [s, "touchend", void 0],
              [s, "touchcancel", void 0],
              [s, "mousedown", void 0],
              [s, "mousemove", void 0],
              [s, "mouseup", void 0],
              [document, "mousemove", { capture: !0 }],
              [document, "mouseup", void 0],
              [s, "mouseover", void 0],
              [s, "mouseout", void 0],
              [s, "dblclick", void 0],
              [s, "click", void 0],
              [s, "keydown", { capture: !1 }],
              [s, "keyup", void 0],
              [s, "wheel", { passive: !1 }],
              [s, "contextmenu", void 0],
              [window, "blur", void 0],
            ];
            for (const [a, h, f] of this._listeners)
              me.addEventListener(
                a,
                h,
                a === document ? this.handleWindowEvent : this.handleEvent,
                f,
              );
          }
          destroy() {
            for (const [e, i, s] of this._listeners)
              me.removeEventListener(
                e,
                i,
                e === document ? this.handleWindowEvent : this.handleEvent,
                s,
              );
          }
          _addDefaultHandlers(e) {
            const i = this._map,
              s = i.getCanvasContainer();
            this._add("mapEvent", new co(i, e));
            const a = (i.boxZoom = new fu(i, e));
            (this._add("boxZoom", a), e.interactive && e.boxZoom && a.enable());
            const h = (i.cooperativeGestures = new Ya(
              i,
              e.cooperativeGestures,
            ));
            (this._add("cooperativeGestures", h),
              e.cooperativeGestures && h.enable());
            const f = new Vr(i),
              g = new jt(i);
            ((i.doubleClickZoom = new Ur(g, f)),
              this._add("tapZoom", f),
              this._add("clickZoom", g),
              e.interactive && e.doubleClickZoom && i.doubleClickZoom.enable());
            const y = new Hs();
            this._add("tapDragZoom", y);
            const v = (i.touchPitch = new qs(i));
            (this._add("touchPitch", v),
              e.interactive &&
                e.touchPitch &&
                i.touchPitch.enable(e.touchPitch));
            const C = () => i.project(i.getCenter()),
              A = (function (
                {
                  enable: Q,
                  clickTolerance: ee,
                  aroundCenter: re = !0,
                  minPixelCenterThreshold: ie = 100,
                  rotateDegreesPerPixelMoved: he = 0.8,
                },
                pe,
              ) {
                const be = new On({
                  checkCorrectEvent: (Ee) =>
                    (me.mouseButton(Ee) === 0 && Ee.ctrlKey) ||
                    (me.mouseButton(Ee) === 2 && !Ee.ctrlKey),
                });
                return new Re({
                  clickTolerance: ee,
                  move: (Ee, ye) => {
                    const Be = pe();
                    if (re && Math.abs(Be.y - Ee.y) > ie)
                      return {
                        bearingDelta: u.c7(new u.P(Ee.x, ye.y), ye, Be),
                      };
                    let Me = (ye.x - Ee.x) * he;
                    return (
                      re && ye.y < Be.y && (Me = -Me),
                      { bearingDelta: Me }
                    );
                  },
                  moveStateManager: be,
                  enable: Q,
                  assignEvents: on,
                });
              })(e, C),
              T = (function ({
                enable: Q,
                clickTolerance: ee,
                pitchDegreesPerPixelMoved: re = -0.5,
              }) {
                const ie = new On({
                  checkCorrectEvent: (he) =>
                    (me.mouseButton(he) === 0 && he.ctrlKey) ||
                    me.mouseButton(he) === 2,
                });
                return new Re({
                  clickTolerance: ee,
                  move: (he, pe) => ({ pitchDelta: (pe.y - he.y) * re }),
                  moveStateManager: ie,
                  enable: Q,
                  assignEvents: on,
                });
              })(e),
              M = (function (
                {
                  enable: Q,
                  clickTolerance: ee,
                  rollDegreesPerPixelMoved: re = 0.3,
                },
                ie,
              ) {
                const he = new On({
                  checkCorrectEvent: (pe) =>
                    me.mouseButton(pe) === 2 && pe.ctrlKey,
                });
                return new Re({
                  clickTolerance: ee,
                  move: (pe, be) => {
                    const Ee = ie();
                    let ye = (be.x - pe.x) * re;
                    return (be.y < Ee.y && (ye = -ye), { rollDelta: ye });
                  },
                  moveStateManager: he,
                  enable: Q,
                  assignEvents: on,
                });
              })(e, C);
            ((i.dragRotate = new Wa(e, A, T, M)),
              this._add("mouseRotate", A, ["mousePitch"]),
              this._add("mousePitch", T, ["mouseRotate", "mouseRoll"]),
              this._add("mouseRoll", M, ["mousePitch"]),
              e.interactive && e.dragRotate && i.dragRotate.enable());
            const k = (function ({ enable: Q, clickTolerance: ee }) {
                const re = new On({
                  checkCorrectEvent: (ie) =>
                    me.mouseButton(ie) === 0 && !ie.ctrlKey,
                });
                return new Re({
                  clickTolerance: ee,
                  move: (ie, he) => ({ around: he, panDelta: he.sub(ie) }),
                  activateOnStart: !0,
                  moveStateManager: re,
                  enable: Q,
                  assignEvents: on,
                });
              })(e),
              V = new yu(e, i);
            ((i.dragPan = new Xs(s, k, V)),
              this._add("mousePan", k),
              this._add("touchPan", V, ["touchZoom", "touchRotate"]),
              e.interactive && e.dragPan && i.dragPan.enable(e.dragPan));
            const N = new bu(),
              $ = new Zs();
            ((i.touchZoomRotate = new Ka(s, $, N, y)),
              this._add("touchRotate", N, ["touchPan", "touchZoom"]),
              this._add("touchZoom", $, ["touchPan", "touchRotate"]),
              e.interactive &&
                e.touchZoomRotate &&
                i.touchZoomRotate.enable(e.touchZoomRotate));
            const G = (i.scrollZoom = new Tu(i, () =>
              this._triggerRenderFrame(),
            ));
            (this._add("scrollZoom", G, ["mousePan"]),
              e.interactive &&
                e.scrollZoom &&
                i.scrollZoom.enable(e.scrollZoom));
            const Y = (i.keyboard = new Cu(i));
            (this._add("keyboard", Y),
              e.interactive && e.keyboard && i.keyboard.enable(),
              this._add("blockableMapEvent", new mc(i)));
          }
          _add(e, i, s) {
            (this._handlers.push({ handlerName: e, handler: i, allowed: s }),
              (this._handlersById[e] = i));
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const { handler: i } of this._handlers) i.reset();
              (this._inertia.clear(),
                this._fireEvents({}, {}, e),
                (this._changes = []));
            }
          }
          isActive() {
            for (const { handler: e } of this._handlers)
              if (e.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return (
              !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
            );
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(Ws(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(e, i, s) {
            for (const a in e)
              if (a !== s && (!i || i.indexOf(a) < 0)) return !0;
            return !1;
          }
          _getMapTouches(e) {
            const i = [];
            for (const s of e) this._el.contains(s.target) && i.push(s);
            return i;
          }
          mergeHandlerResult(e, i, s, a, h) {
            if (!s) return;
            u.e(e, s);
            const f = { handlerName: a, originalEvent: s.originalEvent || h };
            (s.zoomDelta !== void 0 && (i.zoom = f),
              s.panDelta !== void 0 && (i.drag = f),
              s.rollDelta !== void 0 && (i.roll = f),
              s.pitchDelta !== void 0 && (i.pitch = f),
              s.bearingDelta !== void 0 && (i.rotate = f));
          }
          _applyChanges() {
            const e = {},
              i = {},
              s = {};
            for (const [a, h, f] of this._changes)
              (a.panDelta &&
                (e.panDelta = (e.panDelta || new u.P(0, 0))._add(a.panDelta)),
                a.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + a.zoomDelta),
                a.bearingDelta &&
                  (e.bearingDelta = (e.bearingDelta || 0) + a.bearingDelta),
                a.pitchDelta &&
                  (e.pitchDelta = (e.pitchDelta || 0) + a.pitchDelta),
                a.rollDelta && (e.rollDelta = (e.rollDelta || 0) + a.rollDelta),
                a.around !== void 0 && (e.around = a.around),
                a.pinchAround !== void 0 && (e.pinchAround = a.pinchAround),
                a.noInertia && (e.noInertia = a.noInertia),
                u.e(i, h),
                u.e(s, f));
            (this._updateMapTransform(e, i, s), (this._changes = []));
          }
          _updateMapTransform(e, i, s) {
            const a = this._map,
              h = a._getTransformForUpdate(),
              f = a.terrain;
            if (!(po(e) || (f && this._terrainMovement)))
              return this._fireEvents(i, s, !0);
            a._stop(!0);
            let {
              panDelta: g,
              zoomDelta: y,
              bearingDelta: v,
              pitchDelta: C,
              rollDelta: A,
              around: T,
              pinchAround: M,
            } = e;
            (M !== void 0 && (T = M),
              (T = T || a.transform.centerPoint),
              f && !h.isPointOnMapSurface(T) && (T = h.centerPoint));
            const k = {
              panDelta: g,
              zoomDelta: y,
              rollDelta: A,
              pitchDelta: C,
              bearingDelta: v,
              around: T,
            };
            this._map.cameraHelper.useGlobeControls &&
              !h.isPointOnMapSurface(T) &&
              (T = h.centerPoint);
            const V =
              T.distSqr(h.centerPoint) < 0.01
                ? h.center
                : h.screenPointToLocation(g ? T.sub(g) : T);
            (f
              ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(
                  k,
                  h,
                ),
                this._terrainMovement || (!i.drag && !i.zoom)
                  ? i.drag && this._terrainMovement
                    ? h.setCenter(h.screenPointToLocation(h.centerPoint.sub(g)))
                    : this._map.cameraHelper.handleMapControlsPan(k, h, V)
                  : ((this._terrainMovement = !0),
                    (this._map._elevationFreeze = !0),
                    this._map.cameraHelper.handleMapControlsPan(k, h, V)))
              : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(
                  k,
                  h,
                ),
                this._map.cameraHelper.handleMapControlsPan(k, h, V)),
              a._applyUpdatedTransform(h),
              this._map._update(),
              e.noInertia || this._inertia.record(e),
              this._fireEvents(i, s, !0));
          }
          _fireEvents(e, i, s) {
            const a = Ws(this._eventsInProgress),
              h = Ws(e),
              f = {};
            for (const A in e) {
              const { originalEvent: T } = e[A];
              (this._eventsInProgress[A] || (f[`${A}start`] = T),
                (this._eventsInProgress[A] = e[A]));
            }
            !a && h && this._fireEvent("movestart", h.originalEvent);
            for (const A in f) this._fireEvent(A, f[A]);
            h && this._fireEvent("move", h.originalEvent);
            for (const A in e) {
              const { originalEvent: T } = e[A];
              this._fireEvent(A, T);
            }
            const g = {};
            let y;
            for (const A in this._eventsInProgress) {
              const { handlerName: T, originalEvent: M } =
                this._eventsInProgress[A];
              this._handlersById[T].isActive() ||
                (delete this._eventsInProgress[A],
                (y = i[T] || M),
                (g[`${A}end`] = y));
            }
            for (const A in g) this._fireEvent(A, g[A]);
            const v = Ws(this._eventsInProgress),
              C = (a || h) && !v;
            if (C && this._terrainMovement) {
              ((this._map._elevationFreeze = !1), (this._terrainMovement = !1));
              const A = this._map._getTransformForUpdate();
              (this._map.getCenterClampedToGround() &&
                A.recalculateZoomAndCenter(this._map.terrain),
                this._map._applyUpdatedTransform(A));
            }
            if (s && C) {
              this._updatingCamera = !0;
              const A = this._inertia._onMoveEnd(
                  this._map.dragPan._inertiaOptions,
                ),
                T = (M) =>
                  M !== 0 && -this._bearingSnap < M && M < this._bearingSnap;
              (!A || (!A.essential && Qe.prefersReducedMotion)
                ? (this._map.fire(new u.k("moveend", { originalEvent: y })),
                  T(this._map.getBearing()) && this._map.resetNorth())
                : (T(A.bearing || this._map.getBearing()) && (A.bearing = 0),
                  (A.freezeElevation = !0),
                  this._map.easeTo(A, { originalEvent: y })),
                (this._updatingCamera = !1));
            }
          }
          _fireEvent(e, i) {
            this._map.fire(new u.k(e, i ? { originalEvent: i } : {}));
          }
          _requestFrame() {
            return (
              this._map.triggerRepaint(),
              this._map._renderTaskQueue.add((e) => {
                (delete this._frameId,
                  this.handleEvent(new Dr("renderFrame", { timeStamp: e })),
                  this._applyChanges());
              })
            );
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class et extends u.E {
          constructor(e, i, s) {
            (super(),
              (this._renderFrameCallback = () => {
                const a = Math.min(
                  (Qe.now() - this._easeStart) / this._easeOptions.duration,
                  1,
                );
                (this._onEaseFrame(this._easeOptions.easing(a)),
                  a < 1 && this._easeFrameId
                    ? (this._easeFrameId = this._requestRenderFrame(
                        this._renderFrameCallback,
                      ))
                    : this.stop());
              }),
              (this._moving = !1),
              (this._zooming = !1),
              (this.transform = e),
              (this._bearingSnap = s.bearingSnap),
              (this.cameraHelper = i),
              this.on("moveend", () => {
                delete this._requestedCameraState;
              }));
          }
          migrateProjection(e, i) {
            (e.apply(this.transform),
              (this.transform = e),
              (this.cameraHelper = i));
          }
          getCenter() {
            return new u.N(
              this.transform.center.lng,
              this.transform.center.lat,
            );
          }
          setCenter(e, i) {
            return this.jumpTo({ center: e }, i);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e, i) {
            return (this.jumpTo({ elevation: e }, i), this);
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e;
          }
          panBy(e, i, s) {
            return (
              (e = u.P.convert(e).mult(-1)),
              this.panTo(this.transform.center, u.e({ offset: e }, i), s)
            );
          }
          panTo(e, i, s) {
            return this.easeTo(u.e({ center: e }, i), s);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e, i) {
            return (this.jumpTo({ zoom: e }, i), this);
          }
          zoomTo(e, i, s) {
            return this.easeTo(u.e({ zoom: e }, i), s);
          }
          zoomIn(e, i) {
            return (this.zoomTo(this.getZoom() + 1, e, i), this);
          }
          zoomOut(e, i) {
            return (this.zoomTo(this.getZoom() - 1, e, i), this);
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e, i) {
            return (
              e != this.transform.fov &&
                (this.transform.setFov(e),
                this.fire(new u.k("movestart", i))
                  .fire(new u.k("move", i))
                  .fire(new u.k("moveend", i))),
              this
            );
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e, i) {
            return (this.jumpTo({ bearing: e }, i), this);
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e, i) {
            return (this.jumpTo({ padding: e }, i), this);
          }
          rotateTo(e, i, s) {
            return this.easeTo(u.e({ bearing: e }, i), s);
          }
          resetNorth(e, i) {
            return (this.rotateTo(0, u.e({ duration: 1e3 }, e), i), this);
          }
          resetNorthPitch(e, i) {
            return (
              this.easeTo(
                u.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e),
                i,
              ),
              this
            );
          }
          snapToNorth(e, i) {
            return Math.abs(this.getBearing()) < this._bearingSnap
              ? this.resetNorth(e, i)
              : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e, i) {
            return (this.jumpTo({ pitch: e }, i), this);
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e, i) {
            return (this.jumpTo({ roll: e }, i), this);
          }
          cameraForBounds(e, i) {
            e = ti.convert(e).adjustAntiMeridian();
            const s = (i && i.bearing) || 0;
            return this._cameraForBoxAndBearing(
              e.getNorthWest(),
              e.getSouthEast(),
              s,
              i,
            );
          }
          _cameraForBoxAndBearing(e, i, s, a) {
            const h = { top: 0, bottom: 0, right: 0, left: 0 };
            if (
              typeof (a = u.e(
                { padding: h, offset: [0, 0], maxZoom: this.transform.maxZoom },
                a,
              )).padding == "number"
            ) {
              const v = a.padding;
              a.padding = { top: v, bottom: v, right: v, left: v };
            }
            const f = u.e(h, a.padding);
            a.padding = f;
            const g = this.transform,
              y = new ti(e, i);
            return this.cameraHelper.cameraForBoxAndBearing(a, f, y, s, g);
          }
          fitBounds(e, i, s) {
            return this._fitInternal(this.cameraForBounds(e, i), i, s);
          }
          fitScreenCoordinates(e, i, s, a, h) {
            return this._fitInternal(
              this._cameraForBoxAndBearing(
                this.transform.screenPointToLocation(u.P.convert(e)),
                this.transform.screenPointToLocation(u.P.convert(i)),
                s,
                a,
              ),
              a,
              h,
            );
          }
          _fitInternal(e, i, s) {
            return e
              ? (delete (i = u.e(e, i)).padding,
                i.linear ? this.easeTo(i, s) : this.flyTo(i, s))
              : this;
          }
          jumpTo(e, i) {
            this.stop();
            const s = this._getTransformForUpdate();
            let a = !1,
              h = !1,
              f = !1;
            const g = s.zoom;
            this.cameraHelper.handleJumpToCenterZoom(s, e);
            const y = s.zoom !== g;
            return (
              "elevation" in e &&
                s.elevation !== +e.elevation &&
                s.setElevation(+e.elevation),
              "bearing" in e &&
                s.bearing !== +e.bearing &&
                ((a = !0), s.setBearing(+e.bearing)),
              "pitch" in e &&
                s.pitch !== +e.pitch &&
                ((h = !0), s.setPitch(+e.pitch)),
              "roll" in e &&
                s.roll !== +e.roll &&
                ((f = !0), s.setRoll(+e.roll)),
              e.padding == null ||
                s.isPaddingEqual(e.padding) ||
                s.setPadding(e.padding),
              this._applyUpdatedTransform(s),
              this.fire(new u.k("movestart", i)).fire(new u.k("move", i)),
              y &&
                this.fire(new u.k("zoomstart", i))
                  .fire(new u.k("zoom", i))
                  .fire(new u.k("zoomend", i)),
              a &&
                this.fire(new u.k("rotatestart", i))
                  .fire(new u.k("rotate", i))
                  .fire(new u.k("rotateend", i)),
              h &&
                this.fire(new u.k("pitchstart", i))
                  .fire(new u.k("pitch", i))
                  .fire(new u.k("pitchend", i)),
              f &&
                this.fire(new u.k("rollstart", i))
                  .fire(new u.k("roll", i))
                  .fire(new u.k("rollend", i)),
              this.fire(new u.k("moveend", i))
            );
          }
          calculateCameraOptionsFromTo(e, i, s, a = 0) {
            const h = u.Y.fromLngLat(e, i),
              f = u.Y.fromLngLat(s, a),
              g = f.x - h.x,
              y = f.y - h.y,
              v = f.z - h.z,
              C = Math.hypot(g, y, v);
            if (C === 0)
              throw new Error(
                "Can't calculate camera options with same From and To",
              );
            const A = Math.hypot(g, y),
              T = u.a8(
                this.transform.cameraToCenterDistance /
                  C /
                  this.transform.tileSize,
              ),
              M = (180 * Math.atan2(g, -y)) / Math.PI;
            let k = (180 * Math.acos(A / C)) / Math.PI;
            return (
              (k = v < 0 ? 90 - k : 90 + k),
              {
                center: f.toLngLat(),
                elevation: a,
                zoom: T,
                pitch: k,
                bearing: M,
              }
            );
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, i, s, a, h) {
            const f = this.transform.calculateCenterFromCameraLngLatAlt(
              e,
              i,
              s,
              a,
            );
            return {
              center: f.center,
              elevation: f.elevation,
              zoom: f.zoom,
              bearing: s,
              pitch: a,
              roll: h,
            };
          }
          easeTo(e, i) {
            (this._stop(!1, e.easeId),
              ((e = u.e({ offset: [0, 0], duration: 500, easing: u.c8 }, e))
                .animate === !1 ||
                (!e.essential && Qe.prefersReducedMotion)) &&
                (e.duration = 0));
            const s = this._getTransformForUpdate(),
              a = this.getBearing(),
              h = s.pitch,
              f = s.roll,
              g = "bearing" in e ? this._normalizeBearing(e.bearing, a) : a,
              y = "pitch" in e ? +e.pitch : h,
              v = "roll" in e ? this._normalizeBearing(e.roll, f) : f,
              C = "padding" in e ? e.padding : s.padding,
              A = u.P.convert(e.offset);
            let T, M;
            e.around &&
              ((T = u.N.convert(e.around)), (M = s.locationToScreenPoint(T)));
            const k = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling,
              },
              V = this.cameraHelper.handleEaseTo(s, {
                bearing: g,
                pitch: y,
                roll: v,
                padding: C,
                around: T,
                aroundPoint: M,
                offsetAsPoint: A,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center,
              });
            return (
              (this._rotating = this._rotating || a !== g),
              (this._pitching = this._pitching || y !== h),
              (this._rolling = this._rolling || v !== f),
              (this._padding = !s.isPaddingEqual(C)),
              (this._zooming = this._zooming || V.isZooming),
              (this._easeId = e.easeId),
              this._prepareEase(i, e.noMoveStart, k),
              this.terrain && this._prepareElevation(V.elevationCenter),
              this._ease(
                (N) => {
                  (V.easeFunc(N),
                    this.terrain &&
                      !e.freezeElevation &&
                      this._updateElevation(N),
                    this._applyUpdatedTransform(s),
                    this._fireMoveEvents(i));
                },
                (N) => {
                  (this.terrain &&
                    e.freezeElevation &&
                    this._finalizeElevation(),
                    this._afterEase(i, N));
                },
                e,
              ),
              this
            );
          }
          _prepareEase(e, i, s = {}) {
            ((this._moving = !0),
              i || s.moving || this.fire(new u.k("movestart", e)),
              this._zooming && !s.zooming && this.fire(new u.k("zoomstart", e)),
              this._rotating &&
                !s.rotating &&
                this.fire(new u.k("rotatestart", e)),
              this._pitching &&
                !s.pitching &&
                this.fire(new u.k("pitchstart", e)),
              this._rolling &&
                !s.rolling &&
                this.fire(new u.k("rollstart", e)));
          }
          _prepareElevation(e) {
            ((this._elevationCenter = e),
              (this._elevationStart = this.transform.elevation),
              (this._elevationTarget = this.terrain.getElevationForLngLatZoom(
                e,
                this.transform.tileZoom,
              )),
              (this._elevationFreeze = !0));
          }
          _updateElevation(e) {
            this.transform.setMinElevationForCurrentTile(
              this.terrain.getMinTileElevationForLngLatZoom(
                this._elevationCenter,
                this.transform.tileZoom,
              ),
            );
            const i = this.terrain.getElevationForLngLatZoom(
              this._elevationCenter,
              this.transform.tileZoom,
            );
            if (e < 1 && i !== this._elevationTarget) {
              const s = this._elevationTarget - this._elevationStart;
              ((this._elevationStart +=
                e * (s - (i - (s * e + this._elevationStart)) / (1 - e))),
                (this._elevationTarget = i));
            }
            this.transform.setElevation(
              u.y.number(this._elevationStart, this._elevationTarget, e),
            );
          }
          _finalizeElevation() {
            ((this._elevationFreeze = !1),
              this.getCenterClampedToGround() &&
                this.transform.recalculateZoomAndCenter(this.terrain));
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain
              ? (this._requestedCameraState ||
                  (this._requestedCameraState = this.transform.clone()),
                this._requestedCameraState)
              : this.transform;
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const i = e.getCameraLngLat(),
              s = e.getCameraAltitude(),
              a = this.terrain
                ? this.terrain.getElevationForLngLatZoom(i, e.zoom)
                : 0;
            if (s < a) {
              const h = this.calculateCameraOptionsFromTo(
                i,
                a,
                e.center,
                e.elevation,
              );
              return { pitch: h.pitch, zoom: h.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e) {
            const i = [];
            if (
              (i.push((a) => this._elevateCameraIfInsideTerrain(a)),
              this.transformCameraUpdate &&
                i.push((a) => this.transformCameraUpdate(a)),
              !i.length)
            )
              return;
            const s = e.clone();
            for (const a of i) {
              const h = s.clone(),
                {
                  center: f,
                  zoom: g,
                  roll: y,
                  pitch: v,
                  bearing: C,
                  elevation: A,
                } = a(h);
              (f && h.setCenter(f),
                A !== void 0 && h.setElevation(A),
                g !== void 0 && h.setZoom(g),
                y !== void 0 && h.setRoll(y),
                v !== void 0 && h.setPitch(v),
                C !== void 0 && h.setBearing(C),
                s.apply(h));
            }
            this.transform.apply(s);
          }
          _fireMoveEvents(e) {
            (this.fire(new u.k("move", e)),
              this._zooming && this.fire(new u.k("zoom", e)),
              this._rotating && this.fire(new u.k("rotate", e)),
              this._pitching && this.fire(new u.k("pitch", e)),
              this._rolling && this.fire(new u.k("roll", e)));
          }
          _afterEase(e, i) {
            if (this._easeId && i && this._easeId === i) return;
            delete this._easeId;
            const s = this._zooming,
              a = this._rotating,
              h = this._pitching,
              f = this._rolling;
            ((this._moving = !1),
              (this._zooming = !1),
              (this._rotating = !1),
              (this._pitching = !1),
              (this._rolling = !1),
              (this._padding = !1),
              s && this.fire(new u.k("zoomend", e)),
              a && this.fire(new u.k("rotateend", e)),
              h && this.fire(new u.k("pitchend", e)),
              f && this.fire(new u.k("rollend", e)),
              this.fire(new u.k("moveend", e)));
          }
          flyTo(e, i) {
            if (!e.essential && Qe.prefersReducedMotion) {
              const ye = u.M(e, [
                "center",
                "zoom",
                "bearing",
                "pitch",
                "roll",
                "elevation",
              ]);
              return this.jumpTo(ye, i);
            }
            (this.stop(),
              (e = u.e(
                { offset: [0, 0], speed: 1.2, curve: 1.42, easing: u.c8 },
                e,
              )));
            const s = this._getTransformForUpdate(),
              a = s.bearing,
              h = s.pitch,
              f = s.roll,
              g = s.padding,
              y = "bearing" in e ? this._normalizeBearing(e.bearing, a) : a,
              v = "pitch" in e ? +e.pitch : h,
              C = "roll" in e ? this._normalizeBearing(e.roll, f) : f,
              A = "padding" in e ? e.padding : s.padding,
              T = u.P.convert(e.offset);
            let M = s.centerPoint.add(T);
            const k = s.screenPointToLocation(M),
              V = this.cameraHelper.handleFlyTo(s, {
                bearing: y,
                pitch: v,
                roll: C,
                padding: A,
                locationAtOffset: k,
                offsetAsPoint: T,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom,
              });
            let N = e.curve;
            const $ = Math.max(s.width, s.height),
              G = $ / V.scaleOfZoom,
              Y = V.pixelPathLength;
            typeof V.scaleOfMinZoom == "number" &&
              (N = Math.sqrt(($ / V.scaleOfMinZoom / Y) * 2));
            const Q = N * N;
            function ee(ye) {
              const Be =
                (G * G - $ * $ + (ye ? -1 : 1) * Q * Q * Y * Y) /
                (2 * (ye ? G : $) * Q * Y);
              return Math.log(Math.sqrt(Be * Be + 1) - Be);
            }
            function re(ye) {
              return (Math.exp(ye) - Math.exp(-ye)) / 2;
            }
            function ie(ye) {
              return (Math.exp(ye) + Math.exp(-ye)) / 2;
            }
            const he = ee(!1);
            let pe = function (ye) {
                return ie(he) / ie(he + N * ye);
              },
              be = function (ye) {
                return (
                  ($ *
                    ((ie(he) * (re((Be = he + N * ye)) / ie(Be)) - re(he)) /
                      Q)) /
                  Y
                );
                var Be;
              },
              Ee = (ee(!0) - he) / N;
            if (Math.abs(Y) < 2e-6 || !isFinite(Ee)) {
              if (Math.abs($ - G) < 1e-6) return this.easeTo(e, i);
              const ye = G < $ ? -1 : 1;
              ((Ee = Math.abs(Math.log(G / $)) / N),
                (be = () => 0),
                (pe = (Be) => Math.exp(ye * N * Be)));
            }
            return (
              (e.duration =
                "duration" in e
                  ? +e.duration
                  : (1e3 * Ee) /
                    ("screenSpeed" in e ? +e.screenSpeed / N : +e.speed)),
              e.maxDuration && e.duration > e.maxDuration && (e.duration = 0),
              (this._zooming = !0),
              (this._rotating = a !== y),
              (this._pitching = v !== h),
              (this._rolling = C !== f),
              (this._padding = !s.isPaddingEqual(A)),
              this._prepareEase(i, !1),
              this.terrain && this._prepareElevation(V.targetCenter),
              this._ease(
                (ye) => {
                  const Be = ye * Ee,
                    Me = 1 / pe(Be),
                    Fe = be(Be);
                  (this._rotating && s.setBearing(u.y.number(a, y, ye)),
                    this._pitching && s.setPitch(u.y.number(h, v, ye)),
                    this._rolling && s.setRoll(u.y.number(f, C, ye)),
                    this._padding &&
                      (s.interpolatePadding(g, A, ye),
                      (M = s.centerPoint.add(T))),
                    V.easeFunc(ye, Me, Fe, M),
                    this.terrain &&
                      !e.freezeElevation &&
                      this._updateElevation(ye),
                    this._applyUpdatedTransform(s),
                    this._fireMoveEvents(i));
                },
                () => {
                  (this.terrain &&
                    e.freezeElevation &&
                    this._finalizeElevation(),
                    this._afterEase(i));
                },
                e,
              ),
              this
            );
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e, i) {
            var s;
            if (
              (this._easeFrameId &&
                (this._cancelRenderFrame(this._easeFrameId),
                delete this._easeFrameId,
                delete this._onEaseFrame),
              this._onEaseEnd)
            ) {
              const a = this._onEaseEnd;
              (delete this._onEaseEnd, a.call(this, i));
            }
            return (
              e || (s = this.handlers) === null || s === void 0 || s.stop(!1),
              this
            );
          }
          _ease(e, i, s) {
            s.animate === !1 || s.duration === 0
              ? (e(1), i())
              : ((this._easeStart = Qe.now()),
                (this._easeOptions = s),
                (this._onEaseFrame = e),
                (this._onEaseEnd = i),
                (this._easeFrameId = this._requestRenderFrame(
                  this._renderFrameCallback,
                )));
          }
          _normalizeBearing(e, i) {
            e = u.aI(e, -180, 180);
            const s = Math.abs(e - i);
            return (
              Math.abs(e - 360 - i) < s && (e -= 360),
              Math.abs(e + 360 - i) < s && (e += 360),
              e
            );
          }
          queryTerrainElevation(e) {
            return this.terrain
              ? this.terrain.getElevationForLngLatZoom(
                  u.N.convert(e),
                  this.transform.tileZoom,
                )
              : null;
          }
        }
        const $o = {
          compact: !0,
          customAttribution:
            "<a href=\"https://maplibre.org/\" target=\"_blank\">MapLibre</a>",
        };
        class Ks {
          constructor(e = $o) {
            ((this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") &&
                (this._container.classList.contains("maplibregl-compact-show")
                  ? (this._container.setAttribute("open", ""),
                    this._container.classList.remove("maplibregl-compact-show"))
                  : (this._container.classList.add("maplibregl-compact-show"),
                    this._container.removeAttribute("open")));
            }),
              (this._updateData = (i) => {
                !i ||
                  (i.sourceDataType !== "metadata" &&
                    i.sourceDataType !== "visibility" &&
                    i.dataType !== "style" &&
                    i.type !== "terrain") ||
                  this._updateAttributions();
              }),
              (this._updateCompact = () => {
                this._map.getCanvasContainer().offsetWidth <= 640 ||
                this._compact
                  ? this._compact === !1
                    ? this._container.setAttribute("open", "")
                    : this._container.classList.contains(
                        "maplibregl-compact",
                      ) ||
                      this._container.classList.contains(
                        "maplibregl-attrib-empty",
                      ) ||
                      (this._container.setAttribute("open", ""),
                      this._container.classList.add(
                        "maplibregl-compact",
                        "maplibregl-compact-show",
                      ))
                  : (this._container.setAttribute("open", ""),
                    this._container.classList.contains("maplibregl-compact") &&
                      this._container.classList.remove(
                        "maplibregl-compact",
                        "maplibregl-compact-show",
                      ));
              }),
              (this._updateCompactMinimize = () => {
                this._container.classList.contains("maplibregl-compact") &&
                  this._container.classList.contains(
                    "maplibregl-compact-show",
                  ) &&
                  this._container.classList.remove("maplibregl-compact-show");
              }),
              (this.options = e));
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e) {
            return (
              (this._map = e),
              (this._compact = this.options.compact),
              (this._container = me.create(
                "details",
                "maplibregl-ctrl maplibregl-ctrl-attrib",
              )),
              (this._compactButton = me.create(
                "summary",
                "maplibregl-ctrl-attrib-button",
                this._container,
              )),
              this._compactButton.addEventListener(
                "click",
                this._toggleAttribution,
              ),
              this._setElementTitle(this._compactButton, "ToggleAttribution"),
              (this._innerContainer = me.create(
                "div",
                "maplibregl-ctrl-attrib-inner",
                this._container,
              )),
              this._updateAttributions(),
              this._updateCompact(),
              this._map.on("styledata", this._updateData),
              this._map.on("sourcedata", this._updateData),
              this._map.on("terrain", this._updateData),
              this._map.on("resize", this._updateCompact),
              this._map.on("drag", this._updateCompactMinimize),
              this._container
            );
          }
          onRemove() {
            (me.remove(this._container),
              this._map.off("styledata", this._updateData),
              this._map.off("sourcedata", this._updateData),
              this._map.off("terrain", this._updateData),
              this._map.off("resize", this._updateCompact),
              this._map.off("drag", this._updateCompactMinimize),
              (this._map = void 0),
              (this._compact = void 0),
              (this._sanitizedAttributionHTML = void 0));
          }
          _setElementTitle(e, i) {
            const s = this._map._getUIString(`AttributionControl.${i}`);
            ((e.title = s), e.setAttribute("aria-label", s));
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (
              (this.options.customAttribution &&
                (Array.isArray(this.options.customAttribution)
                  ? (e = e.concat(
                      this.options.customAttribution.map((a) =>
                        typeof a != "string" ? "" : a,
                      ),
                    ))
                  : typeof this.options.customAttribution == "string" &&
                    e.push(this.options.customAttribution)),
              this._map.style.stylesheet)
            ) {
              const a = this._map.style.stylesheet;
              ((this.styleOwner = a.owner), (this.styleId = a.id));
            }
            const i = this._map.style.sourceCaches;
            for (const a in i) {
              const h = i[a];
              if (h.used || h.usedForTerrain) {
                const f = h.getSource();
                f.attribution &&
                  e.indexOf(f.attribution) < 0 &&
                  e.push(f.attribution);
              }
            }
            ((e = e.filter((a) => String(a).trim())),
              e.sort((a, h) => a.length - h.length),
              (e = e.filter((a, h) => {
                for (let f = h + 1; f < e.length; f++)
                  if (e[f].indexOf(a) >= 0) return !1;
                return !0;
              })));
            const s = e.join(" | ");
            s !== this._sanitizedAttributionHTML &&
              ((this._sanitizedAttributionHTML = me.sanitize(s)),
              e.length
                ? ((this._innerContainer.innerHTML =
                    this._sanitizedAttributionHTML),
                  this._container.classList.remove("maplibregl-attrib-empty"))
                : this._container.classList.add("maplibregl-attrib-empty"),
              this._updateCompact(),
              (this._editLink = null));
          }
        }
        class Ys {
          constructor(e = {}) {
            ((this._updateCompact = () => {
              const i = this._container.children;
              if (i.length) {
                const s = i[0];
                this._map.getCanvasContainer().offsetWidth <= 640 ||
                this._compact
                  ? this._compact !== !1 &&
                    s.classList.add("maplibregl-compact")
                  : s.classList.remove("maplibregl-compact");
              }
            }),
              (this.options = e));
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            ((this._map = e),
              (this._compact = this.options && this.options.compact),
              (this._container = me.create("div", "maplibregl-ctrl")));
            const i = me.create("a", "maplibregl-ctrl-logo");
            return (
              (i.target = "_blank"),
              (i.rel = "noopener nofollow"),
              (i.href = "https://maplibre.org/"),
              i.setAttribute(
                "aria-label",
                this._map._getUIString("LogoControl.Title"),
              ),
              i.setAttribute("rel", "noopener nofollow"),
              this._container.appendChild(i),
              (this._container.style.display = "block"),
              this._map.on("resize", this._updateCompact),
              this._updateCompact(),
              this._container
            );
          }
          onRemove() {
            (me.remove(this._container),
              this._map.off("resize", this._updateCompact),
              (this._map = void 0),
              (this._compact = void 0));
          }
        }
        class $i {
          constructor() {
            ((this._queue = []),
              (this._id = 0),
              (this._cleared = !1),
              (this._currentlyRunning = !1));
          }
          add(e) {
            const i = ++this._id;
            return (this._queue.push({ callback: e, id: i, cancelled: !1 }), i);
          }
          remove(e) {
            const i = this._currentlyRunning,
              s = i ? this._queue.concat(i) : this._queue;
            for (const a of s) if (a.id === e) return void (a.cancelled = !0);
          }
          run(e = 0) {
            if (this._currentlyRunning)
              throw new Error("Attempting to run(), but is already running.");
            const i = (this._currentlyRunning = this._queue);
            this._queue = [];
            for (const s of i)
              if (!s.cancelled && (s.callback(e), this._cleared)) break;
            ((this._cleared = !1), (this._currentlyRunning = !1));
          }
          clear() {
            (this._currentlyRunning && (this._cleared = !0),
              (this._queue = []));
          }
        }
        var Fu = u.aA([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class Mr extends u.E {
          constructor(e) {
            (super(),
              (this._lastTilesetChange = Qe.now()),
              (this.sourceCache = e),
              (this._tiles = {}),
              (this._renderableTilesKeys = []),
              (this._sourceTileCache = {}),
              (this.minzoom = 0),
              (this.maxzoom = 22),
              (this.deltaZoom = 1),
              (this.tileSize = e._source.tileSize * 2 ** this.deltaZoom),
              (e.usedForTerrain = !0),
              (e.tileSize = this.tileSize));
          }
          destruct() {
            ((this.sourceCache.usedForTerrain = !1),
              (this.sourceCache.tileSize = null));
          }
          update(e, i) {
            (this.sourceCache.update(e, i), (this._renderableTilesKeys = []));
            const s = {};
            for (const a of j(e, {
              tileSize: this.tileSize,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              reparseOverscaled: !1,
              terrain: i,
              calculateTileZoom: this.sourceCache._source.calculateTileZoom,
            }))
              ((s[a.key] = !0),
                this._renderableTilesKeys.push(a.key),
                this._tiles[a.key] ||
                  ((a.terrainRttPosMatrix32f = new Float64Array(16)),
                  u.bL(a.terrainRttPosMatrix32f, 0, u.X, u.X, 0, 0, 1),
                  (this._tiles[a.key] = new wn(a, this.tileSize)),
                  (this._lastTilesetChange = Qe.now())));
            for (const a in this._tiles) s[a] || delete this._tiles[a];
          }
          freeRtt(e) {
            for (const i in this._tiles) {
              const s = this._tiles[i];
              (!e ||
                s.tileID.equals(e) ||
                s.tileID.isChildOf(e) ||
                e.isChildOf(s.tileID)) &&
                (s.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e) => this.getTileByID(e));
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          getTerrainCoords(e) {
            const i = {};
            for (const s of this._renderableTilesKeys) {
              const a = this._tiles[s].tileID,
                h = e.clone(),
                f = u.a$();
              if (a.canonical.equals(e.canonical))
                u.bL(f, 0, u.X, u.X, 0, 0, 1);
              else if (a.canonical.isChildOf(e.canonical)) {
                const g = a.canonical.z - e.canonical.z,
                  y = a.canonical.x - ((a.canonical.x >> g) << g),
                  v = a.canonical.y - ((a.canonical.y >> g) << g),
                  C = u.X >> g;
                (u.bL(f, 0, C, C, 0, 0, 1), u.J(f, f, [-y * C, -v * C, 0]));
              } else {
                if (!e.canonical.isChildOf(a.canonical)) continue;
                {
                  const g = e.canonical.z - a.canonical.z,
                    y = e.canonical.x - ((e.canonical.x >> g) << g),
                    v = e.canonical.y - ((e.canonical.y >> g) << g),
                    C = u.X >> g;
                  (u.bL(f, 0, u.X, u.X, 0, 0, 1),
                    u.J(f, f, [y * C, v * C, 0]),
                    u.K(f, f, [1 / 2 ** g, 1 / 2 ** g, 0]));
                }
              }
              ((h.terrainRttPosMatrix32f = new Float32Array(f)), (i[s] = h));
            }
            return i;
          }
          getSourceTile(e, i) {
            const s = this.sourceCache._source;
            let a = e.overscaledZ - this.deltaZoom;
            if ((a > s.maxzoom && (a = s.maxzoom), a < s.minzoom)) return null;
            this._sourceTileCache[e.key] ||
              (this._sourceTileCache[e.key] = e.scaledTo(a).key);
            let h = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!h || !h.dem) && i)
              for (; a >= s.minzoom && (!h || !h.dem); )
                h = this.sourceCache.getTileByID(e.scaledTo(a--).key);
            return h;
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e;
          }
        }
        class gc {
          constructor(e, i, s) {
            ((this._meshCache = {}),
              (this.painter = e),
              (this.sourceCache = new Mr(i)),
              (this.options = s),
              (this.exaggeration =
                typeof s.exaggeration == "number" ? s.exaggeration : 1),
              (this.qualityFactor = 2),
              (this.meshSize = 128),
              (this._demMatrixCache = {}),
              (this.coordsIndex = []),
              (this._coordsTextureSize = 1024));
          }
          getDEMElevation(e, i, s, a = u.X) {
            var h;
            if (!(i >= 0 && i < a && s >= 0 && s < a)) return 0;
            const f = this.getTerrainData(e),
              g = (h = f.tile) === null || h === void 0 ? void 0 : h.dem;
            if (!g) return 0;
            const y = u.c9(
                [],
                [(i / a) * u.X, (s / a) * u.X],
                f.u_terrain_matrix,
              ),
              v = [y[0] * g.dim, y[1] * g.dim],
              C = Math.floor(v[0]),
              A = Math.floor(v[1]),
              T = v[0] - C,
              M = v[1] - A;
            return (
              g.get(C, A) * (1 - T) * (1 - M) +
              g.get(C + 1, A) * T * (1 - M) +
              g.get(C, A + 1) * (1 - T) * M +
              g.get(C + 1, A + 1) * T * M
            );
          }
          getElevationForLngLatZoom(e, i) {
            if (!u.ca(i, e.wrap())) return 0;
            const {
              tileID: s,
              mercatorX: a,
              mercatorY: h,
            } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return this.getElevation(s, a % u.X, h % u.X, u.X);
          }
          getElevation(e, i, s, a = u.X) {
            return this.getDEMElevation(e, i, s, a) * this.exaggeration;
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const a = this.painter.context,
                h = new u.R({ width: 1, height: 1 }, new Uint8Array(4));
              ((this._emptyDepthTexture = new Bt(a, h, a.gl.RGBA, {
                premultiply: !1,
              })),
                (this._emptyDemUnpack = [0, 0, 0, 0]),
                (this._emptyDemTexture = new Bt(
                  a,
                  new u.R({ width: 1, height: 1 }),
                  a.gl.RGBA,
                  { premultiply: !1 },
                )),
                this._emptyDemTexture.bind(a.gl.NEAREST, a.gl.CLAMP_TO_EDGE),
                (this._emptyDemMatrix = u.aq([])));
            }
            const i = this.sourceCache.getSourceTile(e, !0);
            if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
              const a = this.painter.context;
              ((i.demTexture = this.painter.getTileTexture(i.dem.stride)),
                i.demTexture
                  ? i.demTexture.update(i.dem.getPixels(), { premultiply: !1 })
                  : (i.demTexture = new Bt(a, i.dem.getPixels(), a.gl.RGBA, {
                      premultiply: !1,
                    })),
                i.demTexture.bind(a.gl.NEAREST, a.gl.CLAMP_TO_EDGE),
                (i.needsTerrainPrepare = !1));
            }
            const s = i && i + i.tileID.key + e.key;
            if (s && !this._demMatrixCache[s]) {
              const a = this.sourceCache.sourceCache._source.maxzoom;
              let h = e.canonical.z - i.tileID.canonical.z;
              e.overscaledZ > e.canonical.z &&
                (e.canonical.z >= a
                  ? (h = e.canonical.z - a)
                  : u.w(
                      "cannot calculate elevation if elevation maxzoom > source.maxzoom",
                    ));
              const f = e.canonical.x - ((e.canonical.x >> h) << h),
                g = e.canonical.y - ((e.canonical.y >> h) << h),
                y = u.cb(new Float64Array(16), [
                  1 / (u.X << h),
                  1 / (u.X << h),
                  0,
                ]);
              (u.J(y, y, [f * u.X, g * u.X, 0]),
                (this._demMatrixCache[e.key] = { matrix: y, coord: e }));
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: (i && i.dem && i.dem.dim) || 1,
              u_terrain_matrix: s
                ? this._demMatrixCache[e.key].matrix
                : this._emptyDemMatrix,
              u_terrain_unpack:
                (i && i.dem && i.dem.getUnpackVector()) || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: ((i && i.demTexture) || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture)
                .texture,
              tile: i,
            };
          }
          getFramebuffer(e) {
            const i = this.painter,
              s = i.width / devicePixelRatio,
              a = i.height / devicePixelRatio;
            return (
              !this._fbo ||
                (this._fbo.width === s && this._fbo.height === a) ||
                (this._fbo.destroy(),
                this._fboCoordsTexture.destroy(),
                this._fboDepthTexture.destroy(),
                delete this._fbo,
                delete this._fboDepthTexture,
                delete this._fboCoordsTexture),
              this._fboCoordsTexture ||
                ((this._fboCoordsTexture = new Bt(
                  i.context,
                  { width: s, height: a, data: null },
                  i.context.gl.RGBA,
                  { premultiply: !1 },
                )),
                this._fboCoordsTexture.bind(
                  i.context.gl.NEAREST,
                  i.context.gl.CLAMP_TO_EDGE,
                )),
              this._fboDepthTexture ||
                ((this._fboDepthTexture = new Bt(
                  i.context,
                  { width: s, height: a, data: null },
                  i.context.gl.RGBA,
                  { premultiply: !1 },
                )),
                this._fboDepthTexture.bind(
                  i.context.gl.NEAREST,
                  i.context.gl.CLAMP_TO_EDGE,
                )),
              this._fbo ||
                ((this._fbo = i.context.createFramebuffer(s, a, !0, !1)),
                this._fbo.depthAttachment.set(
                  i.context.createRenderbuffer(
                    i.context.gl.DEPTH_COMPONENT16,
                    s,
                    a,
                  ),
                )),
              this._fbo.colorAttachment.set(
                e === "coords"
                  ? this._fboCoordsTexture.texture
                  : this._fboDepthTexture.texture,
              ),
              this._fbo
            );
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const i = new Uint8Array(
              this._coordsTextureSize * this._coordsTextureSize * 4,
            );
            for (let h = 0, f = 0; h < this._coordsTextureSize; h++)
              for (let g = 0; g < this._coordsTextureSize; g++, f += 4)
                ((i[f + 0] = 255 & g),
                  (i[f + 1] = 255 & h),
                  (i[f + 2] = ((g >> 8) << 4) | (h >> 8)),
                  (i[f + 3] = 0));
            const s = new u.R(
                {
                  width: this._coordsTextureSize,
                  height: this._coordsTextureSize,
                },
                new Uint8Array(i.buffer),
              ),
              a = new Bt(e, s, e.gl.RGBA, { premultiply: !1 });
            return (
              a.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE),
              (this._coordsTexture = a),
              a
            );
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const i = new Uint8Array(4),
              s = this.painter.context,
              a = s.gl,
              h = Math.round(
                (e.x * this.painter.pixelRatio) / devicePixelRatio,
              ),
              f = Math.round(
                (e.y * this.painter.pixelRatio) / devicePixelRatio,
              ),
              g = Math.round(this.painter.height / devicePixelRatio);
            (s.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer),
              a.readPixels(h, g - f - 1, 1, 1, a.RGBA, a.UNSIGNED_BYTE, i),
              s.bindFramebuffer.set(null));
            const y = i[0] + ((i[2] >> 4) << 8),
              v = i[1] + ((15 & i[2]) << 8),
              C = this.coordsIndex[255 - i[3]],
              A = C && this.sourceCache.getTileByID(C);
            if (!A) return null;
            const T = this._coordsTextureSize,
              M = (1 << A.tileID.canonical.z) * T;
            return new u.Y(
              (A.tileID.canonical.x * T + y) / M + A.tileID.wrap,
              (A.tileID.canonical.y * T + v) / M,
              this.getElevation(A.tileID, y, v, T),
            );
          }
          depthAtPoint(e) {
            const i = new Uint8Array(4),
              s = this.painter.context,
              a = s.gl;
            return (
              s.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer),
              a.readPixels(
                e.x,
                this.painter.height / devicePixelRatio - e.y - 1,
                1,
                1,
                a.RGBA,
                a.UNSIGNED_BYTE,
                i,
              ),
              s.bindFramebuffer.set(null),
              (i[0] / 16777216 + i[1] / 65536 + i[2] / 256 + i[3]) / 256
            );
          }
          getTerrainMesh(e) {
            var i;
            const s =
                ((i = this.painter.style.projection) === null || i === void 0
                  ? void 0
                  : i.transitionState) > 0,
              a = s && e.canonical.y === 0,
              h = s && e.canonical.y === (1 << e.canonical.z) - 1,
              f = `m_${a ? "n" : ""}_${h ? "s" : ""}`;
            if (this._meshCache[f]) return this._meshCache[f];
            const g = this.painter.context,
              y = new u.cc(),
              v = new u.aE(),
              C = this.meshSize,
              A = u.X / C,
              T = C * C;
            for (let ie = 0; ie <= C; ie++)
              for (let he = 0; he <= C; he++) y.emplaceBack(he * A, ie * A, 0);
            for (let ie = 0; ie < T; ie += C + 1)
              for (let he = 0; he < C; he++)
                (v.emplaceBack(he + ie, C + he + ie + 1, C + he + ie + 2),
                  v.emplaceBack(he + ie, C + he + ie + 2, he + ie + 1));
            const M = y.length,
              k = M + (C + 1),
              V = (C + 1) * C,
              N = a ? u.b6 : 0,
              $ = a ? 0 : 1,
              G = h ? u.b7 : u.X,
              Y = h ? 0 : 1;
            for (let ie = 0; ie <= C; ie++) y.emplaceBack(ie * A, N, $);
            for (let ie = 0; ie <= C; ie++) y.emplaceBack(ie * A, G, Y);
            for (let ie = 0; ie < C; ie++)
              (v.emplaceBack(V + ie, k + ie, k + ie + 1),
                v.emplaceBack(V + ie, k + ie + 1, V + ie + 1),
                v.emplaceBack(0 + ie, M + ie + 1, M + ie),
                v.emplaceBack(0 + ie, 0 + ie + 1, M + ie + 1));
            const Q = y.length,
              ee = Q + 2 * (C + 1);
            for (const ie of [0, 1])
              for (let he = 0; he <= C; he++)
                for (const pe of [0, 1]) y.emplaceBack(ie * u.X, he * A, pe);
            for (let ie = 0; ie < 2 * C; ie += 2)
              (v.emplaceBack(Q + ie, Q + ie + 1, Q + ie + 3),
                v.emplaceBack(Q + ie, Q + ie + 3, Q + ie + 2),
                v.emplaceBack(ee + ie, ee + ie + 3, ee + ie + 1),
                v.emplaceBack(ee + ie, ee + ie + 2, ee + ie + 3));
            const re = new Fr(
              g.createVertexBuffer(y, Fu.members),
              g.createIndexBuffer(v),
              u.aD.simpleSegment(0, 0, y.length, v.length),
            );
            return ((this._meshCache[f] = re), re);
          }
          getMeshFrameDelta(e) {
            return (2 * Math.PI * u.bo) / Math.pow(2, Math.max(e, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e, i) {
            var s;
            const { tileID: a } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return (s = this.getMinMaxElevation(a).minElevation) !== null &&
              s !== void 0
              ? s
              : 0;
          }
          getMinMaxElevation(e) {
            const i = this.getTerrainData(e).tile,
              s = { minElevation: null, maxElevation: null };
            return (
              i &&
                i.dem &&
                ((s.minElevation = i.dem.min * this.exaggeration),
                (s.maxElevation = i.dem.max * this.exaggeration)),
              s
            );
          }
          _getOverscaledTileIDFromLngLatZoom(e, i) {
            const s = u.Y.fromLngLat(e.wrap()),
              a = (1 << i) * u.X,
              h = s.x * a,
              f = s.y * a,
              g = Math.floor(h / u.X),
              y = Math.floor(f / u.X);
            return {
              tileID: new u.S(i, 0, i, g, y),
              mercatorX: h,
              mercatorY: f,
            };
          }
        }
        class Zo {
          constructor(e, i, s) {
            ((this._context = e),
              (this._size = i),
              (this._tileSize = s),
              (this._objects = []),
              (this._recentlyUsed = []),
              (this._stamp = 0));
          }
          destruct() {
            for (const e of this._objects)
              (e.texture.destroy(), e.fbo.destroy());
          }
          _createObject(e) {
            const i = this._context.createFramebuffer(
                this._tileSize,
                this._tileSize,
                !0,
                !0,
              ),
              s = new Bt(
                this._context,
                { width: this._tileSize, height: this._tileSize, data: null },
                this._context.gl.RGBA,
              );
            return (
              s.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE),
              this._context.extTextureFilterAnisotropic &&
                this._context.gl.texParameterf(
                  this._context.gl.TEXTURE_2D,
                  this._context.extTextureFilterAnisotropic
                    .TEXTURE_MAX_ANISOTROPY_EXT,
                  this._context.extTextureFilterAnisotropicMax,
                ),
              i.depthAttachment.set(
                this._context.createRenderbuffer(
                  this._context.gl.DEPTH_STENCIL,
                  this._tileSize,
                  this._tileSize,
                ),
              ),
              i.colorAttachment.set(s.texture),
              { id: e, fbo: i, texture: s, stamp: -1, inUse: !1 }
            );
          }
          getObjectForId(e) {
            return this._objects[e];
          }
          useObject(e) {
            ((e.inUse = !0),
              (this._recentlyUsed = this._recentlyUsed.filter(
                (i) => e.id !== i,
              )),
              this._recentlyUsed.push(e.id));
          }
          stampObject(e) {
            e.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const i of this._recentlyUsed)
              if (!this._objects[i].inUse) return this._objects[i];
            if (this._objects.length >= this._size)
              throw new Error(
                "No free RenderPool available, call freeAllObjects() required!",
              );
            const e = this._createObject(this._objects.length);
            return (this._objects.push(e), e);
          }
          freeObject(e) {
            e.inUse = !1;
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e);
          }
          isFull() {
            return (
              !(this._objects.length < this._size) &&
              this._objects.some((e) => !e.inUse) === !1
            );
          }
        }
        const Mt = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
        };
        class ii {
          constructor(e, i) {
            ((this.painter = e),
              (this.terrain = i),
              (this.pool = new Zo(
                e.context,
                30,
                i.sourceCache.tileSize * i.qualityFactor,
              )));
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id)
              .texture;
          }
          prepareForRender(e, i) {
            ((this._stacks = []),
              (this._prevType = null),
              (this._rttTiles = []),
              (this._renderableTiles =
                this.terrain.sourceCache.getRenderableTiles()),
              (this._renderableLayerIds = e._order.filter(
                (s) => !e._layers[s].isHidden(i),
              )),
              (this._coordsAscending = {}));
            for (const s in e.sourceCaches) {
              this._coordsAscending[s] = {};
              const a = e.sourceCaches[s].getVisibleCoordinates();
              for (const h of a) {
                const f = this.terrain.sourceCache.getTerrainCoords(h);
                for (const g in f)
                  (this._coordsAscending[s][g] ||
                    (this._coordsAscending[s][g] = []),
                    this._coordsAscending[s][g].push(f[g]));
              }
            }
            this._coordsAscendingStr = {};
            for (const s of e._order) {
              const a = e._layers[s],
                h = a.source;
              if (Mt[a.type] && !this._coordsAscendingStr[h]) {
                this._coordsAscendingStr[h] = {};
                for (const f in this._coordsAscending[h])
                  this._coordsAscendingStr[h][f] = this._coordsAscending[h][f]
                    .map((g) => g.key)
                    .sort()
                    .join();
              }
            }
            for (const s of this._renderableTiles)
              for (const a in this._coordsAscendingStr) {
                const h = this._coordsAscendingStr[a][s.tileID.key];
                h && h !== s.rttCoords[a] && (s.rtt = []);
              }
          }
          renderLayer(e, i) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const s = Object.assign(Object.assign({}, i), {
                isRenderingToTexture: !0,
              }),
              a = e.type,
              h = this.painter,
              f =
                this._renderableLayerIds[
                  this._renderableLayerIds.length - 1
                ] === e.id;
            if (
              Mt[a] &&
              ((this._prevType && Mt[this._prevType]) || this._stacks.push([]),
              (this._prevType = a),
              this._stacks[this._stacks.length - 1].push(e.id),
              !f)
            )
              return !0;
            if (Mt[this._prevType] || (Mt[a] && f)) {
              this._prevType = a;
              const g = this._stacks.length - 1,
                y = this._stacks[g] || [];
              for (const v of this._renderableTiles) {
                if (
                  (this.pool.isFull() &&
                    (Ga(this.painter, this.terrain, this._rttTiles, s),
                    (this._rttTiles = []),
                    this.pool.freeAllObjects()),
                  this._rttTiles.push(v),
                  v.rtt[g])
                ) {
                  const A = this.pool.getObjectForId(v.rtt[g].id);
                  if (A.stamp === v.rtt[g].stamp) {
                    this.pool.useObject(A);
                    continue;
                  }
                }
                const C = this.pool.getOrCreateFreeObject();
                (this.pool.useObject(C),
                  this.pool.stampObject(C),
                  (v.rtt[g] = { id: C.id, stamp: C.stamp }),
                  h.context.bindFramebuffer.set(C.fbo.framebuffer),
                  h.context.clear({ color: u.b4.transparent, stencil: 0 }),
                  (h.currentStencilSource = void 0));
                for (let A = 0; A < y.length; A++) {
                  const T = h.style._layers[y[A]],
                    M = T.source
                      ? this._coordsAscending[T.source][v.tileID.key]
                      : [v.tileID];
                  (h.context.viewport.set([0, 0, C.fbo.width, C.fbo.height]),
                    h._renderTileClippingMasks(T, M, !0),
                    h.renderLayer(h, h.style.sourceCaches[T.source], T, M, s),
                    T.source &&
                      (v.rttCoords[T.source] =
                        this._coordsAscendingStr[T.source][v.tileID.key]));
                }
              }
              return (
                Ga(this.painter, this.terrain, this._rttTiles, s),
                (this._rttTiles = []),
                this.pool.freeAllObjects(),
                Mt[a]
              );
            }
            return !1;
          }
        }
        const Pu = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText":
              "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText":
              "Use \u2318 + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText":
              "Use two fingers to move the map",
          },
          Go = Ue,
          qo = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: $o,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0,
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: u.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0,
          },
          Ja = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0,
          };
        class Qa {
          constructor(e, i, s = !1) {
            ((this.mousedown = (h) => {
              (this.startMove(h, me.mousePos(this.element, h)),
                me.addEventListener(window, "mousemove", this.mousemove),
                me.addEventListener(window, "mouseup", this.mouseup));
            }),
              (this.mousemove = (h) => {
                this.move(h, me.mousePos(this.element, h));
              }),
              (this.mouseup = (h) => {
                (this._rotatePitchHanlder.dragEnd(h), this.offTemp());
              }),
              (this.touchstart = (h) => {
                h.targetTouches.length !== 1
                  ? this.reset()
                  : ((this._startPos = this._lastPos =
                      me.touchPos(this.element, h.targetTouches)[0]),
                    this.startMove(h, this._startPos),
                    me.addEventListener(window, "touchmove", this.touchmove, {
                      passive: !1,
                    }),
                    me.addEventListener(window, "touchend", this.touchend));
              }),
              (this.touchmove = (h) => {
                h.targetTouches.length !== 1
                  ? this.reset()
                  : ((this._lastPos = me.touchPos(
                      this.element,
                      h.targetTouches,
                    )[0]),
                    this.move(h, this._lastPos));
              }),
              (this.touchend = (h) => {
                (h.targetTouches.length === 0 &&
                  this._startPos &&
                  this._lastPos &&
                  this._startPos.dist(this._lastPos) < this._clickTolerance &&
                  this.element.click(),
                  delete this._startPos,
                  delete this._lastPos,
                  this.offTemp());
              }),
              (this.reset = () => {
                (this._rotatePitchHanlder.reset(),
                  delete this._startPos,
                  delete this._lastPos,
                  this.offTemp());
              }),
              (this._clickTolerance = 10),
              (this.element = i));
            const a = new Uo();
            ((this._rotatePitchHanlder = new Re({
              clickTolerance: 3,
              move: (h, f) => {
                const g = i.getBoundingClientRect(),
                  y = new u.P((g.bottom - g.top) / 2, (g.right - g.left) / 2);
                return {
                  bearingDelta: u.c7(new u.P(h.x, f.y), f, y),
                  pitchDelta: s ? -0.5 * (f.y - h.y) : void 0,
                };
              },
              moveStateManager: a,
              enable: !0,
              assignEvents: () => {},
            })),
              (this.map = e),
              me.addEventListener(i, "mousedown", this.mousedown),
              me.addEventListener(i, "touchstart", this.touchstart, {
                passive: !1,
              }),
              me.addEventListener(i, "touchcancel", this.reset));
          }
          startMove(e, i) {
            (this._rotatePitchHanlder.dragStart(e, i), me.disableDrag());
          }
          move(e, i) {
            const s = this.map,
              { bearingDelta: a, pitchDelta: h } =
                this._rotatePitchHanlder.dragMove(e, i) || {};
            (a && s.setBearing(s.getBearing() + a),
              h && s.setPitch(s.getPitch() + h));
          }
          off() {
            const e = this.element;
            (me.removeEventListener(e, "mousedown", this.mousedown),
              me.removeEventListener(e, "touchstart", this.touchstart, {
                passive: !1,
              }),
              me.removeEventListener(window, "touchmove", this.touchmove, {
                passive: !1,
              }),
              me.removeEventListener(window, "touchend", this.touchend),
              me.removeEventListener(e, "touchcancel", this.reset),
              this.offTemp());
          }
          offTemp() {
            (me.enableDrag(),
              me.removeEventListener(window, "mousemove", this.mousemove),
              me.removeEventListener(window, "mouseup", this.mouseup),
              me.removeEventListener(window, "touchmove", this.touchmove, {
                passive: !1,
              }),
              me.removeEventListener(window, "touchend", this.touchend));
          }
        }
        let $r;
        function fo(c, e, i) {
          const s = new u.N(c.lng, c.lat);
          if (((c = new u.N(c.lng, c.lat)), e)) {
            const a = new u.N(c.lng - 360, c.lat),
              h = new u.N(c.lng + 360, c.lat),
              f = i.locationToScreenPoint(c).distSqr(e);
            i.locationToScreenPoint(a).distSqr(e) < f
              ? (c = a)
              : i.locationToScreenPoint(h).distSqr(e) < f && (c = h);
          }
          for (; Math.abs(c.lng - i.center.lng) > 180; ) {
            const a = i.locationToScreenPoint(c);
            if (a.x >= 0 && a.y >= 0 && a.x <= i.width && a.y <= i.height)
              break;
            c.lng > i.center.lng ? (c.lng -= 360) : (c.lng += 360);
          }
          return c.lng !== s.lng &&
            i.isPointOnMapSurface(i.locationToScreenPoint(c))
            ? c
            : s;
        }
        const Ho = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)",
        };
        function Js(c, e, i) {
          const s = c.classList;
          for (const a in Ho) s.remove(`maplibregl-${i}-anchor-${a}`);
          s.add(`maplibregl-${i}-anchor-${e}`);
        }
        class Xo extends u.E {
          constructor(e) {
            if (
              (super(),
              (this._onKeyPress = (i) => {
                const s = i.code,
                  a = i.charCode || i.keyCode;
                (s !== "Space" && s !== "Enter" && a !== 32 && a !== 13) ||
                  this.togglePopup();
              }),
              (this._onMapClick = (i) => {
                const s = i.originalEvent.target,
                  a = this._element;
                this._popup && (s === a || a.contains(s)) && this.togglePopup();
              }),
              (this._update = (i) => {
                var s;
                if (!this._map) return;
                const a = this._map.loaded() && !this._map.isMoving();
                (((i == null ? void 0 : i.type) === "terrain" ||
                  ((i == null ? void 0 : i.type) === "render" && !a)) &&
                  this._map.once("render", this._update),
                  (this._lngLat = this._map.transform.renderWorldCopies
                    ? fo(this._lngLat, this._flatPos, this._map.transform)
                    : (s = this._lngLat) === null || s === void 0
                      ? void 0
                      : s.wrap()),
                  (this._flatPos = this._pos =
                    this._map.project(this._lngLat)._add(this._offset)),
                  this._map.terrain &&
                    (this._flatPos = this._map.transform
                      .locationToScreenPoint(this._lngLat)
                      ._add(this._offset)));
                let h = "";
                this._rotationAlignment === "viewport" ||
                this._rotationAlignment === "auto"
                  ? (h = `rotateZ(${this._rotation}deg)`)
                  : this._rotationAlignment === "map" &&
                    (h = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
                let f = "";
                (this._pitchAlignment === "viewport" ||
                this._pitchAlignment === "auto"
                  ? (f = "rotateX(0deg)")
                  : this._pitchAlignment === "map" &&
                    (f = `rotateX(${this._map.getPitch()}deg)`),
                  this._subpixelPositioning ||
                    (i && i.type !== "moveend") ||
                    (this._pos = this._pos.round()),
                  me.setTransform(
                    this._element,
                    `${Ho[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${f} ${h}`,
                  ),
                  Qe.frameAsync(new AbortController())
                    .then(() => {
                      this._updateOpacity(i && i.type === "moveend");
                    })
                    .catch(() => {}));
              }),
              (this._onMove = (i) => {
                if (!this._isDragging) {
                  const s = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = i.point.dist(this._pointerdownPos) >= s;
                }
                this._isDragging &&
                  ((this._pos = i.point.sub(this._positionDelta)),
                  (this._lngLat = this._map.unproject(this._pos)),
                  this.setLngLat(this._lngLat),
                  (this._element.style.pointerEvents = "none"),
                  this._state === "pending" &&
                    ((this._state = "active"), this.fire(new u.k("dragstart"))),
                  this.fire(new u.k("drag")));
              }),
              (this._onUp = () => {
                ((this._element.style.pointerEvents = "auto"),
                  (this._positionDelta = null),
                  (this._pointerdownPos = null),
                  (this._isDragging = !1),
                  this._map.off("mousemove", this._onMove),
                  this._map.off("touchmove", this._onMove),
                  this._state === "active" && this.fire(new u.k("dragend")),
                  (this._state = "inactive"));
              }),
              (this._addDragHandler = (i) => {
                this._element.contains(i.originalEvent.target) &&
                  (i.preventDefault(),
                  (this._positionDelta = i.point
                    .sub(this._pos)
                    .add(this._offset)),
                  (this._pointerdownPos = i.point),
                  (this._state = "pending"),
                  this._map.on("mousemove", this._onMove),
                  this._map.on("touchmove", this._onMove),
                  this._map.once("mouseup", this._onUp),
                  this._map.once("touchend", this._onUp));
              }),
              (this._anchor = (e && e.anchor) || "center"),
              (this._color = (e && e.color) || "#3FB1CE"),
              (this._scale = (e && e.scale) || 1),
              (this._draggable = (e && e.draggable) || !1),
              (this._clickTolerance = (e && e.clickTolerance) || 0),
              (this._subpixelPositioning = (e && e.subpixelPositioning) || !1),
              (this._isDragging = !1),
              (this._state = "inactive"),
              (this._rotation = (e && e.rotation) || 0),
              (this._rotationAlignment = (e && e.rotationAlignment) || "auto"),
              (this._pitchAlignment =
                e && e.pitchAlignment && e.pitchAlignment !== "auto"
                  ? e.pitchAlignment
                  : this._rotationAlignment),
              this.setOpacity(),
              this.setOpacity(
                e == null ? void 0 : e.opacity,
                e == null ? void 0 : e.opacityWhenCovered,
              ),
              e && e.element)
            )
              ((this._element = e.element),
                (this._offset = u.P.convert((e && e.offset) || [0, 0])));
            else {
              ((this._defaultMarker = !0), (this._element = me.create("div")));
              const i = me.createNS("http://www.w3.org/2000/svg", "svg"),
                s = 41,
                a = 27;
              (i.setAttributeNS(null, "display", "block"),
                i.setAttributeNS(null, "height", `${s}px`),
                i.setAttributeNS(null, "width", `${a}px`),
                i.setAttributeNS(null, "viewBox", `0 0 ${a} ${s}`));
              const h = me.createNS("http://www.w3.org/2000/svg", "g");
              (h.setAttributeNS(null, "stroke", "none"),
                h.setAttributeNS(null, "stroke-width", "1"),
                h.setAttributeNS(null, "fill", "none"),
                h.setAttributeNS(null, "fill-rule", "evenodd"));
              const f = me.createNS("http://www.w3.org/2000/svg", "g");
              f.setAttributeNS(null, "fill-rule", "nonzero");
              const g = me.createNS("http://www.w3.org/2000/svg", "g");
              (g.setAttributeNS(null, "transform", "translate(3.0, 29.0)"),
                g.setAttributeNS(null, "fill", "#000000"));
              const y = [
                { rx: "10.5", ry: "5.25002273" },
                { rx: "10.5", ry: "5.25002273" },
                { rx: "9.5", ry: "4.77275007" },
                { rx: "8.5", ry: "4.29549936" },
                { rx: "7.5", ry: "3.81822308" },
                { rx: "6.5", ry: "3.34094679" },
                { rx: "5.5", ry: "2.86367051" },
                { rx: "4.5", ry: "2.38636864" },
              ];
              for (const $ of y) {
                const G = me.createNS("http://www.w3.org/2000/svg", "ellipse");
                (G.setAttributeNS(null, "opacity", "0.04"),
                  G.setAttributeNS(null, "cx", "10.5"),
                  G.setAttributeNS(null, "cy", "5.80029008"),
                  G.setAttributeNS(null, "rx", $.rx),
                  G.setAttributeNS(null, "ry", $.ry),
                  g.appendChild(G));
              }
              const v = me.createNS("http://www.w3.org/2000/svg", "g");
              v.setAttributeNS(null, "fill", this._color);
              const C = me.createNS("http://www.w3.org/2000/svg", "path");
              (C.setAttributeNS(
                null,
                "d",
                "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z",
              ),
                v.appendChild(C));
              const A = me.createNS("http://www.w3.org/2000/svg", "g");
              (A.setAttributeNS(null, "opacity", "0.25"),
                A.setAttributeNS(null, "fill", "#000000"));
              const T = me.createNS("http://www.w3.org/2000/svg", "path");
              (T.setAttributeNS(
                null,
                "d",
                "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z",
              ),
                A.appendChild(T));
              const M = me.createNS("http://www.w3.org/2000/svg", "g");
              (M.setAttributeNS(null, "transform", "translate(6.0, 7.0)"),
                M.setAttributeNS(null, "fill", "#FFFFFF"));
              const k = me.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const V = me.createNS("http://www.w3.org/2000/svg", "circle");
              (V.setAttributeNS(null, "fill", "#000000"),
                V.setAttributeNS(null, "opacity", "0.25"),
                V.setAttributeNS(null, "cx", "5.5"),
                V.setAttributeNS(null, "cy", "5.5"),
                V.setAttributeNS(null, "r", "5.4999962"));
              const N = me.createNS("http://www.w3.org/2000/svg", "circle");
              (N.setAttributeNS(null, "fill", "#FFFFFF"),
                N.setAttributeNS(null, "cx", "5.5"),
                N.setAttributeNS(null, "cy", "5.5"),
                N.setAttributeNS(null, "r", "5.4999962"),
                k.appendChild(V),
                k.appendChild(N),
                f.appendChild(g),
                f.appendChild(v),
                f.appendChild(A),
                f.appendChild(M),
                f.appendChild(k),
                i.appendChild(f),
                i.setAttributeNS(null, "height", s * this._scale + "px"),
                i.setAttributeNS(null, "width", a * this._scale + "px"),
                this._element.appendChild(i),
                (this._offset = u.P.convert((e && e.offset) || [0, -14])));
            }
            if (
              (this._element.classList.add("maplibregl-marker"),
              this._element.addEventListener("dragstart", (i) => {
                i.preventDefault();
              }),
              this._element.addEventListener("mousedown", (i) => {
                i.preventDefault();
              }),
              Js(this._element, this._anchor, "marker"),
              e && e.className)
            )
              for (const i of e.className.split(" "))
                this._element.classList.add(i);
            this._popup = null;
          }
          addTo(e) {
            return (
              this.remove(),
              (this._map = e),
              this._element.setAttribute(
                "aria-label",
                e._getUIString("Marker.Title"),
              ),
              e.getCanvasContainer().appendChild(this._element),
              e.on("move", this._update),
              e.on("moveend", this._update),
              e.on("terrain", this._update),
              e.on("projectiontransition", this._update),
              this.setDraggable(this._draggable),
              this._update(),
              this._map.on("click", this._onMapClick),
              this
            );
          }
          remove() {
            return (
              this._opacityTimeout &&
                (clearTimeout(this._opacityTimeout),
                delete this._opacityTimeout),
              this._map &&
                (this._map.off("click", this._onMapClick),
                this._map.off("move", this._update),
                this._map.off("moveend", this._update),
                this._map.off("terrain", this._update),
                this._map.off("projectiontransition", this._update),
                this._map.off("mousedown", this._addDragHandler),
                this._map.off("touchstart", this._addDragHandler),
                this._map.off("mouseup", this._onUp),
                this._map.off("touchend", this._onUp),
                this._map.off("mousemove", this._onMove),
                this._map.off("touchmove", this._onMove),
                delete this._map),
              me.remove(this._element),
              this._popup && this._popup.remove(),
              this
            );
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return (
              (this._lngLat = u.N.convert(e)),
              (this._pos = null),
              this._popup && this._popup.setLngLat(this._lngLat),
              this._update(),
              this
            );
          }
          getElement() {
            return this._element;
          }
          setPopup(e) {
            if (
              (this._popup &&
                (this._popup.remove(),
                (this._popup = null),
                this._element.removeEventListener("keypress", this._onKeyPress),
                this._originalTabIndex ||
                  this._element.removeAttribute("tabindex")),
              e)
            ) {
              if (!("offset" in e.options)) {
                const a = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker
                  ? {
                      top: [0, 0],
                      "top-left": [0, 0],
                      "top-right": [0, 0],
                      bottom: [0, -38.1],
                      "bottom-left": [a, -1 * (38.1 - 13.5 + a)],
                      "bottom-right": [-a, -1 * (38.1 - 13.5 + a)],
                      left: [13.5, -1 * (38.1 - 13.5)],
                      right: [-13.5, -1 * (38.1 - 13.5)],
                    }
                  : this._offset;
              }
              ((this._popup = e),
                (this._originalTabIndex =
                  this._element.getAttribute("tabindex")),
                this._originalTabIndex ||
                  this._element.setAttribute("tabindex", "0"),
                this._element.addEventListener("keypress", this._onKeyPress));
            }
            return this;
          }
          setSubpixelPositioning(e) {
            return ((this._subpixelPositioning = e), this);
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered
              ? this
              : e
                ? (e.isOpen()
                    ? e.remove()
                    : (e.setLngLat(this._lngLat), e.addTo(this._map)),
                  this)
                : this;
          }
          _updateOpacity(e = !1) {
            var i, s;
            if (!(!((i = this._map) === null || i === void 0) && i.terrain)) {
              const A = this._map.transform.isLocationOccluded(this._lngLat)
                ? this._opacityWhenCovered
                : this._opacity;
              return void (
                this._element.style.opacity !== A &&
                (this._element.style.opacity = A)
              );
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout(() => {
                this._opacityTimeout = null;
              }, 100);
            }
            const a = this._map,
              h = a.terrain.depthAtPoint(this._pos),
              f = a.terrain.getElevationForLngLatZoom(
                this._lngLat,
                a.transform.tileZoom,
              );
            if (a.transform.lngLatToCameraDepth(this._lngLat, f) - h < 0.006)
              return void (this._element.style.opacity = this._opacity);
            const g = -this._offset.y / a.transform.pixelsPerMeter,
              y = Math.sin((a.getPitch() * Math.PI) / 180) * g,
              v = a.terrain.depthAtPoint(
                new u.P(this._pos.x, this._pos.y - this._offset.y),
              ),
              C =
                a.transform.lngLatToCameraDepth(this._lngLat, f + y) - v >
                0.006;
            (((s = this._popup) === null || s === void 0
              ? void 0
              : s.isOpen()) &&
              C &&
              this._popup.remove(),
              (this._element.style.opacity = C
                ? this._opacityWhenCovered
                : this._opacity));
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e) {
            return ((this._offset = u.P.convert(e)), this._update(), this);
          }
          addClassName(e) {
            this._element.classList.add(e);
          }
          removeClassName(e) {
            this._element.classList.remove(e);
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e);
          }
          setDraggable(e) {
            return (
              (this._draggable = !!e),
              this._map &&
                (e
                  ? (this._map.on("mousedown", this._addDragHandler),
                    this._map.on("touchstart", this._addDragHandler))
                  : (this._map.off("mousedown", this._addDragHandler),
                    this._map.off("touchstart", this._addDragHandler))),
              this
            );
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e) {
            return ((this._rotation = e || 0), this._update(), this);
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e) {
            return (
              (this._rotationAlignment = e || "auto"),
              this._update(),
              this
            );
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e) {
            return (
              (this._pitchAlignment =
                e && e !== "auto" ? e : this._rotationAlignment),
              this._update(),
              this
            );
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e, i) {
            return (
              e === void 0 &&
                i === void 0 &&
                ((this._opacity = "1"), (this._opacityWhenCovered = "0.2")),
              e !== void 0 && (this._opacity = e),
              i !== void 0 && (this._opacityWhenCovered = i),
              this._map && this._updateOpacity(!0),
              this
            );
          }
        }
        const el = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3,
          },
          fitBoundsOptions: { maxZoom: 15 },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0,
        };
        let mo = 0,
          jn = !1;
        const tl = { maxWidth: 100, unit: "metric" };
        function Qs(c, e, i) {
          const s = (i && i.maxWidth) || 100,
            a = c._container.clientHeight / 2,
            h = c._container.clientWidth / 2,
            f = c.unproject([h - s / 2, a]),
            g = c.unproject([h + s / 2, a]),
            y = Math.round(c.project(g).x - c.project(f).x),
            v = Math.min(s, y, c._container.clientWidth),
            C = f.distanceTo(g);
          if (i && i.unit === "imperial") {
            const A = 3.2808 * C;
            A > 5280
              ? sn(e, v, A / 5280, c._getUIString("ScaleControl.Miles"))
              : sn(e, v, A, c._getUIString("ScaleControl.Feet"));
          } else
            i && i.unit === "nautical"
              ? sn(e, v, C / 1852, c._getUIString("ScaleControl.NauticalMiles"))
              : C >= 1e3
                ? sn(e, v, C / 1e3, c._getUIString("ScaleControl.Kilometers"))
                : sn(e, v, C, c._getUIString("ScaleControl.Meters"));
        }
        function sn(c, e, i, s) {
          const a = (function (h) {
            const f = Math.pow(10, `${Math.floor(h)}`.length - 1);
            let g = h / f;
            return (
              (g =
                g >= 10
                  ? 10
                  : g >= 5
                    ? 5
                    : g >= 3
                      ? 3
                      : g >= 2
                        ? 2
                        : g >= 1
                          ? 1
                          : (function (y) {
                              const v = Math.pow(
                                10,
                                Math.ceil(-Math.log(y) / Math.LN10),
                              );
                              return Math.round(y * v) / v;
                            })(g)),
              f * g
            );
          })(i);
          ((c.style.width = e * (a / i) + "px"),
            (c.innerHTML = `${a}&nbsp;${s}`));
        }
        const il = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
          },
          rl = [
            "a[href]",
            "[tabindex]:not([tabindex='-1'])",
            "[contenteditable]:not([contenteditable='false'])",
            "button:not([disabled])",
            "input:not([disabled])",
            "select:not([disabled])",
            "textarea:not([disabled])",
          ].join(", ");
        function Wo(c) {
          if (c) {
            if (typeof c == "number") {
              const e = Math.round(Math.abs(c) / Math.SQRT2);
              return {
                center: new u.P(0, 0),
                top: new u.P(0, c),
                "top-left": new u.P(e, e),
                "top-right": new u.P(-e, e),
                bottom: new u.P(0, -c),
                "bottom-left": new u.P(e, -e),
                "bottom-right": new u.P(-e, -e),
                left: new u.P(c, 0),
                right: new u.P(-c, 0),
              };
            }
            if (c instanceof u.P || Array.isArray(c)) {
              const e = u.P.convert(c);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e,
              };
            }
            return {
              center: u.P.convert(c.center || [0, 0]),
              top: u.P.convert(c.top || [0, 0]),
              "top-left": u.P.convert(c["top-left"] || [0, 0]),
              "top-right": u.P.convert(c["top-right"] || [0, 0]),
              bottom: u.P.convert(c.bottom || [0, 0]),
              "bottom-left": u.P.convert(c["bottom-left"] || [0, 0]),
              "bottom-right": u.P.convert(c["bottom-right"] || [0, 0]),
              left: u.P.convert(c.left || [0, 0]),
              right: u.P.convert(c.right || [0, 0]),
            };
          }
          return Wo(new u.P(0, 0));
        }
        const nl = Ue;
        ((E.AJAXError = u.cg),
          (E.Event = u.k),
          (E.Evented = u.E),
          (E.LngLat = u.N),
          (E.MercatorCoordinate = u.Y),
          (E.Point = u.P),
          (E.addProtocol = u.ch),
          (E.config = u.a),
          (E.removeProtocol = u.ci),
          (E.AttributionControl = Ks),
          (E.BoxZoomHandler = fu),
          (E.CanvasSource = xn),
          (E.CooperativeGesturesHandler = Ya),
          (E.DoubleClickZoomHandler = Ur),
          (E.DragPanHandler = Xs),
          (E.DragRotateHandler = Wa),
          (E.EdgeInsets = xi),
          (E.FullscreenControl = class extends u.E {
            constructor(c = {}) {
              (super(),
                (this._onFullscreenChange = () => {
                  var e;
                  let i =
                    window.document.fullscreenElement ||
                    window.document.mozFullScreenElement ||
                    window.document.webkitFullscreenElement ||
                    window.document.msFullscreenElement;
                  for (
                    ;
                    !(
                      (e = i == null ? void 0 : i.shadowRoot) === null ||
                      e === void 0
                    ) && e.fullscreenElement;

                  )
                    i = i.shadowRoot.fullscreenElement;
                  (i === this._container) !== this._fullscreen &&
                    this._handleFullscreenChange();
                }),
                (this._onClickFullscreen = () => {
                  this._isFullscreen()
                    ? this._exitFullscreen()
                    : this._requestFullscreen();
                }),
                (this._fullscreen = !1),
                c &&
                  c.container &&
                  (c.container instanceof HTMLElement
                    ? (this._container = c.container)
                    : u.w(
                        "Full screen control 'container' must be a DOM element.",
                      )),
                "onfullscreenchange" in document
                  ? (this._fullscreenchange = "fullscreenchange")
                  : "onmozfullscreenchange" in document
                    ? (this._fullscreenchange = "mozfullscreenchange")
                    : "onwebkitfullscreenchange" in document
                      ? (this._fullscreenchange = "webkitfullscreenchange")
                      : "onmsfullscreenchange" in document &&
                        (this._fullscreenchange = "MSFullscreenChange"));
            }
            onAdd(c) {
              return (
                (this._map = c),
                this._container || (this._container = this._map.getContainer()),
                (this._controlContainer = me.create(
                  "div",
                  "maplibregl-ctrl maplibregl-ctrl-group",
                )),
                this._setupUI(),
                this._controlContainer
              );
            }
            onRemove() {
              (me.remove(this._controlContainer),
                (this._map = null),
                window.document.removeEventListener(
                  this._fullscreenchange,
                  this._onFullscreenChange,
                ));
            }
            _setupUI() {
              const c = (this._fullscreenButton = me.create(
                "button",
                "maplibregl-ctrl-fullscreen",
                this._controlContainer,
              ));
              (me
                .create("span", "maplibregl-ctrl-icon", c)
                .setAttribute("aria-hidden", "true"),
                (c.type = "button"),
                this._updateTitle(),
                this._fullscreenButton.addEventListener(
                  "click",
                  this._onClickFullscreen,
                ),
                window.document.addEventListener(
                  this._fullscreenchange,
                  this._onFullscreenChange,
                ));
            }
            _updateTitle() {
              const c = this._getTitle();
              (this._fullscreenButton.setAttribute("aria-label", c),
                (this._fullscreenButton.title = c));
            }
            _getTitle() {
              return this._map._getUIString(
                this._isFullscreen()
                  ? "FullscreenControl.Exit"
                  : "FullscreenControl.Enter",
              );
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _handleFullscreenChange() {
              ((this._fullscreen = !this._fullscreen),
                this._fullscreenButton.classList.toggle(
                  "maplibregl-ctrl-shrink",
                ),
                this._fullscreenButton.classList.toggle(
                  "maplibregl-ctrl-fullscreen",
                ),
                this._updateTitle(),
                this._fullscreen
                  ? (this.fire(new u.k("fullscreenstart")),
                    (this._prevCooperativeGesturesEnabled =
                      this._map.cooperativeGestures.isEnabled()),
                    this._map.cooperativeGestures.disable())
                  : (this.fire(new u.k("fullscreenend")),
                    this._prevCooperativeGesturesEnabled &&
                      this._map.cooperativeGestures.enable()));
            }
            _exitFullscreen() {
              window.document.exitFullscreen
                ? window.document.exitFullscreen()
                : window.document.mozCancelFullScreen
                  ? window.document.mozCancelFullScreen()
                  : window.document.msExitFullscreen
                    ? window.document.msExitFullscreen()
                    : window.document.webkitCancelFullScreen
                      ? window.document.webkitCancelFullScreen()
                      : this._togglePseudoFullScreen();
            }
            _requestFullscreen() {
              this._container.requestFullscreen
                ? this._container.requestFullscreen()
                : this._container.mozRequestFullScreen
                  ? this._container.mozRequestFullScreen()
                  : this._container.msRequestFullscreen
                    ? this._container.msRequestFullscreen()
                    : this._container.webkitRequestFullscreen
                      ? this._container.webkitRequestFullscreen()
                      : this._togglePseudoFullScreen();
            }
            _togglePseudoFullScreen() {
              (this._container.classList.toggle("maplibregl-pseudo-fullscreen"),
                this._handleFullscreenChange(),
                this._map.resize());
            }
          }),
          (E.GeoJSONSource = Kr),
          (E.GeolocateControl = class extends u.E {
            constructor(c) {
              (super(),
                (this._onSuccess = (e) => {
                  if (this._map) {
                    if (this._isOutOfMapMaxBounds(e))
                      return (
                        this._setErrorState(),
                        this.fire(new u.k("outofmaxbounds", e)),
                        this._updateMarker(),
                        void this._finish()
                      );
                    if (this.options.trackUserLocation)
                      switch (
                        ((this._lastKnownPosition = e), this._watchState)
                      ) {
                        case "WAITING_ACTIVE":
                        case "ACTIVE_LOCK":
                        case "ACTIVE_ERROR":
                          ((this._watchState = "ACTIVE_LOCK"),
                            this._geolocateButton.classList.remove(
                              "maplibregl-ctrl-geolocate-waiting",
                            ),
                            this._geolocateButton.classList.remove(
                              "maplibregl-ctrl-geolocate-active-error",
                            ),
                            this._geolocateButton.classList.add(
                              "maplibregl-ctrl-geolocate-active",
                            ));
                          break;
                        case "BACKGROUND":
                        case "BACKGROUND_ERROR":
                          ((this._watchState = "BACKGROUND"),
                            this._geolocateButton.classList.remove(
                              "maplibregl-ctrl-geolocate-waiting",
                            ),
                            this._geolocateButton.classList.remove(
                              "maplibregl-ctrl-geolocate-background-error",
                            ),
                            this._geolocateButton.classList.add(
                              "maplibregl-ctrl-geolocate-background",
                            ));
                          break;
                        default:
                          throw new Error(
                            `Unexpected watchState ${this._watchState}`,
                          );
                      }
                    (this.options.showUserLocation &&
                      this._watchState !== "OFF" &&
                      this._updateMarker(e),
                      (this.options.trackUserLocation &&
                        this._watchState !== "ACTIVE_LOCK") ||
                        this._updateCamera(e),
                      this.options.showUserLocation &&
                        this._dotElement.classList.remove(
                          "maplibregl-user-location-dot-stale",
                        ),
                      this.fire(new u.k("geolocate", e)),
                      this._finish());
                  }
                }),
                (this._updateCamera = (e) => {
                  const i = new u.N(e.coords.longitude, e.coords.latitude),
                    s = e.coords.accuracy,
                    a = this._map.getBearing(),
                    h = u.e({ bearing: a }, this.options.fitBoundsOptions),
                    f = ti.fromLngLat(i, s);
                  this._map.fitBounds(f, h, { geolocateSource: !0 });
                }),
                (this._updateMarker = (e) => {
                  if (e) {
                    const i = new u.N(e.coords.longitude, e.coords.latitude);
                    (this._accuracyCircleMarker.setLngLat(i).addTo(this._map),
                      this._userLocationDotMarker.setLngLat(i).addTo(this._map),
                      (this._accuracy = e.coords.accuracy),
                      this.options.showUserLocation &&
                        this.options.showAccuracyCircle &&
                        this._updateCircleRadius());
                  } else
                    (this._userLocationDotMarker.remove(),
                      this._accuracyCircleMarker.remove());
                }),
                (this._onZoom = () => {
                  this.options.showUserLocation &&
                    this.options.showAccuracyCircle &&
                    this._updateCircleRadius();
                }),
                (this._onError = (e) => {
                  if (this._map) {
                    if (this.options.trackUserLocation)
                      if (e.code === 1) {
                        ((this._watchState = "OFF"),
                          this._geolocateButton.classList.remove(
                            "maplibregl-ctrl-geolocate-waiting",
                          ),
                          this._geolocateButton.classList.remove(
                            "maplibregl-ctrl-geolocate-active",
                          ),
                          this._geolocateButton.classList.remove(
                            "maplibregl-ctrl-geolocate-active-error",
                          ),
                          this._geolocateButton.classList.remove(
                            "maplibregl-ctrl-geolocate-background",
                          ),
                          this._geolocateButton.classList.remove(
                            "maplibregl-ctrl-geolocate-background-error",
                          ),
                          (this._geolocateButton.disabled = !0));
                        const i = this._map._getUIString(
                          "GeolocateControl.LocationNotAvailable",
                        );
                        ((this._geolocateButton.title = i),
                          this._geolocateButton.setAttribute("aria-label", i),
                          this._geolocationWatchID !== void 0 &&
                            this._clearWatch());
                      } else {
                        if (e.code === 3 && jn) return;
                        this._setErrorState();
                      }
                    (this._watchState !== "OFF" &&
                      this.options.showUserLocation &&
                      this._dotElement.classList.add(
                        "maplibregl-user-location-dot-stale",
                      ),
                      this.fire(new u.k("error", e)),
                      this._finish());
                  }
                }),
                (this._finish = () => {
                  (this._timeoutId && clearTimeout(this._timeoutId),
                    (this._timeoutId = void 0));
                }),
                (this._setupUI = () => {
                  this._map &&
                    (this._container.addEventListener("contextmenu", (e) =>
                      e.preventDefault(),
                    ),
                    (this._geolocateButton = me.create(
                      "button",
                      "maplibregl-ctrl-geolocate",
                      this._container,
                    )),
                    me
                      .create(
                        "span",
                        "maplibregl-ctrl-icon",
                        this._geolocateButton,
                      )
                      .setAttribute("aria-hidden", "true"),
                    (this._geolocateButton.type = "button"),
                    (this._geolocateButton.disabled = !0));
                }),
                (this._finishSetupUI = (e) => {
                  if (this._map) {
                    if (e === !1) {
                      u.w(
                        "Geolocation support is not available so the GeolocateControl will be disabled.",
                      );
                      const i = this._map._getUIString(
                        "GeolocateControl.LocationNotAvailable",
                      );
                      ((this._geolocateButton.disabled = !0),
                        (this._geolocateButton.title = i),
                        this._geolocateButton.setAttribute("aria-label", i));
                    } else {
                      const i = this._map._getUIString(
                        "GeolocateControl.FindMyLocation",
                      );
                      ((this._geolocateButton.disabled = !1),
                        (this._geolocateButton.title = i),
                        this._geolocateButton.setAttribute("aria-label", i));
                    }
                    (this.options.trackUserLocation &&
                      (this._geolocateButton.setAttribute(
                        "aria-pressed",
                        "false",
                      ),
                      (this._watchState = "OFF")),
                      this.options.showUserLocation &&
                        ((this._dotElement = me.create(
                          "div",
                          "maplibregl-user-location-dot",
                        )),
                        (this._userLocationDotMarker = new Xo({
                          element: this._dotElement,
                        })),
                        (this._circleElement = me.create(
                          "div",
                          "maplibregl-user-location-accuracy-circle",
                        )),
                        (this._accuracyCircleMarker = new Xo({
                          element: this._circleElement,
                          pitchAlignment: "map",
                        })),
                        this.options.trackUserLocation &&
                          (this._watchState = "OFF"),
                        this._map.on("zoom", this._onZoom)),
                      this._geolocateButton.addEventListener("click", () =>
                        this.trigger(),
                      ),
                      (this._setup = !0),
                      this.options.trackUserLocation &&
                        this._map.on("movestart", (i) => {
                          i.geolocateSource ||
                            this._watchState !== "ACTIVE_LOCK" ||
                            (i.originalEvent &&
                              i.originalEvent.type === "resize") ||
                            ((this._watchState = "BACKGROUND"),
                            this._geolocateButton.classList.add(
                              "maplibregl-ctrl-geolocate-background",
                            ),
                            this._geolocateButton.classList.remove(
                              "maplibregl-ctrl-geolocate-active",
                            ),
                            this.fire(new u.k("trackuserlocationend")),
                            this.fire(new u.k("userlocationlostfocus")));
                        }));
                  }
                }),
                (this.options = u.e({}, el, c)));
            }
            onAdd(c) {
              return (
                (this._map = c),
                (this._container = me.create(
                  "div",
                  "maplibregl-ctrl maplibregl-ctrl-group",
                )),
                this._setupUI(),
                (function () {
                  return u._(this, arguments, void 0, function* (e = !1) {
                    if ($r !== void 0 && !e) return $r;
                    if (window.navigator.permissions === void 0)
                      return (($r = !!window.navigator.geolocation), $r);
                    try {
                      $r =
                        (yield window.navigator.permissions.query({
                          name: "geolocation",
                        })).state !== "denied";
                    } catch {
                      $r = !!window.navigator.geolocation;
                    }
                    return $r;
                  });
                })().then((e) => this._finishSetupUI(e)),
                this._container
              );
            }
            onRemove() {
              (this._geolocationWatchID !== void 0 &&
                (window.navigator.geolocation.clearWatch(
                  this._geolocationWatchID,
                ),
                (this._geolocationWatchID = void 0)),
                this.options.showUserLocation &&
                  this._userLocationDotMarker &&
                  this._userLocationDotMarker.remove(),
                this.options.showAccuracyCircle &&
                  this._accuracyCircleMarker &&
                  this._accuracyCircleMarker.remove(),
                me.remove(this._container),
                this._map.off("zoom", this._onZoom),
                (this._map = void 0),
                (mo = 0),
                (jn = !1));
            }
            _isOutOfMapMaxBounds(c) {
              const e = this._map.getMaxBounds(),
                i = c.coords;
              return (
                e &&
                (i.longitude < e.getWest() ||
                  i.longitude > e.getEast() ||
                  i.latitude < e.getSouth() ||
                  i.latitude > e.getNorth())
              );
            }
            _setErrorState() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  ((this._watchState = "ACTIVE_ERROR"),
                    this._geolocateButton.classList.remove(
                      "maplibregl-ctrl-geolocate-active",
                    ),
                    this._geolocateButton.classList.add(
                      "maplibregl-ctrl-geolocate-active-error",
                    ));
                  break;
                case "ACTIVE_LOCK":
                  ((this._watchState = "ACTIVE_ERROR"),
                    this._geolocateButton.classList.remove(
                      "maplibregl-ctrl-geolocate-active",
                    ),
                    this._geolocateButton.classList.add(
                      "maplibregl-ctrl-geolocate-active-error",
                    ),
                    this._geolocateButton.classList.add(
                      "maplibregl-ctrl-geolocate-waiting",
                    ));
                  break;
                case "BACKGROUND":
                  ((this._watchState = "BACKGROUND_ERROR"),
                    this._geolocateButton.classList.remove(
                      "maplibregl-ctrl-geolocate-background",
                    ),
                    this._geolocateButton.classList.add(
                      "maplibregl-ctrl-geolocate-background-error",
                    ),
                    this._geolocateButton.classList.add(
                      "maplibregl-ctrl-geolocate-waiting",
                    ));
                  break;
                case "ACTIVE_ERROR":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
            }
            _updateCircleRadius() {
              const c = this._map.getBounds(),
                e = c.getSouthEast(),
                i = c.getNorthEast(),
                s = e.distanceTo(i),
                a = Math.ceil(
                  (this._accuracy / (s / this._map._container.clientHeight)) *
                    2,
                );
              ((this._circleElement.style.width = `${a}px`),
                (this._circleElement.style.height = `${a}px`));
            }
            trigger() {
              if (!this._setup)
                return (
                  u.w("Geolocate control triggered before added to a map"),
                  !1
                );
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    ((this._watchState = "WAITING_ACTIVE"),
                      this.fire(new u.k("trackuserlocationstart")));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    (mo--,
                      (jn = !1),
                      (this._watchState = "OFF"),
                      this._geolocateButton.classList.remove(
                        "maplibregl-ctrl-geolocate-waiting",
                      ),
                      this._geolocateButton.classList.remove(
                        "maplibregl-ctrl-geolocate-active",
                      ),
                      this._geolocateButton.classList.remove(
                        "maplibregl-ctrl-geolocate-active-error",
                      ),
                      this._geolocateButton.classList.remove(
                        "maplibregl-ctrl-geolocate-background",
                      ),
                      this._geolocateButton.classList.remove(
                        "maplibregl-ctrl-geolocate-background-error",
                      ),
                      this.fire(new u.k("trackuserlocationend")));
                    break;
                  case "BACKGROUND":
                    ((this._watchState = "ACTIVE_LOCK"),
                      this._geolocateButton.classList.remove(
                        "maplibregl-ctrl-geolocate-background",
                      ),
                      this._lastKnownPosition &&
                        this._updateCamera(this._lastKnownPosition),
                      this.fire(new u.k("trackuserlocationstart")),
                      this.fire(new u.k("userlocationfocus")));
                    break;
                  default:
                    throw new Error(
                      `Unexpected watchState ${this._watchState}`,
                    );
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    (this._geolocateButton.classList.add(
                      "maplibregl-ctrl-geolocate-waiting",
                    ),
                      this._geolocateButton.classList.add(
                        "maplibregl-ctrl-geolocate-active",
                      ));
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add(
                      "maplibregl-ctrl-geolocate-active",
                    );
                    break;
                  case "OFF":
                    break;
                  default:
                    throw new Error(
                      `Unexpected watchState ${this._watchState}`,
                    );
                }
                if (
                  this._watchState === "OFF" &&
                  this._geolocationWatchID !== void 0
                )
                  this._clearWatch();
                else if (this._geolocationWatchID === void 0) {
                  let c;
                  (this._geolocateButton.classList.add(
                    "maplibregl-ctrl-geolocate-waiting",
                  ),
                    this._geolocateButton.setAttribute("aria-pressed", "true"),
                    mo++,
                    mo > 1
                      ? ((c = { maximumAge: 6e5, timeout: 0 }), (jn = !0))
                      : ((c = this.options.positionOptions), (jn = !1)),
                    (this._geolocationWatchID =
                      window.navigator.geolocation.watchPosition(
                        this._onSuccess,
                        this._onError,
                        c,
                      )));
                }
              } else
                (window.navigator.geolocation.getCurrentPosition(
                  this._onSuccess,
                  this._onError,
                  this.options.positionOptions,
                ),
                  (this._timeoutId = setTimeout(this._finish, 1e4)));
              return !0;
            }
            _clearWatch() {
              (window.navigator.geolocation.clearWatch(
                this._geolocationWatchID,
              ),
                (this._geolocationWatchID = void 0),
                this._geolocateButton.classList.remove(
                  "maplibregl-ctrl-geolocate-waiting",
                ),
                this._geolocateButton.setAttribute("aria-pressed", "false"),
                this.options.showUserLocation && this._updateMarker(null));
            }
          }),
          (E.GlobeControl = class {
            constructor() {
              ((this._toggleProjection = () => {
                var c;
                const e =
                  (c = this._map.getProjection()) === null || c === void 0
                    ? void 0
                    : c.type;
                (this._map.setProjection(
                  e !== "mercator" && e
                    ? { type: "mercator" }
                    : { type: "globe" },
                ),
                  this._updateGlobeIcon());
              }),
                (this._updateGlobeIcon = () => {
                  var c;
                  (this._globeButton.classList.remove("maplibregl-ctrl-globe"),
                    this._globeButton.classList.remove(
                      "maplibregl-ctrl-globe-enabled",
                    ),
                    ((c = this._map.getProjection()) === null || c === void 0
                      ? void 0
                      : c.type) === "globe"
                      ? (this._globeButton.classList.add(
                          "maplibregl-ctrl-globe-enabled",
                        ),
                        (this._globeButton.title = this._map._getUIString(
                          "GlobeControl.Disable",
                        )))
                      : (this._globeButton.classList.add(
                          "maplibregl-ctrl-globe",
                        ),
                        (this._globeButton.title = this._map._getUIString(
                          "GlobeControl.Enable",
                        ))));
                }));
            }
            onAdd(c) {
              return (
                (this._map = c),
                (this._container = me.create(
                  "div",
                  "maplibregl-ctrl maplibregl-ctrl-group",
                )),
                (this._globeButton = me.create(
                  "button",
                  "maplibregl-ctrl-globe",
                  this._container,
                )),
                me
                  .create("span", "maplibregl-ctrl-icon", this._globeButton)
                  .setAttribute("aria-hidden", "true"),
                (this._globeButton.type = "button"),
                this._globeButton.addEventListener(
                  "click",
                  this._toggleProjection,
                ),
                this._updateGlobeIcon(),
                this._map.on("styledata", this._updateGlobeIcon),
                this._container
              );
            }
            onRemove() {
              (me.remove(this._container),
                this._map.off("styledata", this._updateGlobeIcon),
                this._globeButton.removeEventListener(
                  "click",
                  this._toggleProjection,
                ),
                (this._map = void 0));
            }
          }),
          (E.Hash = Ha),
          (E.ImageSource = Ji),
          (E.KeyboardHandler = Cu),
          (E.LngLatBounds = ti),
          (E.LogoControl = Ys),
          (E.Map = class extends et {
            constructor(c) {
              var e, i;
              u.cd.mark(u.ce.create);
              const s = Object.assign(Object.assign(Object.assign({}, qo), c), {
                canvasContextAttributes: Object.assign(
                  Object.assign({}, qo.canvasContextAttributes),
                  c.canvasContextAttributes,
                ),
              });
              if (
                s.minZoom != null &&
                s.maxZoom != null &&
                s.minZoom > s.maxZoom
              )
                throw new Error(
                  "maxZoom must be greater than or equal to minZoom",
                );
              if (
                s.minPitch != null &&
                s.maxPitch != null &&
                s.minPitch > s.maxPitch
              )
                throw new Error(
                  "maxPitch must be greater than or equal to minPitch",
                );
              if (s.minPitch != null && s.minPitch < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (s.maxPitch != null && s.maxPitch > 180)
                throw new Error("maxPitch must be less than or equal to 180");
              const a = new Fi(),
                h = new tn();
              if (
                (s.minZoom !== void 0 && a.setMinZoom(s.minZoom),
                s.maxZoom !== void 0 && a.setMaxZoom(s.maxZoom),
                s.minPitch !== void 0 && a.setMinPitch(s.minPitch),
                s.maxPitch !== void 0 && a.setMaxPitch(s.maxPitch),
                s.renderWorldCopies !== void 0 &&
                  a.setRenderWorldCopies(s.renderWorldCopies),
                super(a, h, { bearingSnap: s.bearingSnap }),
                (this._idleTriggered = !1),
                (this._crossFadingFactor = 1),
                (this._renderTaskQueue = new $i()),
                (this._controls = []),
                (this._mapId = u.a1()),
                (this._contextLost = (g) => {
                  (g.preventDefault(),
                    this._frameRequest &&
                      (this._frameRequest.abort(), (this._frameRequest = null)),
                    this.fire(
                      new u.k("webglcontextlost", { originalEvent: g }),
                    ));
                }),
                (this._contextRestored = (g) => {
                  (this._setupPainter(),
                    this.resize(),
                    this._update(),
                    this.fire(
                      new u.k("webglcontextrestored", { originalEvent: g }),
                    ));
                }),
                (this._onMapScroll = (g) => {
                  if (g.target === this._container)
                    return (
                      (this._container.scrollTop = 0),
                      (this._container.scrollLeft = 0),
                      !1
                    );
                }),
                (this._onWindowOnline = () => {
                  this._update();
                }),
                (this._interactive = s.interactive),
                (this._maxTileCacheSize = s.maxTileCacheSize),
                (this._maxTileCacheZoomLevels = s.maxTileCacheZoomLevels),
                (this._canvasContextAttributes = Object.assign(
                  {},
                  s.canvasContextAttributes,
                )),
                (this._trackResize = s.trackResize === !0),
                (this._bearingSnap = s.bearingSnap),
                (this._centerClampedToGround = s.centerClampedToGround),
                (this._refreshExpiredTiles = s.refreshExpiredTiles === !0),
                (this._fadeDuration = s.fadeDuration),
                (this._crossSourceCollisions = s.crossSourceCollisions === !0),
                (this._collectResourceTiming = s.collectResourceTiming === !0),
                (this._locale = Object.assign(Object.assign({}, Pu), s.locale)),
                (this._clickTolerance = s.clickTolerance),
                (this._overridePixelRatio = s.pixelRatio),
                (this._maxCanvasSize = s.maxCanvasSize),
                (this.transformCameraUpdate = s.transformCameraUpdate),
                (this.cancelPendingTileRequestsWhileZooming =
                  s.cancelPendingTileRequestsWhileZooming === !0),
                (this._imageQueueHandle = ei.addThrottleControl(() =>
                  this.isMoving(),
                )),
                (this._requestManager = new Vi(s.transformRequest)),
                typeof s.container == "string")
              ) {
                if (
                  ((this._container = document.getElementById(s.container)),
                  !this._container)
                )
                  throw new Error(`Container '${s.container}' not found.`);
              } else {
                if (!(s.container instanceof HTMLElement))
                  throw new Error(
                    "Invalid type: 'container' must be a String or HTMLElement.",
                  );
                this._container = s.container;
              }
              if (
                (s.maxBounds && this.setMaxBounds(s.maxBounds),
                this._setupContainer(),
                this._setupPainter(),
                this.on("move", () => this._update(!1)),
                this.on("moveend", () => this._update(!1)),
                this.on("zoom", () => this._update(!0)),
                this.on("terrain", () => {
                  ((this.painter.terrainFacilitator.dirty = !0),
                    this._update(!0));
                }),
                this.once("idle", () => {
                  this._idleTriggered = !0;
                }),
                typeof window < "u")
              ) {
                addEventListener("online", this._onWindowOnline, !1);
                let g = !1;
                const y = nn((v) => {
                  this._trackResize &&
                    !this._removed &&
                    (this.resize(v), this.redraw());
                }, 50);
                ((this._resizeObserver = new ResizeObserver((v) => {
                  g ? y(v) : (g = !0);
                })),
                  this._resizeObserver.observe(this._container));
              }
              ((this.handlers = new He(this, s)),
                (this._hash =
                  s.hash &&
                  new Ha((typeof s.hash == "string" && s.hash) || void 0).addTo(
                    this,
                  )),
                (this._hash && this._hash._onHashChange()) ||
                  (this.jumpTo({
                    center: s.center,
                    elevation: s.elevation,
                    zoom: s.zoom,
                    bearing: s.bearing,
                    pitch: s.pitch,
                    roll: s.roll,
                  }),
                  s.bounds &&
                    (this.resize(),
                    this.fitBounds(
                      s.bounds,
                      u.e({}, s.fitBoundsOptions, { duration: 0 }),
                    ))));
              const f =
                typeof s.style == "string" ||
                ((i =
                  (e = s.style) === null || e === void 0
                    ? void 0
                    : e.projection) === null || i === void 0
                  ? void 0
                  : i.type) !== "globe";
              (this.resize(null, f),
                (this._localIdeographFontFamily = s.localIdeographFontFamily),
                (this._validateStyle = s.validateStyle),
                s.style &&
                  this.setStyle(s.style, {
                    localIdeographFontFamily: s.localIdeographFontFamily,
                  }),
                s.attributionControl &&
                  this.addControl(
                    new Ks(
                      typeof s.attributionControl == "boolean"
                        ? void 0
                        : s.attributionControl,
                    ),
                  ),
                s.maplibreLogo && this.addControl(new Ys(), s.logoPosition),
                this.on("style.load", () => {
                  if (
                    (f || this._resizeTransform(), this.transform.unmodified)
                  ) {
                    const g = u.M(this.style.stylesheet, [
                      "center",
                      "zoom",
                      "bearing",
                      "pitch",
                      "roll",
                    ]);
                    this.jumpTo(g);
                  }
                }),
                this.on("data", (g) => {
                  (this._update(g.dataType === "style"),
                    this.fire(new u.k(`${g.dataType}data`, g)));
                }),
                this.on("dataloading", (g) => {
                  this.fire(new u.k(`${g.dataType}dataloading`, g));
                }),
                this.on("dataabort", (g) => {
                  this.fire(new u.k("sourcedataabort", g));
                }));
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(c, e) {
              if (
                (e === void 0 &&
                  (e = c.getDefaultPosition
                    ? c.getDefaultPosition()
                    : "top-right"),
                !c || !c.onAdd)
              )
                return this.fire(
                  new u.j(
                    new Error(
                      "Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.",
                    ),
                  ),
                );
              const i = c.onAdd(this);
              this._controls.push(c);
              const s = this._controlPositions[e];
              return (
                e.indexOf("bottom") !== -1
                  ? s.insertBefore(i, s.firstChild)
                  : s.appendChild(i),
                this
              );
            }
            removeControl(c) {
              if (!c || !c.onRemove)
                return this.fire(
                  new u.j(
                    new Error(
                      "Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.",
                    ),
                  ),
                );
              const e = this._controls.indexOf(c);
              return (
                e > -1 && this._controls.splice(e, 1),
                c.onRemove(this),
                this
              );
            }
            hasControl(c) {
              return this._controls.indexOf(c) > -1;
            }
            calculateCameraOptionsFromTo(c, e, i, s) {
              return (
                s == null &&
                  this.terrain &&
                  (s = this.terrain.getElevationForLngLatZoom(
                    i,
                    this.transform.tileZoom,
                  )),
                super.calculateCameraOptionsFromTo(c, e, i, s)
              );
            }
            resize(c, e = !0) {
              const [i, s] = this._containerDimensions(),
                a = this._getClampedPixelRatio(i, s);
              if (
                (this._resizeCanvas(i, s, a),
                this.painter.resize(i, s, a),
                this.painter.overLimit())
              ) {
                const f = this.painter.context.gl;
                this._maxCanvasSize = [
                  f.drawingBufferWidth,
                  f.drawingBufferHeight,
                ];
                const g = this._getClampedPixelRatio(i, s);
                (this._resizeCanvas(i, s, g), this.painter.resize(i, s, g));
              }
              this._resizeTransform(e);
              const h = !this._moving;
              return (
                h &&
                  (this.stop(),
                  this.fire(new u.k("movestart", c)).fire(new u.k("move", c))),
                this.fire(new u.k("resize", c)),
                h && this.fire(new u.k("moveend", c)),
                this
              );
            }
            _resizeTransform(c = !0) {
              var e;
              const [i, s] = this._containerDimensions();
              (this.transform.resize(i, s, c),
                (e = this._requestedCameraState) === null ||
                  e === void 0 ||
                  e.resize(i, s, c));
            }
            _getClampedPixelRatio(c, e) {
              const { 0: i, 1: s } = this._maxCanvasSize,
                a = this.getPixelRatio(),
                h = c * a,
                f = e * a;
              return Math.min(h > i ? i / h : 1, f > s ? s / f : 1) * a;
            }
            getPixelRatio() {
              var c;
              return (c = this._overridePixelRatio) !== null && c !== void 0
                ? c
                : devicePixelRatio;
            }
            setPixelRatio(c) {
              ((this._overridePixelRatio = c), this.resize());
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds();
            }
            setMaxBounds(c) {
              return (
                this.transform.setMaxBounds(ti.convert(c)),
                this._update()
              );
            }
            setMinZoom(c) {
              if ((c = c == null ? -2 : c) >= -2 && c <= this.transform.maxZoom)
                return (
                  this.transform.setMinZoom(c),
                  this._update(),
                  this.getZoom() < c && this.setZoom(c),
                  this
                );
              throw new Error(
                "minZoom must be between -2 and the current maxZoom, inclusive",
              );
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(c) {
              if ((c = c == null ? 22 : c) >= this.transform.minZoom)
                return (
                  this.transform.setMaxZoom(c),
                  this._update(),
                  this.getZoom() > c && this.setZoom(c),
                  this
                );
              throw new Error(
                "maxZoom must be greater than the current minZoom",
              );
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(c) {
              if ((c = c == null ? 0 : c) < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (c >= 0 && c <= this.transform.maxPitch)
                return (
                  this.transform.setMinPitch(c),
                  this._update(),
                  this.getPitch() < c && this.setPitch(c),
                  this
                );
              throw new Error(
                "minPitch must be between 0 and the current maxPitch, inclusive",
              );
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(c) {
              if ((c = c == null ? 60 : c) > 180)
                throw new Error("maxPitch must be less than or equal to 180");
              if (c >= this.transform.minPitch)
                return (
                  this.transform.setMaxPitch(c),
                  this._update(),
                  this.getPitch() > c && this.setPitch(c),
                  this
                );
              throw new Error(
                "maxPitch must be greater than the current minPitch",
              );
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(c) {
              return (this.transform.setRenderWorldCopies(c), this._update());
            }
            project(c) {
              return this.transform.locationToScreenPoint(
                u.N.convert(c),
                this.style && this.terrain,
              );
            }
            unproject(c) {
              return this.transform.screenPointToLocation(
                u.P.convert(c),
                this.terrain,
              );
            }
            isMoving() {
              var c;
              return (
                this._moving ||
                ((c = this.handlers) === null || c === void 0
                  ? void 0
                  : c.isMoving())
              );
            }
            isZooming() {
              var c;
              return (
                this._zooming ||
                ((c = this.handlers) === null || c === void 0
                  ? void 0
                  : c.isZooming())
              );
            }
            isRotating() {
              var c;
              return (
                this._rotating ||
                ((c = this.handlers) === null || c === void 0
                  ? void 0
                  : c.isRotating())
              );
            }
            _createDelegatedListener(c, e, i) {
              if (c === "mouseenter" || c === "mouseover") {
                let s = !1;
                return {
                  layers: e,
                  listener: i,
                  delegates: {
                    mousemove: (h) => {
                      const f = e.filter((y) => this.getLayer(y)),
                        g =
                          f.length !== 0
                            ? this.queryRenderedFeatures(h.point, { layers: f })
                            : [];
                      g.length
                        ? s ||
                          ((s = !0),
                          i.call(
                            this,
                            new Yt(c, this, h.originalEvent, { features: g }),
                          ))
                        : (s = !1);
                    },
                    mouseout: () => {
                      s = !1;
                    },
                  },
                };
              }
              if (c === "mouseleave" || c === "mouseout") {
                let s = !1;
                return {
                  layers: e,
                  listener: i,
                  delegates: {
                    mousemove: (f) => {
                      const g = e.filter((y) => this.getLayer(y));
                      (g.length !== 0
                        ? this.queryRenderedFeatures(f.point, { layers: g })
                        : []
                      ).length
                        ? (s = !0)
                        : s &&
                          ((s = !1),
                          i.call(this, new Yt(c, this, f.originalEvent)));
                    },
                    mouseout: (f) => {
                      s &&
                        ((s = !1),
                        i.call(this, new Yt(c, this, f.originalEvent)));
                    },
                  },
                };
              }
              {
                const s = (a) => {
                  const h = e.filter((g) => this.getLayer(g)),
                    f =
                      h.length !== 0
                        ? this.queryRenderedFeatures(a.point, { layers: h })
                        : [];
                  f.length &&
                    ((a.features = f), i.call(this, a), delete a.features);
                };
                return { layers: e, listener: i, delegates: { [c]: s } };
              }
            }
            _saveDelegatedListener(c, e) {
              ((this._delegatedListeners = this._delegatedListeners || {}),
                (this._delegatedListeners[c] =
                  this._delegatedListeners[c] || []),
                this._delegatedListeners[c].push(e));
            }
            _removeDelegatedListener(c, e, i) {
              if (!this._delegatedListeners || !this._delegatedListeners[c])
                return;
              const s = this._delegatedListeners[c];
              for (let a = 0; a < s.length; a++) {
                const h = s[a];
                if (
                  h.listener === i &&
                  h.layers.length === e.length &&
                  h.layers.every((f) => e.includes(f))
                ) {
                  for (const f in h.delegates) this.off(f, h.delegates[f]);
                  return void s.splice(a, 1);
                }
              }
            }
            on(c, e, i) {
              if (i === void 0) return super.on(c, e);
              const s = typeof e == "string" ? [e] : e,
                a = this._createDelegatedListener(c, s, i);
              this._saveDelegatedListener(c, a);
              for (const h in a.delegates) this.on(h, a.delegates[h]);
              return {
                unsubscribe: () => {
                  this._removeDelegatedListener(c, s, i);
                },
              };
            }
            once(c, e, i) {
              if (i === void 0) return super.once(c, e);
              const s = typeof e == "string" ? [e] : e,
                a = this._createDelegatedListener(c, s, i);
              for (const h in a.delegates) {
                const f = a.delegates[h];
                a.delegates[h] = (...g) => {
                  (this._removeDelegatedListener(c, s, i), f(...g));
                };
              }
              this._saveDelegatedListener(c, a);
              for (const h in a.delegates) this.once(h, a.delegates[h]);
              return this;
            }
            off(c, e, i) {
              return i === void 0
                ? super.off(c, e)
                : (this._removeDelegatedListener(
                    c,
                    typeof e == "string" ? [e] : e,
                    i,
                  ),
                  this);
            }
            queryRenderedFeatures(c, e) {
              if (!this.style) return [];
              let i;
              const s = c instanceof u.P || Array.isArray(c),
                a = s
                  ? c
                  : [
                      [0, 0],
                      [this.transform.width, this.transform.height],
                    ];
              if (
                ((e = e || (s ? {} : c) || {}),
                a instanceof u.P || typeof a[0] == "number")
              )
                i = [u.P.convert(a)];
              else {
                const h = u.P.convert(a[0]),
                  f = u.P.convert(a[1]);
                i = [h, new u.P(f.x, h.y), f, new u.P(h.x, f.y), h];
              }
              return this.style.queryRenderedFeatures(i, e, this.transform);
            }
            querySourceFeatures(c, e) {
              return this.style.querySourceFeatures(c, e);
            }
            setStyle(c, e) {
              return (e = u.e(
                {},
                {
                  localIdeographFontFamily: this._localIdeographFontFamily,
                  validate: this._validateStyle,
                },
                e,
              )).diff !== !1 &&
                e.localIdeographFontFamily === this._localIdeographFontFamily &&
                this.style &&
                c
                ? (this._diffStyle(c, e), this)
                : ((this._localIdeographFontFamily =
                    e.localIdeographFontFamily),
                  this._updateStyle(c, e));
            }
            setTransformRequest(c) {
              return (this._requestManager.setTransformRequest(c), this);
            }
            _getUIString(c) {
              const e = this._locale[c];
              if (e == null) throw new Error(`Missing UI string '${c}'`);
              return e;
            }
            _updateStyle(c, e) {
              var i, s;
              if (e.transformStyle && this.style && !this.style._loaded)
                return void this.style.once("style.load", () =>
                  this._updateStyle(c, e),
                );
              const a =
                this.style && e.transformStyle
                  ? this.style.serialize()
                  : void 0;
              return (
                this.style &&
                  (this.style.setEventedParent(null), this.style._remove(!c)),
                c
                  ? ((this.style = new ba(this, e || {})),
                    this.style.setEventedParent(this, { style: this.style }),
                    typeof c == "string"
                      ? this.style.loadURL(c, e, a)
                      : this.style.loadJSON(c, e, a),
                    this)
                  : ((s =
                      (i = this.style) === null || i === void 0
                        ? void 0
                        : i.projection) === null ||
                      s === void 0 ||
                      s.destroy(),
                    delete this.style,
                    this)
              );
            }
            _lazyInitEmptyStyle() {
              this.style ||
                ((this.style = new ba(this, {})),
                this.style.setEventedParent(this, { style: this.style }),
                this.style.loadEmpty());
            }
            _diffStyle(c, e) {
              if (typeof c == "string") {
                const i = this._requestManager.transformRequest(c, "Style");
                u.h(i, new AbortController())
                  .then((s) => {
                    this._updateDiff(s.data, e);
                  })
                  .catch((s) => {
                    s && this.fire(new u.j(s));
                  });
              } else typeof c == "object" && this._updateDiff(c, e);
            }
            _updateDiff(c, e) {
              try {
                this.style.setState(c, e) && this._update(!0);
              } catch (i) {
                (u.w(
                  `Unable to perform style diff: ${i.message || i.error || i}.  Rebuilding the style from scratch.`,
                ),
                  this._updateStyle(c, e));
              }
            }
            getStyle() {
              if (this.style) return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style
                ? this.style.loaded()
                : u.w("There is no style added to the map.");
            }
            addSource(c, e) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.addSource(c, e),
                this._update(!0)
              );
            }
            isSourceLoaded(c) {
              const e = this.style && this.style.sourceCaches[c];
              if (e !== void 0) return e.loaded();
              this.fire(
                new u.j(new Error(`There is no source with ID '${c}'`)),
              );
            }
            setTerrain(c) {
              if (
                (this.style._checkLoaded(),
                this._terrainDataCallback &&
                  this.style.off("data", this._terrainDataCallback),
                c)
              ) {
                const e = this.style.sourceCaches[c.source];
                if (!e)
                  throw new Error(
                    `cannot load terrain, because there exists no source with ID: ${c.source}`,
                  );
                this.terrain === null && e.reload();
                for (const i in this.style._layers) {
                  const s = this.style._layers[i];
                  s.type === "hillshade" &&
                    s.source === c.source &&
                    u.w(
                      "You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.",
                    );
                }
                ((this.terrain = new gc(this.painter, e, c)),
                  (this.painter.renderToTexture = new ii(
                    this.painter,
                    this.terrain,
                  )),
                  this.transform.setMinElevationForCurrentTile(
                    this.terrain.getMinTileElevationForLngLatZoom(
                      this.transform.center,
                      this.transform.tileZoom,
                    ),
                  ),
                  this.transform.setElevation(
                    this.terrain.getElevationForLngLatZoom(
                      this.transform.center,
                      this.transform.tileZoom,
                    ),
                  ),
                  (this._terrainDataCallback = (i) => {
                    i.dataType === "style"
                      ? this.terrain.sourceCache.freeRtt()
                      : i.dataType === "source" &&
                        i.tile &&
                        (i.sourceId !== c.source ||
                          this._elevationFreeze ||
                          (this.transform.setMinElevationForCurrentTile(
                            this.terrain.getMinTileElevationForLngLatZoom(
                              this.transform.center,
                              this.transform.tileZoom,
                            ),
                          ),
                          this._centerClampedToGround &&
                            this.transform.setElevation(
                              this.terrain.getElevationForLngLatZoom(
                                this.transform.center,
                                this.transform.tileZoom,
                              ),
                            )),
                        this.terrain.sourceCache.freeRtt(i.tile.tileID));
                  }),
                  this.style.on("data", this._terrainDataCallback));
              } else
                (this.terrain && this.terrain.sourceCache.destruct(),
                  (this.terrain = null),
                  this.painter.renderToTexture &&
                    this.painter.renderToTexture.destruct(),
                  (this.painter.renderToTexture = null),
                  this.transform.setMinElevationForCurrentTile(0),
                  this._centerClampedToGround &&
                    this.transform.setElevation(0));
              return (this.fire(new u.k("terrain", { terrain: c })), this);
            }
            getTerrain() {
              var c, e;
              return (e =
                (c = this.terrain) === null || c === void 0
                  ? void 0
                  : c.options) !== null && e !== void 0
                ? e
                : null;
            }
            areTilesLoaded() {
              const c = this.style && this.style.sourceCaches;
              for (const e in c) {
                const i = c[e]._tiles;
                for (const s in i) {
                  const a = i[s];
                  if (a.state !== "loaded" && a.state !== "errored") return !1;
                }
              }
              return !0;
            }
            removeSource(c) {
              return (this.style.removeSource(c), this._update(!0));
            }
            getSource(c) {
              return this.style.getSource(c);
            }
            addImage(c, e, i = {}) {
              const {
                pixelRatio: s = 1,
                sdf: a = !1,
                stretchX: h,
                stretchY: f,
                content: g,
                textFitWidth: y,
                textFitHeight: v,
              } = i;
              if (
                (this._lazyInitEmptyStyle(),
                !(e instanceof HTMLImageElement || u.b(e)))
              ) {
                if (e.width === void 0 || e.height === void 0)
                  return this.fire(
                    new u.j(
                      new Error(
                        "Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`",
                      ),
                    ),
                  );
                {
                  const { width: C, height: A, data: T } = e,
                    M = e;
                  return (
                    this.style.addImage(c, {
                      data: new u.R({ width: C, height: A }, new Uint8Array(T)),
                      pixelRatio: s,
                      stretchX: h,
                      stretchY: f,
                      content: g,
                      textFitWidth: y,
                      textFitHeight: v,
                      sdf: a,
                      version: 0,
                      userImage: M,
                    }),
                    M.onAdd && M.onAdd(this, c),
                    this
                  );
                }
              }
              {
                const { width: C, height: A, data: T } = Qe.getImageData(e);
                this.style.addImage(c, {
                  data: new u.R({ width: C, height: A }, T),
                  pixelRatio: s,
                  stretchX: h,
                  stretchY: f,
                  content: g,
                  textFitWidth: y,
                  textFitHeight: v,
                  sdf: a,
                  version: 0,
                });
              }
            }
            updateImage(c, e) {
              const i = this.style.getImage(c);
              if (!i)
                return this.fire(
                  new u.j(
                    new Error(
                      "The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.",
                    ),
                  ),
                );
              const s =
                  e instanceof HTMLImageElement || u.b(e)
                    ? Qe.getImageData(e)
                    : e,
                { width: a, height: h, data: f } = s;
              if (a === void 0 || h === void 0)
                return this.fire(
                  new u.j(
                    new Error(
                      "Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`",
                    ),
                  ),
                );
              if (a !== i.data.width || h !== i.data.height)
                return this.fire(
                  new u.j(
                    new Error(
                      "The width and height of the updated image must be that same as the previous version of the image",
                    ),
                  ),
                );
              const g = !(e instanceof HTMLImageElement || u.b(e));
              return (i.data.replace(f, g), this.style.updateImage(c, i), this);
            }
            getImage(c) {
              return this.style.getImage(c);
            }
            hasImage(c) {
              return c
                ? !!this.style.getImage(c)
                : (this.fire(new u.j(new Error("Missing required image id"))),
                  !1);
            }
            removeImage(c) {
              this.style.removeImage(c);
            }
            loadImage(c) {
              return ei.getImage(
                this._requestManager.transformRequest(c, "Image"),
                new AbortController(),
              );
            }
            listImages() {
              return this.style.listImages();
            }
            addLayer(c, e) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.addLayer(c, e),
                this._update(!0)
              );
            }
            moveLayer(c, e) {
              return (this.style.moveLayer(c, e), this._update(!0));
            }
            removeLayer(c) {
              return (this.style.removeLayer(c), this._update(!0));
            }
            getLayer(c) {
              return this.style.getLayer(c);
            }
            getLayersOrder() {
              return this.style.getLayersOrder();
            }
            setLayerZoomRange(c, e, i) {
              return (this.style.setLayerZoomRange(c, e, i), this._update(!0));
            }
            setFilter(c, e, i = {}) {
              return (this.style.setFilter(c, e, i), this._update(!0));
            }
            getFilter(c) {
              return this.style.getFilter(c);
            }
            setPaintProperty(c, e, i, s = {}) {
              return (
                this.style.setPaintProperty(c, e, i, s),
                this._update(!0)
              );
            }
            getPaintProperty(c, e) {
              return this.style.getPaintProperty(c, e);
            }
            setLayoutProperty(c, e, i, s = {}) {
              return (
                this.style.setLayoutProperty(c, e, i, s),
                this._update(!0)
              );
            }
            getLayoutProperty(c, e) {
              return this.style.getLayoutProperty(c, e);
            }
            setGlyphs(c, e = {}) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.setGlyphs(c, e),
                this._update(!0)
              );
            }
            getGlyphs() {
              return this.style.getGlyphsUrl();
            }
            addSprite(c, e, i = {}) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.addSprite(c, e, i, (s) => {
                  s || this._update(!0);
                }),
                this
              );
            }
            removeSprite(c) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.removeSprite(c),
                this._update(!0)
              );
            }
            getSprite() {
              return this.style.getSprite();
            }
            setSprite(c, e = {}) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.setSprite(c, e, (i) => {
                  i || this._update(!0);
                }),
                this
              );
            }
            setLight(c, e = {}) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.setLight(c, e),
                this._update(!0)
              );
            }
            getLight() {
              return this.style.getLight();
            }
            setSky(c, e = {}) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.setSky(c, e),
                this._update(!0)
              );
            }
            getSky() {
              return this.style.getSky();
            }
            setFeatureState(c, e) {
              return (this.style.setFeatureState(c, e), this._update());
            }
            removeFeatureState(c, e) {
              return (this.style.removeFeatureState(c, e), this._update());
            }
            getFeatureState(c) {
              return this.style.getFeatureState(c);
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            _containerDimensions() {
              let c = 0,
                e = 0;
              return (
                this._container &&
                  ((c = this._container.clientWidth || 400),
                  (e = this._container.clientHeight || 300)),
                [c, e]
              );
            }
            _setupContainer() {
              const c = this._container;
              c.classList.add("maplibregl-map");
              const e = (this._canvasContainer = me.create(
                "div",
                "maplibregl-canvas-container",
                c,
              ));
              (this._interactive && e.classList.add("maplibregl-interactive"),
                (this._canvas = me.create("canvas", "maplibregl-canvas", e)),
                this._canvas.addEventListener(
                  "webglcontextlost",
                  this._contextLost,
                  !1,
                ),
                this._canvas.addEventListener(
                  "webglcontextrestored",
                  this._contextRestored,
                  !1,
                ),
                this._canvas.setAttribute(
                  "tabindex",
                  this._interactive ? "0" : "-1",
                ),
                this._canvas.setAttribute(
                  "aria-label",
                  this._getUIString("Map.Title"),
                ),
                this._canvas.setAttribute("role", "region"));
              const i = this._containerDimensions(),
                s = this._getClampedPixelRatio(i[0], i[1]);
              this._resizeCanvas(i[0], i[1], s);
              const a = (this._controlContainer = me.create(
                  "div",
                  "maplibregl-control-container",
                  c,
                )),
                h = (this._controlPositions = {});
              (["top-left", "top-right", "bottom-left", "bottom-right"].forEach(
                (f) => {
                  h[f] = me.create("div", `maplibregl-ctrl-${f} `, a);
                },
              ),
                this._container.addEventListener(
                  "scroll",
                  this._onMapScroll,
                  !1,
                ));
            }
            _resizeCanvas(c, e, i) {
              ((this._canvas.width = Math.floor(i * c)),
                (this._canvas.height = Math.floor(i * e)),
                (this._canvas.style.width = `${c}px`),
                (this._canvas.style.height = `${e}px`));
            }
            _setupPainter() {
              const c = Object.assign(
                Object.assign({}, this._canvasContextAttributes),
                { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 },
              );
              let e = null;
              this._canvas.addEventListener(
                "webglcontextcreationerror",
                (s) => {
                  ((e = { requestedAttributes: c }),
                    s &&
                      ((e.statusMessage = s.statusMessage), (e.type = s.type)));
                },
                { once: !0 },
              );
              let i = null;
              if (
                ((i = this._canvasContextAttributes.contextType
                  ? this._canvas.getContext(
                      this._canvasContextAttributes.contextType,
                      c,
                    )
                  : this._canvas.getContext("webgl2", c) ||
                    this._canvas.getContext("webgl", c)),
                !i)
              ) {
                const s = "Failed to initialize WebGL";
                throw e
                  ? ((e.message = s), new Error(JSON.stringify(e)))
                  : new Error(s);
              }
              ((this.painter = new lu(i, this.transform)), Ze.testSupport(i));
            }
            migrateProjection(c, e) {
              (super.migrateProjection(c, e),
                (this.painter.transform = c),
                this.fire(
                  new u.k("projectiontransition", {
                    newProjection: this.style.projection.name,
                  }),
                ));
            }
            loaded() {
              return (
                !this._styleDirty &&
                !this._sourcesDirty &&
                !!this.style &&
                this.style.loaded()
              );
            }
            _update(c) {
              return this.style && this.style._loaded
                ? ((this._styleDirty = this._styleDirty || c),
                  (this._sourcesDirty = !0),
                  this.triggerRepaint(),
                  this)
                : this;
            }
            _requestRenderFrame(c) {
              return (this._update(), this._renderTaskQueue.add(c));
            }
            _cancelRenderFrame(c) {
              this._renderTaskQueue.remove(c);
            }
            _render(c) {
              var e, i, s, a, h;
              const f = this._idleTriggered ? this._fadeDuration : 0,
                g =
                  ((e = this.style.projection) === null || e === void 0
                    ? void 0
                    : e.transitionState) > 0;
              if (
                (this.painter.context.setDirty(),
                this.painter.setBaseState(),
                this._renderTaskQueue.run(c),
                this._removed)
              )
                return;
              let y = !1;
              if (this.style && this._styleDirty) {
                this._styleDirty = !1;
                const A = this.transform.zoom,
                  T = Qe.now();
                this.style.zoomHistory.update(A, T);
                const M = new u.z(A, {
                    now: T,
                    fadeDuration: f,
                    zoomHistory: this.style.zoomHistory,
                    transition: this.style.getTransition(),
                  }),
                  k = M.crossFadingFactor();
                ((k === 1 && k === this._crossFadingFactor) ||
                  ((y = !0), (this._crossFadingFactor = k)),
                  this.style.update(M));
              }
              const v =
                ((i = this.style.projection) === null || i === void 0
                  ? void 0
                  : i.transitionState) >
                  0 !==
                g;
              ((s = this.style.projection) === null ||
                s === void 0 ||
                s.setErrorQueryLatitudeDegrees(this.transform.center.lat),
                this.transform.setTransitionState(
                  (a = this.style.projection) === null || a === void 0
                    ? void 0
                    : a.transitionState,
                  (h = this.style.projection) === null || h === void 0
                    ? void 0
                    : h.latitudeErrorCorrectionRadians,
                ),
                this.style &&
                  (this._sourcesDirty || v) &&
                  ((this._sourcesDirty = !1),
                  this.style._updateSources(this.transform)),
                this.terrain
                  ? (this.terrain.sourceCache.update(
                      this.transform,
                      this.terrain,
                    ),
                    this.transform.setMinElevationForCurrentTile(
                      this.terrain.getMinTileElevationForLngLatZoom(
                        this.transform.center,
                        this.transform.tileZoom,
                      ),
                    ),
                    !this._elevationFreeze &&
                      this._centerClampedToGround &&
                      this.transform.setElevation(
                        this.terrain.getElevationForLngLatZoom(
                          this.transform.center,
                          this.transform.tileZoom,
                        ),
                      ))
                  : (this.transform.setMinElevationForCurrentTile(0),
                    this._centerClampedToGround &&
                      this.transform.setElevation(0)),
                (this._placementDirty =
                  this.style &&
                  this.style._updatePlacement(
                    this.transform,
                    this.showCollisionBoxes,
                    f,
                    this._crossSourceCollisions,
                    v,
                  )),
                this.painter.render(this.style, {
                  showTileBoundaries: this.showTileBoundaries,
                  showOverdrawInspector: this._showOverdrawInspector,
                  rotating: this.isRotating(),
                  zooming: this.isZooming(),
                  moving: this.isMoving(),
                  fadeDuration: f,
                  showPadding: this.showPadding,
                }),
                this.fire(new u.k("render")),
                this.loaded() &&
                  !this._loaded &&
                  ((this._loaded = !0),
                  u.cd.mark(u.ce.load),
                  this.fire(new u.k("load"))),
                this.style &&
                  (this.style.hasTransitions() || y) &&
                  (this._styleDirty = !0),
                this.style &&
                  !this._placementDirty &&
                  this.style._releaseSymbolFadeTiles());
              const C =
                this._sourcesDirty || this._styleDirty || this._placementDirty;
              return (
                C || this._repaint
                  ? this.triggerRepaint()
                  : !this.isMoving() &&
                    this.loaded() &&
                    this.fire(new u.k("idle")),
                !this._loaded ||
                  this._fullyLoaded ||
                  C ||
                  ((this._fullyLoaded = !0), u.cd.mark(u.ce.fullLoad)),
                this
              );
            }
            redraw() {
              return (
                this.style &&
                  (this._frameRequest &&
                    (this._frameRequest.abort(), (this._frameRequest = null)),
                  this._render(0)),
                this
              );
            }
            remove() {
              var c;
              this._hash && this._hash.remove();
              for (const i of this._controls) i.onRemove(this);
              ((this._controls = []),
                this._frameRequest &&
                  (this._frameRequest.abort(), (this._frameRequest = null)),
                this._renderTaskQueue.clear(),
                this.painter.destroy(),
                this.handlers.destroy(),
                delete this.handlers,
                this.setStyle(null),
                typeof window < "u" &&
                  removeEventListener("online", this._onWindowOnline, !1),
                ei.removeThrottleControl(this._imageQueueHandle),
                (c = this._resizeObserver) === null ||
                  c === void 0 ||
                  c.disconnect());
              const e =
                this.painter.context.gl.getExtension("WEBGL_lose_context");
              (e != null && e.loseContext && e.loseContext(),
                this._canvas.removeEventListener(
                  "webglcontextrestored",
                  this._contextRestored,
                  !1,
                ),
                this._canvas.removeEventListener(
                  "webglcontextlost",
                  this._contextLost,
                  !1,
                ),
                me.remove(this._canvasContainer),
                me.remove(this._controlContainer),
                this._container.removeEventListener(
                  "scroll",
                  this._onMapScroll,
                  !1,
                ),
                this._container.classList.remove("maplibregl-map"),
                u.cd.clearMetrics(),
                (this._removed = !0),
                this.fire(new u.k("remove")));
            }
            triggerRepaint() {
              this.style &&
                !this._frameRequest &&
                ((this._frameRequest = new AbortController()),
                Qe.frameAsync(this._frameRequest)
                  .then((c) => {
                    (u.cd.frame(c),
                      (this._frameRequest = null),
                      this._render(c));
                  })
                  .catch((c) => {
                    if (
                      !u.cf(c) &&
                      !(function (e) {
                        return e.message === Bs;
                      })(c)
                    )
                      throw c;
                  }));
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(c) {
              this._showTileBoundaries !== c &&
                ((this._showTileBoundaries = c), this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(c) {
              this._showPadding !== c &&
                ((this._showPadding = c), this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(c) {
              this._showCollisionBoxes !== c &&
                ((this._showCollisionBoxes = c),
                c ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(c) {
              this._showOverdrawInspector !== c &&
                ((this._showOverdrawInspector = c), this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(c) {
              this._repaint !== c &&
                ((this._repaint = c), this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(c) {
              ((this._vertices = c), this._update());
            }
            get version() {
              return Go;
            }
            getCameraTargetElevation() {
              return this.transform.elevation;
            }
            getProjection() {
              return this.style.getProjection();
            }
            setProjection(c) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.setProjection(c),
                this._update(!0)
              );
            }
          }),
          (E.MapMouseEvent = Yt),
          (E.MapTouchEvent = uo),
          (E.MapWheelEvent = xr),
          (E.Marker = Xo),
          (E.NavigationControl = class {
            constructor(c) {
              ((this._updateZoomButtons = () => {
                const e = this._map.getZoom(),
                  i = e === this._map.getMaxZoom(),
                  s = e === this._map.getMinZoom();
                ((this._zoomInButton.disabled = i),
                  (this._zoomOutButton.disabled = s),
                  this._zoomInButton.setAttribute(
                    "aria-disabled",
                    i.toString(),
                  ),
                  this._zoomOutButton.setAttribute(
                    "aria-disabled",
                    s.toString(),
                  ));
              }),
                (this._rotateCompassArrow = () => {
                  this._compassIcon.style.transform =
                    this.options.visualizePitch && this.options.visualizeRoll
                      ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)`
                      : this.options.visualizePitch
                        ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)`
                        : this.options.visualizeRoll
                          ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)`
                          : `rotate(${-this._map.transform.bearing}deg)`;
                }),
                (this._setButtonTitle = (e, i) => {
                  const s = this._map._getUIString(`NavigationControl.${i}`);
                  ((e.title = s), e.setAttribute("aria-label", s));
                }),
                (this.options = u.e({}, Ja, c)),
                (this._container = me.create(
                  "div",
                  "maplibregl-ctrl maplibregl-ctrl-group",
                )),
                this._container.addEventListener("contextmenu", (e) =>
                  e.preventDefault(),
                ),
                this.options.showZoom &&
                  ((this._zoomInButton = this._createButton(
                    "maplibregl-ctrl-zoom-in",
                    (e) => this._map.zoomIn({}, { originalEvent: e }),
                  )),
                  me
                    .create("span", "maplibregl-ctrl-icon", this._zoomInButton)
                    .setAttribute("aria-hidden", "true"),
                  (this._zoomOutButton = this._createButton(
                    "maplibregl-ctrl-zoom-out",
                    (e) => this._map.zoomOut({}, { originalEvent: e }),
                  )),
                  me
                    .create("span", "maplibregl-ctrl-icon", this._zoomOutButton)
                    .setAttribute("aria-hidden", "true")),
                this.options.showCompass &&
                  ((this._compass = this._createButton(
                    "maplibregl-ctrl-compass",
                    (e) => {
                      this.options.visualizePitch
                        ? this._map.resetNorthPitch({}, { originalEvent: e })
                        : this._map.resetNorth({}, { originalEvent: e });
                    },
                  )),
                  (this._compassIcon = me.create(
                    "span",
                    "maplibregl-ctrl-icon",
                    this._compass,
                  )),
                  this._compassIcon.setAttribute("aria-hidden", "true")));
            }
            onAdd(c) {
              return (
                (this._map = c),
                this.options.showZoom &&
                  (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                  this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                  this._map.on("zoom", this._updateZoomButtons),
                  this._updateZoomButtons()),
                this.options.showCompass &&
                  (this._setButtonTitle(this._compass, "ResetBearing"),
                  this.options.visualizePitch &&
                    this._map.on("pitch", this._rotateCompassArrow),
                  this.options.visualizeRoll &&
                    this._map.on("roll", this._rotateCompassArrow),
                  this._map.on("rotate", this._rotateCompassArrow),
                  this._rotateCompassArrow(),
                  (this._handler = new Qa(
                    this._map,
                    this._compass,
                    this.options.visualizePitch,
                  ))),
                this._container
              );
            }
            onRemove() {
              (me.remove(this._container),
                this.options.showZoom &&
                  this._map.off("zoom", this._updateZoomButtons),
                this.options.showCompass &&
                  (this.options.visualizePitch &&
                    this._map.off("pitch", this._rotateCompassArrow),
                  this.options.visualizeRoll &&
                    this._map.off("roll", this._rotateCompassArrow),
                  this._map.off("rotate", this._rotateCompassArrow),
                  this._handler.off(),
                  delete this._handler),
                delete this._map);
            }
            _createButton(c, e) {
              const i = me.create("button", c, this._container);
              return ((i.type = "button"), i.addEventListener("click", e), i);
            }
          }),
          (E.Popup = class extends u.E {
            constructor(c) {
              (super(),
                (this.remove = () => (
                  this._content && me.remove(this._content),
                  this._container &&
                    (me.remove(this._container), delete this._container),
                  this._map &&
                    (this._map.off("move", this._update),
                    this._map.off("move", this._onClose),
                    this._map.off("click", this._onClose),
                    this._map.off("remove", this.remove),
                    this._map.off("mousemove", this._onMouseMove),
                    this._map.off("mouseup", this._onMouseUp),
                    this._map.off("drag", this._onDrag),
                    this._map._canvasContainer.classList.remove(
                      "maplibregl-track-pointer",
                    ),
                    delete this._map,
                    this.fire(new u.k("close"))),
                  this
                )),
                (this._onMouseUp = (e) => {
                  this._update(e.point);
                }),
                (this._onMouseMove = (e) => {
                  this._update(e.point);
                }),
                (this._onDrag = (e) => {
                  this._update(e.point);
                }),
                (this._update = (e) => {
                  var i;
                  if (
                    !this._map ||
                    (!this._lngLat && !this._trackPointer) ||
                    !this._content
                  )
                    return;
                  if (!this._container) {
                    if (
                      ((this._container = me.create(
                        "div",
                        "maplibregl-popup",
                        this._map.getContainer(),
                      )),
                      (this._tip = me.create(
                        "div",
                        "maplibregl-popup-tip",
                        this._container,
                      )),
                      this._container.appendChild(this._content),
                      this.options.className)
                    )
                      for (const g of this.options.className.split(" "))
                        this._container.classList.add(g);
                    (this._closeButton &&
                      this._closeButton.setAttribute(
                        "aria-label",
                        this._map._getUIString("Popup.Close"),
                      ),
                      this._trackPointer &&
                        this._container.classList.add(
                          "maplibregl-popup-track-pointer",
                        ));
                  }
                  if (
                    (this.options.maxWidth &&
                      this._container.style.maxWidth !==
                        this.options.maxWidth &&
                      (this._container.style.maxWidth = this.options.maxWidth),
                    (this._lngLat =
                      this._map.transform.renderWorldCopies &&
                      !this._trackPointer
                        ? fo(this._lngLat, this._flatPos, this._map.transform)
                        : (i = this._lngLat) === null || i === void 0
                          ? void 0
                          : i.wrap()),
                    this._trackPointer && !e)
                  )
                    return;
                  const s =
                    (this._flatPos =
                    this._pos =
                      this._trackPointer && e
                        ? e
                        : this._map.project(this._lngLat));
                  this._map.terrain &&
                    (this._flatPos =
                      this._trackPointer && e
                        ? e
                        : this._map.transform.locationToScreenPoint(
                            this._lngLat,
                          ));
                  let a = this.options.anchor;
                  const h = Wo(this.options.offset);
                  if (!a) {
                    const g = this._container.offsetWidth,
                      y = this._container.offsetHeight;
                    let v;
                    ((v =
                      s.y + h.bottom.y < y
                        ? ["top"]
                        : s.y > this._map.transform.height - y
                          ? ["bottom"]
                          : []),
                      s.x < g / 2
                        ? v.push("left")
                        : s.x > this._map.transform.width - g / 2 &&
                          v.push("right"),
                      (a = v.length === 0 ? "bottom" : v.join("-")));
                  }
                  let f = s.add(h[a]);
                  (this.options.subpixelPositioning || (f = f.round()),
                    me.setTransform(
                      this._container,
                      `${Ho[a]} translate(${f.x}px,${f.y}px)`,
                    ),
                    Js(this._container, a, "popup"));
                }),
                (this._onClose = () => {
                  this.remove();
                }),
                (this.options = u.e(Object.create(il), c)));
            }
            addTo(c) {
              return (
                this._map && this.remove(),
                (this._map = c),
                this.options.closeOnClick &&
                  this._map.on("click", this._onClose),
                this.options.closeOnMove && this._map.on("move", this._onClose),
                this._map.on("remove", this.remove),
                this._update(),
                this._focusFirstElement(),
                this._trackPointer
                  ? (this._map.on("mousemove", this._onMouseMove),
                    this._map.on("mouseup", this._onMouseUp),
                    this._container &&
                      this._container.classList.add(
                        "maplibregl-popup-track-pointer",
                      ),
                    this._map._canvasContainer.classList.add(
                      "maplibregl-track-pointer",
                    ))
                  : this._map.on("move", this._update),
                this.fire(new u.k("open")),
                this
              );
            }
            isOpen() {
              return !!this._map;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(c) {
              return (
                (this._lngLat = u.N.convert(c)),
                (this._pos = null),
                (this._flatPos = null),
                (this._trackPointer = !1),
                this._update(),
                this._map &&
                  (this._map.on("move", this._update),
                  this._map.off("mousemove", this._onMouseMove),
                  this._container &&
                    this._container.classList.remove(
                      "maplibregl-popup-track-pointer",
                    ),
                  this._map._canvasContainer.classList.remove(
                    "maplibregl-track-pointer",
                  )),
                this
              );
            }
            trackPointer() {
              return (
                (this._trackPointer = !0),
                (this._pos = null),
                (this._flatPos = null),
                this._update(),
                this._map &&
                  (this._map.off("move", this._update),
                  this._map.on("mousemove", this._onMouseMove),
                  this._map.on("drag", this._onDrag),
                  this._container &&
                    this._container.classList.add(
                      "maplibregl-popup-track-pointer",
                    ),
                  this._map._canvasContainer.classList.add(
                    "maplibregl-track-pointer",
                  )),
                this
              );
            }
            getElement() {
              return this._container;
            }
            setText(c) {
              return this.setDOMContent(document.createTextNode(c));
            }
            setHTML(c) {
              const e = document.createDocumentFragment(),
                i = document.createElement("body");
              let s;
              for (i.innerHTML = c; (s = i.firstChild), s; ) e.appendChild(s);
              return this.setDOMContent(e);
            }
            getMaxWidth() {
              var c;
              return (c = this._container) === null || c === void 0
                ? void 0
                : c.style.maxWidth;
            }
            setMaxWidth(c) {
              return ((this.options.maxWidth = c), this._update(), this);
            }
            setDOMContent(c) {
              if (this._content)
                for (; this._content.hasChildNodes(); )
                  this._content.firstChild &&
                    this._content.removeChild(this._content.firstChild);
              else
                this._content = me.create(
                  "div",
                  "maplibregl-popup-content",
                  this._container,
                );
              return (
                this._content.appendChild(c),
                this._createCloseButton(),
                this._update(),
                this._focusFirstElement(),
                this
              );
            }
            addClassName(c) {
              return (
                this._container && this._container.classList.add(c),
                this
              );
            }
            removeClassName(c) {
              return (
                this._container && this._container.classList.remove(c),
                this
              );
            }
            setOffset(c) {
              return ((this.options.offset = c), this._update(), this);
            }
            toggleClassName(c) {
              if (this._container) return this._container.classList.toggle(c);
            }
            setSubpixelPositioning(c) {
              this.options.subpixelPositioning = c;
            }
            _createCloseButton() {
              this.options.closeButton &&
                ((this._closeButton = me.create(
                  "button",
                  "maplibregl-popup-close-button",
                  this._content,
                )),
                (this._closeButton.type = "button"),
                (this._closeButton.innerHTML = "&#215;"),
                this._closeButton.addEventListener("click", this._onClose));
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container) return;
              const c = this._container.querySelector(rl);
              c && c.focus();
            }
          }),
          (E.RasterDEMTileSource = Wr),
          (E.RasterTileSource = gr),
          (E.ScaleControl = class {
            constructor(c) {
              ((this._onMove = () => {
                Qs(this._map, this._container, this.options);
              }),
                (this.setUnit = (e) => {
                  ((this.options.unit = e),
                    Qs(this._map, this._container, this.options));
                }),
                (this.options = Object.assign(Object.assign({}, tl), c)));
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            onAdd(c) {
              return (
                (this._map = c),
                (this._container = me.create(
                  "div",
                  "maplibregl-ctrl maplibregl-ctrl-scale",
                  c.getContainer(),
                )),
                this._map.on("move", this._onMove),
                this._onMove(),
                this._container
              );
            }
            onRemove() {
              (me.remove(this._container),
                this._map.off("move", this._onMove),
                (this._map = void 0));
            }
          }),
          (E.ScrollZoomHandler = Tu),
          (E.Style = ba),
          (E.TerrainControl = class {
            constructor(c) {
              ((this._toggleTerrain = () => {
                (this._map.getTerrain()
                  ? this._map.setTerrain(null)
                  : this._map.setTerrain(this.options),
                  this._updateTerrainIcon());
              }),
                (this._updateTerrainIcon = () => {
                  (this._terrainButton.classList.remove(
                    "maplibregl-ctrl-terrain",
                  ),
                    this._terrainButton.classList.remove(
                      "maplibregl-ctrl-terrain-enabled",
                    ),
                    this._map.terrain
                      ? (this._terrainButton.classList.add(
                          "maplibregl-ctrl-terrain-enabled",
                        ),
                        (this._terrainButton.title = this._map._getUIString(
                          "TerrainControl.Disable",
                        )))
                      : (this._terrainButton.classList.add(
                          "maplibregl-ctrl-terrain",
                        ),
                        (this._terrainButton.title = this._map._getUIString(
                          "TerrainControl.Enable",
                        ))));
                }),
                (this.options = c));
            }
            onAdd(c) {
              return (
                (this._map = c),
                (this._container = me.create(
                  "div",
                  "maplibregl-ctrl maplibregl-ctrl-group",
                )),
                (this._terrainButton = me.create(
                  "button",
                  "maplibregl-ctrl-terrain",
                  this._container,
                )),
                me
                  .create("span", "maplibregl-ctrl-icon", this._terrainButton)
                  .setAttribute("aria-hidden", "true"),
                (this._terrainButton.type = "button"),
                this._terrainButton.addEventListener(
                  "click",
                  this._toggleTerrain,
                ),
                this._updateTerrainIcon(),
                this._map.on("terrain", this._updateTerrainIcon),
                this._container
              );
            }
            onRemove() {
              (me.remove(this._container),
                this._map.off("terrain", this._updateTerrainIcon),
                (this._map = void 0));
            }
          }),
          (E.TwoFingersTouchPitchHandler = qs),
          (E.TwoFingersTouchRotateHandler = bu),
          (E.TwoFingersTouchZoomHandler = Zs),
          (E.TwoFingersTouchZoomRotateHandler = Ka),
          (E.VectorTileSource = _n),
          (E.VideoSource = yn),
          (E.addSourceType = (c, e) =>
            u._(void 0, void 0, void 0, function* () {
              if (Ao(c))
                throw new Error(`A source type called "${c}" already exists.`);
              ((i, s) => {
                Yr[i] = s;
              })(c, e);
            })),
          (E.clearPrewarmedResources = function () {
            const c = ar;
            c &&
              (c.isPreloaded() && c.numActive() === 1
                ? (c.release(_i), (ar = null))
                : console.warn(
                    "Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()",
                  ));
          }),
          (E.createTileMesh = ds),
          (E.getMaxParallelImageRequests = function () {
            return u.a.MAX_PARALLEL_IMAGE_REQUESTS;
          }),
          (E.getRTLTextPluginStatus = function () {
            return Rr().getRTLTextPluginStatus();
          }),
          (E.getVersion = function () {
            return nl;
          }),
          (E.getWorkerCount = function () {
            return Ii.workerCount;
          }),
          (E.getWorkerUrl = function () {
            return u.a.WORKER_URL;
          }),
          (E.importScriptInWorkers = function (c) {
            return mn().broadcast("IS", c);
          }),
          (E.prewarm = function () {
            pn().acquire(_i);
          }),
          (E.setMaxParallelImageRequests = function (c) {
            u.a.MAX_PARALLEL_IMAGE_REQUESTS = c;
          }),
          (E.setRTLTextPlugin = function (c, e) {
            return Rr().setRTLTextPlugin(c, e);
          }),
          (E.setWorkerCount = function (c) {
            Ii.workerCount = c;
          }),
          (E.setWorkerUrl = function (c) {
            u.a.WORKER_URL = c;
          }));
      }));
    var X = se;
    return X;
  });
})(Kd);
const Jd = zf(Kd.exports);
const Lf = `
const vsSource = \`#version 300 es
    in vec4 a_position;
    out vec2 v_tex_coord;

    void main() {
        gl_Position = a_position;
        v_tex_coord = vec2(a_position.x * 0.5 + 0.5, a_position.y * -0.5 + 0.5);
    }
\`;

const fsSource = \`#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    uniform sampler2D u_height_map;
    in vec2 v_tex_coord;
    out vec4 fragColor;

    void main() {
        vec4 color = texture(u_height_map, v_tex_coord);
        vec3 rgb = color.rgb * 255.0;

        // terrarium\u306B\u304A\u3051\u308B\u9AD8\u5EA60\u306E\u8272
        vec4 zero_elevation_color = vec4(128.0, 0.0, 0.0, 255.0) / 255.0;

        // \u5730\u7406\u9662\u6A19\u9AD8\u30BF\u30A4\u30EB\u306E\u7121\u52B9\u5024\u307E\u305F\u306F\u5B8C\u5168\u306B\u900F\u660E\u306A\u30D4\u30AF\u30BB\u30EB\u306E\u5224\u5B9A
        bool is_valid = (rgb.r != 128.0 || rgb.g != 0.0 || rgb.b != 0.0) && color.a != 0.0;

        float rgb_value = dot(rgb, vec3(65536.0, 256.0, 1.0));
        float height = mix(rgb_value, rgb_value - 16777216.0, step(8388608.0, rgb_value)) * 0.01;

        // terrarium\u306E\u6A19\u9AD8\u5024\u30A8\u30F3\u30B3\u30FC\u30C9
        height += 32768.0;
        float r = floor(height / 256.0);
        float g = floor(mod(height, 256.0));
        float b = floor((height - floor(height)) * 256.0);

        // terrarium\u306E\u6A19\u9AD8\u5024\u3092\u8272\u306B\u5909\u63DB
        fragColor = mix(
            zero_elevation_color,
            vec4(
                r / 255.0,
                g / 255.0,
                b / 255.0,
                1.0
            ),
            float(is_valid)
        );
    }
\`;

let gl = null;
let program = null;
let positionBuffer = null;
let heightMapLocation = null;

const initWebGL = (canvas) => {
	gl = canvas.getContext('webgl2');
	if (!gl) {
		throw new Error('WebGL not supported');
	}

	const loadShader = (
		gl,
		type,
		source,
	) => {
		const shader = gl.createShader(type);
		if (!shader) {
			console.error('Unable to create shader');
			return null;
		}
		gl.shaderSource(shader, source);
		gl.compileShader(shader);

		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.error(
				'An error occurred compiling the shaders: ' +
					gl.getShaderInfoLog(shader),
			);
			gl.deleteShader(shader);
			return null;
		}
		return shader;
	};

	const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
	const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
	if (!vertexShader || !fragmentShader) {
		throw new Error('Failed to load shaders');
	}

	program = gl.createProgram();
	if (!program) {
		throw new Error('Failed to create program');
	}
	gl.attachShader(program, vertexShader);
	gl.attachShader(program, fragmentShader);
	gl.linkProgram(program);

	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
		console.error(
			'Unable to initialize the shader program: ' +
				gl.getProgramInfoLog(program),
		);
		throw new Error('Failed to link program');
	}

	positionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
	const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
	gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
	const positionLocation = gl.getAttribLocation(program, 'a_position');
	gl.enableVertexAttribArray(positionLocation);
	gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

	heightMapLocation = gl.getUniformLocation(program, 'u_height_map');
};

const canvas = new OffscreenCanvas(256, 256);

self.onmessage = async (e) => {
	const { url, image } = e.data;

	try {
		if (!gl) {
			initWebGL(canvas);
		}

		if (!gl || !program || !positionBuffer || !heightMapLocation) {
			throw new Error('WebGL initialization failed');
		}

		const heightMap = gl.createTexture();
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, heightMap);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

		gl.useProgram(program);
		gl.uniform1i(heightMapLocation, 0);

		gl.clear(gl.COLOR_BUFFER_BIT);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

		const blob = await canvas.convertToBlob();
		if (!blob) {
			throw new Error('Failed to convert canvas to blob');
		}
		const buffer = await blob.arrayBuffer();
		self.postMessage({ url, buffer });
	} catch (error) {
		if (error instanceof Error) {
			self.postMessage({ url, error: error.message });
		}
	}
};
`,
  Rf = async (K, J) => {
    let se;
    try {
      se = await fetch(K, { signal: J });
    } catch (le) {
      return (J.aborted || console.error(`Failed to fetch image: ${le}`), null);
    }
    return se.ok ? await createImageBitmap(await se.blob()) : null;
  };
class Of {
  constructor(J) {
    Pl(this, "worker");
    Pl(this, "pendingRequests");
    Pl(this, "handleMessage", (J) => {
      const { url: se, buffer: le, error: U } = J.data;
      if (U) console.error(`Error processing tile ${se}:`, U);
      else {
        const X = this.pendingRequests.get(se);
        X &&
          (X.resolve({ data: new Uint8Array(le) }),
          this.pendingRequests.delete(se));
      }
    });
    Pl(this, "handleError", (J) => {
      (console.error("Worker error:", J),
        this.pendingRequests.forEach((se) => {
          se.reject(new Error("Worker error occurred"));
        }),
        this.pendingRequests.clear());
    });
    ((this.worker = J),
      (this.pendingRequests = new Map()),
      this.worker.addEventListener("message", this.handleMessage),
      this.worker.addEventListener("error", this.handleError));
  }
  async request(J, se) {
    const le = await Rf(J, se.signal);
    return le
      ? new Promise((U, X) => {
          (this.pendingRequests.set(J, {
            resolve: U,
            reject: X,
            controller: se,
          }),
            this.worker.postMessage({ image: le, url: J }),
            (se.signal.onabort = () => {
              (this.pendingRequests.delete(J), X(new Error("Request aborted")));
            }));
        })
      : Promise.reject(new Error("Failed to load image"));
  }
}
const jf = new Blob([Lf], { type: "application/javascript" }),
  Nf = new Worker(URL.createObjectURL(jf)),
  Vf = new Of(Nf),
  Uf = (K) => (J, se) => {
    const le = J.url.replace(K + "://", "");
    return Vf.request(le, se);
  },
  $f = (K) => {
    const J = K.split(
        `
`,
      ).filter((U) => U.trim()),
      se = J[0].split(",").map((U) => U.trim()),
      le = [];
    for (let U = 1; U < J.length; U++) {
      const X = J[U].split(",").map((E) => E.trim());
      if (X.length >= 3) {
        const E = {
          x: parseFloat(X[0]),
          y: parseFloat(X[1]),
          z: parseFloat(X[2]),
          elevation: parseFloat(X[3] || X[2]),
          type: X[4] || "point",
          description: X[5] || "",
          properties: {},
        };
        if (se.length > 6)
          for (let u = 6; u < se.length && u < X.length; u++)
            E.properties[se[u]] = X[u];
        le.push(E);
      }
    }
    return le;
  },
  sh = (K) => ({
    id: K.id,
    name: K.name,
    type: K.type === "flight" ? "waypoint" : "object",
    source: K.source,
    position: {
      longitude: K.longitude,
      latitude: K.latitude,
      altitude: K.altitude,
    },
    properties: K.properties,
  }),
  Ku = (K) => ({
    id: K.id,
    name: K.name,
    longitude: K.position.longitude,
    latitude: K.position.latitude,
    altitude: K.position.altitude,
    type: K.type === "waypoint" ? "flight" : "unknown",
    source: K.source,
    properties: K.properties,
  }),
  Qd = (K) => {
    if (K.length < 2) return 0;
    let J = 0;
    for (let se = 1; se < K.length; se++) {
      const le = K[se - 1].position,
        U = K[se].position,
        X = 6371e3,
        E = (le.latitude * Math.PI) / 180,
        u = (U.latitude * Math.PI) / 180,
        Ue = ((U.latitude - le.latitude) * Math.PI) / 180,
        rt = ((U.longitude - le.longitude) * Math.PI) / 180,
        _t =
          Math.sin(Ue / 2) * Math.sin(Ue / 2) +
          Math.cos(E) * Math.cos(u) * Math.sin(rt / 2) * Math.sin(rt / 2),
        li = 2 * Math.atan2(Math.sqrt(_t), Math.sqrt(1 - _t)),
        Qe = X * li,
        me = U.altitude - le.altitude,
        Ze = Math.sqrt(Qe * Qe + me * me);
      J += Ze;
    }
    return J;
  },
  Zf = (K, J = 10) => {
    var le;
    Qd(K);
    let se = 0;
    for (let U = 1; U < K.length; U++) {
      const X = ((le = K[U].flight) == null ? void 0 : le.speed) || J,
        E = K[U - 1].position,
        u = K[U].position,
        Ue = 6371e3,
        rt = (E.latitude * Math.PI) / 180,
        _t = (u.latitude * Math.PI) / 180,
        li = ((u.latitude - E.latitude) * Math.PI) / 180,
        Qe = ((u.longitude - E.longitude) * Math.PI) / 180,
        me =
          Math.sin(li / 2) * Math.sin(li / 2) +
          Math.cos(rt) * Math.cos(_t) * Math.sin(Qe / 2) * Math.sin(Qe / 2),
        Ze = 2 * Math.atan2(Math.sqrt(me), Math.sqrt(1 - me)),
        Ei = (Ue * Ze) / X,
        Mi = K[U].duration || 0;
      se += Ei + Mi;
    }
    return se;
  },
  Gf = (K, J, se, le) => {
    const U = new Date().toISOString();
    return {
      id: `mission_${Date.now()}`,
      name: K,
      created: U,
      settings: {
        homePosition: se,
        maxAltitude: 400,
        maxDistance: 1e3,
        returnToHomeAltitude: 50,
        emergencyAction: "rtl",
        ...le,
      },
      waypoints: J,
      metadata: {
        totalDistance: Qd(J),
        estimatedDuration: Zf(J),
        maxAltitude: Math.max(...J.map((X) => X.position.altitude)),
      },
    };
  },
  qf = (K) => {
    const J = K.split(
      `
`,
    ).filter((le) => le.trim());
    J[0].split(",").map((le) => le.trim());
    const se = [];
    for (let le = 1; le < J.length; le++) {
      const U = J[le].split(",").map((X) => X.trim());
      if (U.length >= 6) {
        const X = {
          x: parseFloat(U[0]),
          y: parseFloat(U[1]),
          z: parseFloat(U[2]),
          mesh_id: parseInt(U[3]),
          vertex_id: parseInt(U[4]),
          elevation: parseFloat(U[5]),
          slope: U[6] ? parseFloat(U[6]) : void 0,
          aspect: U[7] ? parseFloat(U[7]) : void 0,
        };
        se.push(X);
      }
    }
    return se;
  },
  Hf = (K) => {
    const J = K.split(
        `
`,
      ).filter((U) => U.trim()),
      se = J[0].split(",").map((U) => U.trim()),
      le = [];
    for (let U = 1; U < J.length; U++) {
      const X = J[U].split(",").map((E) => E.trim());
      if (X.length >= 6) {
        const E = {
          x: parseFloat(X[0]),
          y: parseFloat(X[1]),
          z: parseFloat(X[2]),
          elevation: parseFloat(X[3]),
          waypoint_id: parseInt(X[4]),
          timestamp: X[5] || void 0,
          speed: X[6] ? parseFloat(X[6]) : void 0,
          action: X[7] || void 0,
          description: X[8] || void 0,
          properties: {},
        };
        if (se.length > 9)
          for (let u = 9; u < se.length && u < X.length; u++)
            E.properties[se[u]] = X[u];
        le.push(E);
      }
    }
    return le;
  },
  Xf = (K) => {
    const J = K.split(
        `
`,
      ).filter((U) => U.trim()),
      se = J[0].split(",").map((U) => U.trim()),
      le = [];
    for (let U = 1; U < J.length; U++) {
      const X = J[U].split(",").map((E) => E.trim());
      if (X.length >= 6) {
        const E = {
          x: parseFloat(X[0]),
          y: parseFloat(X[1]),
          z: parseFloat(X[2]),
          elevation: parseFloat(X[3]),
          timestamp: X[4],
          speed: parseFloat(X[5]),
          battery_level: X[6] ? parseFloat(X[6]) : void 0,
          signal_strength: X[7] ? parseFloat(X[7]) : void 0,
          gps_accuracy: X[8] ? parseFloat(X[8]) : void 0,
          action: X[9] || void 0,
          description: X[10] || void 0,
          properties: {},
        };
        if (se.length > 11)
          for (let u = 11; u < se.length && u < X.length; u++)
            E.properties[se[u]] = X[u];
        le.push(E);
      }
    }
    return le;
  },
  Wf = (K) => {
    (console.log(
      "\u5EFA\u7269\u70B9\u691C\u30C7\u30FC\u30BF\u30D1\u30FC\u30B9\u958B\u59CB",
    ),
      console.log(
        "CSV\u5185\u5BB9\uFF08\u6700\u521D\u306E500\u6587\u5B57\uFF09:",
        K.substring(0, 500),
      ));
    const J = K.split(
      `
`,
    ).filter((U) => U.trim());
    if ((console.log("CSV\u884C\u6570:", J.length), J.length < 2))
      throw (
        console.error(
          "CSV\u30C7\u30FC\u30BF\u304C\u4E0D\u8DB3\u3057\u3066\u3044\u307E\u3059",
        ),
        new Error(
          "\u5EFA\u7269\u70B9\u691C\u30C7\u30FC\u30BF\u306E\u5F62\u5F0F\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093",
        )
      );
    const se = J[0].split(",").map((U) => U.trim());
    console.log("\u30D8\u30C3\u30C0\u30FC:", se);
    const le = [];
    for (let U = 1; U < J.length; U++)
      try {
        const X = J[U].split(",").map((u) => u.trim());
        if (X.length < 6) {
          console.warn(
            `\u884C ${U} \u306E\u30C7\u30FC\u30BF\u304C\u4E0D\u5B8C\u5168\u3067\u3059:`,
            X,
          );
          continue;
        }
        const E = {
          x: parseFloat(X[0]),
          y: parseFloat(X[1]),
          z: parseFloat(X[2]),
          elevation: parseFloat(X[3]),
          type: X[4],
          description: X[5],
          properties: {
            damage_level: X[6] ? parseInt(X[6]) : 0,
            component_type: X[7] || "unknown",
            inspection_date: X[8] || void 0,
          },
        };
        if (isNaN(E.x) || isNaN(E.y) || isNaN(E.z)) {
          console.warn(
            `\u884C ${U} \u306E\u5EA7\u6A19\u30C7\u30FC\u30BF\u304C\u7121\u52B9\u3067\u3059:`,
            X,
          );
          continue;
        }
        le.push(E);
      } catch (X) {
        console.error(
          `\u884C ${U} \u306E\u30D1\u30FC\u30B9\u30A8\u30E9\u30FC:`,
          X,
          J[U],
        );
      }
    return (
      console.log(
        "\u30D1\u30FC\u30B9\u5B8C\u4E86:",
        le.length,
        "\u500B\u306E\u30DD\u30A4\u30F3\u30C8",
      ),
      console.log(
        "\u6700\u521D\u306E3\u3064\u306E\u30DD\u30A4\u30F3\u30C8:",
        le.slice(0, 3),
      ),
      le
    );
  },
  Kf = (K) => {
    (console.log(
      "\u5EFA\u7269\u70B9\u691C\u30E1\u30C3\u30B7\u30E5\u30C7\u30FC\u30BF\u30D1\u30FC\u30B9\u958B\u59CB",
    ),
      console.log(
        "CSV\u5185\u5BB9\uFF08\u6700\u521D\u306E500\u6587\u5B57\uFF09:",
        K.substring(0, 500),
      ));
    const J = K.split(
      `
`,
    ).filter((U) => U.trim());
    if ((console.log("CSV\u884C\u6570:", J.length), J.length < 2))
      throw (
        console.error(
          "CSV\u30C7\u30FC\u30BF\u304C\u4E0D\u8DB3\u3057\u3066\u3044\u307E\u3059",
        ),
        new Error(
          "\u5EFA\u7269\u70B9\u691C\u30E1\u30C3\u30B7\u30E5\u30C7\u30FC\u30BF\u306E\u5F62\u5F0F\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093",
        )
      );
    const se = J[0].split(",").map((U) => U.trim());
    console.log("\u30D8\u30C3\u30C0\u30FC:", se);
    const le = [];
    for (let U = 1; U < J.length; U++)
      try {
        const X = J[U].split(",").map((u) => u.trim());
        if (X.length < 6) {
          console.warn(
            `\u884C ${U} \u306E\u30C7\u30FC\u30BF\u304C\u4E0D\u5B8C\u5168\u3067\u3059:`,
            X,
          );
          continue;
        }
        const E = {
          x: parseFloat(X[0]),
          y: parseFloat(X[1]),
          z: parseFloat(X[2]),
          mesh_id: parseInt(X[3]),
          vertex_id: parseInt(X[4]),
          elevation: parseFloat(X[5]),
          slope: X[6] ? parseFloat(X[6]) : void 0,
          aspect: X[7] ? parseFloat(X[7]) : void 0,
          damage_level: X[8] ? parseInt(X[8]) : 0,
          component_type: X[9] || "unknown",
        };
        if (isNaN(E.x) || isNaN(E.y) || isNaN(E.z)) {
          console.warn(
            `\u884C ${U} \u306E\u5EA7\u6A19\u30C7\u30FC\u30BF\u304C\u7121\u52B9\u3067\u3059:`,
            X,
          );
          continue;
        }
        le.push(E);
      } catch (X) {
        console.error(
          `\u884C ${U} \u306E\u30D1\u30FC\u30B9\u30A8\u30E9\u30FC:`,
          X,
          J[U],
        );
      }
    return (
      console.log(
        "\u30D1\u30FC\u30B9\u5B8C\u4E86:",
        le.length,
        "\u500B\u306E\u9802\u70B9",
      ),
      console.log(
        "\u6700\u521D\u306E3\u3064\u306E\u9802\u70B9:",
        le.slice(0, 3),
      ),
      le
    );
  },
  Yf = (K) => {
    const J = [],
      se = new Map();
    return (
      K.forEach((le) => {
        (se.has(le.mesh_id) || se.set(le.mesh_id, []),
          se.get(le.mesh_id).push(le));
      }),
      se.forEach((le, U) => {
        if (le.length === 25)
          for (let X = 0; X < 4; X++)
            for (let E = 0; E < 4; E++) {
              const u = le[X * 5 + E],
                Ue = le[X * 5 + E + 1],
                rt = le[(X + 1) * 5 + E],
                _t = le[(X + 1) * 5 + E + 1];
              (J.push([
                [u.x, u.y, u.z],
                [Ue.x, Ue.y, Ue.z],
                [rt.x, rt.y, rt.z],
              ]),
                J.push([
                  [Ue.x, Ue.y, Ue.z],
                  [_t.x, _t.y, _t.z],
                  [rt.x, rt.y, rt.z],
                ]));
            }
      }),
      J
    );
  },
  Gd = (K, J, se = "3d-points") => {
    (console.log(
      "3D\u30DD\u30A4\u30F3\u30C8\u30C7\u30FC\u30BF\u306E\u63CF\u753B\u958B\u59CB:",
      J.length,
      "\u500B\u306E\u30DD\u30A4\u30F3\u30C8",
    ),
      console.log("\u6700\u521D\u306E\u30DD\u30A4\u30F3\u30C8:", J[0]));
    const le = J.map((X) => {
      var E;
      return {
        type: "Feature",
        geometry: { type: "Point", coordinates: [X.x, X.y] },
        properties: {
          elevation: X.elevation,
          z: X.z,
          type: X.type,
          description: X.description,
          damage_level:
            ((E = X.properties) == null ? void 0 : E.damage_level) || 0,
          ...X.properties,
        },
      };
    });
    (console.log(
      "\u4F5C\u6210\u3055\u308C\u305F\u30D5\u30A3\u30FC\u30C1\u30E3\u30FC:",
      le.slice(0, 3),
    ),
      K.getSource(se) && K.removeSource(se));
    const U = `${se}-layer`;
    K.getLayer(U) && K.removeLayer(U);
    try {
      if (
        (console.log("\u30BD\u30FC\u30B9\u3092\u8FFD\u52A0\u4E2D:", se),
        K.addSource(se, {
          type: "geojson",
          data: { type: "FeatureCollection", features: le },
        }),
        console.log("\u30EC\u30A4\u30E4\u30FC\u3092\u8FFD\u52A0\u4E2D:", U),
        K.addLayer({
          id: U,
          type: "circle",
          source: se,
          paint: {
            "circle-radius": [
              "interpolate",
              ["linear"],
              ["zoom"],
              10,
              8,
              15,
              15,
              20,
              25,
            ],
            "circle-color": [
              "match",
              ["get", "damage_level"],
              0,
              "#00ff00",
              1,
              "#ffff00",
              2,
              "#ffaa00",
              3,
              "#ff6600",
              4,
              "#ff0000",
              5,
              "#990000",
              "#ff4444",
            ],
            "circle-opacity": 0.9,
            "circle-stroke-width": 3,
            "circle-stroke-color": "#ffffff",
          },
        }),
        console.log(
          "3D\u30DD\u30A4\u30F3\u30C8\u30EC\u30A4\u30E4\u30FC\u304C\u6B63\u5E38\u306B\u8FFD\u52A0\u3055\u308C\u307E\u3057\u305F",
        ),
        J.length > 0)
      ) {
        const X = J.reduce((u, Ue) => u + Ue.x, 0) / J.length,
          E = J.reduce((u, Ue) => u + Ue.y, 0) / J.length;
        (console.log("\u5730\u56F3\u4E2D\u5FC3\u79FB\u52D5:", [X, E]),
          K.flyTo({ center: [X, E], zoom: 16, duration: 2e3 }));
      }
    } catch (X) {
      throw (
        console.error(
          "3D\u30DD\u30A4\u30F3\u30C8\u30EC\u30A4\u30E4\u30FC\u306E\u8FFD\u52A0\u306B\u5931\u6557:",
          X,
        ),
        X
      );
    }
  },
  qd = (K, J, se = "3d-mesh") => {
    console.log(
      "3D\u30E1\u30C3\u30B7\u30E5\u30C7\u30FC\u30BF\u306E\u63CF\u753B\u958B\u59CB:",
      J.length,
      "\u500B\u306E\u9802\u70B9",
    );
    const le = Yf(J);
    console.log(
      "\u751F\u6210\u3055\u308C\u305F\u4E09\u89D2\u5F62:",
      le.length,
      "\u500B",
    );
    const U = le.map((E, u) => ({
      type: "Feature",
      geometry: {
        type: "Polygon",
        coordinates: [E.map((Ue) => [Ue[0], Ue[1]])],
      },
      properties: {
        id: u,
        elevation: E.reduce((Ue, rt) => Ue + rt[2], 0) / 3,
        z: E.reduce((Ue, rt) => Ue + rt[2], 0) / 3,
      },
    }));
    (console.log(
      "\u4F5C\u6210\u3055\u308C\u305F\u30E1\u30C3\u30B7\u30E5\u30D5\u30A3\u30FC\u30C1\u30E3\u30FC:",
      U.slice(0, 2),
    ),
      K.getSource(se) && K.removeSource(se));
    const X = `${se}-layer`;
    K.getLayer(X) && K.removeLayer(X);
    try {
      if (
        (K.addSource(se, {
          type: "geojson",
          data: { type: "FeatureCollection", features: U },
        }),
        K.addLayer({
          id: X,
          type: "fill",
          source: se,
          paint: {
            "fill-color": [
              "match",
              ["get", "damage_level"],
              0,
              "#00ff00",
              1,
              "#ffff00",
              2,
              "#ffaa00",
              3,
              "#ff6600",
              4,
              "#ff0000",
              5,
              "#990000",
              "#ff4444",
            ],
            "fill-opacity": 0.7,
            "fill-outline-color": "#ffffff",
          },
        }),
        console.log(
          "3D\u30E1\u30C3\u30B7\u30E5\u30EC\u30A4\u30E4\u30FC\u304C\u6B63\u5E38\u306B\u8FFD\u52A0\u3055\u308C\u307E\u3057\u305F",
        ),
        J.length > 0)
      ) {
        const E = J.reduce((Ue, rt) => Ue + rt.x, 0) / J.length,
          u = J.reduce((Ue, rt) => Ue + rt.y, 0) / J.length;
        K.flyTo({ center: [E, u], zoom: 16, duration: 2e3 });
      }
    } catch (E) {
      throw (
        console.error(
          "3D\u30E1\u30C3\u30B7\u30E5\u30EC\u30A4\u30E4\u30FC\u306E\u8FFD\u52A0\u306B\u5931\u6557:",
          E,
        ),
        E
      );
    }
  },
  Jf = (K, J, se = "drone-waypoints") => {
    console.log(
      "\u30C9\u30ED\u30FC\u30F3\u98DB\u884C\u7D4C\u8DEF\u306E\u63CF\u753B\u958B\u59CB:",
      J.length,
      "\u500B\u306E\u30A6\u30A7\u30A4\u30DD\u30A4\u30F3\u30C8",
    );
    const le = J.map((u) => ({
        type: "Feature",
        geometry: { type: "Point", coordinates: [u.x, u.y] },
        properties: {
          elevation: u.elevation,
          z: u.z,
          waypoint_id: u.waypoint_id,
          timestamp: u.timestamp,
          speed: u.speed,
          action: u.action,
          description: u.description,
          ...u.properties,
        },
      })),
      U =
        J.length > 1
          ? [
              {
                type: "Feature",
                geometry: {
                  type: "LineString",
                  coordinates: J.map((u) => [u.x, u.y]),
                },
                properties: { type: "flight-path", waypoint_count: J.length },
              },
            ]
          : [];
    (console.log(
      "\u4F5C\u6210\u3055\u308C\u305F\u30A6\u30A7\u30A4\u30DD\u30A4\u30F3\u30C8\u30D5\u30A3\u30FC\u30C1\u30E3\u30FC:",
      le.slice(0, 3),
    ),
      K.getSource(se) && K.removeSource(se));
    const X = `${se}-waypoints-layer`,
      E = `${se}-path-layer`;
    (K.getLayer(X) && K.removeLayer(X), K.getLayer(E) && K.removeLayer(E));
    try {
      if (
        (K.addSource(se, {
          type: "geojson",
          data: { type: "FeatureCollection", features: le },
        }),
        K.addLayer({
          id: X,
          type: "circle",
          source: se,
          paint: {
            "circle-radius": [
              "interpolate",
              ["linear"],
              ["zoom"],
              10,
              6,
              15,
              12,
              20,
              20,
            ],
            "circle-color": [
              "match",
              ["get", "action"],
              "takeoff",
              "#00ff00",
              "land",
              "#ff0000",
              "hover",
              "#ffff00",
              "#007cba",
            ],
            "circle-opacity": 0.9,
            "circle-stroke-width": 2,
            "circle-stroke-color": "#ffffff",
          },
        }),
        U.length > 0 &&
          (K.addSource(`${se}-path`, {
            type: "geojson",
            data: { type: "FeatureCollection", features: U },
          }),
          K.addLayer({
            id: E,
            type: "line",
            source: `${se}-path`,
            paint: {
              "line-color": "#ff6b35",
              "line-width": 3,
              "line-opacity": 0.8,
            },
          })),
        console.log(
          "\u30C9\u30ED\u30FC\u30F3\u98DB\u884C\u7D4C\u8DEF\u30EC\u30A4\u30E4\u30FC\u304C\u6B63\u5E38\u306B\u8FFD\u52A0\u3055\u308C\u307E\u3057\u305F",
        ),
        J.length > 0)
      ) {
        const u = J.reduce((rt, _t) => rt + _t.x, 0) / J.length,
          Ue = J.reduce((rt, _t) => rt + _t.y, 0) / J.length;
        K.flyTo({ center: [u, Ue], zoom: 15, duration: 2e3 });
      }
    } catch (u) {
      throw (
        console.error(
          "\u30C9\u30ED\u30FC\u30F3\u98DB\u884C\u7D4C\u8DEF\u30EC\u30A4\u30E4\u30FC\u306E\u8FFD\u52A0\u306B\u5931\u6557:",
          u,
        ),
        u
      );
    }
  },
  Qf = (K, J, se = "drone-flight-log") => {
    console.log(
      "\u30C9\u30ED\u30FC\u30F3\u98DB\u884C\u30ED\u30B0\u306E\u63CF\u753B\u958B\u59CB:",
      J.length,
      "\u500B\u306E\u30ED\u30B0\u30A8\u30F3\u30C8\u30EA",
    );
    const le = J.map((u) => ({
        type: "Feature",
        geometry: { type: "Point", coordinates: [u.x, u.y] },
        properties: {
          elevation: u.elevation,
          z: u.z,
          timestamp: u.timestamp,
          speed: u.speed,
          battery_level: u.battery_level,
          signal_strength: u.signal_strength,
          gps_accuracy: u.gps_accuracy,
          action: u.action,
          description: u.description,
          ...u.properties,
        },
      })),
      U =
        J.length > 1
          ? [
              {
                type: "Feature",
                geometry: {
                  type: "LineString",
                  coordinates: J.map((u) => [u.x, u.y]),
                },
                properties: { type: "flight-trajectory", log_count: J.length },
              },
            ]
          : [];
    (console.log(
      "\u4F5C\u6210\u3055\u308C\u305F\u98DB\u884C\u30ED\u30B0\u30D5\u30A3\u30FC\u30C1\u30E3\u30FC:",
      le.slice(0, 3),
    ),
      K.getSource(se) && K.removeSource(se));
    const X = `${se}-points-layer`,
      E = `${se}-trajectory-layer`;
    (K.getLayer(X) && K.removeLayer(X), K.getLayer(E) && K.removeLayer(E));
    try {
      if (
        (K.addSource(se, {
          type: "geojson",
          data: { type: "FeatureCollection", features: le },
        }),
        K.addLayer({
          id: X,
          type: "circle",
          source: se,
          paint: {
            "circle-radius": [
              "interpolate",
              ["linear"],
              ["zoom"],
              10,
              3,
              15,
              6,
              20,
              10,
            ],
            "circle-color": [
              "interpolate",
              ["linear"],
              ["get", "speed"],
              0,
              "#00ff00",
              10,
              "#ffff00",
              20,
              "#ff0000",
            ],
            "circle-opacity": 0.7,
            "circle-stroke-width": 1,
            "circle-stroke-color": "#ffffff",
          },
        }),
        U.length > 0 &&
          (K.addSource(`${se}-trajectory`, {
            type: "geojson",
            data: { type: "FeatureCollection", features: U },
          }),
          K.addLayer({
            id: E,
            type: "line",
            source: `${se}-trajectory`,
            paint: {
              "line-color": "#00ff00",
              "line-width": 2,
              "line-opacity": 0.6,
            },
          })),
        console.log(
          "\u30C9\u30ED\u30FC\u30F3\u98DB\u884C\u30ED\u30B0\u30EC\u30A4\u30E4\u30FC\u304C\u6B63\u5E38\u306B\u8FFD\u52A0\u3055\u308C\u307E\u3057\u305F",
        ),
        J.length > 0)
      ) {
        const u = J.reduce((rt, _t) => rt + _t.x, 0) / J.length,
          Ue = J.reduce((rt, _t) => rt + _t.y, 0) / J.length;
        K.flyTo({ center: [u, Ue], zoom: 15, duration: 2e3 });
      }
    } catch (u) {
      throw (
        console.error(
          "\u30C9\u30ED\u30FC\u30F3\u98DB\u884C\u30ED\u30B0\u30EC\u30A4\u30E4\u30FC\u306E\u8FFD\u52A0\u306B\u5931\u6557:",
          u,
        ),
        u
      );
    }
  },
  Yu = async (K, J, se = "points") => {
    console.log(
      "\u30D5\u30A1\u30A4\u30EB\u30A4\u30F3\u30DD\u30FC\u30C8\u958B\u59CB:",
      K.name,
      "\u30BF\u30A4\u30D7:",
      se,
    );
    const le = await K.text();
    switch (
      (console.log(
        "\u30D5\u30A1\u30A4\u30EB\u5185\u5BB9\u306E\u6700\u521D\u306E100\u6587\u5B57:",
        le.substring(0, 100),
      ),
      se)
    ) {
      case "points":
        const U = $f(le);
        (console.log(
          "\u30D1\u30FC\u30B9\u3055\u308C\u305F\u30DD\u30A4\u30F3\u30C8\u30C7\u30FC\u30BF:",
          U.length,
          "\u500B",
        ),
          console.log(
            "\u6700\u521D\u306E3\u3064\u306E\u30DD\u30A4\u30F3\u30C8:",
            U.slice(0, 3),
          ),
          Gd(J, U));
        break;
      case "mesh":
        const X = qf(le);
        (console.log(
          "\u30D1\u30FC\u30B9\u3055\u308C\u305F\u30E1\u30C3\u30B7\u30E5\u30C7\u30FC\u30BF:",
          X.length,
          "\u500B",
        ),
          console.log(
            "\u6700\u521D\u306E3\u3064\u306E\u9802\u70B9:",
            X.slice(0, 3),
          ),
          qd(J, X));
        break;
      case "waypoints":
        const E = Hf(le);
        (console.log(
          "\u30D1\u30FC\u30B9\u3055\u308C\u305F\u30A6\u30A7\u30A4\u30DD\u30A4\u30F3\u30C8\u30C7\u30FC\u30BF:",
          E.length,
          "\u500B",
        ),
          console.log(
            "\u6700\u521D\u306E3\u3064\u306E\u30A6\u30A7\u30A4\u30DD\u30A4\u30F3\u30C8:",
            E.slice(0, 3),
          ),
          Jf(J, E));
        break;
      case "flight-log":
        const u = Xf(le);
        (console.log(
          "\u30D1\u30FC\u30B9\u3055\u308C\u305F\u98DB\u884C\u30ED\u30B0\u30C7\u30FC\u30BF:",
          u.length,
          "\u500B",
        ),
          console.log(
            "\u6700\u521D\u306E3\u3064\u306E\u30ED\u30B0\u30A8\u30F3\u30C8\u30EA:",
            u.slice(0, 3),
          ),
          Qf(J, u));
        break;
      case "building-inspection":
        const Ue = Wf(le);
        (console.log(
          "\u30D1\u30FC\u30B9\u3055\u308C\u305F\u5EFA\u7269\u70B9\u691C\u30C7\u30FC\u30BF:",
          Ue.length,
          "\u500B",
        ),
          console.log(
            "\u6700\u521D\u306E3\u3064\u306E\u5EFA\u7269\u70B9\u691C\u30DD\u30A4\u30F3\u30C8:",
            Ue.slice(0, 3),
          ),
          Gd(J, Ue));
        break;
      case "building-inspection-mesh":
        const rt = Kf(le);
        (console.log(
          "\u30D1\u30FC\u30B9\u3055\u308C\u305F\u5EFA\u7269\u70B9\u691C\u30E1\u30C3\u30B7\u30E5\u30C7\u30FC\u30BF:",
          rt.length,
          "\u500B",
        ),
          console.log(
            "\u6700\u521D\u306E3\u3064\u306E\u5EFA\u7269\u70B9\u691C\u9802\u70B9:",
            rt.slice(0, 3),
          ),
          qd(J, rt));
        break;
      default:
        throw new Error(
          `\u672A\u5BFE\u5FDC\u306E\u30C7\u30FC\u30BF\u30BF\u30A4\u30D7: ${se}`,
        );
    }
  },
  em = (K, J = ["3d-points", "3d-mesh"]) => {
    J.forEach((se) => {
      const le = `${se}-layer`;
      (K.getLayer(le) && K.removeLayer(le),
        K.getSource(se) && K.removeSource(se));
    });
  },
  tm = (K, J) => {
    const se = K.trim().split(`
`);
    if (se.length < 2) return [];
    const le = se[0].split(",").map((X) => X.trim().toLowerCase()),
      U = [];
    for (let X = 1; X < se.length; X++) {
      const E = se[X].split(",").map((Ue) => Ue.trim().replace(/"/g, "")),
        u = {};
      if (
        (le.forEach((Ue, rt) => {
          u[Ue] = E[rt] || "";
        }),
        u.longitude && u.latitude)
      ) {
        const Ue = {
          id: u.id || `${J}_${X}_${Date.now()}`,
          name: u.name || `\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8${X}`,
          longitude: parseFloat(u.longitude),
          latitude: parseFloat(u.latitude),
          altitude: parseFloat(u.altitude || u.height || u.elevation) || 50,
          type: u.type || "unknown",
          source: J,
          properties: {},
        };
        (Object.keys(u).forEach((rt) => {
          [
            "id",
            "name",
            "longitude",
            "latitude",
            "altitude",
            "height",
            "elevation",
            "type",
          ].includes(rt) || (Ue.properties[rt] = u[rt]);
        }),
          U.push(Ue));
      }
    }
    return U;
  },
  im = (K, J) => {
    const se = JSON.parse(K),
      le = [];
    return (
      se.type === "FeatureCollection" && se.features
        ? se.features.forEach((U, X) => {
            if (U.geometry && U.geometry.type === "Point") {
              const E = U.geometry.coordinates,
                u = U.properties || {},
                Ue = {
                  id: u.id || `${J}_${X}_${Date.now()}`,
                  name:
                    u.name || `\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8${X + 1}`,
                  longitude: E[0],
                  latitude: E[1],
                  altitude: E[2] || u.altitude || u.height || u.elevation || 50,
                  type: u.type || "unknown",
                  source: J,
                  properties: { ...u },
                };
              (delete Ue.properties.id,
                delete Ue.properties.name,
                delete Ue.properties.altitude,
                delete Ue.properties.height,
                delete Ue.properties.elevation,
                delete Ue.properties.type,
                le.push(Ue));
            }
          })
        : Array.isArray(se) &&
          se.forEach((U, X) => {
            if (U.longitude && U.latitude) {
              const E = {
                id: U.id || `${J}_${X}_${Date.now()}`,
                name: U.name || `\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8${X + 1}`,
                longitude: parseFloat(U.longitude || U.lng),
                latitude: parseFloat(U.latitude || U.lat),
                altitude:
                  parseFloat(U.altitude || U.height || U.elevation) || 50,
                type: U.type || "unknown",
                source: J,
                properties: {},
              };
              (Object.keys(U).forEach((u) => {
                [
                  "id",
                  "name",
                  "longitude",
                  "latitude",
                  "lng",
                  "lat",
                  "altitude",
                  "height",
                  "elevation",
                  "type",
                ].includes(u) || (E.properties[u] = U[u]);
              }),
                le.push(E));
            }
          }),
      le
    );
  },
  rm = (K) => {
    if (K.length === 0) return "";
    const se = [
      ["longitude", "latitude", "altitude", "name", "type", "source"].join(","),
    ];
    return (
      K.forEach((le) => {
        const U = [
          le.longitude,
          le.latitude,
          le.altitude,
          `"${le.name}"`,
          le.type,
          `"${le.source}"`,
        ];
        se.push(U.join(","));
      }),
      se.join(`
`)
    );
  },
  nm = (K) => {
    const J = {
      type: "FeatureCollection",
      metadata: {
        export_time: new Date().toISOString(),
        total_objects: K.length,
        generator: "MapLibre GSI Terrain System",
      },
      features: K.map((se) => ({
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [se.longitude, se.latitude, se.altitude],
        },
        properties: {
          name: se.name,
          type: se.type,
          altitude: se.altitude,
          source: se.source,
          id: se.id,
          ...se.properties,
        },
      })),
    };
    return JSON.stringify(J, null, 2);
  },
  Hd = (K) => {
    if (K.length === 0) return "";
    const J = [
        "id",
        "name",
        "type",
        "source",
        "longitude",
        "latitude",
        "altitude",
        "relativeAltitude",
        "timestamp",
        "duration",
        "speed",
        "heading",
        "action",
        "waypointId",
        "sequenceNumber",
        "batteryLevel",
        "signalStrength",
        "gpsAccuracy",
        "temperature",
        "humidity",
        "windSpeed",
        "windDirection",
        "missionId",
        "operatorId",
        "aircraftModel",
        "aircraftSerial",
        "description",
      ],
      se = K.map((U) => {
        var X, E, u, Ue, rt, _t, li, Qe, me, Ze, Ni, Ei, Mi, Ki, mr, ei, Vi;
        return [
          U.id,
          U.name,
          U.type,
          U.source,
          U.position.longitude,
          U.position.latitude,
          U.position.altitude,
          U.position.relativeAltitude || "",
          U.timestamp || "",
          U.duration || "",
          ((X = U.flight) == null ? void 0 : X.speed) || "",
          ((E = U.flight) == null ? void 0 : E.heading) || "",
          ((u = U.flight) == null ? void 0 : u.action) || "",
          ((Ue = U.flight) == null ? void 0 : Ue.waypointId) || "",
          ((rt = U.flight) == null ? void 0 : rt.sequenceNumber) || "",
          ((_t = U.telemetry) == null ? void 0 : _t.batteryLevel) || "",
          ((li = U.telemetry) == null ? void 0 : li.signalStrength) || "",
          ((Qe = U.telemetry) == null ? void 0 : Qe.gpsAccuracy) || "",
          ((me = U.telemetry) == null ? void 0 : me.temperature) || "",
          ((Ze = U.telemetry) == null ? void 0 : Ze.humidity) || "",
          ((Ni = U.telemetry) == null ? void 0 : Ni.windSpeed) || "",
          ((Ei = U.telemetry) == null ? void 0 : Ei.windDirection) || "",
          ((Mi = U.metadata) == null ? void 0 : Mi.missionId) || "",
          ((Ki = U.metadata) == null ? void 0 : Ki.operatorId) || "",
          ((mr = U.metadata) == null ? void 0 : mr.aircraftModel) || "",
          ((ei = U.metadata) == null ? void 0 : ei.aircraftSerial) || "",
          ((Vi = U.metadata) == null ? void 0 : Vi.description) || "",
        ];
      });
    return [J.join(","), ...se.map((U) => U.join(","))].join(`
`);
  },
  Xd = (K) => {
    const J = K.map((le) => ({
        type: "Feature",
        geometry: le.geometry || {
          type: "Point",
          coordinates: [
            le.position.longitude,
            le.position.latitude,
            le.position.altitude,
          ],
        },
        properties: {
          id: le.id,
          name: le.name,
          type: le.type,
          source: le.source,
          altitude: le.position.altitude,
          relativeAltitude: le.position.relativeAltitude,
          timestamp: le.timestamp,
          duration: le.duration,
          flight: le.flight,
          telemetry: le.telemetry,
          metadata: le.metadata,
          ...le.properties,
        },
      })),
      se = {
        type: "FeatureCollection",
        metadata: {
          generator: "MapLibre GSI Terrain - Unified Flight Data",
          timestamp: new Date().toISOString(),
          count: K.length,
        },
        features: J,
      };
    return JSON.stringify(se, null, 2);
  },
  om = (K) => {
    const J = K.waypoints;
    if (J.length === 0) return "";
    const se = J.map((X) => {
        var E, u;
        return `
        <Placemark>
            <name>${X.name}</name>
            <description>
                <![CDATA[
                    <b>Action:</b> ${((E = X.flight) == null ? void 0 : E.action) || "waypoint"}<br/>
                    <b>Altitude:</b> ${X.position.altitude}m<br/>
                    <b>Speed:</b> ${((u = X.flight) == null ? void 0 : u.speed) || "N/A"} m/s<br/>
                    <b>Duration:</b> ${X.duration || 0}s
                ]]>
            </description>
            <Point>
                <coordinates>${X.position.longitude},${X.position.latitude},${X.position.altitude}</coordinates>
            </Point>
        </Placemark>`;
      }).join(""),
      le = J.map(
        (X) =>
          `${X.position.longitude},${X.position.latitude},${X.position.altitude}`,
      ).join(" ");
    return `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
    <Document>
        <name>${K.name}</name>
        <description>${K.description || ""}</description>
        
        <Style id="waypointStyle">
            <IconStyle>
                <Icon>
                    <href>http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png</href>
                </Icon>
            </IconStyle>
        </Style>
        
        <Style id="pathStyle">
            <LineStyle>
                <color>ff0000ff</color>
                <width>3</width>
            </LineStyle>
        </Style>
        
        ${se}
        
        <Placemark>
            <name>Flight Path</name>
            <styleUrl>#pathStyle</styleUrl>
            <LineString>
                <altitudeMode>absolute</altitudeMode>
                <coordinates>${le}</coordinates>
            </LineString>
        </Placemark>
        
        <Placemark>
            <name>Home Position</name>
            <Point>
                <coordinates>${K.settings.homePosition.longitude},${K.settings.homePosition.latitude},${K.settings.homePosition.altitude}</coordinates>
            </Point>
        </Placemark>
    </Document>
</kml>`;
  },
  Ju = (K) => {
    const J = K.trim().split(`
`);
    if (J.length < 2) return [];
    J[0].split(",").map((le) => le.trim());
    const se = [];
    for (let le = 1; le < J.length; le++) {
      const U = J[le].split(",").map((X) => X.trim());
      if (U.length >= 6) {
        const X = {
          id: U[0] || `unified_${Date.now()}_${le}`,
          name: U[1] || `Flight Data ${le}`,
          type: U[2] || "waypoint",
          source: U[3] || "csv_import",
          position: {
            longitude: parseFloat(U[4]) || 0,
            latitude: parseFloat(U[5]) || 0,
            altitude: parseFloat(U[6]) || 0,
            relativeAltitude: U[7] ? parseFloat(U[7]) : void 0,
          },
        };
        (U[8] && (X.timestamp = U[8]),
          U[9] && (X.duration = parseFloat(U[9])),
          (U[10] || U[11] || U[12] || U[13] || U[14]) &&
            (X.flight = {
              speed: U[10] ? parseFloat(U[10]) : void 0,
              heading: U[11] ? parseFloat(U[11]) : void 0,
              action: U[12],
              waypointId: U[13] ? parseInt(U[13]) : void 0,
              sequenceNumber: U[14] ? parseInt(U[14]) : void 0,
            }),
          (U[15] || U[16] || U[17] || U[18] || U[19] || U[20] || U[21]) &&
            (X.telemetry = {
              batteryLevel: U[15] ? parseFloat(U[15]) : void 0,
              signalStrength: U[16] ? parseFloat(U[16]) : void 0,
              gpsAccuracy: U[17] ? parseFloat(U[17]) : void 0,
              temperature: U[18] ? parseFloat(U[18]) : void 0,
              humidity: U[19] ? parseFloat(U[19]) : void 0,
              windSpeed: U[20] ? parseFloat(U[20]) : void 0,
              windDirection: U[21] ? parseFloat(U[21]) : void 0,
            }),
          (U[22] || U[23] || U[24] || U[25] || U[26]) &&
            (X.metadata = {
              missionId: U[22] || void 0,
              operatorId: U[23] || void 0,
              aircraftModel: U[24] || void 0,
              aircraftSerial: U[25] || void 0,
              description: U[26] || void 0,
            }),
          se.push(X));
      }
    }
    return se;
  },
  Wd = (K) => {
    try {
      const J = JSON.parse(K);
      if (J.type !== "FeatureCollection" || !J.features)
        throw new Error("Invalid GeoJSON format");
      return J.features.map((le, U) => {
        const X = le.properties || {},
          E = le.geometry;
        let u = { longitude: 0, latitude: 0, altitude: 0 };
        return (
          E &&
            (E.type === "Point"
              ? (u = {
                  longitude: E.coordinates[0],
                  latitude: E.coordinates[1],
                  altitude: E.coordinates[2] || X.altitude || 0,
                })
              : E.type === "LineString" && E.coordinates.length > 0
                ? (u = {
                    longitude: E.coordinates[0][0],
                    latitude: E.coordinates[0][1],
                    altitude: E.coordinates[0][2] || X.altitude || 0,
                  })
                : E.type === "Polygon" &&
                  E.coordinates[0].length > 0 &&
                  (u = {
                    longitude: E.coordinates[0][0][0],
                    latitude: E.coordinates[0][0][1],
                    altitude: E.coordinates[0][0][2] || X.altitude || 0,
                  })),
          {
            id: X.id || `geojson_${Date.now()}_${U}`,
            name: X.name || `Flight Data ${U + 1}`,
            type: X.type || "waypoint",
            source: X.source || "geojson_import",
            position: { ...u, relativeAltitude: X.relativeAltitude },
            timestamp: X.timestamp,
            duration: X.duration,
            flight: X.flight,
            telemetry: X.telemetry,
            metadata: X.metadata,
            geometry: E,
            properties: X,
          }
        );
      });
    } catch (J) {
      return (console.error("GeoJSON parse error:", J), []);
    }
  },
  sm = (K) => {
    try {
      const J = JSON.parse(K);
      if (!J.id || !J.name || !J.settings || !J.waypoints)
        throw new Error("Invalid flight mission format");
      return J;
    } catch (J) {
      return (console.error("Flight mission parse error:", J), null);
    }
  },
  wo = (K, J, se) => {
    try {
      const le = new Blob([K], { type: se }),
        U = URL.createObjectURL(le),
        X = document.createElement("a");
      ((X.href = U),
        (X.download = J),
        (X.style.display = "none"),
        document.body.appendChild(X),
        X.click(),
        document.body.removeChild(X),
        URL.revokeObjectURL(U),
        console.log(
          `\u30D5\u30A1\u30A4\u30EB\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u5B8C\u4E86: ${J}`,
        ));
    } catch (le) {
      throw (
        console.error(
          "\u30D5\u30A1\u30A4\u30EB\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u30A8\u30E9\u30FC:",
          le,
        ),
        le
      );
    }
  },
  am = (K = [139.7454, 35.6586]) => {
    const J = [];
    for (let le = 1; le <= 5; le++) {
      const U = (le - 1) * ((2 * Math.PI) / 5) + Math.random() * 0.5,
        X = 200 + Math.random() * 300,
        E = [
          K[0] + (X * Math.cos(U)) / 111320,
          K[1] + (X * Math.sin(U)) / 110540,
        ];
      J.push({
        id: `tokyo_tower_drone_${le}_${Date.now()}`,
        name: `\u70B9\u691C\u7528\u30C9\u30ED\u30FC\u30F3${String(le).padStart(2, "0")}`,
        longitude: E[0],
        latitude: E[1],
        altitude: 250 + Math.random() * 100,
        type: "drone",
        source: "tokyo_tower_inspection",
        properties: { mission: "tower_inspection", status: "active" },
      });
    }
    return (
      [
        {
          type: "base",
          name: "\u7BA1\u5236\u57FA\u5730",
          lat_offset: -0.001,
          lng_offset: 0.001,
          altitude: 50,
        },
        {
          type: "sensor",
          name: "\u98A8\u5411\u30BB\u30F3\u30B5\u30FC",
          lat_offset: 5e-4,
          lng_offset: -8e-4,
          altitude: 100,
        },
        {
          type: "weather",
          name: "\u6C17\u8C61\u89B3\u6E2C\u70B9",
          lat_offset: -8e-4,
          lng_offset: -0.001,
          altitude: 80,
        },
        {
          type: "manual",
          name: "\u70B9\u691C\u30DD\u30A4\u30F3\u30C8A",
          lat_offset: 3e-4,
          lng_offset: 5e-4,
          altitude: 200,
        },
      ].forEach((le, U) => {
        J.push({
          id: `tokyo_tower_${le.type}_${U}_${Date.now()}`,
          name: le.name,
          longitude: K[0] + le.lng_offset,
          latitude: K[1] + le.lat_offset,
          altitude: le.altitude + (Math.random() - 0.5) * 20,
          type: le.type,
          source: "tokyo_tower_inspection",
          properties: {
            facility_type: "inspection_equipment",
            tower_related: !0,
          },
        });
      }),
      J
    );
  },
  lm = Uf("gsidem");
Jd.addProtocol("gsidem", lm);
const um = {
    type: "raster-dem",
    tiles: ["gsidem://https://tiles.gsj.jp/tiles/elev/mixed/{z}/{y}/{x}.png"],
    tileSize: 256,
    encoding: "terrarium",
    minzoom: 1,
    maxzoom: 17,
    attribution:
      "<a href=\"https://maps.gsi.go.jp/development/ichiran.html\">\u5730\u7406\u9662\u30BF\u30A4\u30EB</a>",
  },
  Xe = new Jd.Map({
    container: "map",
    zoom: 15,
    center: [139.7454, 35.6586],
    minZoom: 5,
    maxZoom: 18,
    pitch: 60,
    maxPitch: 85,
    style: {
      version: 8,
      sources: {
        seamlessphoto: {
          type: "raster",
          tiles: [
            "https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg",
          ],
          maxzoom: 18,
          tileSize: 256,
          attribution:
            "<a href=\"https://maps.gsi.go.jp/development/ichiran.html\">\u5730\u7406\u9662\u30BF\u30A4\u30EB</a>",
        },
        terrain: um,
        "drone-objects": {
          type: "geojson",
          data: { type: "FeatureCollection", features: [] },
        },
        "drone-connections": {
          type: "geojson",
          data: { type: "FeatureCollection", features: [] },
        },
        "altitude-lines": {
          type: "geojson",
          data: { type: "FeatureCollection", features: [] },
        },
        "drawing-polygon": {
          type: "geojson",
          data: { type: "FeatureCollection", features: [] },
        },
        "selected-object": {
          type: "geojson",
          data: { type: "FeatureCollection", features: [] },
        },
      },
      layers: [
        { id: "seamlessphoto", source: "seamlessphoto", type: "raster" },
      ],
      terrain: { source: "terrain", exaggeration: 1.5 },
    },
  });
let ft = [],
  Sl = !0,
  cn = !1,
  hn = !1,
  fr = !1,
  Qt = null,
  Co = !1,
  ca = null,
  ji = [],
  rs = null,
  ah = !1,
  ns = [],
  ha = !1,
  Dl = 0,
  Zn = [],
  os = "",
  lh = "";
const cm = [
  {
    phase: "\u96E2\u9678",
    action:
      "\u6771\u4EAC\u30BF\u30EF\u30FC\u5357\u5074\u304B\u3089\u96E2\u9678\u958B\u59CB",
    duration: 3e3,
    position: [139.7454, 35.6586, 100],
  },
  {
    phase: "\u5916\u5074\u65CB\u56DE1",
    action:
      "\u5317\u6771\u89D2\u3078\u79FB\u52D5\u30FB\u30DB\u30D0\u30EA\u30F3\u30B0",
    duration: 4e3,
    position: [139.7456, 35.6588, 150],
  },
  {
    phase: "\u5916\u5074\u65CB\u56DE2",
    action:
      "\u5317\u897F\u89D2\u3078\u79FB\u52D5\u30FB\u30DB\u30D0\u30EA\u30F3\u30B0",
    duration: 4e3,
    position: [139.7452, 35.6588, 150],
  },
  {
    phase: "\u5916\u5074\u65CB\u56DE3",
    action:
      "\u5357\u897F\u89D2\u3078\u79FB\u52D5\u30FB\u30DB\u30D0\u30EA\u30F3\u30B0",
    duration: 4e3,
    position: [139.7452, 35.6584, 150],
  },
  {
    phase: "\u5916\u5074\u65CB\u56DE4",
    action:
      "\u5357\u6771\u89D2\u3078\u79FB\u52D5\u30FB\u30DB\u30D0\u30EA\u30F3\u30B0",
    duration: 4e3,
    position: [139.7456, 35.6584, 150],
  },
  {
    phase: "\u5185\u5074\u65CB\u56DE1",
    action:
      "\u5185\u5074\u5317\u6771\u3078\u79FB\u52D5\u30FB\u8A73\u7D30\u64AE\u5F71",
    duration: 3e3,
    position: [139.7455, 35.6587, 120],
  },
  {
    phase: "\u5185\u5074\u65CB\u56DE2",
    action:
      "\u5185\u5074\u5317\u897F\u3078\u79FB\u52D5\u30FB\u8A73\u7D30\u64AE\u5F71",
    duration: 3e3,
    position: [139.7453, 35.6587, 120],
  },
  {
    phase: "\u5185\u5074\u65CB\u56DE3",
    action:
      "\u5185\u5074\u5357\u897F\u3078\u79FB\u52D5\u30FB\u8A73\u7D30\u64AE\u5F71",
    duration: 3e3,
    position: [139.7453, 35.6585, 120],
  },
  {
    phase: "\u5185\u5074\u65CB\u56DE4",
    action:
      "\u5185\u5074\u5357\u6771\u3078\u79FB\u52D5\u30FB\u8A73\u7D30\u64AE\u5F71",
    duration: 3e3,
    position: [139.7455, 35.6585, 120],
  },
  {
    phase: "\u4E2D\u5FC3\u90E8\u64AE\u5F71",
    action:
      "\u6771\u4EAC\u30BF\u30EF\u30FC\u4E2D\u5FC3\u90E8\u3067\u8A73\u7D30\u64AE\u5F71",
    duration: 5e3,
    position: [139.7454, 35.6586, 200],
  },
  {
    phase: "\u7740\u9678",
    action: "\u96E2\u9678\u5730\u70B9\u306B\u623B\u3063\u3066\u7740\u9678",
    duration: 3e3,
    position: [139.7454, 35.6586, 0],
  },
];
Zn = cm;
os =
  "\u6771\u4EAC\u30BF\u30EF\u30FC\u70B9\u691C\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3";
lh =
  "\u6771\u4EAC\u30BF\u30EF\u30FC\u5468\u8FBA\u306E\u5305\u62EC\u7684\u70B9\u691C\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3";
const Ye = (K, J = "info") => {
    const se = document.createElement("div");
    ((se.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${J === "success" ? "rgba(34, 197, 94, 0.9)" : J === "error" ? "rgba(239, 68, 68, 0.9)" : "rgba(59, 130, 246, 0.9)"};
        backdrop-filter: blur(4px);
        color: white;
        padding: 12px 16px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        z-index: 10000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-size: 13px;
        font-weight: 500;
        max-width: 300px;
        word-wrap: break-word;
        border: 1px solid ${J === "success" ? "rgba(34, 197, 94, 0.3)" : J === "error" ? "rgba(239, 68, 68, 0.3)" : "rgba(59, 130, 246, 0.3)"};
        transform: translateX(100%);
        opacity: 0;
        transition: all 0.3s ease;
    `),
      (se.textContent = K),
      document.body.appendChild(se),
      setTimeout(() => {
        ((se.style.transform = "translateX(0)"), (se.style.opacity = "1"));
      }, 100),
      setTimeout(() => {
        ((se.style.transform = "translateX(100%)"),
          (se.style.opacity = "0"),
          setTimeout(() => {
            document.body.contains(se) && document.body.removeChild(se);
          }, 300));
      }, 3e3));
  },
  ot = (K, J, se, le = "info") => {
    const E = {
      timestamp: new Date().toLocaleTimeString("ja-JP"),
      phase: K,
      action: J,
      details: se,
      type: le,
    };
    (ns.push(E), ep(), ns.length > 50 && (ns = ns.slice(-30)));
  },
  ep = () => {
    const K = document.getElementById("flightLog");
    !K ||
      ((K.innerHTML = ""),
      ns.forEach((J) => {
        const se = document.createElement("div");
        se.className = "log-entry";
        const le = document.createElement("span");
        ((le.className = "log-timestamp"), (le.textContent = J.timestamp));
        const U = document.createElement("span");
        ((U.className = "log-phase"), (U.textContent = J.phase));
        const X = document.createElement("span");
        ((X.className = `log-action ${J.type}`), (X.textContent = J.action));
        const E = document.createElement("span");
        ((E.className = "log-details"),
          (E.textContent = J.details),
          se.appendChild(le),
          se.appendChild(U),
          se.appendChild(X),
          se.appendChild(E),
          K.appendChild(se));
      }),
      (K.scrollTop = K.scrollHeight));
  },
  hm = () => {
    ((ns = []),
      ep(),
      ot(
        "\u30B7\u30B9\u30C6\u30E0",
        "\u30ED\u30B0\u30AF\u30EA\u30A2",
        "\u30D5\u30E9\u30A4\u30C8\u30ED\u30B0\u3092\u30AF\u30EA\u30A2\u3057\u307E\u3057\u305F",
        "info",
      ));
  },
  dm = () => {
    const se =
        `timestamp,phase,action,details,type
` +
        ns.map(
          (E) => `${E.timestamp},${E.phase},${E.action},${E.details},${E.type}`,
        ).join(`
`),
      le = new Blob([se], { type: "text/csv" }),
      U = URL.createObjectURL(le),
      X = document.createElement("a");
    ((X.href = U),
      (X.download = `tokyo_tower_flight_log_${new Date().toISOString().slice(0, 19).replace(/:/g, "-")}.csv`),
      document.body.appendChild(X),
      X.click(),
      document.body.removeChild(X),
      URL.revokeObjectURL(U),
      ot(
        "\u30B7\u30B9\u30C6\u30E0",
        "\u30ED\u30B0\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
        "\u30D5\u30E9\u30A4\u30C8\u30ED\u30B0\u3092CSV\u30D5\u30A1\u30A4\u30EB\u3067\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F",
        "success",
      ));
  },
  wt = (K) => {
    const J = document.getElementById("status");
    (J && (J.textContent = K), console.log("Status:", K));
  },
  pm = () => {
    (Xe.addLayer({
      id: "altitude-lines-layer",
      type: "line",
      source: "altitude-lines",
      paint: { "line-color": "#ffaa00", "line-width": 1, "line-opacity": 0.4 },
    }),
      Xe.addLayer({
        id: "polygon-fill-layer",
        type: "fill",
        source: "drone-objects",
        filter: ["==", ["get", "type"], "polygon"],
        paint: { "fill-color": "#ff6b6b", "fill-opacity": 0.3 },
      }),
      Xe.addLayer({
        id: "polygon-stroke-layer",
        type: "line",
        source: "drone-objects",
        filter: ["==", ["get", "type"], "polygon"],
        paint: {
          "line-color": "#ff6b6b",
          "line-width": 2,
          "line-opacity": 0.8,
        },
      }),
      Xe.addLayer({
        id: "drone-objects-3d",
        type: "circle",
        source: "drone-objects",
        filter: ["!=", ["get", "type"], "polygon"],
        paint: {
          "circle-radius": [
            "interpolate",
            ["linear"],
            ["zoom"],
            10,
            ["interpolate", ["linear"], ["get", "altitude"], 50, 3, 300, 8],
            18,
            ["interpolate", ["linear"], ["get", "altitude"], 50, 6, 300, 16],
          ],
          "circle-color": [
            "match",
            ["get", "type"],
            "drone",
            "#ff4444",
            "building",
            "#44ff44",
            "sensor",
            "#4444ff",
            "base",
            "#ffaa00",
            "weather",
            "#ff44ff",
            "manual",
            "#888888",
            "flight",
            "#ff6b6b",
            "#cccccc",
          ],
          "circle-stroke-width": 2,
          "circle-stroke-color": "#ffffff",
          "circle-opacity": 0.9,
        },
      }),
      Xe.addLayer({
        id: "drone-objects-2d",
        type: "circle",
        source: "drone-objects",
        filter: ["!=", ["get", "type"], "polygon"],
        layout: { visibility: "none" },
        paint: {
          "circle-radius": 6,
          "circle-color": [
            "match",
            ["get", "type"],
            "drone",
            "#ff4444",
            "building",
            "#44ff44",
            "sensor",
            "#4444ff",
            "base",
            "#ffaa00",
            "weather",
            "#ff44ff",
            "manual",
            "#888888",
            "flight",
            "#ff6b6b",
            "#cccccc",
          ],
          "circle-stroke-width": 2,
          "circle-stroke-color": "#ffffff",
          "circle-opacity": 0.9,
        },
      }),
      Xe.addLayer({
        id: "drone-connections",
        type: "line",
        source: "drone-connections",
        paint: {
          "line-color": "#00ff00",
          "line-width": 2,
          "line-opacity": 0.7,
          "line-dasharray": [2, 2],
        },
      }),
      Xe.addLayer({
        id: "drone-labels",
        type: "symbol",
        source: "drone-objects",
        layout: {
          "text-field": [
            "format",
            ["get", "name"],
            {},
            `
`,
            {},
            ["concat", ["to-string", ["get", "altitude"]], "m"],
            { "font-scale": 0.8 },
          ],
          "text-font": ["Open Sans Regular", "Arial Unicode MS Regular"],
          "text-size": 12,
          "text-offset": [0, -2],
          "text-anchor": "bottom",
        },
        paint: {
          "text-color": "#ffffff",
          "text-halo-color": "#000000",
          "text-halo-width": 1,
        },
      }),
      Xe.addLayer({
        id: "polygon-fill",
        type: "fill",
        source: "drawing-polygon",
        paint: { "fill-color": "#ff6b6b", "fill-opacity": 0.3 },
      }),
      Xe.addLayer({
        id: "polygon-stroke",
        type: "line",
        source: "drawing-polygon",
        paint: {
          "line-color": "#ff6b6b",
          "line-width": 3,
          "line-opacity": 0.8,
        },
      }),
      Xe.addLayer({
        id: "polygon-points",
        type: "circle",
        source: "drawing-polygon",
        paint: {
          "circle-radius": 6,
          "circle-color": "#ff6b6b",
          "circle-stroke-width": 2,
          "circle-stroke-color": "#ffffff",
        },
      }),
      Xe.addLayer({
        id: "selected-object-highlight",
        type: "fill",
        source: "selected-object",
        paint: { "fill-color": "#00ff00", "fill-opacity": 0.2 },
      }),
      Xe.addLayer({
        id: "selected-object-stroke",
        type: "line",
        source: "selected-object",
        paint: {
          "line-color": "#00ff00",
          "line-width": 4,
          "line-opacity": 0.8,
        },
      }),
      Xe.addLayer({
        id: "selected-object-points",
        type: "circle",
        source: "selected-object",
        paint: {
          "circle-radius": 8,
          "circle-color": "#00ff00",
          "circle-stroke-width": 3,
          "circle-stroke-color": "#ffffff",
          "circle-opacity": 0.9,
        },
      }));
  },
  Wi = () => {
    var le, U;
    const K = ft.map((X) => {
      const E = X;
      if (X.type === "polygon" && E.geometry) {
        const u = {
          type: "Feature",
          geometry: E.geometry,
          properties: {
            id: X.id,
            name: X.name,
            altitude: X.altitude,
            type: X.type,
            area: E.area || 0,
          },
        };
        return (
          console.log(
            "\u591A\u89D2\u5F62\u30D5\u30A3\u30FC\u30C1\u30E3\u30FC\u4F5C\u6210:",
            u,
          ),
          u
        );
      } else
        return {
          type: "Feature",
          geometry: { type: "Point", coordinates: [X.longitude, X.latitude] },
          properties: {
            id: X.id,
            name: X.name,
            altitude: X.altitude,
            type: X.type,
          },
        };
    });
    console.log(
      "updateDisplay: \u5168\u30D5\u30A3\u30FC\u30C1\u30E3\u30FC:",
      K,
    );
    const J = { type: "FeatureCollection", features: K };
    (console.log(
      "drone-objects\u30BD\u30FC\u30B9\u306B\u8A2D\u5B9A\u3059\u308B\u30C7\u30FC\u30BF:",
      J,
    ),
      (le = Xe.getSource("drone-objects")) == null || le.setData(J));
    const se = ft.map((X) => ({
      type: "Feature",
      geometry: {
        type: "LineString",
        coordinates: [
          [X.longitude, X.latitude],
          [X.longitude, X.latitude],
        ],
      },
      properties: { altitude: X.altitude },
    }));
    ((U = Xe.getSource("altitude-lines")) == null ||
      U.setData({ type: "FeatureCollection", features: se }),
      fm(),
      console.log(
        `\u8868\u793A\u66F4\u65B0: ${ft.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8`,
      ));
  },
  fm = () => {
    var se, le;
    if (ft.length < 2) {
      (se = Xe.getSource("drone-connections")) == null ||
        se.setData({ type: "FeatureCollection", features: [] });
      return;
    }
    const K = {};
    ft.forEach((U) => {
      (K[U.type] || (K[U.type] = []), K[U.type].push(U));
    });
    const J = [];
    (Object.values(K).forEach((U) => {
      if (U.length >= 2) {
        const X = U.map((E) => [E.longitude, E.latitude]);
        J.push({
          type: "Feature",
          geometry: { type: "LineString", coordinates: X },
          properties: { type: "connection" },
        });
      }
    }),
      (le = Xe.getSource("drone-connections")) == null ||
        le.setData({ type: "FeatureCollection", features: J }));
  },
  mm = (K) => {
    const J = [K.lng, K.lat];
    if (ji.length >= 3) {
      const se = ji[0];
      if (
        Math.sqrt(
          Math.pow((J[0] - se[0]) * 111e3, 2) +
            Math.pow((J[1] - se[1]) * 111e3, 2),
        ) < 100
      ) {
        _m();
        return;
      }
    }
    (ji.push(J),
      gm(),
      Ye(
        `\u9802\u70B9${ji.length}\u3092\u8FFD\u52A0 (${ji.length >= 3 ? "\u59CB\u70B9\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u5B8C\u6210" : ""})`,
        "info",
      ));
  },
  gm = () => {
    const K = [];
    if (
      (ji.forEach((J, se) => {
        const le = {
          type: "Feature",
          geometry: { type: "Point", coordinates: J },
          properties: { index: se, isFirst: se === 0 },
        };
        K.push(le);
      }),
      ji.length >= 2)
    ) {
      const J = [...ji];
      (ji.length >= 3 && J.push(ji[0]),
        K.push({
          type: "Feature",
          geometry: { type: "LineString", coordinates: J },
          properties: { type: "drawing-line" },
        }));
    }
    Xe.getSource("drawing-polygon").setData({
      type: "FeatureCollection",
      features: K,
    });
  },
  _m = () => {
    if (ji.length < 3) {
      Ye(
        "\u591A\u89D2\u5F62\u3092\u4F5C\u6210\u3059\u308B\u306B\u306F\u6700\u4F4E3\u70B9\u304C\u5FC5\u8981\u3067\u3059",
        "warning",
      );
      return;
    }
    const K = [...ji, ji[0]],
      J = ym(ji),
      se = {
        id: `polygon_${Date.now()}`,
        name: `\u691C\u67FB\u30A8\u30EA\u30A2_${ft.filter((le) => le.type === "polygon").length + 1}`,
        longitude: ji[0][0],
        latitude: ji[0][1],
        altitude: 0,
        type: "polygon",
        source: "polygon_draw",
        geometry: { type: "Polygon", coordinates: [K] },
        area: J,
      };
    (ft.push(se),
      console.log(
        "\u591A\u89D2\u5F62\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u8FFD\u52A0:",
        se,
      ),
      console.log("\u73FE\u5728\u306EloadedObjects:", ft),
      Qu(),
      Wi(),
      Ye(
        `\u591A\u89D2\u5F62\u300C${se.name}\u300D\u3092\u4F5C\u6210\u3057\u307E\u3057\u305F (\u9762\u7A4D: ${J.toFixed(0)}\u33A1)`,
        "success",
      ));
  },
  ym = (K) => {
    let J = 0;
    const se = K.length;
    for (let U = 0; U < se; U++) {
      const X = (U + 1) % se;
      ((J += K[U][0] * K[X][1]), (J -= K[X][0] * K[U][1]));
    }
    J = Math.abs(J) / 2;
    const le = 111e3;
    return J * le * le;
  },
  Qu = () => {
    ((ji = []),
      Xe.getSource("drawing-polygon").setData({
        type: "FeatureCollection",
        features: [],
      }));
  },
  xm = (K) => {
    const J = Xe.project(K),
      se = 20;
    let le = null,
      U = 1 / 0;
    return (
      ft.forEach((X) => {
        const E = Xe.project([X.longitude, X.latitude]),
          u = Math.sqrt(Math.pow(J.x - E.x, 2) + Math.pow(J.y - E.y, 2));
        u < se && u < U && ((U = u), (le = X));
      }),
      le
        ? ((Qt = le),
          uh(),
          Ye(
            `\u300C${le.name}\u300D\u3092\u9078\u629E\u3057\u307E\u3057\u305F`,
            "info",
          ),
          !0)
        : (Ml(), !1)
    );
  },
  Ml = () => {
    ((Qt = null), uh());
  },
  uh = () => {
    if (!Qt) {
      Xe.getSource("selected-object").setData({
        type: "FeatureCollection",
        features: [],
      });
      return;
    }
    const K = [];
    if (Qt.type === "polygon") {
      const J = Qt;
      J.geometry &&
        J.geometry.coordinates &&
        (K.push({
          type: "Feature",
          geometry: J.geometry,
          properties: { id: Qt.id, type: "selected-polygon" },
        }),
        J.geometry.coordinates[0].slice(0, -1).forEach((se, le) => {
          K.push({
            type: "Feature",
            geometry: { type: "Point", coordinates: se },
            properties: { id: Qt.id, type: "selected-vertex", vertexIndex: le },
          });
        }));
    } else
      K.push({
        type: "Feature",
        geometry: { type: "Point", coordinates: [Qt.longitude, Qt.latitude] },
        properties: { id: Qt.id, type: "selected-point" },
      });
    Xe.getSource("selected-object").setData({
      type: "FeatureCollection",
      features: K,
    });
  },
  vm = () => {
    (Xe.dragPan.disable(),
      Xe.scrollZoom.disable(),
      Xe.boxZoom.disable(),
      Xe.dragRotate.disable(),
      Xe.keyboard.disable(),
      Xe.doubleClickZoom.disable(),
      Xe.touchZoomRotate.disable());
  },
  bm = () => {
    (Xe.dragPan.enable(),
      Xe.scrollZoom.enable(),
      Xe.boxZoom.enable(),
      Xe.dragRotate.enable(),
      Xe.keyboard.enable(),
      Xe.doubleClickZoom.enable(),
      Xe.touchZoomRotate.enable());
  },
  wm = (K) =>
    Qt
      ? ((Co = !0),
        (ca = [K.lng, K.lat]),
        (Xe.getCanvas().style.cursor = "grabbing"),
        vm(),
        !0)
      : !1,
  Cm = (K) => {
    if (!Co || !Qt || !ca) return;
    const J = K.lng - ca[0],
      se = K.lat - ca[1];
    if (Qt.type === "polygon") {
      const le = Qt;
      le.geometry &&
        le.geometry.coordinates &&
        (le.geometry.coordinates[0] = le.geometry.coordinates[0].map((U) => [
          U[0] + J,
          U[1] + se,
        ]));
    }
    ((Qt.longitude += J),
      (Qt.latitude += se),
      (ca = [K.lng, K.lat]),
      Wi(),
      uh());
  },
  tp = () => {
    Co &&
      Qt &&
      ((Co = !1),
      (ca = null),
      (Xe.getCanvas().style.cursor = fr ? "crosshair" : ""),
      bm(),
      Ye(
        `\u300C${Qt.name}\u300D\u3092\u79FB\u52D5\u3057\u307E\u3057\u305F`,
        "success",
      ));
  },
  Em = () => {
    if (!Qt) {
      Ye(
        "\u524A\u9664\u3059\u308B\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093",
        "warning",
      );
      return;
    }
    const K = Qt.name;
    confirm(
      `\u300C${K}\u300D\u3092\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F`,
    ) &&
      ((ft = ft.filter((se) => se.id !== Qt.id)),
      Ml(),
      Wi(),
      Ye(
        `\u300C${K}\u300D\u3092\u524A\u9664\u3057\u307E\u3057\u305F`,
        "success",
      ));
  },
  Am = (K) => {
    const J = {
      id: `manual_${Date.now()}`,
      name: `\u70B9\u691C\u30DD\u30A4\u30F3\u30C8_${ft.filter((se) => se.type === "manual").length + 1}`,
      longitude: K.lng,
      latitude: K.lat,
      altitude: 150 + Math.random() * 100,
      type: "manual",
      source: "manual_draw",
    };
    (ft.push(J),
      Wi(),
      Ye(
        `\u70B9\u691C\u30DD\u30A4\u30F3\u30C8\u3092\u8FFD\u52A0: ${J.name}`,
        "success",
      ));
  },
  Tm = () => {
    ((Sl = !Sl),
      Sl
        ? (Xe.easeTo({ pitch: 60, duration: 1e3 }),
          Xe.setLayoutProperty("drone-objects-3d", "visibility", "visible"),
          Xe.setLayoutProperty("drone-objects-2d", "visibility", "none"),
          wt("3D\u8868\u793A\u306B\u5207\u308A\u66FF\u3048"))
        : (Xe.easeTo({ pitch: 0, duration: 1e3 }),
          Xe.setLayoutProperty("drone-objects-3d", "visibility", "none"),
          Xe.setLayoutProperty("drone-objects-2d", "visibility", "visible"),
          wt("2D\u8868\u793A\u306B\u5207\u308A\u66FF\u3048")));
  },
  Fm = () => {
    var K,
      J,
      se,
      le,
      U,
      X,
      E,
      u,
      Ue,
      rt,
      _t,
      li,
      Qe,
      me,
      Ze,
      Ni,
      Ei,
      Mi,
      Ki,
      mr,
      ei,
      Vi,
      It,
      Dt,
      Bt,
      Xr,
      dn,
      or,
      sr;
    ((K = document.getElementById("loadPoints")) == null ||
      K.addEventListener("click", async () => {
        try {
          const Ae = await fetch("./data/mock-3d-data.csv");
          if (!Ae.ok) throw new Error(`HTTP error! status: ${Ae.status}`);
          const Oe = await Ae.text(),
            $e = new Blob([Oe], { type: "text/csv" }),
            qe = new File([$e], "sample-points.csv", { type: "text/csv" });
          (await Yu(qe, Xe, "points"),
            Ye(
              "\u30DD\u30A4\u30F3\u30C8\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u307F\u307E\u3057\u305F",
              "success",
            ));
        } catch (Ae) {
          (console.error(
            "\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u30A8\u30E9\u30FC:",
            Ae,
          ),
            Ye(
              "\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
              "error",
            ));
        }
      }),
      (J = document.getElementById("loadMesh")) == null ||
        J.addEventListener("click", async () => {
          try {
            const Ae = await fetch("./data/mock-mesh-data.csv");
            if (!Ae.ok) throw new Error(`HTTP error! status: ${Ae.status}`);
            const Oe = await Ae.text(),
              $e = new Blob([Oe], { type: "text/csv" }),
              qe = new File([$e], "sample-mesh.csv", { type: "text/csv" });
            (await Yu(qe, Xe, "mesh"),
              Ye(
                "\u30E1\u30C3\u30B7\u30E5\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u307F\u307E\u3057\u305F",
                "success",
              ));
          } catch (Ae) {
            (console.error(
              "\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u30A8\u30E9\u30FC:",
              Ae,
            ),
              Ye(
                "\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                "error",
              ));
          }
        }),
      (se = document.getElementById("loadBuilding")) == null ||
        se.addEventListener("click", async () => {
          try {
            console.log(
              "\u5EFA\u7269\u70B9\u691C\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u958B\u59CB",
            );
            const [Ae, Oe] = await Promise.all([
              fetch("./data/mock-building-inspection-points.csv"),
              fetch("./data/mock-building-inspection-mesh.csv"),
            ]);
            if (
              (console.log("\u30EC\u30B9\u30DD\u30F3\u30B9\u78BA\u8A8D:", {
                points: { ok: Ae.ok, status: Ae.status },
                mesh: { ok: Oe.ok, status: Oe.status },
              }),
              !Ae.ok || !Oe.ok)
            )
              throw new Error(
                `\u5EFA\u7269\u70B9\u691C\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F: HTTP error! status: points=${Ae.status}, mesh=${Oe.status}`,
              );
            const [$e, qe] = await Promise.all([Ae.text(), Oe.text()]);
            console.log("CSV\u5185\u5BB9\u78BA\u8A8D:", {
              pointsLength: $e.length,
              meshLength: qe.length,
              pointsPreview: $e.substring(0, 200),
              meshPreview: qe.substring(0, 200),
            });
            const pt = new Blob([$e], { type: "text/csv" }),
              tt = new File([pt], "building-points.csv", { type: "text/csv" });
            await Yu(tt, Xe, "building-inspection");
            const Et = new Blob([qe], { type: "text/csv" }),
              $t = new File([Et], "building-mesh.csv", { type: "text/csv" });
            (await Yu($t, Xe, "building-inspection-mesh"),
              Ye(
                "\u5EFA\u7269\u70B9\u691C\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u307F\u307E\u3057\u305F",
                "success",
              ));
          } catch (Ae) {
            (console.error(
              "\u5EFA\u7269\u70B9\u691C\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u30A8\u30E9\u30FC:",
              Ae,
            ),
              Ye(
                `\u5EFA\u7269\u70B9\u691C\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F: ${Ae instanceof Error ? Ae.message : "\u4E0D\u660E\u306A\u30A8\u30E9\u30FC"}`,
                "error",
              ));
          }
        }),
      (le = document.getElementById("loadDroneData")) == null ||
        le.addEventListener("click", () => {
          if (ah)
            Ye(
              "\u70B9\u691C\u30C9\u30ED\u30FC\u30F3\u306F\u65E2\u306B\u914D\u7F6E\u6E08\u307F\u3067\u3059",
              "info",
            );
          else {
            const Ae = am([139.7454, 35.6586]);
            (ft.push(...Ae),
              Wi(),
              (ah = !0),
              wt(
                `\u6771\u4EAC\u30BF\u30EF\u30FC\u70B9\u691C\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u5B8C\u4E86: ${Ae.length}\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8`,
              ),
              Ye(
                "\u6771\u4EAC\u30BF\u30EF\u30FC\u5468\u8FBA\u70B9\u691C\u30C9\u30ED\u30FC\u30F3\u3092\u914D\u7F6E\u3057\u307E\u3057\u305F",
                "success",
              ));
          }
        }),
      (U = document.getElementById("startSimulation")) == null ||
        U.addEventListener("click", () => {
          if (rs) {
            (clearInterval(rs),
              (rs = null),
              wt(
                "\u30B7\u30DF\u30E5\u30EC\u30FC\u30B7\u30E7\u30F3\u505C\u6B62",
              ));
            return;
          }
          if (ft.length === 0) {
            Ye(
              "\u30B7\u30DF\u30E5\u30EC\u30FC\u30B7\u30E7\u30F3\u3059\u308B\u30C9\u30ED\u30FC\u30F3\u304C\u3042\u308A\u307E\u305B\u3093",
              "error",
            );
            return;
          }
          (wt(
            "\u30C9\u30ED\u30FC\u30F3\u30B7\u30DF\u30E5\u30EC\u30FC\u30B7\u30E7\u30F3\u958B\u59CB",
          ),
            (rs = setInterval(() => {
              (ft.forEach((Ae) => {
                Ae.type === "drone" &&
                  ((Ae.longitude += (Math.random() - 0.5) * 2e-4),
                  (Ae.latitude += (Math.random() - 0.5) * 2e-4),
                  (Ae.altitude += (Math.random() - 0.5) * 10),
                  (Ae.altitude = Math.max(50, Math.min(400, Ae.altitude))));
              }),
                Wi());
            }, 1e3)));
        }),
      (X = document.getElementById("toggleDrawMode")) == null ||
        X.addEventListener("click", () => {
          if (((cn = !cn), cn)) {
            hn = !1;
            const Oe = document.getElementById("togglePolygonMode");
            (Oe && (Oe.textContent = "\u591A\u89D2\u5F62\u4F5C\u6210"), Qu());
          }
          const Ae = document.getElementById("toggleDrawMode");
          (Ae &&
            (Ae.textContent = cn
              ? "\u30DD\u30A4\u30F3\u30C8\u4F5C\u6210\u505C\u6B62"
              : "\u30DD\u30A4\u30F3\u30C8\u4F5C\u6210"),
            (Xe.getCanvas().style.cursor = cn ? "crosshair" : ""),
            wt(
              cn
                ? "\u63CF\u753B\u30E2\u30FC\u30C9\u6709\u52B9 - \u30DE\u30C3\u30D7\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u70B9\u691C\u30DD\u30A4\u30F3\u30C8\u3092\u8FFD\u52A0"
                : "\u63CF\u753B\u30E2\u30FC\u30C9\u7121\u52B9",
            ),
            Ye(
              cn
                ? "\u63CF\u753B\u30E2\u30FC\u30C9\u3092\u6709\u52B9\u306B\u3057\u307E\u3057\u305F"
                : "\u63CF\u753B\u30E2\u30FC\u30C9\u3092\u7121\u52B9\u306B\u3057\u307E\u3057\u305F",
              "info",
            ));
        }),
      (E = document.getElementById("togglePolygonMode")) == null ||
        E.addEventListener("click", () => {
          if (((hn = !hn), hn)) {
            cn = !1;
            const Oe = document.getElementById("toggleDrawMode");
            Oe && (Oe.textContent = "\u63CF\u753B\u30E2\u30FC\u30C9");
          } else Qu();
          const Ae = document.getElementById("togglePolygonMode");
          (Ae &&
            (Ae.textContent = hn
              ? "\u591A\u89D2\u5F62\u4F5C\u6210\u505C\u6B62"
              : "\u591A\u89D2\u5F62\u4F5C\u6210"),
            (Xe.getCanvas().style.cursor = hn ? "crosshair" : ""),
            wt(
              hn
                ? "\u591A\u89D2\u5F62\u63CF\u753B\u30E2\u30FC\u30C9\u6709\u52B9 - \u30AF\u30EA\u30C3\u30AF\u3057\u3066\u9802\u70B9\u3092\u8FFD\u52A0\u3001\u59CB\u70B9\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u5B8C\u6210"
                : "\u591A\u89D2\u5F62\u63CF\u753B\u30E2\u30FC\u30C9\u7121\u52B9",
            ),
            Ye(
              hn
                ? "\u591A\u89D2\u5F62\u63CF\u753B\u30E2\u30FC\u30C9\u3092\u6709\u52B9\u306B\u3057\u307E\u3057\u305F"
                : "\u591A\u89D2\u5F62\u63CF\u753B\u30E2\u30FC\u30C9\u3092\u7121\u52B9\u306B\u3057\u307E\u3057\u305F",
              "info",
            ));
        }),
      (u = document.getElementById("toggleEditMode")) == null ||
        u.addEventListener("click", () => {
          if (((fr = !fr), fr)) {
            ((cn = !1), (hn = !1));
            const Oe = document.getElementById("toggleDrawMode"),
              $e = document.getElementById("togglePolygonMode");
            (Oe && (Oe.textContent = "\u30DD\u30A4\u30F3\u30C8\u4F5C\u6210"),
              $e && ($e.textContent = "\u591A\u89D2\u5F62\u4F5C\u6210"),
              Qu());
          } else Ml();
          const Ae = document.getElementById("toggleEditMode");
          (Ae &&
            (Ae.textContent = fr
              ? "\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u7DE8\u96C6\u505C\u6B62"
              : "\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u7DE8\u96C6"),
            (Xe.getCanvas().style.cursor = fr ? "crosshair" : ""),
            wt(
              fr
                ? "\u7DE8\u96C6\u30E2\u30FC\u30C9\u6709\u52B9 - \u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u9078\u629E\u3001\u30C9\u30E9\u30C3\u30B0\u3067\u79FB\u52D5\u3001Delete\u30AD\u30FC\u3067\u524A\u9664"
                : "\u7DE8\u96C6\u30E2\u30FC\u30C9\u7121\u52B9",
            ),
            Ye(
              fr
                ? "\u7DE8\u96C6\u30E2\u30FC\u30C9\u3092\u6709\u52B9\u306B\u3057\u307E\u3057\u305F"
                : "\u7DE8\u96C6\u30E2\u30FC\u30C9\u3092\u7121\u52B9\u306B\u3057\u307E\u3057\u305F",
              "info",
            ));
        }),
      (Ue = document.getElementById("importCSV")) == null ||
        Ue.addEventListener("click", () => {
          const Ae = document.createElement("input");
          ((Ae.type = "file"),
            (Ae.accept = ".csv"),
            (Ae.onchange = async (Oe) => {
              var qe;
              const $e = (qe = Oe.target.files) == null ? void 0 : qe[0];
              if ($e)
                try {
                  wt(
                    "CSV\u30D5\u30A1\u30A4\u30EB\u8AAD\u307F\u8FBC\u307F\u4E2D...",
                  );
                  const pt = await $e.text(),
                    tt = tm(pt, $e.name);
                  tt.length > 0
                    ? (ft.push(...tt),
                      Wi(),
                      wt(
                        `CSV\u8AAD\u307F\u8FBC\u307F\u5B8C\u4E86: ${tt.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8`,
                      ),
                      Ye(
                        `CSV\u304B\u3089${tt.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F`,
                        "success",
                      ),
                      ot(
                        "\u30C7\u30FC\u30BF\u7BA1\u7406",
                        "CSV\u30A4\u30F3\u30DD\u30FC\u30C8",
                        `${$e.name}\u304B\u3089${tt.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u8AAD\u307F\u8FBC\u307F`,
                        "success",
                      ))
                    : (Ye(
                        "CSV\u30D5\u30A1\u30A4\u30EB\u304B\u3089\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F",
                        "warning",
                      ),
                      ot(
                        "\u30C7\u30FC\u30BF\u7BA1\u7406",
                        "CSV\u30A4\u30F3\u30DD\u30FC\u30C8",
                        "CSV\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557",
                        "warning",
                      ));
                } catch (pt) {
                  (console.error(
                    "CSV\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC:",
                    pt,
                  ),
                    Ye(
                      "CSV\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                      "error",
                    ),
                    ot(
                      "\u30C7\u30FC\u30BF\u7BA1\u7406",
                      "CSV\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                      `${$e.name}\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557`,
                      "error",
                    ),
                    wt("CSV\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC"));
                }
            }),
            Ae.click());
        }),
      (rt = document.getElementById("importGeoJSON")) == null ||
        rt.addEventListener("click", () => {
          const Ae = document.createElement("input");
          ((Ae.type = "file"),
            (Ae.accept = ".geojson,.json"),
            (Ae.onchange = async (Oe) => {
              var qe;
              const $e = (qe = Oe.target.files) == null ? void 0 : qe[0];
              if ($e)
                try {
                  wt(
                    "GeoJSON\u30D5\u30A1\u30A4\u30EB\u8AAD\u307F\u8FBC\u307F\u4E2D...",
                  );
                  const pt = await $e.text(),
                    tt = im(pt, $e.name);
                  tt.length > 0
                    ? (ft.push(...tt),
                      Wi(),
                      wt(
                        `GeoJSON\u8AAD\u307F\u8FBC\u307F\u5B8C\u4E86: ${tt.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8`,
                      ),
                      Ye(
                        `GeoJSON\u304B\u3089${tt.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F`,
                        "success",
                      ),
                      ot(
                        "\u30C7\u30FC\u30BF\u7BA1\u7406",
                        "GeoJSON\u30A4\u30F3\u30DD\u30FC\u30C8",
                        `${$e.name}\u304B\u3089${tt.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u8AAD\u307F\u8FBC\u307F`,
                        "success",
                      ))
                    : (Ye(
                        "GeoJSON\u30D5\u30A1\u30A4\u30EB\u304B\u3089\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F",
                        "warning",
                      ),
                      ot(
                        "\u30C7\u30FC\u30BF\u7BA1\u7406",
                        "GeoJSON\u30A4\u30F3\u30DD\u30FC\u30C8",
                        "GeoJSON\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557",
                        "warning",
                      ));
                } catch (pt) {
                  (console.error(
                    "GeoJSON\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC:",
                    pt,
                  ),
                    Ye(
                      "GeoJSON\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                      "error",
                    ),
                    ot(
                      "\u30C7\u30FC\u30BF\u7BA1\u7406",
                      "GeoJSON\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                      `${$e.name}\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557`,
                      "error",
                    ),
                    wt(
                      "GeoJSON\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                    ));
                }
            }),
            Ae.click());
        }),
      (_t = document.getElementById("exportCSV")) == null ||
        _t.addEventListener("click", () => {
          if (ft.length > 0) {
            const Ae = rm(ft);
            (wo(Ae, "tokyo_tower_drone_data.csv", "text/csv"),
              wt("CSV\u66F8\u304D\u51FA\u3057\u5B8C\u4E86"),
              Ye(
                "CSV\u30D5\u30A1\u30A4\u30EB\u3092\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3057\u307E\u3057\u305F",
                "success",
              ));
          } else
            Ye(
              "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3059\u308B\u30C7\u30FC\u30BF\u304C\u3042\u308A\u307E\u305B\u3093",
              "error",
            );
        }),
      (li = document.getElementById("exportGeoJSON")) == null ||
        li.addEventListener("click", () => {
          if (ft.length > 0) {
            const Ae = nm(ft);
            (wo(Ae, "tokyo_tower_drone_data.geojson", "application/geo+json"),
              wt("GeoJSON\u66F8\u304D\u51FA\u3057\u5B8C\u4E86"),
              Ye(
                "GeoJSON\u30D5\u30A1\u30A4\u30EB\u3092\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3057\u307E\u3057\u305F",
                "success",
              ));
          } else
            Ye(
              "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3059\u308B\u30C7\u30FC\u30BF\u304C\u3042\u308A\u307E\u305B\u3093",
              "error",
            );
        }),
      (Qe = document.getElementById("clearData")) == null ||
        Qe.addEventListener("click", () => {
          ft.length > 0 &&
            confirm(
              `${ft.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u5168\u3066\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F`,
            ) &&
            ((ft = []),
            Wi(),
            em(Xe),
            (ah = !1),
            rs && (clearInterval(rs), (rs = null)),
            wt("\u5168\u30C7\u30FC\u30BF\u30AF\u30EA\u30A2\u5B8C\u4E86"),
            Ye(
              "\u5168\u3066\u306E\u30C7\u30FC\u30BF\u3092\u30AF\u30EA\u30A2\u3057\u307E\u3057\u305F",
              "info",
            ));
        }),
      (me = document.getElementById("toggle3D")) == null ||
        me.addEventListener("click", () => {
          Tm();
          const Ae = document.getElementById("toggle3D");
          (Ae && (Ae.textContent = Sl ? "2D\u8868\u793A" : "3D\u8868\u793A"),
            Ye(
              Sl
                ? "3D\u8868\u793A\u306B\u5207\u308A\u66FF\u3048\u307E\u3057\u305F"
                : "2D\u8868\u793A\u306B\u5207\u308A\u66FF\u3048\u307E\u3057\u305F",
              "info",
            ));
        }),
      (Ze = document.getElementById("clearFlightLog")) == null ||
        Ze.addEventListener("click", () => {
          hm();
        }),
      (Ni = document.getElementById("exportFlightLog")) == null ||
        Ni.addEventListener("click", () => {
          dm();
        }),
      (Ei = document.getElementById("startFlightPlan")) == null ||
        Ei.addEventListener("click", () => {
          Pm();
        }),
      (Mi = document.getElementById("pauseFlightPlan")) == null ||
        Mi.addEventListener("click", () => {
          Sm();
        }),
      (Ki = document.getElementById("exportFlightPlan")) == null ||
        Ki.addEventListener("click", () => {
          Mm();
        }),
      (mr = document.getElementById("importFlightPlan")) == null ||
        mr.addEventListener("click", () => {
          Im();
        }),
      (ei = document.getElementById("toggleLog")) == null ||
        ei.addEventListener("click", () => {
          const Ae = document.getElementById("flightLog"),
            Oe = document.getElementById("toggleLog");
          if (
            (console.log(
              "Toggle\u30DC\u30BF\u30F3\u304C\u30AF\u30EA\u30C3\u30AF\u3055\u308C\u307E\u3057\u305F",
            ),
            console.log("FlightLog\u8981\u7D20:", Ae),
            console.log("Toggle\u30DC\u30BF\u30F3\u8981\u7D20:", Oe),
            console.log(
              "\u73FE\u5728\u306EFlightLog\u8868\u793A\u72B6\u614B:",
              Ae == null ? void 0 : Ae.classList.contains("visible"),
            ),
            Ae && Oe)
          ) {
            const $e = Ae.classList.contains("visible");
            (console.log("\u73FE\u5728\u306E\u8868\u793A\u72B6\u614B:", $e),
              $e
                ? (Ae.classList.remove("visible"),
                  Ae.classList.add("hidden"),
                  (Oe.textContent = "\u30ED\u30B0\u8868\u793A"),
                  ot(
                    "\u30B7\u30B9\u30C6\u30E0",
                    "\u30ED\u30B0\u8868\u793A\u5207\u66FF",
                    "\u30ED\u30B0\u8868\u793A\u3092\u7121\u52B9\u306B\u3057\u307E\u3057\u305F",
                    "info",
                  ),
                  console.log(
                    "\u30ED\u30B0\u30EA\u30B9\u30C8\u3092\u975E\u8868\u793A\u306B\u3057\u307E\u3057\u305F",
                  ))
                : (Ae.classList.remove("hidden"),
                  Ae.classList.add("visible"),
                  (Oe.textContent = "\u30ED\u30B0\u975E\u8868\u793A"),
                  ot(
                    "\u30B7\u30B9\u30C6\u30E0",
                    "\u30ED\u30B0\u8868\u793A\u5207\u66FF",
                    "\u30ED\u30B0\u8868\u793A\u3092\u6709\u52B9\u306B\u3057\u307E\u3057\u305F",
                    "info",
                  ),
                  console.log(
                    "\u30ED\u30B0\u30EA\u30B9\u30C8\u3092\u8868\u793A\u306B\u3057\u307E\u3057\u305F",
                  )));
          } else
            console.error(
              "FlightLog\u307E\u305F\u306FToggle\u30DC\u30BF\u30F3\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093",
            );
        }),
      (Vi = document.getElementById("importFlightData")) == null ||
        Vi.addEventListener("click", () => {
          const Ae = document.createElement("input");
          ((Ae.type = "file"),
            (Ae.accept = ".csv,.json,.geojson"),
            (Ae.onchange = async (Oe) => {
              var qe;
              const $e = (qe = Oe.target.files) == null ? void 0 : qe[0];
              if ($e)
                try {
                  wt(
                    "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u4E2D...",
                  );
                  const pt = await $e.text();
                  let tt = [];
                  if (
                    ($e.name.endsWith(".csv")
                      ? (tt = Ju(pt, $e.name))
                      : ($e.name.endsWith(".json") ||
                          $e.name.endsWith(".geojson")) &&
                        (tt = Wd(pt, $e.name)),
                    tt.length > 0)
                  ) {
                    const Et = tt.map(($t) => Ku($t));
                    (ft.push(...Et),
                      Wi(),
                      wt(
                        `\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u5B8C\u4E86: ${tt.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8`,
                      ),
                      Ye(
                        `\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u304B\u3089${tt.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F`,
                        "success",
                      ),
                      ot(
                        "\u30C7\u30FC\u30BF\u7BA1\u7406",
                        "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30A4\u30F3\u30DD\u30FC\u30C8",
                        `${$e.name}\u304B\u3089${tt.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u8AAD\u307F\u8FBC\u307F`,
                        "success",
                      ));
                  } else
                    (Ye(
                      "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30D5\u30A1\u30A4\u30EB\u304B\u3089\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F",
                      "warning",
                    ),
                      ot(
                        "\u30C7\u30FC\u30BF\u7BA1\u7406",
                        "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30A4\u30F3\u30DD\u30FC\u30C8",
                        "\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557",
                        "warning",
                      ));
                } catch (pt) {
                  (console.error(
                    "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC:",
                    pt,
                  ),
                    Ye(
                      "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                      "error",
                    ),
                    ot(
                      "\u30C7\u30FC\u30BF\u7BA1\u7406",
                      "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                      `${$e.name}\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557`,
                      "error",
                    ),
                    wt(
                      "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                    ));
                }
            }),
            Ae.click());
        }),
      (It = document.getElementById("importMission")) == null ||
        It.addEventListener("click", () => {
          const Ae = document.createElement("input");
          ((Ae.type = "file"),
            (Ae.accept = ".json"),
            (Ae.onchange = async (Oe) => {
              var qe;
              const $e = (qe = Oe.target.files) == null ? void 0 : qe[0];
              if ($e)
                try {
                  wt(
                    "\u30D5\u30E9\u30A4\u30C8\u30DF\u30C3\u30B7\u30E7\u30F3\u8AAD\u307F\u8FBC\u307F\u4E2D...",
                  );
                  const pt = await $e.text(),
                    tt = sm(pt, $e.name);
                  if (tt && tt.waypoints.length > 0) {
                    const Et = tt.waypoints.map((_i, Ii) => ({
                      id: `mission_waypoint_${Ii + 1}`,
                      name: `\u30DF\u30C3\u30B7\u30E7\u30F3_${tt.name}_WP${Ii + 1}`,
                      longitude: _i.position.longitude,
                      latitude: _i.position.latitude,
                      altitude: _i.position.altitude,
                      type: "flight",
                      source: `mission_${$e.name}`,
                    }));
                    (ft.push(...Et),
                      Wi(),
                      wt(
                        `\u30D5\u30E9\u30A4\u30C8\u30DF\u30C3\u30B7\u30E7\u30F3\u8AAD\u307F\u8FBC\u307F\u5B8C\u4E86: ${tt.waypoints.length}\u500B\u306E\u30A6\u30A7\u30A4\u30DD\u30A4\u30F3\u30C8`,
                      ),
                      Ye(
                        `\u30DF\u30C3\u30B7\u30E7\u30F3\u300C${tt.name}\u300D\u304B\u3089${tt.waypoints.length}\u500B\u306E\u30A6\u30A7\u30A4\u30DD\u30A4\u30F3\u30C8\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F`,
                        "success",
                      ),
                      ot(
                        "\u30C7\u30FC\u30BF\u7BA1\u7406",
                        "\u30DF\u30C3\u30B7\u30E7\u30F3\u30A4\u30F3\u30DD\u30FC\u30C8",
                        `${tt.name}: ${tt.waypoints.length}\u500B\u306E\u30A6\u30A7\u30A4\u30DD\u30A4\u30F3\u30C8`,
                        "success",
                      ));
                    const $t = tt.waypoints[0];
                    Xe.flyTo({
                      center: [$t.position.longitude, $t.position.latitude],
                      zoom: 16,
                      duration: 2e3,
                    });
                  } else
                    (Ye(
                      "\u30D5\u30E9\u30A4\u30C8\u30DF\u30C3\u30B7\u30E7\u30F3\u30D5\u30A1\u30A4\u30EB\u304B\u3089\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F",
                      "warning",
                    ),
                      ot(
                        "\u30C7\u30FC\u30BF\u7BA1\u7406",
                        "\u30DF\u30C3\u30B7\u30E7\u30F3\u30A4\u30F3\u30DD\u30FC\u30C8",
                        "\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557",
                        "warning",
                      ));
                } catch (pt) {
                  (console.error(
                    "\u30D5\u30E9\u30A4\u30C8\u30DF\u30C3\u30B7\u30E7\u30F3\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC:",
                    pt,
                  ),
                    Ye(
                      "\u30D5\u30E9\u30A4\u30C8\u30DF\u30C3\u30B7\u30E7\u30F3\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                      "error",
                    ),
                    ot(
                      "\u30C7\u30FC\u30BF\u7BA1\u7406",
                      "\u30DF\u30C3\u30B7\u30E7\u30F3\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                      `${$e.name}\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557`,
                      "error",
                    ),
                    wt(
                      "\u30D5\u30E9\u30A4\u30C8\u30DF\u30C3\u30B7\u30E7\u30F3\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                    ));
                }
            }),
            Ae.click());
        }),
      (Dt = document.getElementById("loadSampleFlightData")) == null ||
        Dt.addEventListener("click", async () => {
          try {
            wt(
              "\u30B5\u30F3\u30D7\u30EB\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u4E2D...",
            );
            const Ae = await fetch("./data/sample-flight-data.csv");
            if (!Ae.ok) throw new Error(`HTTP error! status: ${Ae.status}`);
            const Oe = await Ae.text(),
              $e = Ju(Oe, "sample-flight-data.csv");
            if ($e.length > 0) {
              const qe = $e.map((pt) => Ku(pt));
              (ft.push(...qe),
                Wi(),
                wt(
                  `\u30B5\u30F3\u30D7\u30EB\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u5B8C\u4E86: ${$e.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8`,
                ),
                Ye(
                  `\u30B5\u30F3\u30D7\u30EB\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u304B\u3089${$e.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u8AAD\u307F\u8FBC\u307F\u307E\u3057\u305F`,
                  "success",
                ),
                ot(
                  "\u30C7\u30FC\u30BF\u7BA1\u7406",
                  "\u30B5\u30F3\u30D7\u30EB\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF",
                  `${$e.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u8AAD\u307F\u8FBC\u307F`,
                  "success",
                ));
            } else
              (Ye(
                "\u30B5\u30F3\u30D7\u30EB\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                "error",
              ),
                ot(
                  "\u30C7\u30FC\u30BF\u7BA1\u7406",
                  "\u30B5\u30F3\u30D7\u30EB\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF",
                  "\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557",
                  "error",
                ));
          } catch (Ae) {
            (console.error(
              "\u30B5\u30F3\u30D7\u30EB\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u30A8\u30E9\u30FC:",
              Ae,
            ),
              Ye(
                "\u30B5\u30F3\u30D7\u30EB\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                "error",
              ),
              ot(
                "\u30C7\u30FC\u30BF\u7BA1\u7406",
                "\u30B5\u30F3\u30D7\u30EB\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30A8\u30E9\u30FC",
                "\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557",
                "error",
              ),
              wt(
                "\u30B5\u30F3\u30D7\u30EB\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u30A8\u30E9\u30FC",
              ));
          }
        }),
      (Bt = document.getElementById("loadSampleTrajectory")) == null ||
        Bt.addEventListener("click", async () => {
          try {
            wt(
              "\u30B5\u30F3\u30D7\u30EB\u8ECC\u8DE1\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u4E2D...",
            );
            const Ae = await fetch("./data/sample-trajectory-data.csv");
            if (!Ae.ok) throw new Error(`HTTP error! status: ${Ae.status}`);
            const Oe = await Ae.text(),
              $e = Ju(Oe, "sample-trajectory-data.csv");
            if ($e.length > 0) {
              const qe = $e
                  .filter((tt) => tt.timestamp)
                  .sort(
                    (tt, Et) =>
                      new Date(tt.timestamp).getTime() -
                      new Date(Et.timestamp).getTime(),
                  ),
                pt = qe.map((tt, Et) => {
                  const $t = Ku(tt);
                  return (
                    ($t.name = `\u8ECC\u8DE1\u70B9_${Et + 1}`),
                    ($t.type = "flight"),
                    $t
                  );
                });
              if (
                (ft.push(...pt),
                Wi(),
                wt(
                  `\u30B5\u30F3\u30D7\u30EB\u8ECC\u8DE1\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u5B8C\u4E86: ${qe.length}\u500B\u306E\u8ECC\u8DE1\u70B9`,
                ),
                Ye(
                  `\u30B5\u30F3\u30D7\u30EB\u8ECC\u8DE1\u30C7\u30FC\u30BF\u304B\u3089${qe.length}\u500B\u306E\u8ECC\u8DE1\u70B9\u3092\u8AAD\u307F\u8FBC\u307F\u307E\u3057\u305F`,
                  "success",
                ),
                ot(
                  "\u30C7\u30FC\u30BF\u7BA1\u7406",
                  "\u30B5\u30F3\u30D7\u30EB\u8ECC\u8DE1\u30C7\u30FC\u30BF",
                  `${qe.length}\u500B\u306E\u8ECC\u8DE1\u70B9\u3092\u8AAD\u307F\u8FBC\u307F`,
                  "success",
                ),
                qe.length > 0)
              ) {
                const tt = qe[0];
                Xe.flyTo({
                  center: [tt.position.longitude, tt.position.latitude],
                  zoom: 16,
                  duration: 2e3,
                });
              }
            } else
              (Ye(
                "\u30B5\u30F3\u30D7\u30EB\u8ECC\u8DE1\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                "error",
              ),
                ot(
                  "\u30C7\u30FC\u30BF\u7BA1\u7406",
                  "\u30B5\u30F3\u30D7\u30EB\u8ECC\u8DE1\u30C7\u30FC\u30BF",
                  "\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557",
                  "error",
                ));
          } catch (Ae) {
            (console.error(
              "\u30B5\u30F3\u30D7\u30EB\u8ECC\u8DE1\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u30A8\u30E9\u30FC:",
              Ae,
            ),
              Ye(
                "\u30B5\u30F3\u30D7\u30EB\u8ECC\u8DE1\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                "error",
              ),
              ot(
                "\u30C7\u30FC\u30BF\u7BA1\u7406",
                "\u30B5\u30F3\u30D7\u30EB\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A8\u30E9\u30FC",
                "\u30C7\u30FC\u30BF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557",
                "error",
              ),
              wt(
                "\u30B5\u30F3\u30D7\u30EB\u8ECC\u8DE1\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u30A8\u30E9\u30FC",
              ));
          }
        }),
      (Xr = document.getElementById("exportFlightData")) == null ||
        Xr.addEventListener("click", () => {
          if (ft.length > 0) {
            const Ae = ft.map((Oe) => sh(Oe));
            try {
              const Oe = Hd(Ae);
              wo(Oe, "unified_flight_data.csv", "text/csv");
              const $e = Xd(Ae);
              (wo($e, "unified_flight_data.geojson", "application/geo+json"),
                wt(
                  "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u5B8C\u4E86",
                ),
                Ye(
                  "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u3092CSV\u3068GeoJSON\u5F62\u5F0F\u3067\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F",
                  "success",
                ),
                ot(
                  "\u30C7\u30FC\u30BF\u7BA1\u7406",
                  "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
                  `${Ae.length}\u500B\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3092\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8`,
                  "success",
                ));
            } catch (Oe) {
              (console.error(
                "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC:",
                Oe,
              ),
                Ye(
                  "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                  "error",
                ),
                ot(
                  "\u30C7\u30FC\u30BF\u7BA1\u7406",
                  "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                  "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u306B\u5931\u6557",
                  "error",
                ));
            }
          } else
            (Ye(
              "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3059\u308B\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u304C\u3042\u308A\u307E\u305B\u3093",
              "warning",
            ),
              ot(
                "\u30C7\u30FC\u30BF\u7BA1\u7406",
                "\u30D5\u30E9\u30A4\u30C8\u30C7\u30FC\u30BF\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
                "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3059\u308B\u30C7\u30FC\u30BF\u304C\u3042\u308A\u307E\u305B\u3093",
                "warning",
              ));
        }),
      (dn = document.getElementById("exportMission")) == null ||
        dn.addEventListener("click", () => {
          if (ft.length > 0) {
            const Ae = ft.filter(
              (Oe) => Oe.type === "flight" || Oe.type === "drone",
            );
            if (Ae.length > 0)
              try {
                const Oe = Gf(
                    "Generated_Mission",
                    "\u30B7\u30B9\u30C6\u30E0\u751F\u6210\u30D5\u30E9\u30A4\u30C8\u30DF\u30C3\u30B7\u30E7\u30F3",
                    Ae.map((pt) => sh(pt)),
                  ),
                  $e = om(Oe);
                wo(
                  $e,
                  `flight_mission_${new Date().toISOString().slice(0, 10)}.kml`,
                  "application/vnd.google-earth.kml+xml",
                );
                const qe = JSON.stringify(Oe, null, 2);
                (wo(
                  qe,
                  `flight_mission_${new Date().toISOString().slice(0, 10)}.json`,
                  "application/json",
                ),
                  wt(
                    "\u30D5\u30E9\u30A4\u30C8\u30DF\u30C3\u30B7\u30E7\u30F3\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u5B8C\u4E86",
                  ),
                  Ye(
                    "\u30D5\u30E9\u30A4\u30C8\u30DF\u30C3\u30B7\u30E7\u30F3\u3092KML\u3068JSON\u5F62\u5F0F\u3067\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F",
                    "success",
                  ),
                  ot(
                    "\u30C7\u30FC\u30BF\u7BA1\u7406",
                    "\u30DF\u30C3\u30B7\u30E7\u30F3\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
                    `${Oe.waypoints.length}\u500B\u306E\u30A6\u30A7\u30A4\u30DD\u30A4\u30F3\u30C8`,
                    "success",
                  ));
              } catch (Oe) {
                (console.error(
                  "\u30D5\u30E9\u30A4\u30C8\u30DF\u30C3\u30B7\u30E7\u30F3\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC:",
                  Oe,
                ),
                  Ye(
                    "\u30D5\u30E9\u30A4\u30C8\u30DF\u30C3\u30B7\u30E7\u30F3\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                    "error",
                  ),
                  ot(
                    "\u30C7\u30FC\u30BF\u7BA1\u7406",
                    "\u30DF\u30C3\u30B7\u30E7\u30F3\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                    "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u306B\u5931\u6557",
                    "error",
                  ));
              }
            else
              (Ye(
                "\u30D5\u30E9\u30A4\u30C8\u95A2\u9023\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u304C\u3042\u308A\u307E\u305B\u3093",
                "warning",
              ),
                ot(
                  "\u30C7\u30FC\u30BF\u7BA1\u7406",
                  "\u30DF\u30C3\u30B7\u30E7\u30F3\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
                  "\u30D5\u30E9\u30A4\u30C8\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093",
                  "warning",
                ));
          } else
            (Ye(
              "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3059\u308B\u30C7\u30FC\u30BF\u304C\u3042\u308A\u307E\u305B\u3093",
              "warning",
            ),
              ot(
                "\u30C7\u30FC\u30BF\u7BA1\u7406",
                "\u30DF\u30C3\u30B7\u30E7\u30F3\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
                "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3059\u308B\u30C7\u30FC\u30BF\u304C\u3042\u308A\u307E\u305B\u3093",
                "warning",
              ));
        }),
      (or = document.getElementById("importTrajectory")) == null ||
        or.addEventListener("click", () => {
          const Ae = document.createElement("input");
          ((Ae.type = "file"),
            (Ae.accept = ".csv,.json,.geojson"),
            (Ae.onchange = async (Oe) => {
              var qe;
              const $e = (qe = Oe.target.files) == null ? void 0 : qe[0];
              if ($e)
                try {
                  wt(
                    "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u4E2D...",
                  );
                  const pt = await $e.text();
                  let tt = [];
                  $e.name.endsWith(".csv")
                    ? (tt = Ju(pt, $e.name))
                    : ($e.name.endsWith(".json") ||
                        $e.name.endsWith(".geojson")) &&
                      (tt = Wd(pt, $e.name));
                  const Et = tt
                    .filter(($t) => $t.timestamp)
                    .sort(
                      ($t, _i) =>
                        new Date($t.timestamp).getTime() -
                        new Date(_i.timestamp).getTime(),
                    );
                  if (Et.length > 0) {
                    const $t = Et.map((_i, Ii) => {
                      const Bi = Ku(_i);
                      return (
                        (Bi.name = `\u8ECC\u8DE1\u70B9_${Ii + 1}`),
                        (Bi.type = "flight"),
                        Bi
                      );
                    });
                    if (
                      (ft.push(...$t),
                      Wi(),
                      wt(
                        `\u8ECC\u8DE1\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u5B8C\u4E86: ${Et.length}\u500B\u306E\u8ECC\u8DE1\u70B9`,
                      ),
                      Ye(
                        `\u8ECC\u8DE1\u30C7\u30FC\u30BF\u304B\u3089${Et.length}\u500B\u306E\u8ECC\u8DE1\u70B9\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F`,
                        "success",
                      ),
                      ot(
                        "\u30C7\u30FC\u30BF\u7BA1\u7406",
                        "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A4\u30F3\u30DD\u30FC\u30C8",
                        `${$e.name}\u304B\u3089${Et.length}\u500B\u306E\u8ECC\u8DE1\u70B9\u3092\u8AAD\u307F\u8FBC\u307F`,
                        "success",
                      ),
                      Et.length > 0)
                    ) {
                      const _i = Et[0];
                      Xe.flyTo({
                        center: [_i.position.longitude, _i.position.latitude],
                        zoom: 16,
                        duration: 2e3,
                      });
                    }
                  } else
                    (Ye(
                      "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30D5\u30A1\u30A4\u30EB\u304B\u3089\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F",
                      "warning",
                    ),
                      ot(
                        "\u30C7\u30FC\u30BF\u7BA1\u7406",
                        "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A4\u30F3\u30DD\u30FC\u30C8",
                        "\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557",
                        "warning",
                      ));
                } catch (pt) {
                  (console.error(
                    "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC:",
                    pt,
                  ),
                    Ye(
                      "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                      "error",
                    ),
                    ot(
                      "\u30C7\u30FC\u30BF\u7BA1\u7406",
                      "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                      `${$e.name}\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557`,
                      "error",
                    ),
                    wt(
                      "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A4\u30F3\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                    ));
                }
            }),
            Ae.click());
        }),
      (sr = document.getElementById("exportTrajectory")) == null ||
        sr.addEventListener("click", () => {
          if (ft.length > 0) {
            const Ae = ft.filter(
              (Oe) => Oe.type === "flight" || Oe.type === "drone",
            );
            if (Ae.length > 0)
              try {
                const Oe = Ae.map((pt, tt) => {
                    const Et = sh(pt);
                    return (
                      Et.timestamp ||
                        (Et.timestamp = new Date(
                          Date.now() + tt * 1e4,
                        ).toISOString()),
                      (Et.type = "trajectory_point"),
                      Et
                    );
                  }),
                  $e = Hd(Oe);
                wo($e, "flight_trajectory.csv", "text/csv");
                const qe = Xd(Oe);
                (wo(qe, "flight_trajectory.geojson", "application/geo+json"),
                  wt(
                    "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u5B8C\u4E86",
                  ),
                  Ye(
                    "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u3092CSV\u3068GeoJSON\u5F62\u5F0F\u3067\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F",
                    "success",
                  ),
                  ot(
                    "\u30C7\u30FC\u30BF\u7BA1\u7406",
                    "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
                    `${Oe.length}\u500B\u306E\u8ECC\u8DE1\u70B9\u3092\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8`,
                    "success",
                  ));
              } catch (Oe) {
                (console.error(
                  "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC:",
                  Oe,
                ),
                  Ye(
                    "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                    "error",
                  ),
                  ot(
                    "\u30C7\u30FC\u30BF\u7BA1\u7406",
                    "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u30A8\u30E9\u30FC",
                    "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u306B\u5931\u6557",
                    "error",
                  ));
              }
            else
              (Ye(
                "\u8ECC\u8DE1\u3068\u3057\u3066\u51FA\u529B\u3067\u304D\u308B\u30C7\u30FC\u30BF\u304C\u3042\u308A\u307E\u305B\u3093",
                "warning",
              ),
                ot(
                  "\u30C7\u30FC\u30BF\u7BA1\u7406",
                  "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
                  "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093",
                  "warning",
                ));
          } else
            (Ye(
              "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3059\u308B\u30C7\u30FC\u30BF\u304C\u3042\u308A\u307E\u305B\u3093",
              "warning",
            ),
              ot(
                "\u30C7\u30FC\u30BF\u7BA1\u7406",
                "\u8ECC\u8DE1\u30C7\u30FC\u30BF\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
                "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3059\u308B\u30C7\u30FC\u30BF\u304C\u3042\u308A\u307E\u305B\u3093",
                "warning",
              ));
        }));
  },
  Pm = () => {
    if (ha) {
      ot(
        "\u30B7\u30B9\u30C6\u30E0",
        "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3",
        "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u306F\u65E2\u306B\u5B9F\u884C\u4E2D\u3067\u3059",
        "warning",
      );
      return;
    }
    if (Zn.length === 0) {
      ot(
        "\u30A8\u30E9\u30FC",
        "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3",
        "\u5B9F\u884C\u53EF\u80FD\u306A\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u304C\u3042\u308A\u307E\u305B\u3093",
        "error",
      );
      return;
    }
    if (
      ((ha = !0),
      (Dl = 0),
      ot(
        "\u30B7\u30B9\u30C6\u30E0",
        "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u958B\u59CB",
        `${os}\u3092\u958B\u59CB\u3057\u307E\u3059`,
        "success",
      ),
      ft.length === 0)
    ) {
      const K = {
        id: "inspection-drone-1",
        name: `${os}\u30C9\u30ED\u30FC\u30F3`,
        longitude: Zn[0].position[0],
        latitude: Zn[0].position[1],
        altitude: 0,
        type: "drone",
        source: "flight-plan",
      };
      (ft.push(K), Wi());
    }
    ip();
  },
  ip = () => {
    if (!ha || Dl >= Zn.length) {
      Dm();
      return;
    }
    const K = Zn[Dl],
      J = ft.find((se) => se.type === "drone");
    if (!J) {
      ot(
        "\u30A8\u30E9\u30FC",
        "\u30C9\u30ED\u30FC\u30F3\u4E0D\u5728",
        "\u70B9\u691C\u30C9\u30ED\u30FC\u30F3\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093",
        "error",
      );
      return;
    }
    ((J.longitude = K.position[0]),
      (J.latitude = K.position[1]),
      (J.altitude = K.position[2]),
      ot(K.phase, "\u5B9F\u884C\u4E2D", K.action, "info"),
      Xe.flyTo({ center: [J.longitude, J.latitude], zoom: 18, duration: 2e3 }),
      Wi(),
      setTimeout(() => {
        (Dl++, ip());
      }, K.duration));
  },
  Sm = () => {
    if (!ha) {
      ot(
        "\u30B7\u30B9\u30C6\u30E0",
        "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3",
        "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u306F\u5B9F\u884C\u3055\u308C\u3066\u3044\u307E\u305B\u3093",
        "warning",
      );
      return;
    }
    ((ha = !1),
      ot(
        "\u30B7\u30B9\u30C6\u30E0",
        "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u4E00\u6642\u505C\u6B62",
        `\u30D5\u30A7\u30FC\u30BA${Dl + 1}\u3067\u4E00\u6642\u505C\u6B62\u3057\u307E\u3057\u305F`,
        "warning",
      ));
  },
  Dm = () => {
    ((ha = !1),
      ot(
        "\u30B7\u30B9\u30C6\u30E0",
        "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u5B8C\u4E86",
        `${os}\u304C\u5B8C\u4E86\u3057\u307E\u3057\u305F`,
        "success",
      ),
      Ye(
        "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u304C\u5B8C\u4E86\u3057\u307E\u3057\u305F",
        "success",
      ));
  },
  Mm = () => {
    const K = {
        name: os,
        description: lh,
        created: new Date().toISOString(),
        phases: Zn,
        totalDuration: Zn.reduce((X, E) => X + E.duration, 0),
      },
      J = JSON.stringify(K, null, 2),
      se = new Blob([J], { type: "application/json" }),
      le = URL.createObjectURL(se),
      U = document.createElement("a");
    ((U.href = le),
      (U.download = `${os.replace(/\s+/g, "_")}_${new Date().toISOString().slice(0, 19).replace(/:/g, "-")}.json`),
      document.body.appendChild(U),
      U.click(),
      document.body.removeChild(U),
      URL.revokeObjectURL(le),
      ot(
        "\u30B7\u30B9\u30C6\u30E0",
        "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
        "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u3092JSON\u30D5\u30A1\u30A4\u30EB\u3067\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F",
        "success",
      ));
  },
  Im = () => {
    const K = document.createElement("input");
    ((K.type = "file"),
      (K.accept = ".json"),
      (K.onchange = (J) => {
        var le;
        const se = (le = J.target.files) == null ? void 0 : le[0];
        if (se) {
          const U = new FileReader();
          ((U.onload = (X) => {
            var E;
            try {
              const u = JSON.parse((E = X.target) == null ? void 0 : E.result);
              if (!u.name || !u.phases || !Array.isArray(u.phases))
                throw new Error(
                  "\u7121\u52B9\u306A\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u30D5\u30A1\u30A4\u30EB\u3067\u3059",
                );
              if (
                ((Zn = u.phases),
                (os = u.name),
                (lh = u.description || ""),
                ot(
                  "\u30B7\u30B9\u30C6\u30E0",
                  "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u30A4\u30F3\u30DD\u30FC\u30C8",
                  `${u.name}\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F`,
                  "success",
                ),
                Ye(
                  "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F",
                  "success",
                ),
                u.phases.length > 0)
              ) {
                const Ue = u.phases[0].position;
                Xe.flyTo({ center: [Ue[0], Ue[1]], zoom: 16, duration: 2e3 });
              }
            } catch {
              (ot(
                "\u30A8\u30E9\u30FC",
                "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u30A4\u30F3\u30DD\u30FC\u30C8",
                "\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                "error",
              ),
                Ye(
                  "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
                  "error",
                ));
            }
          }),
            U.readAsText(se));
        }
      }),
      K.click());
  };
Xe.on("click", (K) => {
  Co || (hn ? mm(K.lngLat) : cn ? Am(K.lngLat) : fr && (xm(K.lngLat) || Ml()));
});
Xe.on("mousedown", (K) => {
  if (fr) {
    const J = Xe.project(K.lngLat),
      se = 20;
    let le = !1;
    (ft.forEach((U) => {
      const X = Xe.project([U.longitude, U.latitude]);
      Math.sqrt(Math.pow(J.x - X.x, 2) + Math.pow(J.y - X.y, 2)) < se &&
        ((le = !0), Qt && Qt.id === U.id && (wm(K.lngLat), K.preventDefault()));
    }),
      !le && Co && tp());
  }
});
Xe.on("mousemove", (K) => {
  fr && Co && (K.preventDefault(), Cm(K.lngLat));
});
Xe.on("mouseup", (K) => {
  fr && Co && (K.preventDefault(), tp());
});
document.addEventListener("keydown", (K) => {
  ((K.key === "Delete" || K.key === "Backspace") &&
    fr &&
    Qt &&
    (K.preventDefault(), Em()),
    K.key === "Escape" && fr && Ml());
});
Xe.on("load", () => {
  (pm(),
    Fm(),
    wt(
      "\u5730\u56F3\u8AAD\u307F\u8FBC\u307F\u5B8C\u4E86 - \u6771\u4EAC\u30BF\u30EF\u30FC\u5468\u8FBA\u306E\u30C9\u30ED\u30FC\u30F3\u70B9\u691C\u3092\u958B\u59CB\u3057\u3066\u304F\u3060\u3055\u3044",
    ),
    console.log("\u30B7\u30B9\u30C6\u30E0\u6E96\u5099\u5B8C\u4E86"),
    ot(
      "\u30B7\u30B9\u30C6\u30E0",
      "\u521D\u671F\u5316",
      "\u6771\u4EAC\u30BF\u30EF\u30FC\u70B9\u691C\u30B7\u30B9\u30C6\u30E0\u304C\u8D77\u52D5\u3057\u307E\u3057\u305F",
      "success",
    ),
    ot(
      "\u30B7\u30B9\u30C6\u30E0",
      "\u6E96\u5099\u5B8C\u4E86",
      "\u30D5\u30E9\u30A4\u30C8\u30D7\u30E9\u30F3\u3068\u30EA\u30A2\u30EB\u30BF\u30A4\u30E0\u30ED\u30B0\u6A5F\u80FD\u304C\u5229\u7528\u53EF\u80FD\u3067\u3059",
      "info",
    ),
    setTimeout(() => {
      const K = document.getElementById("flightLog"),
        J = document.getElementById("toggleLog");
      K && J
        ? (K.classList.remove("hidden"),
          K.classList.add("visible"),
          (J.textContent = "\u30ED\u30B0\u975E\u8868\u793A"),
          console.log(
            "\u30ED\u30B0\u30EA\u30B9\u30C8\u3092\u521D\u671F\u8868\u793A\u72B6\u614B\u306B\u8A2D\u5B9A\u3057\u307E\u3057\u305F",
          ))
        : console.error(
            "FlightLog\u307E\u305F\u306FToggle\u30DC\u30BF\u30F3\u306E\u521D\u671F\u5316\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
          );
    }, 100));
});
